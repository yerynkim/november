UpdateCTestConfiguration  from :/home/yk/rosros/build/unitree_guide2/CTestConfiguration.ini
Parse Config file:/home/yk/rosros/build/unitree_guide2/CTestConfiguration.ini
   Site: yk-VirtualBox
   Build name: (empty)
 Add coverage exclude regular expressions.
Create new tag: 20241108-1141 - Experimental
UpdateCTestConfiguration  from :/home/yk/rosros/build/unitree_guide2/CTestConfiguration.ini
Parse Config file:/home/yk/rosros/build/unitree_guide2/CTestConfiguration.ini
Test project /home/yk/rosros/build/unitree_guide2
Constructing a list of tests
Done constructing a list of tests
Updating test list for fixtures
Added 0 tests to meet fixture requirements
Checking test dependency graph...
Checking test dependency graph end
test 1
    Start 1: cppcheck

1: Test command: /usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/cppcheck.xunit.xml" "--package-name" "unitree_guide2" "--output-file" "/home/yk/rosros/build/unitree_guide2/ament_cppcheck/cppcheck.txt" "--command" "/opt/ros/humble/bin/ament_cppcheck" "--xunit-file" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/cppcheck.xunit.xml" "--include_dirs" "/home/yk/rosros/src/unitree_ros2_sim/unitree_guide2/include"
1: Test timeout computed to be: 300
1: -- run_test.py: invoking following command in '/home/yk/rosros/src/unitree_ros2_sim/unitree_guide2':
1:  - /opt/ros/humble/bin/ament_cppcheck --xunit-file /home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/cppcheck.xunit.xml --include_dirs /home/yk/rosros/src/unitree_ros2_sim/unitree_guide2/include
1: cppcheck 2.7 has known performance issues and therefore will not be used, set the AMENT_CPPCHECK_ALLOW_SLOW_VERSIONS environment variable to override this.
1: -- run_test.py: return code 0
1: -- run_test.py: verify result file '/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/cppcheck.xunit.xml'
1/4 Test #1: cppcheck .........................   Passed    0.25 sec
test 2
    Start 2: lint_cmake

2: Test command: /usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/lint_cmake.xunit.xml" "--package-name" "unitree_guide2" "--output-file" "/home/yk/rosros/build/unitree_guide2/ament_lint_cmake/lint_cmake.txt" "--command" "/opt/ros/humble/bin/ament_lint_cmake" "--xunit-file" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/lint_cmake.xunit.xml"
2: Test timeout computed to be: 60
2: -- run_test.py: invoking following command in '/home/yk/rosros/src/unitree_ros2_sim/unitree_guide2':
2:  - /opt/ros/humble/bin/ament_lint_cmake --xunit-file /home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/lint_cmake.xunit.xml
2: 
2: No problems found
2: -- run_test.py: return code 0
2: -- run_test.py: verify result file '/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/lint_cmake.xunit.xml'
2/4 Test #2: lint_cmake .......................   Passed    0.17 sec
test 3
    Start 3: uncrustify

3: Test command: /usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/uncrustify.xunit.xml" "--package-name" "unitree_guide2" "--output-file" "/home/yk/rosros/build/unitree_guide2/ament_uncrustify/uncrustify.txt" "--command" "/opt/ros/humble/bin/ament_uncrustify" "--xunit-file" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/uncrustify.xunit.xml"
3: Test timeout computed to be: 60
3: -- run_test.py: invoking following command in '/home/yk/rosros/src/unitree_ros2_sim/unitree_guide2':
3:  - /opt/ros/humble/bin/ament_uncrustify --xunit-file /home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/uncrustify.xunit.xml
3: Code style divergence in file 'include/FSM/FSM.h':
3: 
3: --- include/FSM/FSM.h
3: +++ include/FSM/FSM.h.uncrustify
3: @@ -26,9 +26,10 @@
3: -struct FSMStateList{
3: -    FSMState *invalid;
3: -    State_Passive *passive;
3: -    State_FixedStand *fixedStand;
3: -    State_FreeStand *freeStand;
3: -    State_Trotting *trotting;
3: -    State_BalanceTest *balanceTest;
3: -    State_SwingTest *swingTest;
3: -    State_StepTest *stepTest;
3: +struct FSMStateList
3: +{
3: +  FSMState * invalid;
3: +  State_Passive * passive;
3: +  State_FixedStand * fixedStand;
3: +  State_FreeStand * freeStand;
3: +  State_Trotting * trotting;
3: +  State_BalanceTest * balanceTest;
3: +  State_SwingTest * swingTest;
3: +  State_StepTest * stepTest;
3: @@ -36 +37 @@
3: -    State_move_base *moveBase;
3: +  State_move_base * moveBase;
3: @@ -40 +41 @@
3: -    State_move_base *moveBase;
3: +  State_move_base * moveBase;
3: @@ -43,9 +44,10 @@
3: -    void deletePtr(){
3: -        delete invalid;
3: -        delete passive;
3: -        delete fixedStand;
3: -        delete freeStand;
3: -        delete trotting;
3: -        delete balanceTest;
3: -        delete swingTest;
3: -        delete stepTest;
3: +  void deletePtr()
3: +  {
3: +    delete invalid;
3: +    delete passive;
3: +    delete fixedStand;
3: +    delete freeStand;
3: +    delete trotting;
3: +    delete balanceTest;
3: +    delete swingTest;
3: +    delete stepTest;
3: @@ -53 +55 @@
3: -        delete moveBase;
3: +    delete moveBase;
3: @@ -56 +58 @@
3: -        delete moveBase;
3: +    delete moveBase;
3: @@ -58 +60 @@
3: -    }
3: +  }
3: @@ -61 +63 @@
3: -class FSM{
3: +class FSM {
3: @@ -63,4 +65,5 @@
3: -    FSM(CtrlComponents *ctrlComp);
3: -    ~FSM();
3: -    void initialize();
3: -    void run();
3: +  FSM(CtrlComponents * ctrlComp);
3: +  ~FSM();
3: +  void initialize();
3: +  void run();
3: +
3: @@ -68,10 +71,10 @@
3: -    FSMState* getNextState(FSMStateName stateName);
3: -    bool checkSafty();
3: -    CtrlComponents *_ctrlComp;
3: -    FSMState *_currentState;
3: -    FSMState *_nextState;
3: -    FSMStateName _nextStateName;
3: -    FSMStateList _stateList;
3: -    FSMMode _mode;
3: -    long long _startTime;
3: -    int count;
3: +  FSMState * getNextState(FSMStateName stateName);
3: +  bool checkSafty();
3: +  CtrlComponents * _ctrlComp;
3: +  FSMState * _currentState;
3: +  FSMState * _nextState;
3: +  FSMStateName _nextStateName;
3: +  FSMStateList _stateList;
3: +  FSMMode _mode;
3: +  long long _startTime;
3: +  int count;
3: @@ -81 +84 @@
3: -#endif  // FSM_H
3: +#endif  // FSM_H
3: 
3: Code style divergence in file 'include/FSM/FSMState.h':
3: 
3: --- include/FSM/FSMState.h
3: +++ include/FSM/FSMState.h.uncrustify
3: @@ -19 +19 @@
3: -class FSMState{
3: +class FSMState {
3: @@ -21 +21 @@
3: -    FSMState(CtrlComponents *ctrlComp, FSMStateName stateName, std::string stateNameString);
3: +  FSMState(CtrlComponents * ctrlComp, FSMStateName stateName, std::string stateNameString);
3: @@ -23,4 +23,4 @@
3: -    virtual void enter() = 0;
3: -    virtual void run() = 0;
3: -    virtual void exit() = 0;
3: -    virtual FSMStateName checkChange() {return FSMStateName::INVALID;}
3: +  virtual void enter() = 0;
3: +  virtual void run() = 0;
3: +  virtual void exit() = 0;
3: +  virtual FSMStateName checkChange() {return FSMStateName::INVALID;}
3: @@ -28,2 +28,3 @@
3: -    FSMStateName _stateName;
3: -    std::string _stateNameString;
3: +  FSMStateName _stateName;
3: +  std::string _stateNameString;
3: +
3: @@ -31,2 +32,2 @@
3: -    CtrlComponents *_ctrlComp;
3: -    FSMStateName _nextStateName;
3: +  CtrlComponents * _ctrlComp;
3: +  FSMStateName _nextStateName;
3: @@ -34,3 +35,3 @@
3: -    LowlevelCmd *_lowCmd;
3: -    LowlevelState *_lowState;
3: -    UserValue _userValue;
3: +  LowlevelCmd * _lowCmd;
3: +  LowlevelState * _lowState;
3: +  UserValue _userValue;
3: @@ -39 +40 @@
3: -#endif  // FSMSTATE_H
3: +#endif  // FSMSTATE_H
3: 
3: Code style divergence in file 'include/FSM/State_BalanceTest.h':
3: 
3: --- include/FSM/State_BalanceTest.h
3: +++ include/FSM/State_BalanceTest.h.uncrustify
3: @@ -9 +9 @@
3: -class State_BalanceTest : public FSMState{
3: +class State_BalanceTest: public FSMState {
3: @@ -11,6 +11,8 @@
3: -    State_BalanceTest(CtrlComponents *ctrlComp);
3: -    ~State_BalanceTest(){}
3: -    void enter();
3: -    void run();
3: -    void exit();
3: -    FSMStateName checkChange();
3: +  State_BalanceTest(CtrlComponents * ctrlComp);
3: +  ~State_BalanceTest() {
3: +  }
3: +  void enter();
3: +  void run();
3: +  void exit();
3: +  FSMStateName checkChange();
3: +
3: @@ -18 +20 @@
3: -    void calcTau();
3: +  void calcTau();
3: @@ -20,3 +22,3 @@
3: -    Estimator *_est;
3: -    QuadrupedRobot *_robModel;
3: -    BalanceCtrl *_balCtrl;
3: +  Estimator * _est;
3: +  QuadrupedRobot * _robModel;
3: +  BalanceCtrl * _balCtrl;
3: @@ -24 +26 @@
3: -    VecInt4 *_contact;
3: +  VecInt4 * _contact;
3: @@ -26,5 +28,5 @@
3: -    RotMat _Rd, _RdInit;
3: -    Vec3 _pcd, _pcdInit;
3: -    double _kpw;
3: -    Mat3 _Kpp, _Kdp, _Kdw;
3: -    Vec3 _ddPcd, _dWbd;
3: +  RotMat _Rd, _RdInit;
3: +  Vec3 _pcd, _pcdInit;
3: +  double _kpw;
3: +  Mat3 _Kpp, _Kdp, _Kdw;
3: +  Vec3 _ddPcd, _dWbd;
3: @@ -32,5 +34,5 @@
3: -    Vec12 _q, _tau;
3: -    Vec3 _posBody, _velBody;
3: -    RotMat _B2G_RotMat, _G2B_RotMat;
3: -    Vec34 _posFeet2BGlobal;
3: -    Vec34 _forceFeetGlobal, _forceFeetBody;
3: +  Vec12 _q, _tau;
3: +  Vec3 _posBody, _velBody;
3: +  RotMat _B2G_RotMat, _G2B_RotMat;
3: +  Vec34 _posFeet2BGlobal;
3: +  Vec34 _forceFeetGlobal, _forceFeetBody;
3: @@ -38,4 +40,4 @@
3: -    float _xMax, _xMin;
3: -    float _yMax, _yMin;
3: -    float _zMax, _zMin;
3: -    float _yawMax, _yawMin;
3: +  float _xMax, _xMin;
3: +  float _yMax, _yMin;
3: +  float _zMax, _zMin;
3: +  float _yawMax, _yawMin;
3: @@ -44 +46 @@
3: -#endif  // BALANCETEST_H
3: +#endif  // BALANCETEST_H
3: 
3: Code style divergence in file 'include/FSM/State_FixedStand.h':
3: 
3: --- include/FSM/State_FixedStand.h
3: +++ include/FSM/State_FixedStand.h.uncrustify
3: @@ -9 +9 @@
3: -class State_FixedStand : public FSMState{
3: +class State_FixedStand: public FSMState {
3: @@ -11,6 +11,7 @@
3: -    State_FixedStand(CtrlComponents *ctrlComp);
3: -    ~State_FixedStand(){}
3: -    void enter();
3: -    void run();
3: -    void exit();
3: -    FSMStateName checkChange();
3: +  State_FixedStand(CtrlComponents * ctrlComp);
3: +  ~State_FixedStand() {
3: +  }
3: +  void enter();
3: +  void run();
3: +  void exit();
3: +  FSMStateName checkChange();
3: @@ -19,5 +20,5 @@
3: -    float _targetPos[12] = {0.0, 0.67, -1.3, 0.0, 0.67, -1.3, 
3: -                            0.0, 0.67, -1.3, 0.0, 0.67, -1.3};
3: -    float _startPos[12];
3: -    float _duration = 1000;   //steps
3: -    float _percent = 0;       //%
3: +  float _targetPos[12] = {0.0, 0.67, -1.3, 0.0, 0.67, -1.3,
3: +    0.0, 0.67, -1.3, 0.0, 0.67, -1.3};
3: +  float _startPos[12];
3: +  float _duration = 1000;     //steps
3: +  float _percent = 0;         //%
3: @@ -26 +27 @@
3: -#endif  // FIXEDSTAND_H
3: +#endif  // FIXEDSTAND_H
3: 
3: Code style divergence in file 'include/FSM/State_FreeStand.h':
3: 
3: --- include/FSM/State_FreeStand.h
3: +++ include/FSM/State_FreeStand.h.uncrustify
3: @@ -9 +9 @@
3: -class State_FreeStand : public FSMState{
3: +class State_FreeStand: public FSMState {
3: @@ -11,6 +11,8 @@
3: -    State_FreeStand(CtrlComponents *ctrlComp);
3: -    ~State_FreeStand(){}
3: -    void enter();
3: -    void run();
3: -    void exit();
3: -    FSMStateName checkChange();
3: +  State_FreeStand(CtrlComponents * ctrlComp);
3: +  ~State_FreeStand() {
3: +  }
3: +  void enter();
3: +  void run();
3: +  void exit();
3: +  FSMStateName checkChange();
3: +
3: @@ -18,6 +20,6 @@
3: -    Vec3 _initVecOX;
3: -    Vec34 _initVecXP;
3: -    float _rowMax, _rowMin;
3: -    float _pitchMax, _pitchMin;
3: -    float _yawMax, _yawMin;
3: -    float _heightMax, _heightMin;
3: +  Vec3 _initVecOX;
3: +  Vec34 _initVecXP;
3: +  float _rowMax, _rowMin;
3: +  float _pitchMax, _pitchMin;
3: +  float _yawMax, _yawMin;
3: +  float _heightMax, _heightMin;
3: @@ -25,2 +27,2 @@
3: -    Vec34 _calcOP(float row, float pitch, float yaw, float height);
3: -    void _calcCmd(Vec34 vecOP);
3: +  Vec34 _calcOP(float row, float pitch, float yaw, float height);
3: +  void _calcCmd(Vec34 vecOP);
3: @@ -29 +31 @@
3: -#endif  // FREESTAND_H
3: +#endif  // FREESTAND_H
3: 
3: Code style divergence in file 'include/FSM/State_Passive.h':
3: 
3: --- include/FSM/State_Passive.h
3: +++ include/FSM/State_Passive.h.uncrustify
3: @@ -9 +9 @@
3: -class State_Passive : public FSMState{
3: +class State_Passive: public FSMState {
3: @@ -11,5 +11,5 @@
3: -    State_Passive(CtrlComponents *ctrlComp);
3: -    void enter();
3: -    void run();
3: -    void exit();
3: -    FSMStateName checkChange();
3: +  State_Passive(CtrlComponents * ctrlComp);
3: +  void enter();
3: +  void run();
3: +  void exit();
3: +  FSMStateName checkChange();
3: @@ -18 +18 @@
3: -#endif  // PASSIVE_H
3: +#endif  // PASSIVE_H
3: 
3: Code style divergence in file 'include/FSM/State_StepTest.h':
3: 
3: --- include/FSM/State_StepTest.h
3: +++ include/FSM/State_StepTest.h.uncrustify
3: @@ -9 +9 @@
3: -class State_StepTest : public FSMState{
3: +class State_StepTest: public FSMState {
3: @@ -11,6 +11,8 @@
3: -    State_StepTest(CtrlComponents *ctrlComp);
3: -    ~State_StepTest(){}
3: -    void enter();
3: -    void run();
3: -    void exit();
3: -    FSMStateName checkChange();
3: +  State_StepTest(CtrlComponents * ctrlComp);
3: +  ~State_StepTest() {
3: +  }
3: +  void enter();
3: +  void run();
3: +  void exit();
3: +  FSMStateName checkChange();
3: +
3: @@ -18 +20 @@
3: -    void calcTau();
3: +  void calcTau();
3: @@ -20 +22 @@
3: -    float _gaitHeight;
3: +  float _gaitHeight;
3: @@ -22,3 +24,3 @@
3: -    Estimator *_est;
3: -    QuadrupedRobot *_robModel;
3: -    BalanceCtrl *_balCtrl;
3: +  Estimator * _est;
3: +  QuadrupedRobot * _robModel;
3: +  BalanceCtrl * _balCtrl;
3: @@ -26,2 +28,2 @@
3: -    VecInt4 *_contact;
3: -    Vec4 *_phase;
3: +  VecInt4 * _contact;
3: +  Vec4 * _phase;
3: @@ -29,5 +31,5 @@
3: -    RotMat _Rd;
3: -    Vec3 _pcd;
3: -    Mat3 _Kpp, _Kpw, _Kdp, _Kdw;
3: -    Mat3 _KpSwing, _KdSwing;
3: -    Vec3 _ddPcd, _dWbd;
3: +  RotMat _Rd;
3: +  Vec3 _pcd;
3: +  Mat3 _Kpp, _Kpw, _Kdp, _Kdw;
3: +  Mat3 _KpSwing, _KdSwing;
3: +  Vec3 _ddPcd, _dWbd;
3: @@ -35,7 +37,7 @@
3: -    Vec12 _q, _tau;
3: -    Vec3 _posBody, _velBody;
3: -    RotMat _B2G_RotMat, _G2B_RotMat;
3: -    Vec34 _posFeet2BGlobal;
3: -    Vec34 _posFeetGlobalInit, _posFeetGlobalGoal, _velFeetGlobalGoal;
3: -    Vec34 _posFeetGlobal, _velFeetGlobal;
3: -    Vec34 _forceFeetGlobal, _forceFeetBody;
3: +  Vec12 _q, _tau;
3: +  Vec3 _posBody, _velBody;
3: +  RotMat _B2G_RotMat, _G2B_RotMat;
3: +  Vec34 _posFeet2BGlobal;
3: +  Vec34 _posFeetGlobalInit, _posFeetGlobalGoal, _velFeetGlobalGoal;
3: +  Vec34 _posFeetGlobal, _velFeetGlobal;
3: +  Vec34 _forceFeetGlobal, _forceFeetBody;
3: @@ -44 +46 @@
3: -#endif  // STEPTEST_H
3: +#endif  // STEPTEST_H
3: 
3: Code style divergence in file 'include/FSM/State_SwingTest.h':
3: 
3: --- include/FSM/State_SwingTest.h
3: +++ include/FSM/State_SwingTest.h.uncrustify
3: @@ -10 +10 @@
3: -class State_SwingTest : public FSMState{
3: +class State_SwingTest: public FSMState {
3: @@ -12,6 +12,8 @@
3: -    State_SwingTest(CtrlComponents *ctrlComp);
3: -    ~State_SwingTest(){};
3: -    void enter();
3: -    void run();
3: -    void exit();
3: -    FSMStateName checkChange();
3: +  State_SwingTest(CtrlComponents * ctrlComp);
3: +  ~State_SwingTest() {
3: +  };
3: +  void enter();
3: +  void run();
3: +  void exit();
3: +  FSMStateName checkChange();
3: +
3: @@ -19,2 +21,2 @@
3: -    void _positionCtrl();
3: -    void _torqueCtrl();
3: +  void _positionCtrl();
3: +  void _torqueCtrl();
3: @@ -22,7 +24,7 @@
3: -    Vec34 _initFeetPos, _feetPos;
3: -    Vec3  _initPos, _posGoal;
3: -    Vec12 _targetPos;
3: -    float _xMin, _xMax;
3: -    float _yMin, _yMax;
3: -    float _zMin, _zMax;
3: -    Mat3 _Kp, _Kd;
3: +  Vec34 _initFeetPos, _feetPos;
3: +  Vec3 _initPos, _posGoal;
3: +  Vec12 _targetPos;
3: +  float _xMin, _xMax;
3: +  float _yMin, _yMax;
3: +  float _zMin, _zMax;
3: +  Mat3 _Kp, _Kd;
3: @@ -31 +33 @@
3: -#endif  // STATE_SWINGTEST_H
3: +#endif  // STATE_SWINGTEST_H
3: 
3: Code style divergence in file 'include/FSM/State_Trotting.h':
3: 
3: --- include/FSM/State_Trotting.h
3: +++ include/FSM/State_Trotting.h.uncrustify
3: @@ -11 +11 @@
3: -class State_Trotting : public FSMState{
3: +class State_Trotting: public FSMState {
3: @@ -13,7 +13,8 @@
3: -    State_Trotting(CtrlComponents *ctrlComp);
3: -    ~State_Trotting();
3: -    void enter();
3: -    void run();
3: -    void exit();
3: -    virtual FSMStateName checkChange();
3: -    void setHighCmd(double vx, double vy, double wz);
3: +  State_Trotting(CtrlComponents * ctrlComp);
3: +  ~State_Trotting();
3: +  void enter();
3: +  void run();
3: +  void exit();
3: +  virtual FSMStateName checkChange();
3: +  void setHighCmd(double vx, double vy, double wz);
3: +
3: @@ -21,6 +22,6 @@
3: -    void calcTau();
3: -    void calcQQd();
3: -    void calcCmd();
3: -    virtual void getUserCmd();
3: -    void calcBalanceKp();
3: -    bool checkStepOrNot();
3: +  void calcTau();
3: +  void calcQQd();
3: +  void calcCmd();
3: +  virtual void getUserCmd();
3: +  void calcBalanceKp();
3: +  bool checkStepOrNot();
3: @@ -28,4 +29,4 @@
3: -    GaitGenerator *_gait;
3: -    Estimator *_est;
3: -    QuadrupedRobot *_robModel;
3: -    BalanceCtrl *_balCtrl;
3: +  GaitGenerator * _gait;
3: +  Estimator * _est;
3: +  QuadrupedRobot * _robModel;
3: +  BalanceCtrl * _balCtrl;
3: @@ -33,7 +34,7 @@
3: -    // Rob State
3: -    Vec3  _posBody, _velBody;
3: -    double _yaw, _dYaw;
3: -    Vec34 _posFeetGlobal, _velFeetGlobal;
3: -    Vec34 _posFeet2BGlobal;
3: -    RotMat _B2G_RotMat, _G2B_RotMat;
3: -    Vec12 _q;
3: +  // Rob State
3: +  Vec3 _posBody, _velBody;
3: +  double _yaw, _dYaw;
3: +  Vec34 _posFeetGlobal, _velFeetGlobal;
3: +  Vec34 _posFeet2BGlobal;
3: +  RotMat _B2G_RotMat, _G2B_RotMat;
3: +  Vec12 _q;
3: @@ -41,13 +42,13 @@
3: -    // Robot command
3: -    Vec3 _pcd;
3: -    Vec3 _vCmdGlobal, _vCmdBody;
3: -    double _yawCmd, _dYawCmd;
3: -    double _dYawCmdPast;
3: -    Vec3 _wCmdGlobal;
3: -    Vec34 _posFeetGlobalGoal, _velFeetGlobalGoal;
3: -    Vec34 _posFeet2BGoal, _velFeet2BGoal;
3: -    RotMat _Rd;
3: -    Vec3 _ddPcd, _dWbd;
3: -    Vec34 _forceFeetGlobal, _forceFeetBody;
3: -    Vec34 _qGoal, _qdGoal;
3: -    Vec12 _tau;
3: +  // Robot command
3: +  Vec3 _pcd;
3: +  Vec3 _vCmdGlobal, _vCmdBody;
3: +  double _yawCmd, _dYawCmd;
3: +  double _dYawCmdPast;
3: +  Vec3 _wCmdGlobal;
3: +  Vec34 _posFeetGlobalGoal, _velFeetGlobalGoal;
3: +  Vec34 _posFeet2BGoal, _velFeet2BGoal;
3: +  RotMat _Rd;
3: +  Vec3 _ddPcd, _dWbd;
3: +  Vec34 _forceFeetGlobal, _forceFeetBody;
3: +  Vec34 _qGoal, _qdGoal;
3: +  Vec12 _tau;
3: @@ -55,9 +56,9 @@
3: -    // Control Parameters
3: -    double _gaitHeight;
3: -    Vec3 _posError, _velError;
3: -    Mat3 _Kpp, _Kdp, _Kdw;
3: -    double _kpw;
3: -    Mat3 _KpSwing, _KdSwing;
3: -    Vec2 _vxLim, _vyLim, _wyawLim;
3: -    Vec4 *_phase;
3: -    VecInt4 *_contact;
3: +  // Control Parameters
3: +  double _gaitHeight;
3: +  Vec3 _posError, _velError;
3: +  Mat3 _Kpp, _Kdp, _Kdw;
3: +  double _kpw;
3: +  Mat3 _KpSwing, _KdSwing;
3: +  Vec2 _vxLim, _vyLim, _wyawLim;
3: +  Vec4 * _phase;
3: +  VecInt4 * _contact;
3: @@ -65,3 +66,3 @@
3: -    // Calculate average value
3: -    AvgCov *_avg_posError = new AvgCov(3, "_posError", true, 1000, 1000, 1);
3: -    AvgCov *_avg_angError = new AvgCov(3, "_angError", true, 1000, 1000, 1000);
3: +  // Calculate average value
3: +  AvgCov * _avg_posError = new AvgCov(3, "_posError", true, 1000, 1000, 1);
3: +  AvgCov * _avg_angError = new AvgCov(3, "_angError", true, 1000, 1000, 1000);
3: @@ -70 +71 @@
3: -#endif  // TROTTING_H
3: +#endif  // TROTTING_H
3: 
3: Code style divergence in file 'include/FSM/State_move_base.h':
3: 
3: --- include/FSM/State_move_base.h
3: +++ include/FSM/State_move_base.h.uncrustify
3: @@ -13 +13 @@
3: -class State_move_base : public State_Trotting{
3: +class State_move_base: public State_Trotting {
3: @@ -15,3 +15,5 @@
3: -    State_move_base(CtrlComponents *ctrlComp);
3: -    ~State_move_base(){}
3: -    FSMStateName checkChange();
3: +  State_move_base(CtrlComponents * ctrlComp);
3: +  ~State_move_base() {
3: +  }
3: +  FSMStateName checkChange();
3: +
3: @@ -19,7 +21,7 @@
3: -    void getUserCmd();
3: -    void initRecv();
3: -    void twistCallback(const geometry_msgs::Twist::msg::SharedPtr msg);
3: -    ros::NodeHandle _nm;
3: -    ros::Subscriber _cmdSub;
3: -    double _vx, _vy;
3: -    double _wz;
3: +  void getUserCmd();
3: +  void initRecv();
3: +  void twistCallback(const geometry_msgs::Twist::msg::SharedPtr msg);
3: +  ros::NodeHandle _nm;
3: +  ros::Subscriber _cmdSub;
3: +  double _vx, _vy;
3: +  double _wz;
3: @@ -41 +43 @@
3: -class State_move_base : public State_Trotting{
3: +class State_move_base: public State_Trotting {
3: @@ -43,3 +45,5 @@
3: -    State_move_base(CtrlComponents *ctrlComp);
3: -    ~State_move_base(){}
3: -    FSMStateName checkChange();
3: +  State_move_base(CtrlComponents * ctrlComp);
3: +  ~State_move_base() {
3: +  }
3: +  FSMStateName checkChange();
3: +
3: @@ -47,9 +51,9 @@
3: -    void getUserCmd();
3: -    void initRecv();
3: -    void twistCallback(const geometry_msgs::msg::Twist::SharedPtr msg);
3: -    rclcpp::Node::SharedPtr _nm;
3: -    rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr _cmdSub;
3: -    double _vx, _vy;
3: -    double _wz;
3: -    rclcpp::executors::MultiThreadedExecutor::SharedPtr executor;
3: -    std::thread executor_thread;
3: +  void getUserCmd();
3: +  void initRecv();
3: +  void twistCallback(const geometry_msgs::msg::Twist::SharedPtr msg);
3: +  rclcpp::Node::SharedPtr _nm;
3: +  rclcpp::Subscription < geometry_msgs::msg::Twist > ::SharedPtr _cmdSub;
3: +  double _vx, _vy;
3: +  double _wz;
3: +  rclcpp::executors::MultiThreadedExecutor::SharedPtr executor;
3: +  std::thread executor_thread;
3: @@ -60 +64 @@
3: -#endif  // COMPILE_WITH_ROS2_MB
3: +#endif  // COMPILE_WITH_ROS2_MB
3: 
3: Code style divergence in file 'include/Gait/FeetEndCal.h':
3: 
3: --- include/Gait/FeetEndCal.h
3: +++ include/Gait/FeetEndCal.h.uncrustify
3: @@ -10 +10 @@
3: -class FeetEndCal{
3: +class FeetEndCal {
3: @@ -12,3 +12,4 @@
3: -    FeetEndCal(CtrlComponents *ctrlComp);
3: -    ~FeetEndCal();
3: -    Vec3 calFootPos(int legID, Vec2 vxyGoalGlobal, float dYawGoal, float phase);
3: +  FeetEndCal(CtrlComponents * ctrlComp);
3: +  ~FeetEndCal();
3: +  Vec3 calFootPos(int legID, Vec2 vxyGoalGlobal, float dYawGoal, float phase);
3: +
3: @@ -16,3 +17,3 @@
3: -    LowlevelState *_lowState;
3: -    Estimator *_est;
3: -    QuadrupedRobot *_robModel;
3: +  LowlevelState * _lowState;
3: +  Estimator * _est;
3: +  QuadrupedRobot * _robModel;
3: @@ -20,4 +21,4 @@
3: -    Vec3 _nextStep, _footPos;
3: -    Vec3 _bodyVelGlobal;        // linear velocity
3: -    Vec3 _bodyAccGlobal;        // linear accelerator
3: -    Vec3 _bodyWGlobal;          // angular velocity
3: +  Vec3 _nextStep, _footPos;
3: +  Vec3 _bodyVelGlobal;          // linear velocity
3: +  Vec3 _bodyAccGlobal;          // linear accelerator
3: +  Vec3 _bodyWGlobal;            // angular velocity
3: @@ -25,2 +26,2 @@
3: -    Vec4 _feetRadius, _feetInitAngle;
3: -    float _yaw, _dYaw, _nextYaw;
3: +  Vec4 _feetRadius, _feetInitAngle;
3: +  float _yaw, _dYaw, _nextYaw;
3: @@ -28,2 +29,2 @@
3: -    float _Tstance, _Tswing;
3: -    float _kx, _ky, _kyaw;
3: +  float _Tstance, _Tswing;
3: +  float _kx, _ky, _kyaw;
3: @@ -32 +33 @@
3: -#endif  // FEETENDCAL_H
3: +#endif  // FEETENDCAL_H
3: 
3: Code style divergence in file 'include/Gait/GaitGenerator.h':
3: 
3: --- include/Gait/GaitGenerator.h
3: +++ include/Gait/GaitGenerator.h.uncrustify
3: @@ -15 +15 @@
3: -class GaitGenerator{
3: +class GaitGenerator {
3: @@ -17,7 +17,8 @@
3: -    GaitGenerator(CtrlComponents *ctrlComp);
3: -    ~GaitGenerator();
3: -    void setGait(Vec2 vxyGoalGlobal, float dYawGoal, float gaitHeight);
3: -    void run(Vec34 &feetPos, Vec34 &feetVel);
3: -    Vec3 getFootPos(int i);
3: -    Vec3 getFootVel(int i);
3: -    void restart();
3: +  GaitGenerator(CtrlComponents * ctrlComp);
3: +  ~GaitGenerator();
3: +  void setGait(Vec2 vxyGoalGlobal, float dYawGoal, float gaitHeight);
3: +  void run(Vec34 & feetPos, Vec34 & feetVel);
3: +  Vec3 getFootPos(int i);
3: +  Vec3 getFootVel(int i);
3: +  void restart();
3: +
3: @@ -25,4 +26,4 @@
3: -    float cycloidXYPosition(float startXY, float endXY, float phase);
3: -    float cycloidXYVelocity(float startXY, float endXY, float phase);
3: -    float cycloidZPosition(float startZ, float height, float phase);
3: -    float cycloidZVelocity(float height, float phase);
3: +  float cycloidXYPosition(float startXY, float endXY, float phase);
3: +  float cycloidXYVelocity(float startXY, float endXY, float phase);
3: +  float cycloidZPosition(float startZ, float height, float phase);
3: +  float cycloidZVelocity(float height, float phase);
3: @@ -30,12 +31,12 @@
3: -    WaveGenerator *_waveG;
3: -    Estimator *_est;
3: -    FeetEndCal *_feetCal;
3: -    QuadrupedRobot *_robModel;
3: -    LowlevelState *_state;
3: -    float _gaitHeight;
3: -    Vec2 _vxyGoal;
3: -    float _dYawGoal;
3: -    Vec4 *_phase, _phasePast;
3: -    VecInt4 *_contact;
3: -    Vec34 _startP, _endP, _idealP, _pastP;
3: -    bool _firstRun;
3: +  WaveGenerator * _waveG;
3: +  Estimator * _est;
3: +  FeetEndCal * _feetCal;
3: +  QuadrupedRobot * _robModel;
3: +  LowlevelState * _state;
3: +  float _gaitHeight;
3: +  Vec2 _vxyGoal;
3: +  float _dYawGoal;
3: +  Vec4 * _phase, _phasePast;
3: +  VecInt4 * _contact;
3: +  Vec34 _startP, _endP, _idealP, _pastP;
3: +  bool _firstRun;
3: @@ -44 +45 @@
3: -    PyPlot _testGaitPlot;
3: +  PyPlot _testGaitPlot;
3: @@ -49 +50 @@
3: -#endif  // GAITGENERATOR_H
3: +#endif  // GAITGENERATOR_H
3: 
3: Code style divergence in file 'include/Gait/WaveGenerator.h':
3: 
3: --- include/Gait/WaveGenerator.h
3: +++ include/Gait/WaveGenerator.h.uncrustify
3: @@ -17 +17 @@
3: -class WaveGenerator{
3: +class WaveGenerator {
3: @@ -19,6 +19,7 @@
3: -    WaveGenerator(double period, double stancePhaseRatio, Vec4 bias);
3: -    ~WaveGenerator();
3: -    void calcContactPhase(Vec4 &phaseResult, VecInt4 &contactResult, WaveStatus status);
3: -    float getTstance();
3: -    float getTswing();
3: -    float getT();
3: +  WaveGenerator(double period, double stancePhaseRatio, Vec4 bias);
3: +  ~WaveGenerator();
3: +  void calcContactPhase(Vec4 & phaseResult, VecInt4 & contactResult, WaveStatus status);
3: +  float getTstance();
3: +  float getTswing();
3: +  float getT();
3: +
3: @@ -26 +27 @@
3: -    void calcWave(Vec4 &phase, VecInt4 &contact, WaveStatus status);
3: +  void calcWave(Vec4 & phase, VecInt4 & contact, WaveStatus status);
3: @@ -28,3 +29,3 @@
3: -    double _period;
3: -    double _stRatio;
3: -    Vec4 _bias;
3: +  double _period;
3: +  double _stRatio;
3: +  Vec4 _bias;
3: @@ -32,5 +33,5 @@
3: -    Vec4 _normalT;                   // [0, 1)
3: -    Vec4 _phase, _phasePast;
3: -    VecInt4 _contact, _contactPast;
3: -    VecInt4 _switchStatus;          // 1: switching, 0: do not switch
3: -    WaveStatus _statusPast;
3: +  Vec4 _normalT;                     // [0, 1)
3: +  Vec4 _phase, _phasePast;
3: +  VecInt4 _contact, _contactPast;
3: +  VecInt4 _switchStatus;            // 1: switching, 0: do not switch
3: +  WaveStatus _statusPast;
3: @@ -38,2 +39,2 @@
3: -    double _passT;                   // unit: second
3: -    long long _startT;    // unit: us
3: +  double _passT;                     // unit: second
3: +  long long _startT;      // unit: us
3: @@ -41 +42 @@
3: -    PyPlot _testPlot;
3: +  PyPlot _testPlot;
3: @@ -46 +47 @@
3: -#endif  // WAVEGENERATOR_H
3: +#endif  // WAVEGENERATOR_H
3: 
3: Code style divergence in file 'include/common/LowPassFilter.h':
3: 
3: --- include/common/LowPassFilter.h
3: +++ include/common/LowPassFilter.h.uncrustify
3: @@ -7 +7 @@
3: -class LPFilter{
3: +class LPFilter {
3: @@ -9,5 +9,6 @@
3: -    LPFilter(double samplePeriod, double cutFrequency);
3: -    ~LPFilter();
3: -    void addValue(double newValue);
3: -    double getValue();
3: -    void clear();
3: +  LPFilter(double samplePeriod, double cutFrequency);
3: +  ~LPFilter();
3: +  void addValue(double newValue);
3: +  double getValue();
3: +  void clear();
3: +
3: @@ -15,3 +16,3 @@
3: -    double _weight;
3: -    double _pastValue;
3: -    bool _start;
3: +  double _weight;
3: +  double _pastValue;
3: +  bool _start;
3: @@ -20 +21 @@
3: -#endif  // LOWPASSFILTER
3: +#endif  // LOWPASSFILTER
3: 
3: Code style divergence in file 'include/common/PyPlot.h':
3: 
3: --- include/common/PyPlot.h
3: +++ include/common/PyPlot.h.uncrustify
3: @@ -18,12 +18,11 @@
3: -struct Curve{
3: -    std::vector<double> x;
3: -    std::vector<double> y;
3: -
3: -    void printXY(double xRough, int pointNum){
3: -        for(int i(0); i<x.size(); ++i){
3: -            if(xRough < x[i]){
3: -                for(int j(0); j < pointNum; ++j){
3: -                    std::cout << "  X: " << x[i+j] << ", Y: " << y[i+j] << std::endl;
3: -                }
3: -                break;
3: -            }
3: +struct Curve
3: +{
3: +  std::vector < double > x;
3: +  std::vector < double > y;
3: +
3: +  void printXY(double xRough, int pointNum)
3: +  {
3: +    for (int i(0); i < x.size(); ++i) {
3: +      if (xRough < x[i]) {
3: +        for (int j(0); j < pointNum; ++j) {
3: +          std::cout << "  X: " << x[i + j] << ", Y: " << y[i + j] << std::endl;
3: @@ -31 +30,4 @@
3: -    }
3: +        break;
3: +      }
3: +    }
3: +  }
3: @@ -34,30 +36,33 @@
3: -struct Plot{
3: -    std::vector<Curve*> curves;
3: -    std::vector<std::string> labels;
3: -    std::string plotName;
3: -    int curveCount;
3: -
3: -    std::map<std::string, int> curveName2ID;
3: -
3: -    Plot(std::string name, int count, std::vector<std::string> labelVec)
3: -        :plotName(name), curveCount(count), labels(labelVec){
3: -        for(int i(0); i < count; ++i){
3: -            curveName2ID.insert(std::pair<std::string, int>(labels[i], i));
3: -            curves.push_back(new Curve());
3: -        }
3: -    }
3: -
3: -    ~Plot(){
3: -        for(int i(0); i < curveCount; ++i){
3: -            delete curves[i];
3: -        }
3: -    }
3: -
3: -    double getX(long long startT){
3: -        return (double)(getSystemTime() - startT) * 1e-6;
3: -    }
3: -
3: -    void printXY(std::string curveName, double xRough, int pointNum){
3: -        std::cout << "[DEBUG] Plot: " << plotName << ", Curve: " << curveName << std::endl;
3: -        curves[curveName2ID[curveName]]->printXY(xRough, pointNum);
3: -    }
3: +struct Plot
3: +{
3: +  std::vector < Curve * > curves;
3: +  std::vector < std::string > labels;
3: +  std::string plotName;
3: +  int curveCount;
3: +
3: +  std::map < std::string, int > curveName2ID;
3: +
3: +  Plot(std::string name, int count, std::vector < std::string > labelVec)
3: +    : plotName(name), curveCount(count), labels(labelVec) {
3: +    for (int i(0); i < count; ++i) {
3: +      curveName2ID.insert(std::pair < std::string, int > (labels[i], i));
3: +      curves.push_back(new Curve());
3: +    }
3: +  }
3: +
3: +  ~Plot() {
3: +    for (int i(0); i < curveCount; ++i) {
3: +      delete curves[i];
3: +    }
3: +  }
3: +
3: +  double getX(long long startT)
3: +  {
3: +    return (double)(getSystemTime() - startT) * 1e-6;
3: +  }
3: +
3: +  void printXY(std::string curveName, double xRough, int pointNum)
3: +  {
3: +    std::cout << "[DEBUG] Plot: " << plotName << ", Curve: " << curveName << std::endl;
3: +    curves[curveName2ID[curveName]]->printXY(xRough, pointNum);
3: +  }
3: @@ -66 +71 @@
3: -class PyPlot{
3: +class PyPlot {
3: @@ -68,27 +73,27 @@
3: -    PyPlot();
3: -    ~PyPlot();
3: -    void addPlot(std::string plotName, int curveCount, std::vector<std::string> labelVec);
3: -    void addPlot(std::string plotName, int curveCount);
3: -    void showPlot(std::string plotName);
3: -    void showPlot(std::vector<std::string> plotNameVec);
3: -    void showPlotAll();
3: -
3: -    void printXY(std::string plotName, std::string curveName, double xRough, int pointNum = 1);
3: -
3: -    void addFrame(std::string plotName, double value);
3: -    void addFrame(std::string plotName, double x, double value);
3: -
3: -    template <typename T>
3: -    void addFrame(std::string plotName, T* valueArray);
3: -    template <typename T>
3: -    void addFrame(std::string plotName, double x, T* valueArray);
3: -
3: -    template <typename T>
3: -    void addFrame(std::string plotName, const Eigen::MatrixBase<T> &vec);
3: -    template <typename T>
3: -    void addFrame(std::string plotName, double x, const Eigen::MatrixBase<T> &vec);
3: -
3: -    template <typename T>
3: -    void addFrame(std::string plotName, const std::vector<T> &vec);
3: -    template <typename T>
3: -    void addFrame(std::string plotName, double x, const std::vector<T> &vec);
3: +  PyPlot();
3: +  ~PyPlot();
3: +  void addPlot(std::string plotName, int curveCount, std::vector < std::string > labelVec);
3: +  void addPlot(std::string plotName, int curveCount);
3: +  void showPlot(std::string plotName);
3: +  void showPlot(std::vector < std::string > plotNameVec);
3: +  void showPlotAll();
3: +
3: +  void printXY(std::string plotName, std::string curveName, double xRough, int pointNum = 1);
3: +
3: +  void addFrame(std::string plotName, double value);
3: +  void addFrame(std::string plotName, double x, double value);
3: +
3: +  template < typename T >
3: +  void addFrame(std::string plotName, T * valueArray);
3: +  template < typename T >
3: +  void addFrame(std::string plotName, double x, T * valueArray);
3: +
3: +  template < typename T >
3: +  void addFrame(std::string plotName, const Eigen::MatrixBase < T > & vec);
3: +  template < typename T >
3: +  void addFrame(std::string plotName, double x, const Eigen::MatrixBase < T > & vec);
3: +
3: +  template < typename T >
3: +  void addFrame(std::string plotName, const std::vector < T > & vec);
3: +  template < typename T >
3: +  void addFrame(std::string plotName, double x, const std::vector < T > & vec);
3: @@ -97,8 +102,8 @@
3: -    void _checkStart();
3: -    int _plotCount = 0;
3: -    std::map<std::string, int> _plotName2ID;
3: -    std::vector< Plot* > _plots;
3: -    long long _pointNum;
3: -    Plot* _getPlotPtr(std::string plotName);
3: -    bool start;
3: -    long long startT;
3: +  void _checkStart();
3: +  int _plotCount = 0;
3: +  std::map < std::string, int > _plotName2ID;
3: +  std::vector < Plot * > _plots;
3: +  long long _pointNum;
3: +  Plot * _getPlotPtr(std::string plotName);
3: +  bool start;
3: +  long long startT;
3: @@ -107,43 +112,68 @@
3: -inline PyPlot::PyPlot(){
3: -    start = false;
3: -}
3: -
3: -inline PyPlot::~PyPlot(){
3: -    for(int i(0); i < _plotCount; ++i){
3: -        delete _plots[i];
3: -    }
3: -}
3: -
3: -inline void PyPlot::_checkStart(){
3: -    if(!start){
3: -        start = true;
3: -        startT = getSystemTime();
3: -    }
3: -}
3: -
3: -inline void PyPlot::printXY(std::string plotName, std::string curveName, double xRough, int pointNum){
3: -    _plots[_plotName2ID[plotName]]->printXY(curveName, xRough, pointNum);
3: -}
3: -
3: -inline void PyPlot::addPlot(std::string plotName, int curveCount, std::vector<std::string> labelVec){
3: -    if(_plotName2ID.count(plotName) == 0){
3: -        _plotName2ID.insert(std::pair<std::string, int>(plotName, _plotCount));
3: -        ++_plotCount;
3: -
3: -        _plots.push_back( new Plot(plotName, curveCount, labelVec) );
3: -    }else{
3: -        std::cout << "[ERROR] Already has same Plot: " << plotName << std::endl;
3: -        exit(-1);
3: -    }
3: -}
3: -
3: -inline void PyPlot::addPlot(std::string plotName, int curveCount){
3: -    std::vector<std::string> label;
3: -    for(int i(0); i < curveCount; ++i){
3: -        label.push_back(std::to_string(i+1));
3: -    }
3: -    addPlot(plotName, curveCount, label);
3: -}
3: -
3: -inline void PyPlot::showPlot(std::string plotName){
3: -    Plot* plot = _getPlotPtr(plotName);
3: +inline PyPlot::PyPlot()
3: +{
3: +  start = false;
3: +}
3: +
3: +inline PyPlot::~PyPlot()
3: +{
3: +  for (int i(0); i < _plotCount; ++i) {
3: +    delete _plots[i];
3: +  }
3: +}
3: +
3: +inline void PyPlot::_checkStart()
3: +{
3: +  if (!start) {
3: +    start = true;
3: +    startT = getSystemTime();
3: +  }
3: +}
3: +
3: +inline void PyPlot::printXY(
3: +  std::string plotName, std::string curveName, double xRough,
3: +  int pointNum)
3: +{
3: +  _plots[_plotName2ID[plotName]]->printXY(curveName, xRough, pointNum);
3: +}
3: +
3: +inline void PyPlot::addPlot(
3: +  std::string plotName, int curveCount,
3: +  std::vector < std::string > labelVec)
3: +{
3: +  if (_plotName2ID.count(plotName) == 0) {
3: +    _plotName2ID.insert(std::pair < std::string, int > (plotName, _plotCount));
3: +    ++_plotCount;
3: +
3: +    _plots.push_back(new Plot(plotName, curveCount, labelVec) );
3: +  } else {
3: +    std::cout << "[ERROR] Already has same Plot: " << plotName << std::endl;
3: +    exit(-1);
3: +  }
3: +}
3: +
3: +inline void PyPlot::addPlot(std::string plotName, int curveCount)
3: +{
3: +  std::vector < std::string > label;
3: +  for (int i(0); i < curveCount; ++i) {
3: +    label.push_back(std::to_string(i + 1));
3: +  }
3: +  addPlot(plotName, curveCount, label);
3: +}
3: +
3: +inline void PyPlot::showPlot(std::string plotName)
3: +{
3: +  Plot * plot = _getPlotPtr(plotName);
3: +  plt::figure();
3: +  plt::title(plot->plotName);
3: +  for (int i(0); i < plot->curveCount; ++i) {
3: +    plt::named_plot(plot->labels[i], plot->curves[i]->x, plot->curves[i]->y);
3: +  }
3: +  plt::legend();
3: +  plt::show();
3: +}
3: +
3: +inline void PyPlot::showPlot(std::vector < std::string > plotNameVec)
3: +{
3: +  for (std::vector < std::string > ::iterator itName = plotNameVec.begin();
3: +    itName != plotNameVec.end(); ++itName)
3: +  {
3: @@ -150,0 +181 @@
3: +    Plot * plot = _plots[_plotName2ID[*itName]];
3: @@ -152,2 +183,2 @@
3: -    for(int i(0); i < plot->curveCount; ++i){
3: -        plt::named_plot(plot->labels[i], plot->curves[i]->x, plot->curves[i]->y);
3: +    for (int i(0); i < plot->curveCount; ++i) {
3: +      plt::named_plot(plot->labels[i], plot->curves[i]->x, plot->curves[i]->y);
3: @@ -156,103 +187,101 @@
3: -    plt::show();
3: -}
3: -
3: -inline void PyPlot::showPlot(std::vector<std::string> plotNameVec){
3: -    for(std::vector<std::string>::iterator itName = plotNameVec.begin(); itName != plotNameVec.end(); ++itName){
3: -        plt::figure();
3: -        Plot* plot = _plots[_plotName2ID[*itName]];
3: -        plt::title(plot->plotName);
3: -        for(int i(0); i < plot->curveCount; ++i){
3: -            plt::named_plot(plot->labels[i], plot->curves[i]->x, plot->curves[i]->y);
3: -        }
3: -        plt::legend();
3: -    }
3: -    plt::show();
3: -}
3: -
3: -inline void PyPlot::showPlotAll(){
3: -    for(int i(0); i < _plotCount; ++i){
3: -        plt::figure();
3: -        Plot* plot = _plots[i];
3: -        plt::title(plot->plotName);
3: -        for(int j(0); j < plot->curveCount; ++j){
3: -            plt::named_plot(plot->labels[j], plot->curves[j]->x, plot->curves[j]->y);
3: -        }
3: -        plt::legend();
3: -    }
3: -    plt::show();
3: -    exit(0);
3: -}
3: -
3: -inline Plot* PyPlot::_getPlotPtr(std::string plotName){
3: -    if(_plotName2ID.count(plotName) == 0){
3: -        std::cout << "[ERROR] Plot " << plotName << " does not exist" << std::endl;
3: -        exit(-1);
3: -    }else{
3: -        return _plots[_plotName2ID[plotName]];
3: -    }
3: -}
3: -
3: -inline void PyPlot::addFrame(std::string plotName, double value){
3: -    _checkStart();
3: -    Plot* plot = _getPlotPtr(plotName);
3: -    addFrame(plotName, plot->getX(startT), value);
3: -}
3: -
3: -inline void PyPlot::addFrame(std::string plotName, double x, double value){
3: -    Plot* plot = _getPlotPtr(plotName);
3: -    
3: -    plot->curves[0]->x.push_back(x);
3: -    plot->curves[0]->y.push_back(value);
3: -}
3: -
3: -template <typename T>
3: -inline void PyPlot::addFrame(std::string plotName, T* valueArray){
3: -    _checkStart();
3: -    Plot* plot = _getPlotPtr(plotName);
3: -    addFrame(plotName, plot->getX(startT), valueArray);
3: -}
3: -
3: -template <typename T>
3: -inline void PyPlot::addFrame(std::string plotName, double x, T* valueArray){
3: -    Plot* plot = _getPlotPtr(plotName);
3: -
3: -    for(int i(0); i < plot->curveCount; ++i){
3: -        plot->curves[i]->x.push_back(x);
3: -        plot->curves[i]->y.push_back(valueArray[i]);
3: -    }
3: -}
3: -
3: -template <typename T>
3: -inline void PyPlot::addFrame(std::string plotName, const Eigen::MatrixBase<T> &vec){
3: -    _checkStart();
3: -    Plot* plot = _getPlotPtr(plotName);
3: -    addFrame(plotName, plot->getX(startT), vec);
3: -}
3: -
3: -template <typename T>
3: -inline void PyPlot::addFrame(std::string plotName, double x, const Eigen::MatrixBase<T> &vec){
3: -    Plot* plot = _getPlotPtr(plotName);
3: -
3: -    for(int i(0); i < plot->curveCount; ++i){
3: -        plot->curves[i]->x.push_back(x);
3: -        plot->curves[i]->y.push_back(vec(i));
3: -    }
3: -}
3: -
3: -template <typename T>
3: -inline void PyPlot::addFrame(std::string plotName, const std::vector<T> &vec){
3: -    _checkStart();
3: -    Plot* plot = _getPlotPtr(plotName);
3: -    addFrame(plotName, plot->getX(startT), vec);
3: -}
3: -
3: -template <typename T>
3: -inline void PyPlot::addFrame(std::string plotName, double x, const std::vector<T> &vec){
3: -    Plot* plot = _getPlotPtr(plotName);
3: -
3: -    for(int i(0); i < plot->curveCount; ++i){
3: -        plot->curves[i]->x.push_back(x);
3: -        plot->curves[i]->y.push_back(vec[i]);
3: -    }
3: -}
3: -#endif // PYPLOT_H
3: +  }
3: +  plt::show();
3: +}
3: +
3: +inline void PyPlot::showPlotAll()
3: +{
3: +  for (int i(0); i < _plotCount; ++i) {
3: +    plt::figure();
3: +    Plot * plot = _plots[i];
3: +    plt::title(plot->plotName);
3: +    for (int j(0); j < plot->curveCount; ++j) {
3: +      plt::named_plot(plot->labels[j], plot->curves[j]->x, plot->curves[j]->y);
3: +    }
3: +    plt::legend();
3: +  }
3: +  plt::show();
3: +  exit(0);
3: +}
3: +
3: +inline Plot * PyPlot::_getPlotPtr(std::string plotName)
3: +{
3: +  if (_plotName2ID.count(plotName) == 0) {
3: +    std::cout << "[ERROR] Plot " << plotName << " does not exist" << std::endl;
3: +    exit(-1);
3: +  } else {
3: +    return _plots[_plotName2ID[plotName]];
3: +  }
3: +}
3: +
3: +inline void PyPlot::addFrame(std::string plotName, double value)
3: +{
3: +  _checkStart();
3: +  Plot * plot = _getPlotPtr(plotName);
3: +  addFrame(plotName, plot->getX(startT), value);
3: +}
3: +
3: +inline void PyPlot::addFrame(std::string plotName, double x, double value)
3: +{
3: +  Plot * plot = _getPlotPtr(plotName);
3: +
3: +  plot->curves[0]->x.push_back(x);
3: +  plot->curves[0]->y.push_back(value);
3: +}
3: +
3: +template < typename T >
3: +inline void PyPlot::addFrame(std::string plotName, T * valueArray)
3: +{
3: +  _checkStart();
3: +  Plot * plot = _getPlotPtr(plotName);
3: +  addFrame(plotName, plot->getX(startT), valueArray);
3: +}
3: +
3: +template < typename T >
3: +inline void PyPlot::addFrame(std::string plotName, double x, T * valueArray)
3: +{
3: +  Plot * plot = _getPlotPtr(plotName);
3: +
3: +  for (int i(0); i < plot->curveCount; ++i) {
3: +    plot->curves[i]->x.push_back(x);
3: +    plot->curves[i]->y.push_back(valueArray[i]);
3: +  }
3: +}
3: +
3: +template < typename T >
3: +inline void PyPlot::addFrame(std::string plotName, const Eigen::MatrixBase < T > & vec)
3: +{
3: +  _checkStart();
3: +  Plot * plot = _getPlotPtr(plotName);
3: +  addFrame(plotName, plot->getX(startT), vec);
3: +}
3: +
3: +template < typename T >
3: +inline void PyPlot::addFrame(std::string plotName, double x, const Eigen::MatrixBase < T > & vec)
3: +{
3: +  Plot * plot = _getPlotPtr(plotName);
3: +
3: +  for (int i(0); i < plot->curveCount; ++i) {
3: +    plot->curves[i]->x.push_back(x);
3: +    plot->curves[i]->y.push_back(vec(i));
3: +  }
3: +}
3: +
3: +template < typename T >
3: +inline void PyPlot::addFrame(std::string plotName, const std::vector < T > & vec)
3: +{
3: +  _checkStart();
3: +  Plot * plot = _getPlotPtr(plotName);
3: +  addFrame(plotName, plot->getX(startT), vec);
3: +}
3: +
3: +template < typename T >
3: +inline void PyPlot::addFrame(std::string plotName, double x, const std::vector < T > & vec)
3: +{
3: +  Plot * plot = _getPlotPtr(plotName);
3: +
3: +  for (int i(0); i < plot->curveCount; ++i) {
3: +    plot->curves[i]->x.push_back(x);
3: +    plot->curves[i]->y.push_back(vec[i]);
3: +  }
3: +}
3: +#endif // PYPLOT_H
3: 
3: Code style divergence in file 'include/common/enumClass.h':
3: 
3: --- include/common/enumClass.h
3: +++ include/common/enumClass.h.uncrustify
3: @@ -10,3 +10,4 @@
3: -enum class CtrlPlatform{
3: -    GAZEBO,
3: -    REALROBOT,
3: +enum class CtrlPlatform
3: +{
3: +  GAZEBO,
3: +  REALROBOT,
3: @@ -15,3 +16,4 @@
3: -enum class RobotType{
3: -    A1,
3: -    Go1
3: +enum class RobotType
3: +{
3: +  A1,
3: +  Go1
3: @@ -20,7 +22,8 @@
3: -enum class UserCommand{
3: -    // EXIT,
3: -    NONE,
3: -    START,      // trotting
3: -    L2_A,       // fixedStand
3: -    L2_B,       // passive
3: -    L2_X,       // freeStand
3: +enum class UserCommand
3: +{
3: +  // EXIT,
3: +  NONE,
3: +  START,        // trotting
3: +  L2_A,         // fixedStand
3: +  L2_B,         // passive
3: +  L2_X,         // freeStand
3: @@ -28 +31 @@
3: -    L2_Y,       // move_base
3: +  L2_Y,         // move_base
3: @@ -31 +34 @@
3: -    L2_Y,       // move_base
3: +  L2_Y,         // move_base
3: @@ -33,3 +36,3 @@
3: -    L1_X,       // balanceTest
3: -    L1_A,       // swingTest
3: -    L1_Y        // stepTest
3: +  L1_X,         // balanceTest
3: +  L1_A,         // swingTest
3: +  L1_Y          // stepTest
3: @@ -38,4 +41,5 @@
3: -enum class FrameType{
3: -    BODY,
3: -    HIP,
3: -    GLOBAL
3: +enum class FrameType
3: +{
3: +  BODY,
3: +  HIP,
3: +  GLOBAL
3: @@ -44,4 +48,5 @@
3: -enum class WaveStatus{
3: -    STANCE_ALL,
3: -    SWING_ALL,
3: -    WAVE_ALL
3: +enum class WaveStatus
3: +{
3: +  STANCE_ALL,
3: +  SWING_ALL,
3: +  WAVE_ALL
3: @@ -50,3 +55,4 @@
3: -enum class FSMMode{
3: -    NORMAL,
3: -    CHANGE
3: +enum class FSMMode
3: +{
3: +  NORMAL,
3: +  CHANGE
3: @@ -55,7 +61,8 @@
3: -enum class FSMStateName{
3: -    // EXIT,
3: -    INVALID,
3: -    PASSIVE,
3: -    FIXEDSTAND,
3: -    FREESTAND,
3: -    TROTTING,
3: +enum class FSMStateName
3: +{
3: +  // EXIT,
3: +  INVALID,
3: +  PASSIVE,
3: +  FIXEDSTAND,
3: +  FREESTAND,
3: +  TROTTING,
3: @@ -63 +70 @@
3: -    MOVE_BASE,       // move_base
3: +  MOVE_BASE,         // move_base
3: @@ -66 +73 @@
3: -    MOVE_BASE,       // move_base
3: +  MOVE_BASE,         // move_base
3: @@ -68,3 +75,3 @@
3: -    BALANCETEST,
3: -    SWINGTEST,
3: -    STEPTEST
3: +  BALANCETEST,
3: +  SWINGTEST,
3: +  STEPTEST
3: @@ -73 +80 @@
3: -#endif  // ENUMCLASS_H
3: +#endif  // ENUMCLASS_H
3: 
3: Code style divergence in file 'include/common/mathTools.h':
3: 
3: --- include/common/mathTools.h
3: +++ include/common/mathTools.h.uncrustify
3: @@ -11,19 +11,290 @@
3: -template<typename T1, typename T2>
3: -inline T1 max(const T1 a, const T2 b){
3: -	return (a > b ? a : b);
3: -}
3: -
3: -template<typename T1, typename T2>
3: -inline T1 min(const T1 a, const T2 b){
3: -	return (a < b ? a : b);
3: -}
3: -
3: -template<typename T>
3: -inline T saturation(const T a, Vec2 limits){
3: -    T lowLim, highLim;
3: -    if(limits(0) > limits(1)){
3: -        lowLim = limits(1);
3: -        highLim= limits(0);
3: -    }else{
3: -        lowLim = limits(0);
3: -        highLim= limits(1);
3: +template < typename T1, typename T2 >
3: +inline T1 max(const T1 a, const T2 b)
3: +{
3: +  return a > b ? a : b;
3: +}
3: +
3: +template < typename T1, typename T2 >
3: +inline T1 min(const T1 a, const T2 b)
3: +{
3: +  return a < b ? a : b;
3: +}
3: +
3: +template < typename T >
3: +inline T saturation(const T a, Vec2 limits)
3: +{
3: +  T lowLim, highLim;
3: +  if (limits(0) > limits(1)) {
3: +    lowLim = limits(1);
3: +    highLim = limits(0);
3: +  } else {
3: +    lowLim = limits(0);
3: +    highLim = limits(1);
3: +  }
3: +
3: +  if (a < lowLim) {
3: +    return lowLim;
3: +  } else if (a > highLim) {
3: +    return highLim;
3: +  } else {
3: +    return a;
3: +  }
3: +}
3: +
3: +template < typename T0, typename T1 >
3: +inline T0 killZeroOffset(T0 a, const T1 limit)
3: +{
3: +  if ((a > -limit) && (a < limit)) {
3: +    a = 0;
3: +  }
3: +  return a;
3: +}
3: +
3: +template < typename T0, typename T1, typename T2 >
3: +inline T1 invNormalize(
3: +  const T0 value, const T1 min, const T2 max, const double minLim = -1,
3: +  const double maxLim = 1)
3: +{
3: +  return (value - minLim) * (max - min) / (maxLim - minLim) + min;
3: +}
3: +
3: +template < typename T >
3: +inline T windowFunc(const T x, const T windowRatio, const T xRange = 1.0, const T yRange = 1.0)
3: +{
3: +  if ((x < 0) || (x > xRange)) {
3: +    std::cout << "[ERROR][windowFunc] The x=" << x << ", which should between [0, xRange]" <<
3: +      std::endl;
3: +  }
3: +  if ((windowRatio <= 0) || (windowRatio >= 0.5)) {
3: +    std::cout << "[ERROR][windowFunc] The windowRatio=" << windowRatio <<
3: +      ", which should between [0, 0.5]" << std::endl;
3: +  }
3: +
3: +  if (x / xRange < windowRatio) {
3: +    return x * yRange / (xRange * windowRatio);
3: +  } else if (x / xRange > 1 - windowRatio) {
3: +    return yRange * (xRange - x) / (xRange * windowRatio);
3: +  } else {
3: +    return yRange;
3: +  }
3: +}
3: +
3: +template < typename T1, typename T2 >
3: +inline void updateAverage(T1 & exp, T2 newValue, double n)
3: +{
3: +  if (exp.rows() != newValue.rows()) {
3: +    std::cout << "The size of updateAverage is error" << std::endl;
3: +    exit(-1);
3: +  }
3: +  if (fabs(n - 1) < 0.001) {
3: +    exp = newValue;
3: +  } else {
3: +    exp = exp + (newValue - exp) / n;
3: +  }
3: +}
3: +
3: +template < typename T1, typename T2, typename T3 >
3: +inline void updateCovariance(T1 & cov, T2 expPast, T3 newValue, double n)
3: +{
3: +  if ( (cov.rows() != cov.cols()) || (cov.rows() != expPast.rows()) ||
3: +    (expPast.rows() != newValue.rows()))
3: +  {
3: +    std::cout << "The size of updateCovariance is error" << std::endl;
3: +    exit(-1);
3: +  }
3: +  if (fabs(n - 1) < 0.1) {
3: +    cov.setZero();
3: +  } else {
3: +    cov = cov * (n - 1) / n + (newValue - expPast) * (newValue - expPast).transpose() * (n - 1) /
3: +      (n * n);
3: +  }
3: +}
3: +
3: +template < typename T1, typename T2, typename T3 >
3: +inline void updateAvgCov(T1 & cov, T2 & exp, T3 newValue, double n)
3: +{
3: +  // The order matters!!! covariance first!!!
3: +  updateCovariance(cov, exp, newValue, n);
3: +  updateAverage(exp, newValue, n);
3: +}
3: +
3: +inline RotMat rotx(const double & theta)
3: +{
3: +  double s = std::sin(theta);
3: +  double c = std::cos(theta);
3: +
3: +  RotMat R;
3: +  R << 1, 0, 0, 0, c, -s, 0, s, c;
3: +  return R;
3: +}
3: +
3: +inline RotMat roty(const double & theta)
3: +{
3: +  double s = std::sin(theta);
3: +  double c = std::cos(theta);
3: +
3: +  RotMat R;
3: +  R << c, 0, s, 0, 1, 0, -s, 0, c;
3: +  return R;
3: +}
3: +
3: +inline RotMat rotz(const double & theta)
3: +{
3: +  double s = std::sin(theta);
3: +  double c = std::cos(theta);
3: +
3: +  RotMat R;
3: +  R << c, -s, 0, s, c, 0, 0, 0, 1;
3: +  return R;
3: +}
3: +
3: +inline Mat2 skew(const double & w)
3: +{
3: +  Mat2 mat; mat.setZero();
3: +  mat(0, 1) = -w;
3: +  mat(1, 0) = w;
3: +  return mat;
3: +}
3: +
3: +inline Mat3 skew(const Vec3 & v)
3: +{
3: +  Mat3 m;
3: +  m << 0, -v(2), v(1),
3: +    v(2), 0, -v(0),
3: +    -v(1), v(0), 0;
3: +  return m;
3: +}
3: +
3: +inline RotMat rpyToRotMat(const double & row, const double & pitch, const double & yaw)
3: +{
3: +  RotMat m = rotz(yaw) * roty(pitch) * rotx(row);
3: +  return m;
3: +}
3: +
3: +inline Vec3 rotMatToRPY(const Mat3 & R)
3: +{
3: +  Vec3 rpy;
3: +  rpy(0) = atan2(R(2, 1), R(2, 2));
3: +  rpy(1) = asin(-R(2, 0));
3: +  rpy(2) = atan2(R(1, 0), R(0, 0));
3: +  return rpy;
3: +}
3: +
3: +inline RotMat quatToRotMat(const Quat & q)
3: +{
3: +  double e0 = q(0);
3: +  double e1 = q(1);
3: +  double e2 = q(2);
3: +  double e3 = q(3);
3: +
3: +  RotMat R;
3: +  R << 1 - 2 * (e2 * e2 + e3 * e3), 2 * (e1 * e2 - e0 * e3),
3: +    2 * (e1 * e3 + e0 * e2), 2 * (e1 * e2 + e0 * e3),
3: +    1 - 2 * (e1 * e1 + e3 * e3), 2 * (e2 * e3 - e0 * e1),
3: +    2 * (e1 * e3 - e0 * e2), 2 * (e2 * e3 + e0 * e1),
3: +    1 - 2 * (e1 * e1 + e2 * e2);
3: +  return R;
3: +}
3: +
3: +inline Vec3 rotMatToExp(const RotMat & rm)
3: +{
3: +  double cosValue = rm.trace() / 2.0 - 1 / 2.0;
3: +  if (cosValue > 1.0f) {
3: +    cosValue = 1.0f;
3: +  } else if (cosValue < -1.0f) {
3: +    cosValue = -1.0f;
3: +  }
3: +
3: +  double angle = acos(cosValue);
3: +  Vec3 exp;
3: +  if (fabs(angle) < 1e-5) {
3: +    exp = Vec3(0, 0, 0);
3: +  } else if (fabs(angle - M_PI) < 1e-5) {
3: +    exp = angle * Vec3(rm(0, 0) + 1, rm(0, 1), rm(0, 2)) / sqrt(2 * (1 + rm(0, 0)));
3: +  } else {
3: +    exp = angle / (2.0f * sin(angle)) * Vec3(
3: +      rm(2, 1) - rm(1, 2), rm(0, 2) - rm(2, 0), rm(1, 0) - rm(
3: +        0, 1));
3: +  }
3: +  return exp;
3: +}
3: +
3: +inline HomoMat homoMatrix(Vec3 p, RotMat m)
3: +{
3: +  HomoMat homoM;
3: +  homoM.setZero();
3: +  homoM.topLeftCorner(3, 3) = m;
3: +  homoM.topRightCorner(3, 1) = p;
3: +  homoM(3, 3) = 1;
3: +  return homoM;
3: +}
3: +
3: +inline HomoMat homoMatrix(Vec3 p, Quat q)
3: +{
3: +  HomoMat homoM;
3: +  homoM.setZero();
3: +  homoM.topLeftCorner(3, 3) = quatToRotMat(q);
3: +  homoM.topRightCorner(3, 1) = p;
3: +  homoM(3, 3) = 1;
3: +  return homoM;
3: +}
3: +
3: +inline HomoMat homoMatrixInverse(HomoMat homoM)
3: +{
3: +  HomoMat homoInv;
3: +  homoInv.setZero();
3: +  homoInv.topLeftCorner(3, 3) = homoM.topLeftCorner(3, 3).transpose();
3: +  homoInv.topRightCorner(
3: +    3,
3: +    1) = -homoM.topLeftCorner(3, 3).transpose() * homoM.topRightCorner(3, 1);
3: +  homoInv(3, 3) = 1;
3: +  return homoInv;
3: +}
3: +
3: +//  add 1 at the end of Vec3
3: +inline Vec4 homoVec(Vec3 v3)
3: +{
3: +  Vec4 v4;
3: +  v4.block(0, 0, 3, 1) = v3;
3: +  v4(3) = 1;
3: +  return v4;
3: +}
3: +
3: +//  remove 1 at the end of Vec4
3: +inline Vec3 noHomoVec(Vec4 v4)
3: +{
3: +  Vec3 v3;
3: +  v3 = v4.block(0, 0, 3, 1);
3: +  return v3;
3: +}
3: +
3: +// Calculate average value and covariance
3: +class AvgCov {
3: +public:
3: +  AvgCov(
3: +    unsigned int size, std::string name, bool avgOnly = false, unsigned int showPeriod = 1000,
3: +    unsigned int waitCount = 5000, double zoomFactor = 10000)
3: +    : _size(size), _showPeriod(showPeriod), _waitCount(waitCount), _zoomFactor(zoomFactor),
3: +    _valueName(name), _avgOnly(avgOnly) {
3: +    _exp.resize(size);
3: +    _cov.resize(size, size);
3: +    _defaultWeight.resize(size, size);
3: +    _defaultWeight.setIdentity();
3: +    _measureCount = 0;
3: +  }
3: +  void measure(VecX newValue)
3: +  {
3: +    ++_measureCount;
3: +
3: +    if (_measureCount > _waitCount) {
3: +      updateAvgCov(_cov, _exp, newValue, _measureCount - _waitCount);
3: +      if (_measureCount % _showPeriod == 0) {
3: +        std::cout << "******" << _valueName << " measured count: " << _measureCount - _waitCount <<
3: +          "******" << std::endl;
3: +        std::cout << _zoomFactor << " Times Average of " << _valueName << std::endl <<
3: +          (_zoomFactor * _exp).transpose() << std::endl;
3: +        if (!_avgOnly) {
3: +          std::cout << _zoomFactor << " Times Covariance of " << _valueName << std::endl <<
3: +            _zoomFactor * _cov << std::endl;
3: +        }
3: +      }
3: @@ -31,237 +302,2 @@
3: -
3: -    if(a < lowLim){
3: -        return lowLim;
3: -    }
3: -    else if(a > highLim){
3: -        return highLim;
3: -    }
3: -    else{
3: -        return a;
3: -    }
3: -}
3: -
3: -template<typename T0, typename T1>
3: -inline T0 killZeroOffset(T0 a, const T1 limit){
3: -    if((a > -limit) && (a < limit)){
3: -        a = 0;
3: -    }
3: -    return a;
3: -}
3: -
3: -template<typename T0, typename T1, typename T2>
3: -inline T1 invNormalize(const T0 value, const T1 min, const T2 max, const double minLim = -1, const double maxLim = 1){
3: -	return (value-minLim)*(max-min)/(maxLim-minLim) + min;
3: -}
3: -
3: -template<typename T>
3: -inline T windowFunc(const T x, const T windowRatio, const T xRange=1.0, const T yRange=1.0){
3: -    if((x < 0)||(x > xRange)){
3: -        std::cout << "[ERROR][windowFunc] The x=" << x << ", which should between [0, xRange]" << std::endl;
3: -    }
3: -    if((windowRatio <= 0)||(windowRatio >= 0.5)){
3: -        std::cout << "[ERROR][windowFunc] The windowRatio=" << windowRatio << ", which should between [0, 0.5]" << std::endl;
3: -    }
3: -
3: -    if(x/xRange < windowRatio){
3: -        return x * yRange / (xRange * windowRatio);
3: -    }
3: -    else if(x/xRange > 1 - windowRatio){
3: -        return yRange * (xRange - x)/(xRange * windowRatio);
3: -    }
3: -    else{
3: -        return yRange;
3: -    }
3: -}
3: -
3: -template<typename T1, typename T2>
3: -inline void updateAverage(T1 &exp, T2 newValue, double n){
3: -    if(exp.rows()!=newValue.rows()){
3: -        std::cout << "The size of updateAverage is error" << std::endl;
3: -        exit(-1);
3: -    }
3: -    if(fabs(n - 1) < 0.001){
3: -        exp = newValue;
3: -    }else{
3: -        exp = exp + (newValue - exp)/n;
3: -    }
3: -}
3: -
3: -template<typename T1, typename T2, typename T3>
3: -inline void updateCovariance(T1 &cov, T2 expPast, T3 newValue, double n){
3: -    if( (cov.rows()!=cov.cols()) || (cov.rows() != expPast.rows()) || (expPast.rows()!=newValue.rows())){
3: -        std::cout << "The size of updateCovariance is error" << std::endl;
3: -        exit(-1);
3: -    }
3: -    if(fabs(n - 1) < 0.1){
3: -        cov.setZero();
3: -    }else{
3: -        cov = cov*(n-1)/n + (newValue-expPast)*(newValue-expPast).transpose()*(n-1)/(n*n);
3: -    }
3: -}
3: -
3: -template<typename T1, typename T2, typename T3>
3: -inline void updateAvgCov(T1 &cov, T2 &exp, T3 newValue, double n){
3: -    // The order matters!!! covariance first!!!
3: -    updateCovariance(cov, exp, newValue, n);
3: -    updateAverage(exp, newValue, n);
3: -}
3: -
3: -inline RotMat rotx(const double &theta) {
3: -    double s = std::sin(theta);
3: -    double c = std::cos(theta);
3: -
3: -    RotMat R;
3: -    R << 1, 0, 0, 0, c, -s, 0, s, c;
3: -    return R;
3: -}
3: -
3: -inline RotMat roty(const double &theta) {
3: -    double s = std::sin(theta);
3: -    double c = std::cos(theta);
3: -
3: -    RotMat R;
3: -    R << c, 0, s, 0, 1, 0, -s, 0, c;
3: -    return R;
3: -}
3: -
3: -inline RotMat rotz(const double &theta) {
3: -    double s = std::sin(theta);
3: -    double c = std::cos(theta);
3: -
3: -    RotMat R;
3: -    R << c, -s, 0, s, c, 0, 0, 0, 1;
3: -    return R;
3: -}
3: -
3: -inline Mat2 skew(const double& w){
3: -    Mat2 mat; mat.setZero();
3: -    mat(0, 1) = -w;
3: -    mat(1, 0) =  w;
3: -    return mat;
3: -}
3: -
3: -inline Mat3 skew(const Vec3& v) {
3: -    Mat3 m;
3: -    m << 0, -v(2), v(1),
3: -            v(2), 0, -v(0),
3: -            -v(1), v(0), 0;
3: -    return m;
3: -}
3: -
3: -inline RotMat rpyToRotMat(const double& row, const double& pitch, const double& yaw) {
3: -    RotMat m = rotz(yaw) * roty(pitch) * rotx(row);
3: -    return m;
3: -}
3: -
3: -inline Vec3 rotMatToRPY(const Mat3& R) {
3: -    Vec3 rpy;
3: -    rpy(0) = atan2(R(2,1),R(2,2));
3: -    rpy(1) = asin(-R(2,0));
3: -    rpy(2) = atan2(R(1,0),R(0,0));
3: -    return rpy;
3: -}
3: -
3: -inline RotMat quatToRotMat(const Quat& q) {
3: -    double e0 = q(0);
3: -    double e1 = q(1);
3: -    double e2 = q(2);
3: -    double e3 = q(3);
3: -
3: -    RotMat R;
3: -    R << 1 - 2 * (e2 * e2 + e3 * e3), 2 * (e1 * e2 - e0 * e3),
3: -            2 * (e1 * e3 + e0 * e2), 2 * (e1 * e2 + e0 * e3),
3: -            1 - 2 * (e1 * e1 + e3 * e3), 2 * (e2 * e3 - e0 * e1),
3: -            2 * (e1 * e3 - e0 * e2), 2 * (e2 * e3 + e0 * e1),
3: -            1 - 2 * (e1 * e1 + e2 * e2);
3: -    return R;
3: -}
3: -
3: -inline Vec3 rotMatToExp(const RotMat& rm){
3: -    double cosValue = rm.trace()/2.0-1/2.0;
3: -    if(cosValue > 1.0f){
3: -        cosValue = 1.0f;
3: -    }else if(cosValue < -1.0f){
3: -        cosValue = -1.0f;
3: -    }
3: -
3: -    double angle = acos(cosValue);
3: -    Vec3 exp;
3: -    if (fabs(angle) < 1e-5){
3: -        exp=Vec3(0,0,0);
3: -    }
3: -    else if (fabs(angle - M_PI) < 1e-5){
3: -        exp = angle * Vec3(rm(0,0)+1, rm(0,1), rm(0,2)) / sqrt(2*(1+rm(0, 0)));
3: -    }
3: -    else{
3: -        exp=angle/(2.0f*sin(angle))*Vec3(rm(2,1)-rm(1,2),rm(0,2)-rm(2,0),rm(1,0)-rm(0,1));
3: -    }
3: -    return exp;
3: -}
3: -
3: -inline HomoMat homoMatrix(Vec3 p, RotMat m){
3: -    HomoMat homoM;
3: -    homoM.setZero();
3: -    homoM.topLeftCorner(3, 3) = m;
3: -    homoM.topRightCorner(3, 1) = p;
3: -    homoM(3, 3) = 1;
3: -    return homoM;
3: -}
3: -
3: -inline HomoMat homoMatrix(Vec3 p, Quat q){
3: -    HomoMat homoM;
3: -    homoM.setZero();
3: -    homoM.topLeftCorner(3, 3) = quatToRotMat(q);
3: -    homoM.topRightCorner(3, 1) = p;
3: -    homoM(3, 3) = 1;
3: -    return homoM;
3: -}
3: -
3: -inline HomoMat homoMatrixInverse(HomoMat homoM){
3: -    HomoMat homoInv;
3: -    homoInv.setZero();
3: -    homoInv.topLeftCorner(3, 3) = homoM.topLeftCorner(3, 3).transpose();
3: -    homoInv.topRightCorner(3, 1) = -homoM.topLeftCorner(3, 3).transpose() * homoM.topRightCorner(3, 1);
3: -    homoInv(3, 3) = 1;
3: -    return homoInv;
3: -}
3: -
3: -//  add 1 at the end of Vec3
3: -inline Vec4 homoVec(Vec3 v3){
3: -    Vec4 v4;
3: -    v4.block(0, 0, 3, 1) = v3;
3: -    v4(3) = 1;
3: -    return v4;
3: -}
3: -
3: -//  remove 1 at the end of Vec4
3: -inline Vec3 noHomoVec(Vec4 v4){
3: -    Vec3 v3;
3: -    v3 = v4.block(0, 0, 3, 1);
3: -    return v3;
3: -}
3: -
3: -// Calculate average value and covariance
3: -class AvgCov{
3: -public:
3: -    AvgCov(unsigned int size, std::string name, bool avgOnly=false, unsigned int showPeriod=1000, unsigned int waitCount=5000, double zoomFactor=10000)
3: -            :_size(size), _showPeriod(showPeriod), _waitCount(waitCount), _zoomFactor(zoomFactor), _valueName(name), _avgOnly(avgOnly) {
3: -        _exp.resize(size);
3: -        _cov.resize(size, size);
3: -        _defaultWeight.resize(size, size);
3: -        _defaultWeight.setIdentity();
3: -        _measureCount = 0;
3: -    }
3: -    void measure(VecX newValue){
3: -        ++_measureCount;
3: -
3: -        if(_measureCount > _waitCount){
3: -            updateAvgCov(_cov, _exp, newValue, _measureCount-_waitCount);
3: -            if(_measureCount % _showPeriod == 0){
3: -                std::cout << "******" << _valueName << " measured count: " << _measureCount-_waitCount << "******" << std::endl;
3: -                std::cout << _zoomFactor << " Times Average of " << _valueName << std::endl << (_zoomFactor*_exp).transpose() << std::endl;
3: -                if(!_avgOnly){
3: -                    std::cout << _zoomFactor << " Times Covariance of " << _valueName << std::endl << _zoomFactor*_cov << std::endl;
3: -                }
3: -            }
3: -        }
3: -    }
3: +  }
3: +
3: @@ -269,10 +305,10 @@
3: -    VecX _exp;
3: -    MatX _cov;
3: -    MatX _defaultWeight;
3: -    bool _avgOnly;
3: -    unsigned int _size;
3: -    unsigned int _measureCount;
3: -    unsigned int _showPeriod;
3: -    unsigned int _waitCount;
3: -    double _zoomFactor;
3: -    std::string _valueName;
3: +  VecX _exp;
3: +  MatX _cov;
3: +  MatX _defaultWeight;
3: +  bool _avgOnly;
3: +  unsigned int _size;
3: +  unsigned int _measureCount;
3: +  unsigned int _showPeriod;
3: +  unsigned int _waitCount;
3: +  double _zoomFactor;
3: +  std::string _valueName;
3: @@ -281 +317 @@
3: -#endif  // MATHTOOLS_H
3: +#endif  // MATHTOOLS_H
3: 
3: Code style divergence in file 'include/common/mathTypes.h':
3: 
3: --- include/common/mathTypes.h
3: +++ include/common/mathTypes.h.uncrustify
3: @@ -13 +13 @@
3: -using Vec2 = typename Eigen::Matrix<double, 2, 1>;
3: +using Vec2 = typename Eigen::Matrix < double, 2, 1 >;
3: @@ -16 +16 @@
3: -using Vec3 = typename Eigen::Matrix<double, 3, 1>;
3: +using Vec3 = typename Eigen::Matrix < double, 3, 1 >;
3: @@ -19 +19 @@
3: -using Vec4 = typename Eigen::Matrix<double, 4, 1>;
3: +using Vec4 = typename Eigen::Matrix < double, 4, 1 >;
3: @@ -22 +22 @@
3: -using Vec6 = typename Eigen::Matrix<double, 6, 1>;
3: +using Vec6 = typename Eigen::Matrix < double, 6, 1 >;
3: @@ -25 +25 @@
3: -using Quat = typename Eigen::Matrix<double, 4, 1>;
3: +using Quat = typename Eigen::Matrix < double, 4, 1 >;
3: @@ -28 +28 @@
3: -using VecInt4 = typename Eigen::Matrix<int, 4, 1>;
3: +using VecInt4 = typename Eigen::Matrix < int, 4, 1 >;
3: @@ -31 +31 @@
3: -using Vec12 = typename Eigen::Matrix<double, 12, 1>;
3: +using Vec12 = typename Eigen::Matrix < double, 12, 1 >;
3: @@ -34 +34 @@
3: -using Vec18 = typename Eigen::Matrix<double, 18, 1>;
3: +using Vec18 = typename Eigen::Matrix < double, 18, 1 >;
3: @@ -37 +37 @@
3: -using VecX = typename Eigen::Matrix<double, Eigen::Dynamic, 1>;
3: +using VecX = typename Eigen::Matrix < double, Eigen::Dynamic, 1 >;
3: @@ -43 +43 @@
3: -using RotMat = typename Eigen::Matrix<double, 3, 3>;
3: +using RotMat = typename Eigen::Matrix < double, 3, 3 >;
3: @@ -46 +46 @@
3: -using HomoMat = typename Eigen::Matrix<double, 4, 4>;
3: +using HomoMat = typename Eigen::Matrix < double, 4, 4 >;
3: @@ -49 +49 @@
3: -using Mat2 = typename Eigen::Matrix<double, 2, 2>;
3: +using Mat2 = typename Eigen::Matrix < double, 2, 2 >;
3: @@ -52 +52 @@
3: -using Mat3 = typename Eigen::Matrix<double, 3, 3>;
3: +using Mat3 = typename Eigen::Matrix < double, 3, 3 >;
3: @@ -58 +58 @@
3: -using Vec34 = typename Eigen::Matrix<double, 3, 4>;
3: +using Vec34 = typename Eigen::Matrix < double, 3, 4 >;
3: @@ -61 +61 @@
3: -using Mat6 = typename Eigen::Matrix<double, 6, 6>;
3: +using Mat6 = typename Eigen::Matrix < double, 6, 6 >;
3: @@ -64 +64 @@
3: -using Mat12 = typename Eigen::Matrix<double, 12, 12>;
3: +using Mat12 = typename Eigen::Matrix < double, 12, 12 >;
3: @@ -73 +73 @@
3: -using MatX = typename Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>;
3: +using MatX = typename Eigen::Matrix < double, Eigen::Dynamic, Eigen::Dynamic >;
3: @@ -78,6 +78,7 @@
3: -inline Vec34 vec12ToVec34(Vec12 vec12){
3: -    Vec34 vec34;
3: -    for(int i(0); i < 4; ++i){
3: -        vec34.col(i) = vec12.segment(3*i, 3);
3: -    }
3: -    return vec34;
3: +inline Vec34 vec12ToVec34(Vec12 vec12)
3: +{
3: +  Vec34 vec34;
3: +  for (int i(0); i < 4; ++i) {
3: +    vec34.col(i) = vec12.segment(3 * i, 3);
3: +  }
3: +  return vec34;
3: @@ -86,6 +87,7 @@
3: -inline Vec12 vec34ToVec12(Vec34 vec34){
3: -    Vec12 vec12;
3: -    for(int i(0); i < 4; ++i){
3: -        vec12.segment(3*i, 3) = vec34.col(i);
3: -    }
3: -    return vec12;
3: +inline Vec12 vec34ToVec12(Vec34 vec34)
3: +{
3: +  Vec12 vec12;
3: +  for (int i(0); i < 4; ++i) {
3: +    vec12.segment(3 * i, 3) = vec34.col(i);
3: +  }
3: +  return vec12;
3: @@ -94 +96 @@
3: -#endif  // MATHTYPES_H
3: +#endif  // MATHTYPES_H
3: 
3: Code style divergence in file 'include/common/timeMarker.h':
3: 
3: --- include/common/timeMarker.h
3: +++ include/common/timeMarker.h.uncrustify
3: @@ -11,5 +11,6 @@
3: -//时间戳  微秒级， 需要#include <sys/time.h> 
3: -inline long long getSystemTime(){
3: -    struct timeval t;  
3: -    gettimeofday(&t, NULL);
3: -    return 1000000 * t.tv_sec + t.tv_usec;  
3: +//时间戳  微秒级， 需要#include <sys/time.h>
3: +inline long long getSystemTime()
3: +{
3: +  struct timeval t;
3: +  gettimeofday(&t, NULL);
3: +  return 1000000 * t.tv_sec + t.tv_usec;
3: @@ -18,3 +19,4 @@
3: -inline double getTimeSecond(){
3: -    double time = getSystemTime() * 0.000001;
3: -    return time;
3: +inline double getTimeSecond()
3: +{
3: +  double time = getSystemTime() * 0.000001;
3: +  return time;
3: @@ -23,8 +25,11 @@
3: -inline void absoluteWait(long long startTime, long long waitTime){
3: -    if(getSystemTime() - startTime > waitTime){
3: -        std::cout << "[WARNING] The waitTime=" << waitTime << " of function absoluteWait is not enough!" << std::endl
3: -        << "The program has already cost " << getSystemTime() - startTime << "us." << std::endl;
3: -    }
3: -    while(getSystemTime() - startTime < waitTime){
3: -        usleep(50);
3: -    }
3: +inline void absoluteWait(long long startTime, long long waitTime)
3: +{
3: +  if (getSystemTime() - startTime > waitTime) {
3: +    std::cout << "[WARNING] The waitTime=" << waitTime <<
3: +      " of function absoluteWait is not enough!" << std::endl
3: +              << "The program has already cost " << getSystemTime() - startTime << "us." <<
3: +      std::endl;
3: +  }
3: +  while (getSystemTime() - startTime < waitTime) {
3: +    usleep(50);
3: +  }
3: @@ -33 +38 @@
3: -#endif //TIMEMARKER_H
3: +#endif //TIMEMARKER_H
3: 
3: Code style divergence in file 'include/common/unitreeLeg.h':
3: 
3: --- include/common/unitreeLeg.h
3: +++ include/common/unitreeLeg.h.uncrustify
3: @@ -10 +10 @@
3: -class QuadrupedLeg{
3: +class QuadrupedLeg {
3: @@ -12,12 +12,15 @@
3: -    QuadrupedLeg(int legID, float abadLinkLength, float hipLinkLength, 
3: -                 float kneeLinkLength, Vec3 pHip2B);
3: -    ~QuadrupedLeg(){}
3: -    Vec3 calcPEe2H(Vec3 q);
3: -    Vec3 calcPEe2B(Vec3 q);
3: -    Vec3 calcVEe(Vec3 q, Vec3 qd);
3: -    Vec3 calcQ(Vec3 pEe, FrameType frame);
3: -    Vec3 calcQd(Vec3 q, Vec3 vEe);
3: -    Vec3 calcQd(Vec3 pEe, Vec3 vEe, FrameType frame);
3: -    Vec3 calcTau(Vec3 q, Vec3 force);
3: -    Mat3 calcJaco(Vec3 q);
3: -    Vec3 getHip2B(){return _pHip2B;}
3: +  QuadrupedLeg(
3: +    int legID, float abadLinkLength, float hipLinkLength,
3: +    float kneeLinkLength, Vec3 pHip2B);
3: +  ~QuadrupedLeg() {
3: +  }
3: +  Vec3 calcPEe2H(Vec3 q);
3: +  Vec3 calcPEe2B(Vec3 q);
3: +  Vec3 calcVEe(Vec3 q, Vec3 qd);
3: +  Vec3 calcQ(Vec3 pEe, FrameType frame);
3: +  Vec3 calcQd(Vec3 q, Vec3 vEe);
3: +  Vec3 calcQd(Vec3 pEe, Vec3 vEe, FrameType frame);
3: +  Vec3 calcTau(Vec3 q, Vec3 force);
3: +  Mat3 calcJaco(Vec3 q);
3: +  Vec3 getHip2B() {return _pHip2B;}
3: +
3: @@ -25,7 +28,8 @@
3: -    float q1_ik(float py, float pz, float b2y);
3: -    float q3_ik(float b3z, float b4z, float b);
3: -    float q2_ik(float q1, float q3, float px, 
3: -                float py, float pz, float b3z, float b4z);
3: -    float _sideSign;
3: -    const float _abadLinkLength, _hipLinkLength, _kneeLinkLength;
3: -    const Vec3 _pHip2B;
3: +  float q1_ik(float py, float pz, float b2y);
3: +  float q3_ik(float b3z, float b4z, float b);
3: +  float q2_ik(
3: +    float q1, float q3, float px,
3: +    float py, float pz, float b3z, float b4z);
3: +  float _sideSign;
3: +  const float _abadLinkLength, _hipLinkLength, _kneeLinkLength;
3: +  const Vec3 _pHip2B;
3: @@ -34 +38 @@
3: -class A1Leg : public QuadrupedLeg{
3: +class A1Leg: public QuadrupedLeg {
3: @@ -36,3 +40,5 @@
3: -    A1Leg(const int legID, const Vec3 pHip2B):
3: -        QuadrupedLeg(legID, 0.0838, 0.2, 0.2, pHip2B){}
3: -    ~A1Leg(){}
3: +  A1Leg(const int legID, const Vec3 pHip2B)
3: +    : QuadrupedLeg(legID, 0.0838, 0.2, 0.2, pHip2B) {
3: +  }
3: +  ~A1Leg() {
3: +  }
3: @@ -41 +47 @@
3: -class Go1Leg : public QuadrupedLeg{
3: +class Go1Leg: public QuadrupedLeg {
3: @@ -43,3 +49,5 @@
3: -    Go1Leg(const int legID, const Vec3 pHip2B):
3: -        QuadrupedLeg(legID, 0.08, 0.213, 0.213, pHip2B){}
3: -    ~Go1Leg(){}
3: +  Go1Leg(const int legID, const Vec3 pHip2B)
3: +    : QuadrupedLeg(legID, 0.08, 0.213, 0.213, pHip2B) {
3: +  }
3: +  ~Go1Leg() {
3: +  }
3: @@ -48 +56 @@
3: -#endif  // UNITREELEG_H
3: +#endif  // UNITREELEG_H
3: 
3: Code style divergence in file 'include/common/unitreeRobot.h':
3: 
3: --- include/common/unitreeRobot.h
3: +++ include/common/unitreeRobot.h.uncrustify
3: @@ -10 +10 @@
3: -class QuadrupedRobot{
3: +class QuadrupedRobot {
3: @@ -12,2 +12,4 @@
3: -    QuadrupedRobot(){};
3: -    ~QuadrupedRobot(){}
3: +  QuadrupedRobot() {
3: +  };
3: +  ~QuadrupedRobot() {
3: +  }
3: @@ -15,2 +17,2 @@
3: -    Vec3 getX(LowlevelState &state);
3: -    Vec34 getVecXP(LowlevelState &state);
3: +  Vec3 getX(LowlevelState & state);
3: +  Vec34 getVecXP(LowlevelState & state);
3: @@ -18,4 +20,4 @@
3: -    // Inverse Kinematics(Body/Hip Frame)
3: -    Vec12 getQ(const Vec34 &feetPosition, FrameType frame);
3: -    Vec12 getQd(const Vec34 &feetPosition, const Vec34 &feetVelocity, FrameType frame);
3: -    Vec12 getTau(const Vec12 &q, const Vec34 feetForce);
3: +  // Inverse Kinematics(Body/Hip Frame)
3: +  Vec12 getQ(const Vec34 & feetPosition, FrameType frame);
3: +  Vec12 getQd(const Vec34 & feetPosition, const Vec34 & feetVelocity, FrameType frame);
3: +  Vec12 getTau(const Vec12 & q, const Vec34 feetForce);
3: @@ -23,5 +25,5 @@
3: -    // Forward Kinematics
3: -    Vec3 getFootPosition(LowlevelState &state, int id, FrameType frame);
3: -    Vec3 getFootVelocity(LowlevelState &state, int id);
3: -    Vec34 getFeet2BPositions(LowlevelState &state, FrameType frame);
3: -    Vec34 getFeet2BVelocities(LowlevelState &state, FrameType frame);
3: +  // Forward Kinematics
3: +  Vec3 getFootPosition(LowlevelState & state, int id, FrameType frame);
3: +  Vec3 getFootVelocity(LowlevelState & state, int id);
3: +  Vec34 getFeet2BPositions(LowlevelState & state, FrameType frame);
3: +  Vec34 getFeet2BVelocities(LowlevelState & state, FrameType frame);
3: @@ -29,8 +31,8 @@
3: -    Mat3 getJaco(LowlevelState &state, int legID);
3: -    Vec2 getRobVelLimitX(){return _robVelLimitX;}
3: -    Vec2 getRobVelLimitY(){return _robVelLimitY;}
3: -    Vec2 getRobVelLimitYaw(){return _robVelLimitYaw;}
3: -    Vec34 getFeetPosIdeal(){return _feetPosNormalStand;}
3: -    double getRobMass(){return _mass;}
3: -    Vec3 getPcb(){return _pcb;}
3: -    Mat3 getRobInertial(){return _Ib;}
3: +  Mat3 getJaco(LowlevelState & state, int legID);
3: +  Vec2 getRobVelLimitX() {return _robVelLimitX;}
3: +  Vec2 getRobVelLimitY() {return _robVelLimitY;}
3: +  Vec2 getRobVelLimitYaw() {return _robVelLimitYaw;}
3: +  Vec34 getFeetPosIdeal() {return _feetPosNormalStand;}
3: +  double getRobMass() {return _mass;}
3: +  Vec3 getPcb() {return _pcb;}
3: +  Mat3 getRobInertial() {return _Ib;}
3: @@ -39,8 +41,8 @@
3: -    QuadrupedLeg* _Legs[4];
3: -    Vec2 _robVelLimitX;
3: -    Vec2 _robVelLimitY;
3: -    Vec2 _robVelLimitYaw;
3: -    Vec34 _feetPosNormalStand;
3: -    double _mass;
3: -    Vec3 _pcb;
3: -    Mat3 _Ib;
3: +  QuadrupedLeg * _Legs[4];
3: +  Vec2 _robVelLimitX;
3: +  Vec2 _robVelLimitY;
3: +  Vec2 _robVelLimitYaw;
3: +  Vec34 _feetPosNormalStand;
3: +  double _mass;
3: +  Vec3 _pcb;
3: +  Mat3 _Ib;
3: @@ -49 +51 @@
3: -class A1Robot : public QuadrupedRobot{
3: +class A1Robot: public QuadrupedRobot {
3: @@ -51,2 +53,3 @@
3: -    A1Robot();
3: -    ~A1Robot(){}
3: +  A1Robot();
3: +  ~A1Robot() {
3: +  }
3: @@ -55 +58 @@
3: -class Go1Robot : public QuadrupedRobot{
3: +class Go1Robot: public QuadrupedRobot {
3: @@ -57,2 +60,3 @@
3: -    Go1Robot();
3: -    ~Go1Robot(){};
3: +  Go1Robot();
3: +  ~Go1Robot() {
3: +  };
3: @@ -61 +65 @@
3: -#endif  // UNITREEROBOT_H
3: +#endif  // UNITREEROBOT_H
3: 
3: Code style divergence in file 'include/control/BalanceCtrl.h':
3: 
3: --- include/control/BalanceCtrl.h
3: +++ include/control/BalanceCtrl.h.uncrustify
3: @@ -15 +15 @@
3: -class BalanceCtrl{
3: +class BalanceCtrl {
3: @@ -17,3 +17,3 @@
3: -    BalanceCtrl(double mass, Mat3 Ib, Mat6 S, double alpha, double beta);
3: -    BalanceCtrl(QuadrupedRobot *robModel);
3: -    Vec34 calF(Vec3 ddPcd, Vec3 dWbd, RotMat rotM, Vec34 feetPos2B, VecInt4 contact);
3: +  BalanceCtrl(double mass, Mat3 Ib, Mat6 S, double alpha, double beta);
3: +  BalanceCtrl(QuadrupedRobot * robModel);
3: +  Vec34 calF(Vec3 ddPcd, Vec3 dWbd, RotMat rotM, Vec34 feetPos2B, VecInt4 contact);
3: @@ -21 +21 @@
3: -    void setPyPlot(PyPlot *plot){_testPlot = plot;}
3: +  void setPyPlot(PyPlot * plot) {_testPlot = plot;}
3: @@ -22,0 +23 @@
3: +
3: @@ -24,4 +25,4 @@
3: -    void calMatrixA(Vec34 feetPos2B, RotMat rotM, VecInt4 contact);
3: -    void calVectorBd(Vec3 ddPcd, Vec3 dWbd, RotMat rotM);
3: -    void calConstraints(VecInt4 contact);
3: -    void solveQP();
3: +  void calMatrixA(Vec34 feetPos2B, RotMat rotM, VecInt4 contact);
3: +  void calVectorBd(Vec3 ddPcd, Vec3 dWbd, RotMat rotM);
3: +  void calConstraints(VecInt4 contact);
3: +  void solveQP();
3: @@ -29,12 +30,12 @@
3: -    Mat12 _G, _W, _U;
3: -    Mat6 _S;
3: -    Mat3 _Ib;
3: -    Vec6 _bd;
3: -    Vec3 _g;
3: -    Vec3 _pcb;
3: -    Vec12 _F, _Fprev, _g0T;
3: -    double _mass, _alpha, _beta, _fricRatio;
3: -    Eigen::MatrixXd _CE, _CI;
3: -    Eigen::VectorXd _ce0, _ci0;
3: -    Eigen::Matrix<double, 6 , 12> _A;
3: -    Eigen::Matrix<double, 5 , 3 > _fricMat;
3: +  Mat12 _G, _W, _U;
3: +  Mat6 _S;
3: +  Mat3 _Ib;
3: +  Vec6 _bd;
3: +  Vec3 _g;
3: +  Vec3 _pcb;
3: +  Vec12 _F, _Fprev, _g0T;
3: +  double _mass, _alpha, _beta, _fricRatio;
3: +  Eigen::MatrixXd _CE, _CI;
3: +  Eigen::VectorXd _ce0, _ci0;
3: +  Eigen::Matrix < double, 6, 12 > _A;
3: +  Eigen::Matrix < double, 5, 3 > _fricMat;
3: @@ -42,2 +43,2 @@
3: -    quadprogpp::Matrix<double> G, CE, CI;
3: -    quadprogpp::Vector<double> g0, ce0, ci0, x;
3: +  quadprogpp::Matrix < double > G, CE, CI;
3: +  quadprogpp::Vector < double > g0, ce0, ci0, x;
3: @@ -46 +47 @@
3: -    PyPlot *_testPlot;
3: +  PyPlot * _testPlot;
3: @@ -50 +51 @@
3: -#endif  // BALANCECTRL_H
3: +#endif  // BALANCECTRL_H
3: 
3: Code style divergence in file 'include/control/ControlFrame.h':
3: 
3: --- include/control/ControlFrame.h
3: +++ include/control/ControlFrame.h.uncrustify
3: @@ -10 +10 @@
3: -class ControlFrame{
3: +class ControlFrame {
3: @@ -12,5 +12,6 @@
3: -	ControlFrame(CtrlComponents *ctrlComp);
3: -	~ControlFrame(){
3: -		delete _FSMController;
3: -	}
3: -	void run();
3: +  ControlFrame(CtrlComponents * ctrlComp);
3: +  ~ControlFrame() {
3: +    delete _FSMController;
3: +  }
3: +  void run();
3: +
3: @@ -18,2 +19,2 @@
3: -	FSM* _FSMController;
3: -	CtrlComponents *_ctrlComp;
3: +  FSM * _FSMController;
3: +  CtrlComponents * _ctrlComp;
3: @@ -22 +23 @@
3: -#endif  //CONTROLFRAME_H
3: +#endif  //CONTROLFRAME_H
3: 
3: Code style divergence in file 'include/control/CtrlComponents.h':
3: 
3: --- include/control/CtrlComponents.h
3: +++ include/control/CtrlComponents.h.uncrustify
3: @@ -22 +22,2 @@
3: -struct CtrlComponents{
3: +struct CtrlComponents
3: +{
3: @@ -24,16 +25,16 @@
3: -    CtrlComponents(IOInterface *ioInter):ioInter(ioInter){
3: -        lowCmd = new LowlevelCmd();
3: -        lowState = new LowlevelState();
3: -        contact = new VecInt4;
3: -        phase = new Vec4;
3: -        *contact = VecInt4(0, 0, 0, 0);
3: -        *phase = Vec4(0.5, 0.5, 0.5, 0.5);
3: -    }
3: -    ~CtrlComponents(){
3: -        delete lowCmd;
3: -        delete lowState;
3: -        delete ioInter;
3: -        delete robotModel;
3: -        delete waveGen;
3: -        delete estimator;
3: -        delete balCtrl;
3: +  CtrlComponents(IOInterface * ioInter) : ioInter(ioInter) {
3: +    lowCmd = new LowlevelCmd();
3: +    lowState = new LowlevelState();
3: +    contact = new VecInt4;
3: +    phase = new Vec4;
3: +    *contact = VecInt4(0, 0, 0, 0);
3: +    *phase = Vec4(0.5, 0.5, 0.5, 0.5);
3: +  }
3: +  ~CtrlComponents() {
3: +    delete lowCmd;
3: +    delete lowState;
3: +    delete ioInter;
3: +    delete robotModel;
3: +    delete waveGen;
3: +    delete estimator;
3: +    delete balCtrl;
3: @@ -41 +42 @@
3: -        delete plot;
3: +    delete plot;
3: @@ -43,8 +44,8 @@
3: -    }
3: -    LowlevelCmd *lowCmd;
3: -    LowlevelState *lowState;
3: -    IOInterface *ioInter;
3: -    QuadrupedRobot *robotModel;
3: -    WaveGenerator *waveGen;
3: -    Estimator *estimator;
3: -    BalanceCtrl *balCtrl;
3: +  }
3: +  LowlevelCmd * lowCmd;
3: +  LowlevelState * lowState;
3: +  IOInterface * ioInter;
3: +  QuadrupedRobot * robotModel;
3: +  WaveGenerator * waveGen;
3: +  Estimator * estimator;
3: +  BalanceCtrl * balCtrl;
3: @@ -53 +54 @@
3: -    PyPlot *plot;
3: +  PyPlot * plot;
3: @@ -56,2 +57,2 @@
3: -    VecInt4 *contact;
3: -    Vec4 *phase;
3: +  VecInt4 * contact;
3: +  Vec4 * phase;
3: @@ -59,3 +60,3 @@
3: -    double dt;
3: -    bool *running;
3: -    CtrlPlatform ctrlPlatform;
3: +  double dt;
3: +  bool * running;
3: +  CtrlPlatform ctrlPlatform;
3: @@ -63,3 +64,4 @@
3: -    void sendRecv(){
3: -        ioInter->sendRecv(lowCmd, lowState);
3: -    }
3: +  void sendRecv()
3: +  {
3: +    ioInter->sendRecv(lowCmd, lowState);
3: +  }
3: @@ -67,3 +69,4 @@
3: -    void runWaveGen(){
3: -        waveGen->calcContactPhase(*phase, *contact, _waveStatus);
3: -    }
3: +  void runWaveGen()
3: +  {
3: +    waveGen->calcContactPhase(*phase, *contact, _waveStatus);
3: +  }
3: @@ -71,3 +74,4 @@
3: -    void setAllStance(){
3: -        _waveStatus = WaveStatus::STANCE_ALL;
3: -    }
3: +  void setAllStance()
3: +  {
3: +    _waveStatus = WaveStatus::STANCE_ALL;
3: +  }
3: @@ -75,3 +79,4 @@
3: -    void setAllSwing(){
3: -        _waveStatus = WaveStatus::SWING_ALL;
3: -    }
3: +  void setAllSwing()
3: +  {
3: +    _waveStatus = WaveStatus::SWING_ALL;
3: +  }
3: @@ -79,3 +84,4 @@
3: -    void setStartWave(){
3: -        _waveStatus = WaveStatus::WAVE_ALL;
3: -    }
3: +  void setStartWave()
3: +  {
3: +    _waveStatus = WaveStatus::WAVE_ALL;
3: +  }
3: @@ -83,3 +89,4 @@
3: -    void geneObj(){
3: -        estimator = new Estimator(robotModel, lowState, contact, phase, dt);
3: -        balCtrl = new BalanceCtrl(robotModel);
3: +  void geneObj()
3: +  {
3: +    estimator = new Estimator(robotModel, lowState, contact, phase, dt);
3: +    balCtrl = new BalanceCtrl(robotModel);
3: @@ -88,3 +95,3 @@
3: -        plot = new PyPlot();
3: -        balCtrl->setPyPlot(plot);
3: -        estimator->setPyPlot(plot);
3: +    plot = new PyPlot();
3: +    balCtrl->setPyPlot(plot);
3: +    estimator->setPyPlot(plot);
3: @@ -92 +99 @@
3: -    }
3: +  }
3: @@ -95 +102 @@
3: -    WaveStatus _waveStatus = WaveStatus::SWING_ALL;
3: +  WaveStatus _waveStatus = WaveStatus::SWING_ALL;
3: @@ -99 +106 @@
3: -#endif  // CTRLCOMPONENTS_H
3: +#endif  // CTRLCOMPONENTS_H
3: 
3: Code style divergence in file 'include/control/Estimator.h':
3: 
3: --- include/control/Estimator.h
3: +++ include/control/Estimator.h.uncrustify
3: @@ -37 +37 @@
3: -class Estimator{
3: +class Estimator {
3: @@ -39,10 +39,14 @@
3: -    Estimator(QuadrupedRobot *robotModel, LowlevelState* lowState, VecInt4 *contact, Vec4 *phase, double dt);
3: -    Estimator(QuadrupedRobot *robotModel, LowlevelState* lowState, VecInt4 *contact, Vec4 *phase, double dt, Vec18 Qdig, std::string testName);
3: -    ~Estimator();
3: -    Vec3  getPosition();
3: -    Vec3  getVelocity();
3: -    Vec3  getFootPos(int i);
3: -    Vec34 getFeetPos();
3: -    Vec34 getFeetVel();
3: -    Vec34 getPosFeet2BGlobal();
3: -    void run();
3: +  Estimator(
3: +    QuadrupedRobot * robotModel, LowlevelState * lowState, VecInt4 * contact, Vec4 * phase,
3: +    double dt);
3: +  Estimator(
3: +    QuadrupedRobot * robotModel, LowlevelState * lowState, VecInt4 * contact, Vec4 * phase,
3: +    double dt, Vec18 Qdig, std::string testName);
3: +  ~Estimator();
3: +  Vec3  getPosition();
3: +  Vec3  getVelocity();
3: +  Vec3  getFootPos(int i);
3: +  Vec34 getFeetPos();
3: +  Vec34 getFeetVel();
3: +  Vec34 getPosFeet2BGlobal();
3: +  void run();
3: @@ -51 +55 @@
3: -    void setPyPlot(PyPlot *plot){_testPlot = plot;}
3: +  void setPyPlot(PyPlot * plot) {_testPlot = plot;}
3: @@ -55,29 +59,29 @@
3: -    void _initSystem();
3: -    // Linear System
3: -    Eigen::Matrix<double, 18, 1>  _xhat;            // The state of estimator, position(3)+velocity(3)+feet position(3x4)
3: -    Vec3 _u;                                        // The input of estimator
3: -    Eigen::Matrix<double, 28,  1> _y;               // The measurement value of output y
3: -    Eigen::Matrix<double, 28,  1> _yhat;            // The prediction of output y
3: -    Eigen::Matrix<double, 18, 18> _A;               // The transtion matrix of estimator
3: -    Eigen::Matrix<double, 18, 3>  _B;               // The input matrix
3: -    Eigen::Matrix<double, 28, 18> _C;               // The output matrix
3: -    // Covariance Matrix
3: -    Eigen::Matrix<double, 18, 18> _P;               // Prediction covariance
3: -    Eigen::Matrix<double, 18, 18> _Ppriori;         // Priori prediction covariance
3: -    Eigen::Matrix<double, 18, 18> _Q;               // Dynamic simulation covariance
3: -    Eigen::Matrix<double, 28, 28> _R;               // Measurement covariance
3: -    Eigen::Matrix<double, 18, 18> _QInit;           // Initial value of Dynamic simulation covariance
3: -    Eigen::Matrix<double, 28, 28> _RInit;           // Initial value of Measurement covariance
3: -    Vec18 _Qdig;                                    // adjustable process noise covariance
3: -    Mat3 _Cu;                                       // The covariance of system input u
3: -    // Output Measurement
3: -    Eigen::Matrix<double, 12, 1>  _feetPos2Body;    // The feet positions to body, in the global coordinate
3: -    Eigen::Matrix<double, 12, 1>  _feetVel2Body;    // The feet velocity to body, in the global coordinate
3: -    Eigen::Matrix<double,  4, 1>  _feetH;           // The Height of each foot, in the global coordinate
3: -    Eigen::Matrix<double, 28, 28> _S;               // _S = C*P*C.T + R
3: -    Eigen::PartialPivLU<Eigen::Matrix<double, 28, 28>> _Slu;    // _S.lu()
3: -    Eigen::Matrix<double, 28,  1> _Sy;              // _Sy = _S.inv() * (y - yhat)
3: -    Eigen::Matrix<double, 28, 18> _Sc;              // _Sc = _S.inv() * C
3: -    Eigen::Matrix<double, 28, 28> _SR;              // _SR = _S.inv() * R
3: -    Eigen::Matrix<double, 28, 18> _STC;             // _STC = (_S.transpose()).inv() * C
3: -    Eigen::Matrix<double, 18, 18> _IKC;             // _IKC = I - KC
3: +  void _initSystem();
3: +  // Linear System
3: +  Eigen::Matrix < double, 18, 1 > _xhat;            // The state of estimator, position(3)+velocity(3)+feet position(3x4)
3: +  Vec3 _u;                                          // The input of estimator
3: +  Eigen::Matrix < double, 28, 1 > _y;               // The measurement value of output y
3: +  Eigen::Matrix < double, 28, 1 > _yhat;            // The prediction of output y
3: +  Eigen::Matrix < double, 18, 18 > _A;              // The transtion matrix of estimator
3: +  Eigen::Matrix < double, 18, 3 > _B;               // The input matrix
3: +  Eigen::Matrix < double, 28, 18 > _C;              // The output matrix
3: +  // Covariance Matrix
3: +  Eigen::Matrix < double, 18, 18 > _P;              // Prediction covariance
3: +  Eigen::Matrix < double, 18, 18 > _Ppriori;        // Priori prediction covariance
3: +  Eigen::Matrix < double, 18, 18 > _Q;              // Dynamic simulation covariance
3: +  Eigen::Matrix < double, 28, 28 > _R;              // Measurement covariance
3: +  Eigen::Matrix < double, 18, 18 > _QInit;          // Initial value of Dynamic simulation covariance
3: +  Eigen::Matrix < double, 28, 28 > _RInit;          // Initial value of Measurement covariance
3: +  Vec18 _Qdig;                                      // adjustable process noise covariance
3: +  Mat3 _Cu;                                         // The covariance of system input u
3: +  // Output Measurement
3: +  Eigen::Matrix < double, 12, 1 > _feetPos2Body;    // The feet positions to body, in the global coordinate
3: +  Eigen::Matrix < double, 12, 1 > _feetVel2Body;    // The feet velocity to body, in the global coordinate
3: +  Eigen::Matrix < double, 4, 1 > _feetH;            // The Height of each foot, in the global coordinate
3: +  Eigen::Matrix < double, 28, 28 > _S;              // _S = C*P*C.T + R
3: +  Eigen::PartialPivLU < Eigen::Matrix < double, 28, 28 >> _Slu; // _S.lu()
3: +  Eigen::Matrix < double, 28, 1 > _Sy;              // _Sy = _S.inv() * (y - yhat)
3: +  Eigen::Matrix < double, 28, 18 > _Sc;             // _Sc = _S.inv() * C
3: +  Eigen::Matrix < double, 28, 28 > _SR;             // _SR = _S.inv() * R
3: +  Eigen::Matrix < double, 28, 18 > _STC;            // _STC = (_S.transpose()).inv() * C
3: +  Eigen::Matrix < double, 18, 18 > _IKC;            // _IKC = I - KC
3: @@ -85,3 +89,3 @@
3: -    RotMat _rotMatB2G;                              // Rotate Matrix: from body to global
3: -    Vec3 _g;
3: -    Vec34 _feetPosGlobalKine, _feetVelGlobalKine;
3: +  RotMat _rotMatB2G;                                // Rotate Matrix: from body to global
3: +  Vec3 _g;
3: +  Vec34 _feetPosGlobalKine, _feetVelGlobalKine;
3: @@ -89,7 +93,7 @@
3: -    LowlevelState* _lowState;
3: -    QuadrupedRobot *_robModel;
3: -    Vec4 *_phase;
3: -    VecInt4 *_contact;
3: -    double _dt;
3: -    double _trust;
3: -    double _largeVariance;
3: +  LowlevelState * _lowState;
3: +  QuadrupedRobot * _robModel;
3: +  Vec4 * _phase;
3: +  VecInt4 * _contact;
3: +  double _dt;
3: +  double _trust;
3: +  double _largeVariance;
3: @@ -97,2 +101,2 @@
3: -    // Low pass filters
3: -    LPFilter *_vxFilter, *_vyFilter, *_vzFilter;
3: +  // Low pass filters
3: +  LPFilter * _vxFilter, * _vyFilter, * _vzFilter;
3: @@ -100,4 +104,4 @@
3: -    // Tuning
3: -    AvgCov *_RCheck;
3: -    AvgCov *_uCheck;
3: -    std::string _estName;
3: +  // Tuning
3: +  AvgCov * _RCheck;
3: +  AvgCov * _uCheck;
3: +  std::string _estName;
3: @@ -106 +110 @@
3: -    PyPlot *_testPlot;
3: +  PyPlot * _testPlot;
3: @@ -109,8 +113,8 @@
3: -    ros::NodeHandle _nh;
3: -    ros::Publisher _pub;
3: -    tf::TransformBroadcaster _odomBroadcaster;
3: -    ros::Time _currentTime;
3: -    geometry_msgs::TransformStamped _odomTF;
3: -    nav_msgs::Odometry _odomMsg;
3: -    int _count = 0;
3: -    double _pubFreq = 10;
3: +  ros::NodeHandle _nh;
3: +  ros::Publisher _pub;
3: +  tf::TransformBroadcaster _odomBroadcaster;
3: +  ros::Time _currentTime;
3: +  geometry_msgs::TransformStamped _odomTF;
3: +  nav_msgs::Odometry _odomMsg;
3: +  int _count = 0;
3: +  double _pubFreq = 10;
3: @@ -118,13 +122,13 @@
3: -    Vec3 _velBody, _wBody;
3: -    boost::array<double, 36> _odom_pose_covariance = {1e-9, 0, 0, 0, 0, 0, 
3: -                                        0, 1e-3, 1e-9, 0, 0, 0, 
3: -                                        0, 0, 1e6, 0, 0, 0,
3: -                                        0, 0, 0, 1e6, 0, 0, 
3: -                                        0, 0, 0, 0, 1e6, 0, 
3: -                                        0, 0, 0, 0, 0, 1e-9};
3: -    boost::array<double, 36> _odom_twist_covariance = {1e-9, 0, 0, 0, 0, 0, 
3: -                                        0, 1e-3, 1e-9, 0, 0, 0, 
3: -                                        0, 0, 1e6, 0, 0, 0, 
3: -                                        0, 0, 0, 1e6, 0, 0, 
3: -                                        0, 0, 0, 0, 1e6, 0, 
3: -                                        0, 0, 0, 0, 0, 1e-9};
3: +  Vec3 _velBody, _wBody;
3: +  boost::array < double, 36 > _odom_pose_covariance = {1e-9, 0, 0, 0, 0, 0,
3: +    0, 1e-3, 1e-9, 0, 0, 0,
3: +    0, 0, 1e6, 0, 0, 0,
3: +    0, 0, 0, 1e6, 0, 0,
3: +    0, 0, 0, 0, 1e6, 0,
3: +    0, 0, 0, 0, 0, 1e-9};
3: +  boost::array < double, 36 > _odom_twist_covariance = {1e-9, 0, 0, 0, 0, 0,
3: +    0, 1e-3, 1e-9, 0, 0, 0,
3: +    0, 0, 1e6, 0, 0, 0,
3: +    0, 0, 0, 1e6, 0, 0,
3: +    0, 0, 0, 0, 1e6, 0,
3: +    0, 0, 0, 0, 0, 1e-9};
3: @@ -134,6 +138,6 @@
3: -    rclcpp::Node::SharedPtr _nh;
3: -    rclcpp::Publisher<nav_msgs::msg::Odometry>::SharedPtr _pub;
3: -    std::shared_ptr<tf2_ros::TransformBroadcaster> _odomBroadcaster;
3: -    rclcpp::Time _currentTime;
3: -    geometry_msgs::msg::TransformStamped _odomTF;
3: -    nav_msgs::msg::Odometry _odomMsg;
3: +  rclcpp::Node::SharedPtr _nh;
3: +  rclcpp::Publisher < nav_msgs::msg::Odometry > ::SharedPtr _pub;
3: +  std::shared_ptr < tf2_ros::TransformBroadcaster > _odomBroadcaster;
3: +  rclcpp::Time _currentTime;
3: +  geometry_msgs::msg::TransformStamped _odomTF;
3: +  nav_msgs::msg::Odometry _odomMsg;
3: @@ -141,2 +145,2 @@
3: -    int _count = 0;
3: -    double _pubFreq = 10;
3: +  int _count = 0;
3: +  double _pubFreq = 10;
3: @@ -144,13 +148,13 @@
3: -    Vec3 _velBody, _wBody;
3: -    std::array<double, 36> _odom_pose_covariance = {1e-9, 0, 0, 0, 0, 0, 
3: -                                        0, 1e-3, 1e-9, 0, 0, 0, 
3: -                                        0, 0, 1e6, 0, 0, 0,
3: -                                        0, 0, 0, 1e6, 0, 0, 
3: -                                        0, 0, 0, 0, 1e6, 0, 
3: -                                        0, 0, 0, 0, 0, 1e-9};
3: -    std::array<double, 36> _odom_twist_covariance = {1e-9, 0, 0, 0, 0, 0, 
3: -                                        0, 1e-3, 1e-9, 0, 0, 0, 
3: -                                        0, 0, 1e6, 0, 0, 0, 
3: -                                        0, 0, 0, 1e6, 0, 0, 
3: -                                        0, 0, 0, 0, 1e6, 0, 
3: -                                        0, 0, 0, 0, 0, 1e-9};
3: +  Vec3 _velBody, _wBody;
3: +  std::array < double, 36 > _odom_pose_covariance = {1e-9, 0, 0, 0, 0, 0,
3: +    0, 1e-3, 1e-9, 0, 0, 0,
3: +    0, 0, 1e6, 0, 0, 0,
3: +    0, 0, 0, 1e6, 0, 0,
3: +    0, 0, 0, 0, 1e6, 0,
3: +    0, 0, 0, 0, 0, 1e-9};
3: +  std::array < double, 36 > _odom_twist_covariance = {1e-9, 0, 0, 0, 0, 0,
3: +    0, 1e-3, 1e-9, 0, 0, 0,
3: +    0, 0, 1e6, 0, 0, 0,
3: +    0, 0, 0, 1e6, 0, 0,
3: +    0, 0, 0, 0, 1e6, 0,
3: +    0, 0, 0, 0, 0, 1e-9};
3: @@ -161 +165 @@
3: -#endif  // ESTIMATOR_H
3: +#endif  // ESTIMATOR_H
3: 
3: Code style divergence in file 'include/interface/CmdPanel.h':
3: 
3: --- include/interface/CmdPanel.h
3: +++ include/interface/CmdPanel.h.uncrustify
3: @@ -20,16 +20,18 @@
3: -struct UserValue{
3: -    float lx;
3: -    float ly;
3: -    float rx;
3: -    float ry;
3: -    float L2;
3: -    UserValue(){
3: -        setZero();
3: -    }
3: -    void setZero(){
3: -        lx = 0;
3: -        ly = 0;
3: -        rx = 0;
3: -        ry = 0;
3: -        L2 = 0;
3: -    }
3: +struct UserValue
3: +{
3: +  float lx;
3: +  float ly;
3: +  float rx;
3: +  float ry;
3: +  float L2;
3: +  UserValue() {
3: +    setZero();
3: +  }
3: +  void setZero()
3: +  {
3: +    lx = 0;
3: +    ly = 0;
3: +    rx = 0;
3: +    ry = 0;
3: +    L2 = 0;
3: +  }
3: @@ -38 +40 @@
3: -class CmdPanel{
3: +class CmdPanel {
3: @@ -40,6 +42,8 @@
3: -    CmdPanel(){}
3: -    virtual ~CmdPanel(){}
3: -    UserCommand getUserCmd(){return userCmd;}
3: -    UserValue getUserValue(){return userValue;}
3: -    void setPassive(){userCmd = UserCommand::L2_B;}
3: -    void setZero(){userValue.setZero();}
3: +  CmdPanel() {
3: +  }
3: +  virtual ~CmdPanel() {
3: +  }
3: +  UserCommand getUserCmd() {return userCmd;}
3: +  UserValue getUserValue() {return userValue;}
3: +  void setPassive() {userCmd = UserCommand::L2_B;}
3: +  void setZero() {userValue.setZero();}
3: @@ -47 +51 @@
3: -    virtual void receiveHandle(UNITREE_LEGGED_SDK::LowState *lowState){};
3: +  virtual void receiveHandle(UNITREE_LEGGED_SDK::LowState * lowState) {}
3: @@ -48,0 +53 @@
3: +
3: @@ -50,3 +55,3 @@
3: -    virtual void* run(void *arg){return NULL;}
3: -    UserCommand userCmd;
3: -    UserValue userValue;
3: +  virtual void * run(void * arg) {return NULL;}
3: +  UserCommand userCmd;
3: +  UserValue userValue;
3: @@ -55 +60 @@
3: -#endif  // CMDPANEL_H
3: +#endif  // CMDPANEL_H
3: 
3: Code style divergence in file 'include/interface/IOInterface.h':
3: 
3: --- include/interface/IOInterface.h
3: +++ include/interface/IOInterface.h.uncrustify
3: @@ -12 +12 @@
3: -class IOInterface{
3: +class IOInterface {
3: @@ -14,5 +14,8 @@
3: -IOInterface(){}
3: -~IOInterface(){delete cmdPanel;}
3: -virtual void sendRecv(const LowlevelCmd *cmd, LowlevelState *state) = 0;
3: -void zeroCmdPanel(){cmdPanel->setZero();}
3: -void setPassive(){cmdPanel->setPassive();}
3: +  IOInterface() {
3: +  }
3: +  ~IOInterface() {
3: +    delete cmdPanel;
3: +  }
3: +  virtual void sendRecv(const LowlevelCmd * cmd, LowlevelState * state) = 0;
3: +  void zeroCmdPanel() {cmdPanel->setZero();}
3: +  void setPassive() {cmdPanel->setPassive();}
3: @@ -21 +24 @@
3: -CmdPanel *cmdPanel;
3: +  CmdPanel * cmdPanel;
3: @@ -24 +27 @@
3: -#endif  //IOINTERFACE_H
3: +#endif  //IOINTERFACE_H
3: 
3: Code style divergence in file 'include/interface/IOROS.h':
3: 
3: --- include/interface/IOROS.h
3: +++ include/interface/IOROS.h.uncrustify
3: @@ -18 +18 @@
3: -class IOROS : public IOInterface{
3: +class IOROS: public IOInterface {
3: @@ -20,3 +20,3 @@
3: -IOROS();
3: -~IOROS();
3: -void sendRecv(const LowlevelCmd *cmd, LowlevelState *state);
3: +  IOROS();
3: +  ~IOROS();
3: +  void sendRecv(const LowlevelCmd * cmd, LowlevelState * state);
3: @@ -25,8 +25,8 @@
3: -void sendCmd(const LowlevelCmd *cmd);
3: -void recvState(LowlevelState *state);
3: -ros::NodeHandle _nm;
3: -ros::Subscriber _servo_sub[12], _imu_sub;
3: -ros::Publisher _servo_pub[12];
3: -unitree_legged_msgs::LowCmd _lowCmd;
3: -unitree_legged_msgs::LowState _lowState;
3: -std::string _robot_name;
3: +  void sendCmd(const LowlevelCmd * cmd);
3: +  void recvState(LowlevelState * state);
3: +  ros::NodeHandle _nm;
3: +  ros::Subscriber _servo_sub[12], _imu_sub;
3: +  ros::Publisher _servo_pub[12];
3: +  unitree_legged_msgs::LowCmd _lowCmd;
3: +  unitree_legged_msgs::LowState _lowState;
3: +  std::string _robot_name;
3: @@ -35,2 +35,2 @@
3: -void initRecv();
3: -void initSend();
3: +  void initRecv();
3: +  void initSend();
3: @@ -39 +39 @@
3: -void imuCallback(const sensor_msgs::Imu & msg);
3: +  void imuCallback(const sensor_msgs::Imu & msg);
3: @@ -41,3 +41,3 @@
3: -void FRhipCallback(const unitree_legged_msgs::MotorState& msg);
3: -void FRthighCallback(const unitree_legged_msgs::MotorState& msg);
3: -void FRcalfCallback(const unitree_legged_msgs::MotorState& msg);
3: +  void FRhipCallback(const unitree_legged_msgs::MotorState & msg);
3: +  void FRthighCallback(const unitree_legged_msgs::MotorState & msg);
3: +  void FRcalfCallback(const unitree_legged_msgs::MotorState & msg);
3: @@ -45,3 +45,3 @@
3: -void FLhipCallback(const unitree_legged_msgs::MotorState& msg);
3: -void FLthighCallback(const unitree_legged_msgs::MotorState& msg);
3: -void FLcalfCallback(const unitree_legged_msgs::MotorState& msg);
3: +  void FLhipCallback(const unitree_legged_msgs::MotorState & msg);
3: +  void FLthighCallback(const unitree_legged_msgs::MotorState & msg);
3: +  void FLcalfCallback(const unitree_legged_msgs::MotorState & msg);
3: @@ -49,3 +49,3 @@
3: -void RRhipCallback(const unitree_legged_msgs::MotorState& msg);
3: -void RRthighCallback(const unitree_legged_msgs::MotorState& msg);
3: -void RRcalfCallback(const unitree_legged_msgs::MotorState& msg);
3: +  void RRhipCallback(const unitree_legged_msgs::MotorState & msg);
3: +  void RRthighCallback(const unitree_legged_msgs::MotorState & msg);
3: +  void RRcalfCallback(const unitree_legged_msgs::MotorState & msg);
3: @@ -53,3 +53,3 @@
3: -void RLhipCallback(const unitree_legged_msgs::MotorState& msg);
3: -void RLthighCallback(const unitree_legged_msgs::MotorState& msg);
3: -void RLcalfCallback(const unitree_legged_msgs::MotorState& msg);
3: +  void RLhipCallback(const unitree_legged_msgs::MotorState & msg);
3: +  void RLthighCallback(const unitree_legged_msgs::MotorState & msg);
3: +  void RLcalfCallback(const unitree_legged_msgs::MotorState & msg);
3: @@ -79 +79 @@
3: -class IOROS : public IOInterface{
3: +class IOROS: public IOInterface {
3: @@ -81,3 +81,3 @@
3: -IOROS(rclcpp::Node::SharedPtr node_ptr);
3: -~IOROS();
3: -void sendRecv(const LowlevelCmd *cmd, LowlevelState *state);
3: +  IOROS(rclcpp::Node::SharedPtr node_ptr);
3: +  ~IOROS();
3: +  void sendRecv(const LowlevelCmd * cmd, LowlevelState * state);
3: @@ -86,14 +86,16 @@
3: -static void RosShutDown(int sig);
3: -void sendCmd(const LowlevelCmd *cmd);
3: -void recvState(LowlevelState *state);
3: -rclcpp::Node::SharedPtr _nm;
3: -rclcpp::Subscription<sensor_msgs::msg::Imu>::SharedPtr _imu_sub;
3: -rclcpp::Subscription<sensor_msgs::msg::JointState>::SharedPtr _joint_state_sub;
3: -std::vector<rclcpp::Subscription<ros2_unitree_legged_msgs::msg::MotorState>::SharedPtr> _servo_sub;
3: -std::vector<rclcpp::Publisher<ros2_unitree_legged_msgs::msg::MotorCmd>::SharedPtr> _servo_pub;
3: -rclcpp::Publisher<std_msgs::msg::Float64MultiArray>::SharedPtr _joint_cmd_pub;
3: -ros2_unitree_legged_msgs::msg::LowCmd _lowCmd;
3: -ros2_unitree_legged_msgs::msg::LowState _lowState;
3: -std::string _robot_name;
3: -std::unordered_map<std::string, int> joint_index_map;
3: -std::thread executor_thread;
3: +  static void RosShutDown(int sig);
3: +  void sendCmd(const LowlevelCmd * cmd);
3: +  void recvState(LowlevelState * state);
3: +  rclcpp::Node::SharedPtr _nm;
3: +  rclcpp::Subscription < sensor_msgs::msg::Imu > ::SharedPtr _imu_sub;
3: +  rclcpp::Subscription < sensor_msgs::msg::JointState > ::SharedPtr _joint_state_sub;
3: +  std::vector < rclcpp::Subscription < ros2_unitree_legged_msgs::msg::MotorState > ::SharedPtr >
3: +  _servo_sub;
3: +  std::vector < rclcpp::Publisher < ros2_unitree_legged_msgs::msg::MotorCmd > ::SharedPtr >
3: +  _servo_pub;
3: +  rclcpp::Publisher < std_msgs::msg::Float64MultiArray > ::SharedPtr _joint_cmd_pub;
3: +  ros2_unitree_legged_msgs::msg::LowCmd _lowCmd;
3: +  ros2_unitree_legged_msgs::msg::LowState _lowState;
3: +  std::string _robot_name;
3: +  std::unordered_map < std::string, int > joint_index_map;
3: +  std::thread executor_thread;
3: @@ -101,2 +103,2 @@
3: -sensor_msgs::msg::JointState _joint_state;
3: -std_msgs::msg::Float64MultiArray _joint_cmd;
3: +  sensor_msgs::msg::JointState _joint_state;
3: +  std_msgs::msg::Float64MultiArray _joint_cmd;
3: @@ -105,2 +107,2 @@
3: -void initRecv();
3: -void initSend();
3: +  void initRecv();
3: +  void initSend();
3: @@ -109 +111 @@
3: -void imuCallback(const sensor_msgs::msg::Imu::SharedPtr msg);
3: +  void imuCallback(const sensor_msgs::msg::Imu::SharedPtr msg);
3: @@ -112,3 +114,3 @@
3: -void FRhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: -void FRthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: -void FRcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: +  void FRhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: +  void FRthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: +  void FRcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: @@ -116,3 +118,3 @@
3: -void FLhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: -void FLthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: -void FLcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: +  void FLhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: +  void FLthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: +  void FLcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: @@ -120,3 +122,3 @@
3: -void RRhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: -void RRthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: -void RRcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: +  void RRhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: +  void RRthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: +  void RRcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: @@ -124,3 +126,3 @@
3: -void RLhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: -void RLthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: -void RLcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: +  void RLhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: +  void RLthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: +  void RLcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
3: @@ -129,2 +131,2 @@
3: -void initializeJointIndexMap();
3: -void jointStateCallback(const sensor_msgs::msg::JointState::SharedPtr msg);
3: +  void initializeJointIndexMap();
3: +  void jointStateCallback(const sensor_msgs::msg::JointState::SharedPtr msg);
3: @@ -136 +138 @@
3: -#endif  // COMPILE_WITH_ROS2_MB
3: +#endif  // COMPILE_WITH_ROS2_MB
3: 
3: Code style divergence in file 'include/interface/IOSDK.h':
3: 
3: --- include/interface/IOSDK.h
3: +++ include/interface/IOSDK.h.uncrustify
3: @@ -22 +22 @@
3: -class IOSDK : public IOInterface{
3: +class IOSDK: public IOInterface {
3: @@ -24,3 +24,4 @@
3: -IOSDK();
3: -~IOSDK(){}
3: -void sendRecv(const LowlevelCmd *cmd, LowlevelState *state);
3: +  IOSDK();
3: +  ~IOSDK() {
3: +  }
3: +  void sendRecv(const LowlevelCmd * cmd, LowlevelState * state);
3: @@ -29,4 +30,4 @@
3: -UNITREE_LEGGED_SDK::UDP _udp;
3: -UNITREE_LEGGED_SDK::Safety _safe;
3: -UNITREE_LEGGED_SDK::LowCmd _lowCmd;
3: -UNITREE_LEGGED_SDK::LowState _lowState;
3: +  UNITREE_LEGGED_SDK::UDP _udp;
3: +  UNITREE_LEGGED_SDK::Safety _safe;
3: +  UNITREE_LEGGED_SDK::LowCmd _lowCmd;
3: +  UNITREE_LEGGED_SDK::LowState _lowState;
3: @@ -35,3 +36,3 @@
3: -    ros::NodeHandle _nh;
3: -    ros::Publisher _pub;
3: -    sensor_msgs::JointState _joint_state;
3: +  ros::NodeHandle _nh;
3: +  ros::Publisher _pub;
3: +  sensor_msgs::JointState _joint_state;
3: @@ -41,3 +42,3 @@
3: -    rclcpp::Node::SharedPtr _nh;
3: -    rclcpp::Publisher<sensor_msgs::msg::JointState>::SharedPtr _pub;
3: -    sensor_msgs::msg::JointState _joint_state;
3: +  rclcpp::Node::SharedPtr _nh;
3: +  rclcpp::Publisher < sensor_msgs::msg::JointState > ::SharedPtr _pub;
3: +  sensor_msgs::msg::JointState _joint_state;
3: @@ -48 +49 @@
3: -#endif  // IOSDK_H
3: +#endif  // IOSDK_H
3: 
3: Code style divergence in file 'include/interface/KeyBoard.h':
3: 
3: --- include/interface/KeyBoard.h
3: +++ include/interface/KeyBoard.h.uncrustify
3: @@ -17 +17 @@
3: -class KeyBoard : public CmdPanel{
3: +class KeyBoard: public CmdPanel {
3: @@ -19,2 +19,3 @@
3: -    KeyBoard();
3: -    ~KeyBoard();
3: +  KeyBoard();
3: +  ~KeyBoard();
3: +
3: @@ -22,4 +23,4 @@
3: -    static void* runKeyBoard(void *arg);
3: -    void* run(void *arg);
3: -    UserCommand checkCmd();
3: -    void changeValue();
3: +  static void * runKeyBoard(void * arg);
3: +  void * run(void * arg);
3: +  UserCommand checkCmd();
3: +  void changeValue();
3: @@ -27,8 +28,8 @@
3: -    pthread_t _tid;
3: -    float sensitivityLeft = 0.05;
3: -    float sensitivityRight = 0.05;
3: -    struct termios _oldSettings, _newSettings;
3: -    fd_set set;
3: -    int res;
3: -    int ret;
3: -    char _c;
3: +  pthread_t _tid;
3: +  float sensitivityLeft = 0.05;
3: +  float sensitivityRight = 0.05;
3: +  struct termios _oldSettings, _newSettings;
3: +  fd_set set;
3: +  int res;
3: +  int ret;
3: +  char _c;
3: @@ -37 +38 @@
3: -#endif  // KEYBOARD_H
3: +#endif  // KEYBOARD_H
3: 
3: Code style divergence in file 'include/interface/WirelessHandle.h':
3: 
3: --- include/interface/WirelessHandle.h
3: +++ include/interface/WirelessHandle.h.uncrustify
3: @@ -11 +11 @@
3: -class WirelessHandle : public CmdPanel{
3: +class WirelessHandle: public CmdPanel {
3: @@ -13,3 +13,5 @@
3: -    WirelessHandle();
3: -    ~WirelessHandle(){}
3: -    void receiveHandle(UNITREE_LEGGED_SDK::LowState *lowState);
3: +  WirelessHandle();
3: +  ~WirelessHandle() {
3: +  }
3: +  void receiveHandle(UNITREE_LEGGED_SDK::LowState * lowState);
3: +
3: @@ -17 +19 @@
3: -    xRockerBtnDataStruct _keyData;
3: +  xRockerBtnDataStruct _keyData;
3: @@ -20 +22 @@
3: -#endif  // WIRELESSHANDLE_H
3: +#endif  // WIRELESSHANDLE_H
3: 
3: Code style divergence in file 'include/message/LowlevelCmd.h':
3: 
3: --- include/message/LowlevelCmd.h
3: +++ include/message/LowlevelCmd.h.uncrustify
3: @@ -10,7 +10,8 @@
3: -struct MotorCmd{
3: -    unsigned int mode;
3: -    float q;
3: -    float dq;
3: -    float tau;
3: -    float Kp;
3: -    float Kd;
3: +struct MotorCmd
3: +{
3: +  unsigned int mode;
3: +  float q;
3: +  float dq;
3: +  float tau;
3: +  float Kp;
3: +  float Kd;
3: @@ -18,8 +19,8 @@
3: -    MotorCmd(){
3: -        mode = 0;
3: -        q = 0;
3: -        dq = 0;
3: -        tau = 0;
3: -        Kp = 0;
3: -        Kd = 0;
3: -    }
3: +  MotorCmd() {
3: +    mode = 0;
3: +    q = 0;
3: +    dq = 0;
3: +    tau = 0;
3: +    Kp = 0;
3: +    Kd = 0;
3: +  }
3: @@ -28,2 +29,3 @@
3: -struct LowlevelCmd{
3: -    MotorCmd motorCmd[12];
3: +struct LowlevelCmd
3: +{
3: +  MotorCmd motorCmd[12];
3: @@ -31,4 +33,4 @@
3: -    void setQ(Vec12 q){
3: -        for(int i(0); i<12; ++i){
3: -            motorCmd[i].q = q(i);
3: -        }
3: +  void setQ(Vec12 q)
3: +  {
3: +    for (int i(0); i < 12; ++i) {
3: +      motorCmd[i].q = q(i);
3: @@ -36,4 +38,11 @@
3: -    void setQ(int legID, Vec3 qi){
3: -        motorCmd[legID*3+0].q = qi(0);
3: -        motorCmd[legID*3+1].q = qi(1);
3: -        motorCmd[legID*3+2].q = qi(2);
3: +  }
3: +  void setQ(int legID, Vec3 qi)
3: +  {
3: +    motorCmd[legID * 3 + 0].q = qi(0);
3: +    motorCmd[legID * 3 + 1].q = qi(1);
3: +    motorCmd[legID * 3 + 2].q = qi(2);
3: +  }
3: +  void setQd(Vec12 qd)
3: +  {
3: +    for (int i(0); i < 12; ++i) {
3: +      motorCmd[i].dq = qd(i);
3: @@ -41,4 +50,14 @@
3: -    void setQd(Vec12 qd){
3: -        for(int i(0); i<12; ++i){
3: -            motorCmd[i].dq = qd(i);
3: -        }
3: +  }
3: +  void setQd(int legID, Vec3 qdi)
3: +  {
3: +    motorCmd[legID * 3 + 0].dq = qdi(0);
3: +    motorCmd[legID * 3 + 1].dq = qdi(1);
3: +    motorCmd[legID * 3 + 2].dq = qdi(2);
3: +  }
3: +  void setTau(Vec12 tau, Vec2 torqueLimit = Vec2(-50, 50))
3: +  {
3: +    for (int i(0); i < 12; ++i) {
3: +      if (std::isnan(tau(i))) {
3: +        printf("[ERROR] The setTau function meets Nan\n");
3: +      }
3: +      motorCmd[i].tau = saturation(tau(i), torqueLimit);
3: @@ -46,4 +65,11 @@
3: -    void setQd(int legID, Vec3 qdi){
3: -        motorCmd[legID*3+0].dq = qdi(0);
3: -        motorCmd[legID*3+1].dq = qdi(1);
3: -        motorCmd[legID*3+2].dq = qdi(2);
3: +  }
3: +  void setZeroDq(int legID)
3: +  {
3: +    motorCmd[legID * 3 + 0].dq = 0;
3: +    motorCmd[legID * 3 + 1].dq = 0;
3: +    motorCmd[legID * 3 + 2].dq = 0;
3: +  }
3: +  void setZeroDq()
3: +  {
3: +    for (int i(0); i < 4; ++i) {
3: +      setZeroDq(i);
3: @@ -51,7 +77,47 @@
3: -    void setTau(Vec12 tau, Vec2 torqueLimit = Vec2(-50, 50)){
3: -        for(int i(0); i<12; ++i){
3: -            if(std::isnan(tau(i))){
3: -                printf("[ERROR] The setTau function meets Nan\n");
3: -            }
3: -            motorCmd[i].tau = saturation(tau(i), torqueLimit);
3: -        }
3: +  }
3: +  void setZeroTau(int legID)
3: +  {
3: +    motorCmd[legID * 3 + 0].tau = 0;
3: +    motorCmd[legID * 3 + 1].tau = 0;
3: +    motorCmd[legID * 3 + 2].tau = 0;
3: +  }
3: +  void setSimStanceGain(int legID)
3: +  {
3: +    motorCmd[legID * 3 + 0].mode = 10;
3: +    motorCmd[legID * 3 + 0].Kp = 180;
3: +    motorCmd[legID * 3 + 0].Kd = 8;
3: +    motorCmd[legID * 3 + 1].mode = 10;
3: +    motorCmd[legID * 3 + 1].Kp = 180;
3: +    motorCmd[legID * 3 + 1].Kd = 8;
3: +    motorCmd[legID * 3 + 2].mode = 10;
3: +    motorCmd[legID * 3 + 2].Kp = 300;
3: +    motorCmd[legID * 3 + 2].Kd = 15;
3: +  }
3: +  void setRealStanceGain(int legID)
3: +  {
3: +    motorCmd[legID * 3 + 0].mode = 10;
3: +    motorCmd[legID * 3 + 0].Kp = 60;
3: +    motorCmd[legID * 3 + 0].Kd = 5;
3: +    motorCmd[legID * 3 + 1].mode = 10;
3: +    motorCmd[legID * 3 + 1].Kp = 40;
3: +    motorCmd[legID * 3 + 1].Kd = 4;
3: +    motorCmd[legID * 3 + 2].mode = 10;
3: +    motorCmd[legID * 3 + 2].Kp = 80;
3: +    motorCmd[legID * 3 + 2].Kd = 7;
3: +  }
3: +  void setZeroGain(int legID)
3: +  {
3: +    motorCmd[legID * 3 + 0].mode = 10;
3: +    motorCmd[legID * 3 + 0].Kp = 0;
3: +    motorCmd[legID * 3 + 0].Kd = 0;
3: +    motorCmd[legID * 3 + 1].mode = 10;
3: +    motorCmd[legID * 3 + 1].Kp = 0;
3: +    motorCmd[legID * 3 + 1].Kd = 0;
3: +    motorCmd[legID * 3 + 2].mode = 10;
3: +    motorCmd[legID * 3 + 2].Kp = 0;
3: +    motorCmd[legID * 3 + 2].Kd = 0;
3: +  }
3: +  void setZeroGain()
3: +  {
3: +    for (int i(0); i < 4; ++i) {
3: +      setZeroGain(i);
3: @@ -59,4 +125,17 @@
3: -    void setZeroDq(int legID){
3: -        motorCmd[legID*3+0].dq = 0;
3: -        motorCmd[legID*3+1].dq = 0;
3: -        motorCmd[legID*3+2].dq = 0;
3: +  }
3: +  void setStableGain(int legID)
3: +  {
3: +    motorCmd[legID * 3 + 0].mode = 10;
3: +    motorCmd[legID * 3 + 0].Kp = 0.8;
3: +    motorCmd[legID * 3 + 0].Kd = 0.8;
3: +    motorCmd[legID * 3 + 1].mode = 10;
3: +    motorCmd[legID * 3 + 1].Kp = 0.8;
3: +    motorCmd[legID * 3 + 1].Kd = 0.8;
3: +    motorCmd[legID * 3 + 2].mode = 10;
3: +    motorCmd[legID * 3 + 2].Kp = 0.8;
3: +    motorCmd[legID * 3 + 2].Kd = 0.8;
3: +  }
3: +  void setStableGain()
3: +  {
3: +    for (int i(0); i < 4; ++i) {
3: +      setStableGain(i);
3: @@ -64,75 +143,13 @@
3: -    void setZeroDq(){
3: -        for(int i(0); i<4; ++i){
3: -            setZeroDq(i);
3: -        }
3: -    }
3: -    void setZeroTau(int legID){
3: -        motorCmd[legID*3+0].tau = 0;
3: -        motorCmd[legID*3+1].tau = 0;
3: -        motorCmd[legID*3+2].tau = 0;
3: -    }
3: -    void setSimStanceGain(int legID){
3: -        motorCmd[legID*3+0].mode = 10;
3: -        motorCmd[legID*3+0].Kp = 180;
3: -        motorCmd[legID*3+0].Kd = 8;
3: -        motorCmd[legID*3+1].mode = 10;
3: -        motorCmd[legID*3+1].Kp = 180;
3: -        motorCmd[legID*3+1].Kd = 8;
3: -        motorCmd[legID*3+2].mode = 10;
3: -        motorCmd[legID*3+2].Kp = 300;
3: -        motorCmd[legID*3+2].Kd = 15;
3: -    }
3: -    void setRealStanceGain(int legID){
3: -        motorCmd[legID*3+0].mode = 10;
3: -        motorCmd[legID*3+0].Kp = 60;
3: -        motorCmd[legID*3+0].Kd = 5;
3: -        motorCmd[legID*3+1].mode = 10;
3: -        motorCmd[legID*3+1].Kp = 40;
3: -        motorCmd[legID*3+1].Kd = 4;
3: -        motorCmd[legID*3+2].mode = 10;
3: -        motorCmd[legID*3+2].Kp = 80;
3: -        motorCmd[legID*3+2].Kd = 7;
3: -    }
3: -    void setZeroGain(int legID){
3: -        motorCmd[legID*3+0].mode = 10;
3: -        motorCmd[legID*3+0].Kp = 0;
3: -        motorCmd[legID*3+0].Kd = 0;
3: -        motorCmd[legID*3+1].mode = 10;
3: -        motorCmd[legID*3+1].Kp = 0;
3: -        motorCmd[legID*3+1].Kd = 0;
3: -        motorCmd[legID*3+2].mode = 10;
3: -        motorCmd[legID*3+2].Kp = 0;
3: -        motorCmd[legID*3+2].Kd = 0;
3: -    }
3: -    void setZeroGain(){
3: -        for(int i(0); i<4; ++i){
3: -            setZeroGain(i);
3: -        }
3: -    }
3: -    void setStableGain(int legID){
3: -        motorCmd[legID*3+0].mode = 10;
3: -        motorCmd[legID*3+0].Kp = 0.8;
3: -        motorCmd[legID*3+0].Kd = 0.8;
3: -        motorCmd[legID*3+1].mode = 10;
3: -        motorCmd[legID*3+1].Kp = 0.8;
3: -        motorCmd[legID*3+1].Kd = 0.8;
3: -        motorCmd[legID*3+2].mode = 10;
3: -        motorCmd[legID*3+2].Kp = 0.8;
3: -        motorCmd[legID*3+2].Kd = 0.8;
3: -    }
3: -    void setStableGain(){
3: -        for(int i(0); i<4; ++i){
3: -            setStableGain(i);
3: -        }
3: -    }
3: -    void setSwingGain(int legID){
3: -        motorCmd[legID*3+0].mode = 10;
3: -        motorCmd[legID*3+0].Kp = 3;
3: -        motorCmd[legID*3+0].Kd = 2;
3: -        motorCmd[legID*3+1].mode = 10;
3: -        motorCmd[legID*3+1].Kp = 3;
3: -        motorCmd[legID*3+1].Kd = 2;
3: -        motorCmd[legID*3+2].mode = 10;
3: -        motorCmd[legID*3+2].Kp = 3;
3: -        motorCmd[legID*3+2].Kd = 2;
3: -    }
3: +  }
3: +  void setSwingGain(int legID)
3: +  {
3: +    motorCmd[legID * 3 + 0].mode = 10;
3: +    motorCmd[legID * 3 + 0].Kp = 3;
3: +    motorCmd[legID * 3 + 0].Kd = 2;
3: +    motorCmd[legID * 3 + 1].mode = 10;
3: +    motorCmd[legID * 3 + 1].Kp = 3;
3: +    motorCmd[legID * 3 + 1].Kd = 2;
3: +    motorCmd[legID * 3 + 2].mode = 10;
3: +    motorCmd[legID * 3 + 2].Kp = 3;
3: +    motorCmd[legID * 3 + 2].Kd = 2;
3: +  }
3: @@ -141 +158 @@
3: -#endif  //LOWLEVELCMD_H
3: +#endif  //LOWLEVELCMD_H
3: 
3: Code style divergence in file 'include/message/LowlevelState.h':
3: 
3: --- include/message/LowlevelState.h
3: +++ include/message/LowlevelState.h.uncrustify
3: @@ -15,5 +15,5 @@
3: -	unsigned int mode;
3: -    float q;
3: -    float dq;
3: -    float ddq;
3: -    float tauEst;
3: +  unsigned int mode;
3: +  float q;
3: +  float dq;
3: +  float ddq;
3: +  float tauEst;
3: @@ -21,6 +21,6 @@
3: -    MotorState(){
3: -        q = 0;
3: -        dq = 0;
3: -        ddq = 0;
3: -        tauEst = 0;
3: -    }
3: +  MotorState() {
3: +    q = 0;
3: +    dq = 0;
3: +    ddq = 0;
3: +    tauEst = 0;
3: +  }
3: @@ -31,3 +31,3 @@
3: -    float quaternion[4];    // w, x, y, z
3: -    float gyroscope[3];
3: -    float accelerometer[3];
3: +  float quaternion[4];      // w, x, y, z
3: +  float gyroscope[3];
3: +  float accelerometer[3];
3: @@ -35,7 +35,5 @@
3: -    IMU(){
3: -        for(int i = 0; i < 3; i++){
3: -            quaternion[i] = 0;
3: -            gyroscope[i] = 0;
3: -            accelerometer[i] = 0;
3: -        }
3: -        quaternion[3] = 0;
3: +  IMU() {
3: +    for (int i = 0; i < 3; i++) {
3: +      quaternion[i] = 0;
3: +      gyroscope[i] = 0;
3: +      accelerometer[i] = 0;
3: @@ -42,0 +41,2 @@
3: +    quaternion[3] = 0;
3: +  }
3: @@ -44,5 +44,6 @@
3: -    RotMat getRotMat(){
3: -        Quat quat;
3: -        quat << quaternion[0], quaternion[1], quaternion[2], quaternion[3];
3: -        return quatToRotMat(quat);
3: -    }
3: +  RotMat getRotMat()
3: +  {
3: +    Quat quat;
3: +    quat << quaternion[0], quaternion[1], quaternion[2], quaternion[3];
3: +    return quatToRotMat(quat);
3: +  }
3: @@ -50,5 +51,6 @@
3: -    Vec3 getAcc(){
3: -        Vec3 acc;
3: -        acc << accelerometer[0], accelerometer[1], accelerometer[2];
3: -        return acc;
3: -    }
3: +  Vec3 getAcc()
3: +  {
3: +    Vec3 acc;
3: +    acc << accelerometer[0], accelerometer[1], accelerometer[2];
3: +    return acc;
3: +  }
3: @@ -56,5 +58,6 @@
3: -    Vec3 getGyro(){
3: -        Vec3 gyro;
3: -        gyro << gyroscope[0], gyroscope[1], gyroscope[2];
3: -        return gyro;
3: -    }
3: +  Vec3 getGyro()
3: +  {
3: +    Vec3 gyro;
3: +    gyro << gyroscope[0], gyroscope[1], gyroscope[2];
3: +    return gyro;
3: +  }
3: @@ -62,5 +65,6 @@
3: -    Quat getQuat(){
3: -        Quat q;
3: -        q << quaternion[0], quaternion[1], quaternion[2], quaternion[3];
3: -        return q;
3: -    }
3: +  Quat getQuat()
3: +  {
3: +    Quat q;
3: +    q << quaternion[0], quaternion[1], quaternion[2], quaternion[3];
3: +    return q;
3: +  }
3: @@ -71,4 +75,4 @@
3: -    IMU imu;
3: -    MotorState motorState[12];
3: -    UserCommand userCmd;
3: -    UserValue userValue;
3: +  IMU imu;
3: +  MotorState motorState[12];
3: +  UserCommand userCmd;
3: +  UserValue userValue;
3: @@ -76,8 +80,7 @@
3: -    Vec34 getQ(){
3: -        Vec34 qLegs;
3: -        for(int i(0); i < 4; ++i){
3: -            qLegs.col(i)(0) = motorState[3*i    ].q;
3: -            qLegs.col(i)(1) = motorState[3*i + 1].q;
3: -            qLegs.col(i)(2) = motorState[3*i + 2].q;
3: -        }
3: -        return qLegs;
3: +  Vec34 getQ()
3: +  {
3: +    Vec34 qLegs;
3: +    for (int i(0); i < 4; ++i) {
3: +      qLegs.col(i)(0) = motorState[3 * i].q;
3: +      qLegs.col(i)(1) = motorState[3 * i + 1].q;
3: +      qLegs.col(i)(2) = motorState[3 * i + 2].q;
3: @@ -84,0 +88,2 @@
3: +    return qLegs;
3: +  }
3: @@ -86,8 +91,7 @@
3: -    Vec34 getQd(){
3: -        Vec34 qdLegs;
3: -        for(int i(0); i < 4; ++i){
3: -            qdLegs.col(i)(0) = motorState[3*i    ].dq;
3: -            qdLegs.col(i)(1) = motorState[3*i + 1].dq;
3: -            qdLegs.col(i)(2) = motorState[3*i + 2].dq;
3: -        }
3: -        return qdLegs;
3: +  Vec34 getQd()
3: +  {
3: +    Vec34 qdLegs;
3: +    for (int i(0); i < 4; ++i) {
3: +      qdLegs.col(i)(0) = motorState[3 * i].dq;
3: +      qdLegs.col(i)(1) = motorState[3 * i + 1].dq;
3: +      qdLegs.col(i)(2) = motorState[3 * i + 2].dq;
3: @@ -94,0 +99,2 @@
3: +    return qdLegs;
3: +  }
3: @@ -96,2 +102,39 @@
3: -    RotMat getRotMat(){
3: -        return imu.getRotMat();
3: +  RotMat getRotMat()
3: +  {
3: +    return imu.getRotMat();
3: +  }
3: +
3: +  Vec3 getAcc()
3: +  {
3: +    return imu.getAcc();
3: +  }
3: +
3: +  Vec3 getGyro()
3: +  {
3: +    return imu.getGyro();
3: +  }
3: +
3: +  Vec3 getAccGlobal()
3: +  {
3: +    return getRotMat() * getAcc();
3: +  }
3: +
3: +  Vec3 getGyroGlobal()
3: +  {
3: +    return getRotMat() * getGyro();
3: +  }
3: +
3: +  double getYaw()
3: +  {
3: +    return rotMatToRPY(getRotMat())(2);
3: +  }
3: +
3: +  double getDYaw()
3: +  {
3: +    return getGyroGlobal()(2);
3: +  }
3: +
3: +  void setQ(Vec12 q)
3: +  {
3: +    for (int i(0); i < 12; ++i) {
3: +      motorState[i].q = q(i);
3: @@ -99,30 +142 @@
3: -
3: -    Vec3 getAcc(){
3: -        return imu.getAcc();
3: -    }
3: -
3: -    Vec3 getGyro(){
3: -        return imu.getGyro();
3: -    }
3: -
3: -    Vec3 getAccGlobal(){
3: -        return getRotMat() * getAcc();
3: -    }
3: -
3: -    Vec3 getGyroGlobal(){
3: -        return getRotMat() * getGyro();
3: -    }
3: -
3: -    double getYaw(){
3: -        return rotMatToRPY(getRotMat())(2);
3: -    }
3: -
3: -    double getDYaw(){
3: -        return getGyroGlobal()(2);
3: -    }
3: -
3: -    void setQ(Vec12 q){
3: -        for(int i(0); i<12; ++i){
3: -            motorState[i].q = q(i);
3: -        }
3: -    }
3: +  }
3: @@ -131 +145 @@
3: -#endif  //LOWLEVELSTATE_HPP
3: +#endif  //LOWLEVELSTATE_HPP
3: 
3: Code style divergence in file 'include/message/unitree_joystick.h':
3: 
3: --- include/message/unitree_joystick.h
3: +++ include/message/unitree_joystick.h.uncrustify
3: @@ -10,19 +10,20 @@
3: -    struct {
3: -        uint8_t R1          :1;
3: -        uint8_t L1          :1;
3: -        uint8_t start       :1;
3: -        uint8_t select      :1;
3: -        uint8_t R2          :1;
3: -        uint8_t L2          :1;
3: -        uint8_t F1          :1;
3: -        uint8_t F2          :1;
3: -        uint8_t A           :1;
3: -        uint8_t B           :1;
3: -        uint8_t X           :1;
3: -        uint8_t Y           :1;
3: -        uint8_t up          :1;
3: -        uint8_t right       :1;
3: -        uint8_t down        :1;
3: -        uint8_t left        :1;
3: -    } components;
3: -    uint16_t value;
3: +  struct
3: +  {
3: +    uint8_t R1          : 1;
3: +    uint8_t L1          : 1;
3: +    uint8_t start       : 1;
3: +    uint8_t select      : 1;
3: +    uint8_t R2          : 1;
3: +    uint8_t L2          : 1;
3: +    uint8_t F1          : 1;
3: +    uint8_t F2          : 1;
3: +    uint8_t A           : 1;
3: +    uint8_t B           : 1;
3: +    uint8_t X           : 1;
3: +    uint8_t Y           : 1;
3: +    uint8_t up          : 1;
3: +    uint8_t right       : 1;
3: +    uint8_t down        : 1;
3: +    uint8_t left        : 1;
3: +  } components;
3: +  uint16_t value;
3: @@ -32,8 +33,9 @@
3: -typedef struct {
3: -    uint8_t head[2];
3: -    xKeySwitchUnion btn;
3: -    float lx;
3: -    float rx;
3: -    float ry;
3: -    float L2;
3: -    float ly;
3: +typedef struct
3: +{
3: +  uint8_t head[2];
3: +  xKeySwitchUnion btn;
3: +  float lx;
3: +  float rx;
3: +  float ry;
3: +  float L2;
3: +  float ly;
3: @@ -41 +43 @@
3: -    uint8_t idle[16];
3: +  uint8_t idle[16];
3: @@ -44 +46 @@
3: -#endif  // UNITREE_JOYSTICK_H
3: +#endif  // UNITREE_JOYSTICK_H
3: 
3: Code style divergence in file 'include/thirdParty/matplotlibcpp.h':
3: 
3: --- include/thirdParty/matplotlibcpp.h
3: +++ include/thirdParty/matplotlibcpp.h.uncrustify
3: @@ -43,74 +43,76 @@
3: -namespace detail {
3: -
3: -static std::string s_backend;
3: -
3: -struct _interpreter {
3: -    PyObject* s_python_function_arrow;
3: -    PyObject *s_python_function_show;
3: -    PyObject *s_python_function_close;
3: -    PyObject *s_python_function_draw;
3: -    PyObject *s_python_function_pause;
3: -    PyObject *s_python_function_save;
3: -    PyObject *s_python_function_figure;
3: -    PyObject *s_python_function_fignum_exists;
3: -    PyObject *s_python_function_plot;
3: -    PyObject *s_python_function_quiver;
3: -    PyObject* s_python_function_contour;
3: -    PyObject *s_python_function_semilogx;
3: -    PyObject *s_python_function_semilogy;
3: -    PyObject *s_python_function_loglog;
3: -    PyObject *s_python_function_fill;
3: -    PyObject *s_python_function_fill_between;
3: -    PyObject *s_python_function_hist;
3: -    PyObject *s_python_function_imshow;
3: -    PyObject *s_python_function_scatter;
3: -    PyObject *s_python_function_boxplot;
3: -    PyObject *s_python_function_subplot;
3: -    PyObject *s_python_function_subplot2grid;
3: -    PyObject *s_python_function_legend;
3: -    PyObject *s_python_function_xlim;
3: -    PyObject *s_python_function_ion;
3: -    PyObject *s_python_function_ginput;
3: -    PyObject *s_python_function_ylim;
3: -    PyObject *s_python_function_title;
3: -    PyObject *s_python_function_axis;
3: -    PyObject *s_python_function_axvline;
3: -    PyObject *s_python_function_axvspan;
3: -    PyObject *s_python_function_xlabel;
3: -    PyObject *s_python_function_ylabel;
3: -    PyObject *s_python_function_gca;
3: -    PyObject *s_python_function_xticks;
3: -    PyObject *s_python_function_yticks;
3: -    PyObject* s_python_function_margins;
3: -    PyObject *s_python_function_tick_params;
3: -    PyObject *s_python_function_grid;
3: -    PyObject* s_python_function_cla;
3: -    PyObject *s_python_function_clf;
3: -    PyObject *s_python_function_errorbar;
3: -    PyObject *s_python_function_annotate;
3: -    PyObject *s_python_function_tight_layout;
3: -    PyObject *s_python_colormap;
3: -    PyObject *s_python_empty_tuple;
3: -    PyObject *s_python_function_stem;
3: -    PyObject *s_python_function_xkcd;
3: -    PyObject *s_python_function_text;
3: -    PyObject *s_python_function_suptitle;
3: -    PyObject *s_python_function_bar;
3: -    PyObject *s_python_function_barh;
3: -    PyObject *s_python_function_colorbar;
3: -    PyObject *s_python_function_subplots_adjust;
3: -
3: -
3: -    /* For now, _interpreter is implemented as a singleton since its currently not possible to have
3: -       multiple independent embedded python interpreters without patching the python source code
3: -       or starting a separate process for each. [1]
3: -       Furthermore, many python objects expect that they are destructed in the same thread as they
3: -       were constructed. [2] So for advanced usage, a `kill()` function is provided so that library
3: -       users can manually ensure that the interpreter is constructed and destroyed within the
3: -       same thread.
3: -
3: -         1: http://bytes.com/topic/python/answers/793370-multiple-independent-python-interpreters-c-c-program
3: -         2: https://github.com/lava/matplotlib-cpp/pull/202#issue-436220256
3: -       */
3: -
3: -    static _interpreter& get() {
3: +  namespace detail {
3: +
3: +    static std::string s_backend;
3: +
3: +    struct _interpreter
3: +    {
3: +      PyObject * s_python_function_arrow;
3: +      PyObject * s_python_function_show;
3: +      PyObject * s_python_function_close;
3: +      PyObject * s_python_function_draw;
3: +      PyObject * s_python_function_pause;
3: +      PyObject * s_python_function_save;
3: +      PyObject * s_python_function_figure;
3: +      PyObject * s_python_function_fignum_exists;
3: +      PyObject * s_python_function_plot;
3: +      PyObject * s_python_function_quiver;
3: +      PyObject * s_python_function_contour;
3: +      PyObject * s_python_function_semilogx;
3: +      PyObject * s_python_function_semilogy;
3: +      PyObject * s_python_function_loglog;
3: +      PyObject * s_python_function_fill;
3: +      PyObject * s_python_function_fill_between;
3: +      PyObject * s_python_function_hist;
3: +      PyObject * s_python_function_imshow;
3: +      PyObject * s_python_function_scatter;
3: +      PyObject * s_python_function_boxplot;
3: +      PyObject * s_python_function_subplot;
3: +      PyObject * s_python_function_subplot2grid;
3: +      PyObject * s_python_function_legend;
3: +      PyObject * s_python_function_xlim;
3: +      PyObject * s_python_function_ion;
3: +      PyObject * s_python_function_ginput;
3: +      PyObject * s_python_function_ylim;
3: +      PyObject * s_python_function_title;
3: +      PyObject * s_python_function_axis;
3: +      PyObject * s_python_function_axvline;
3: +      PyObject * s_python_function_axvspan;
3: +      PyObject * s_python_function_xlabel;
3: +      PyObject * s_python_function_ylabel;
3: +      PyObject * s_python_function_gca;
3: +      PyObject * s_python_function_xticks;
3: +      PyObject * s_python_function_yticks;
3: +      PyObject * s_python_function_margins;
3: +      PyObject * s_python_function_tick_params;
3: +      PyObject * s_python_function_grid;
3: +      PyObject * s_python_function_cla;
3: +      PyObject * s_python_function_clf;
3: +      PyObject * s_python_function_errorbar;
3: +      PyObject * s_python_function_annotate;
3: +      PyObject * s_python_function_tight_layout;
3: +      PyObject * s_python_colormap;
3: +      PyObject * s_python_empty_tuple;
3: +      PyObject * s_python_function_stem;
3: +      PyObject * s_python_function_xkcd;
3: +      PyObject * s_python_function_text;
3: +      PyObject * s_python_function_suptitle;
3: +      PyObject * s_python_function_bar;
3: +      PyObject * s_python_function_barh;
3: +      PyObject * s_python_function_colorbar;
3: +      PyObject * s_python_function_subplots_adjust;
3: +
3: +
3: +      /* For now, _interpreter is implemented as a singleton since its currently not possible to have
3: +         multiple independent embedded python interpreters without patching the python source code
3: +         or starting a separate process for each. [1]
3: +         Furthermore, many python objects expect that they are destructed in the same thread as they
3: +         were constructed. [2] So for advanced usage, a `kill()` function is provided so that library
3: +         users can manually ensure that the interpreter is constructed and destroyed within the
3: +         same thread.
3: +
3: +           1: http://bytes.com/topic/python/answers/793370-multiple-independent-python-interpreters-c-c-program
3: +           2: https://github.com/lava/matplotlib-cpp/pull/202#issue-436220256
3: +         */
3: +
3: +      static _interpreter & get()
3: +      {
3: @@ -118,3 +120,4 @@
3: -    }
3: -
3: -    static _interpreter& kill() {
3: +      }
3: +
3: +      static _interpreter & kill()
3: +      {
3: @@ -122,4 +125,5 @@
3: -    }
3: -
3: -    // Stores the actual singleton object referenced by `get()` and `kill()`.
3: -    static _interpreter& interkeeper(bool should_kill) {
3: +      }
3: +
3: +      // Stores the actual singleton object referenced by `get()` and `kill()`.
3: +      static _interpreter & interkeeper(bool should_kill)
3: +      {
3: @@ -127,2 +131,3 @@
3: -        if (should_kill)
3: -            ctx.~_interpreter();
3: +        if (should_kill) {
3: +          ctx.~_interpreter();
3: +        }
3: @@ -130,10 +135,13 @@
3: -    }
3: -
3: -    PyObject* safe_import(PyObject* module, std::string fname) {
3: -        PyObject* fn = PyObject_GetAttrString(module, fname.c_str());
3: -
3: -        if (!fn)
3: -            throw std::runtime_error(std::string("Couldn't find required function: ") + fname);
3: -
3: -        if (!PyFunction_Check(fn))
3: -            throw std::runtime_error(fname + std::string(" is unexpectedly not a PyFunction."));
3: +      }
3: +
3: +      PyObject * safe_import(PyObject * module, std::string fname)
3: +      {
3: +        PyObject * fn = PyObject_GetAttrString(module, fname.c_str());
3: +
3: +        if (!fn) {
3: +          throw std::runtime_error(std::string("Couldn't find required function: ") + fname);
3: +        }
3: +
3: +        if (!PyFunction_Check(fn)) {
3: +          throw std::runtime_error(fname + std::string(" is unexpectedly not a PyFunction."));
3: +        }
3: @@ -142 +150 @@
3: -    }
3: +      }
3: @@ -145 +152,0 @@
3: -
3: @@ -149 +156,2 @@
3: -    void *import_numpy() {
3: +      void * import_numpy()
3: +      {
3: @@ -152 +160 @@
3: -    }
3: +      }
3: @@ -156 +164,2 @@
3: -    void import_numpy() {
3: +      void import_numpy()
3: +      {
3: @@ -158 +167 @@
3: -    }
3: +      }
3: @@ -163 +172 @@
3: -    _interpreter() {
3: +      _interpreter() {
3: @@ -174,3 +183,3 @@
3: -        wchar_t const *dummy_args[] = {L"Python", NULL};  // const is needed because literals must not be modified
3: -        wchar_t const **argv = dummy_args;
3: -        int             argc = sizeof(dummy_args)/sizeof(dummy_args[0])-1;
3: +        wchar_t const * dummy_args[] = {L"Python", NULL};  // const is needed because literals must not be modified
3: +        wchar_t const ** argv = dummy_args;
3: +        int argc = sizeof(dummy_args) / sizeof(dummy_args[0]) - 1;
3: @@ -180 +189 @@
3: -        char** argm = (char **)(argv); PySys_SetArgv(argc, argm);
3: +        char ** argm = (char **)(argv); PySys_SetArgv(argc, argm);
3: @@ -186,4 +195,4 @@
3: -        PyObject* matplotlibname = PyString_FromString("matplotlib");
3: -        PyObject* pyplotname = PyString_FromString("matplotlib.pyplot");
3: -        PyObject* cmname  = PyString_FromString("matplotlib.cm");
3: -        PyObject* pylabname  = PyString_FromString("pylab");
3: +        PyObject * matplotlibname = PyString_FromString("matplotlib");
3: +        PyObject * pyplotname = PyString_FromString("matplotlib.pyplot");
3: +        PyObject * cmname = PyString_FromString("matplotlib.cm");
3: +        PyObject * pylabname = PyString_FromString("pylab");
3: @@ -191 +200 @@
3: -            throw std::runtime_error("couldnt create string");
3: +          throw std::runtime_error("couldnt create string");
3: @@ -194 +203 @@
3: -        PyObject* matplotlib = PyImport_Import(matplotlibname);
3: +        PyObject * matplotlib = PyImport_Import(matplotlibname);
3: @@ -197,2 +206,2 @@
3: -            PyErr_Print();
3: -            throw std::runtime_error("Error loading module matplotlib!");
3: +          PyErr_Print();
3: +          throw std::runtime_error("Error loading module matplotlib!");
3: @@ -204 +213,3 @@
3: -            PyObject_CallMethod(matplotlib, const_cast<char*>("use"), const_cast<char*>("s"), s_backend.c_str());
3: +          PyObject_CallMethod(
3: +            matplotlib, const_cast < char * > ("use"),
3: +            const_cast < char * > ("s"), s_backend.c_str());
3: @@ -207 +218 @@
3: -        PyObject* pymod = PyImport_Import(pyplotname);
3: +        PyObject * pymod = PyImport_Import(pyplotname);
3: @@ -209 +220 @@
3: -        if (!pymod) { throw std::runtime_error("Error loading module matplotlib.pyplot!"); }
3: +        if (!pymod) {throw std::runtime_error("Error loading module matplotlib.pyplot!");}
3: @@ -213,3 +224,3 @@
3: -        if (!s_python_colormap) { throw std::runtime_error("Error loading module matplotlib.cm!"); }
3: -
3: -        PyObject* pylabmod = PyImport_Import(pylabname);
3: +        if (!s_python_colormap) {throw std::runtime_error("Error loading module matplotlib.cm!");}
3: +
3: +        PyObject * pylabmod = PyImport_Import(pylabname);
3: @@ -217 +228 @@
3: -        if (!pylabmod) { throw std::runtime_error("Error loading module pylab!"); }
3: +        if (!pylabmod) {throw std::runtime_error("Error loading module pylab!");}
3: @@ -234,3 +245,3 @@
3: -        s_python_function_hist = safe_import(pymod,"hist");
3: -        s_python_function_scatter = safe_import(pymod,"scatter");
3: -        s_python_function_boxplot = safe_import(pymod,"boxplot");
3: +        s_python_function_hist = safe_import(pymod, "hist");
3: +        s_python_function_scatter = safe_import(pymod, "scatter");
3: +        s_python_function_boxplot = safe_import(pymod, "boxplot");
3: @@ -257 +268 @@
3: -        s_python_function_annotate = safe_import(pymod,"annotate");
3: +        s_python_function_annotate = safe_import(pymod, "annotate");
3: @@ -266 +277 @@
3: -        s_python_function_bar = safe_import(pymod,"bar");
3: +        s_python_function_bar = safe_import(pymod, "bar");
3: @@ -269 +280 @@
3: -        s_python_function_subplots_adjust = safe_import(pymod,"subplots_adjust");
3: +        s_python_function_subplots_adjust = safe_import(pymod, "subplots_adjust");
3: @@ -274,3 +285,3 @@
3: -    }
3: -
3: -    ~_interpreter() {
3: +      }
3: +
3: +      ~_interpreter() {
3: @@ -278,4 +289,4 @@
3: -    }
3: -};
3: -
3: -} // end namespace detail
3: +      }
3: +    };
3: +
3: +  } // end namespace detail
3: @@ -292,2 +303,2 @@
3: -inline void backend(const std::string& name)
3: -{
3: +  inline void backend(const std::string & name)
3: +  {
3: @@ -295,4 +306,4 @@
3: -}
3: -
3: -inline bool annotate(std::string annotation, double x, double y)
3: -{
3: +  }
3: +
3: +  inline bool annotate(std::string annotation, double x, double y)
3: +  {
3: @@ -304,4 +315,4 @@
3: -    PyTuple_SetItem(xy,0,PyFloat_FromDouble(x));
3: -    PyTuple_SetItem(xy,1,PyFloat_FromDouble(y));
3: -
3: -    PyObject* kwargs = PyDict_New();
3: +    PyTuple_SetItem(xy, 0, PyFloat_FromDouble(x));
3: +    PyTuple_SetItem(xy, 1, PyFloat_FromDouble(y));
3: +
3: +    PyObject * kwargs = PyDict_New();
3: @@ -310 +321 @@
3: -    PyObject* args = PyTuple_New(1);
3: +    PyObject * args = PyTuple_New(1);
3: @@ -313,6 +324,7 @@
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_annotate, args, kwargs);
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -
3: -    if(res) Py_DECREF(res);
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_annotate, args, kwargs);
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +
3: +    if (res) {Py_DECREF(res);}
3: @@ -321,3 +333,3 @@
3: -}
3: -
3: -namespace detail {
3: +  }
3: +
3: +  namespace detail {
3: @@ -327,12 +339,12 @@
3: -template <typename T> struct select_npy_type { const static NPY_TYPES type = NPY_NOTYPE; }; //Default
3: -template <> struct select_npy_type<double> { const static NPY_TYPES type = NPY_DOUBLE; };
3: -template <> struct select_npy_type<float> { const static NPY_TYPES type = NPY_FLOAT; };
3: -template <> struct select_npy_type<bool> { const static NPY_TYPES type = NPY_BOOL; };
3: -template <> struct select_npy_type<int8_t> { const static NPY_TYPES type = NPY_INT8; };
3: -template <> struct select_npy_type<int16_t> { const static NPY_TYPES type = NPY_SHORT; };
3: -template <> struct select_npy_type<int32_t> { const static NPY_TYPES type = NPY_INT; };
3: -template <> struct select_npy_type<int64_t> { const static NPY_TYPES type = NPY_INT64; };
3: -template <> struct select_npy_type<uint8_t> { const static NPY_TYPES type = NPY_UINT8; };
3: -template <> struct select_npy_type<uint16_t> { const static NPY_TYPES type = NPY_USHORT; };
3: -template <> struct select_npy_type<uint32_t> { const static NPY_TYPES type = NPY_ULONG; };
3: -template <> struct select_npy_type<uint64_t> { const static NPY_TYPES type = NPY_UINT64; };
3: +    template < typename T > struct select_npy_type { const static NPY_TYPES type = NPY_NOTYPE; }; //Default
3: +    template < > struct select_npy_type < double > {const static NPY_TYPES type = NPY_DOUBLE;}
3: +    template < > struct select_npy_type < float > {const static NPY_TYPES type = NPY_FLOAT;}
3: +    template < > struct select_npy_type < bool > {const static NPY_TYPES type = NPY_BOOL;}
3: +    template < > struct select_npy_type < int8_t > {const static NPY_TYPES type = NPY_INT8;}
3: +    template < > struct select_npy_type < int16_t > {const static NPY_TYPES type = NPY_SHORT;}
3: +    template < > struct select_npy_type < int32_t > {const static NPY_TYPES type = NPY_INT;}
3: +    template < > struct select_npy_type < int64_t > {const static NPY_TYPES type = NPY_INT64;}
3: +    template < > struct select_npy_type < uint8_t > {const static NPY_TYPES type = NPY_UINT8;}
3: +    template < > struct select_npy_type < uint16_t > {const static NPY_TYPES type = NPY_USHORT;}
3: +    template < > struct select_npy_type < uint32_t > {const static NPY_TYPES type = NPY_ULONG;}
3: +    template < > struct select_npy_type < uint64_t > {const static NPY_TYPES type = NPY_UINT64;}
3: @@ -342,4 +354,5 @@
3: -static_assert(sizeof(long long) == 8);
3: -template <> struct select_npy_type<long long> { const static NPY_TYPES type = NPY_INT64; };
3: -static_assert(sizeof(unsigned long long) == 8);
3: -template <> struct select_npy_type<unsigned long long> { const static NPY_TYPES type = NPY_UINT64; };
3: +    static_assert(sizeof(long long) == 8);
3: +    template < > struct select_npy_type < long long > {const static NPY_TYPES type = NPY_INT64;}
3: +    static_assert(sizeof(unsigned long long) == 8);
3: +    template < > struct select_npy_type < unsigned long long >
3: +    {const static NPY_TYPES type = NPY_UINT64;}
3: @@ -348,12 +361,13 @@
3: -template<typename Numeric>
3: -PyObject* get_array(const std::vector<Numeric>& v)
3: -{
3: -    npy_intp vsize = v.size();
3: -    NPY_TYPES type = select_npy_type<Numeric>::type;
3: -    if (type == NPY_NOTYPE) {
3: -        size_t memsize = v.size()*sizeof(double);
3: -        double* dp = static_cast<double*>(::malloc(memsize));
3: -        for (size_t i=0; i<v.size(); ++i)
3: -            dp[i] = v[i];
3: -        PyObject* varray = PyArray_SimpleNewFromData(1, &vsize, NPY_DOUBLE, dp);
3: -        PyArray_UpdateFlags(reinterpret_cast<PyArrayObject*>(varray), NPY_ARRAY_OWNDATA);
3: +    template < typename Numeric >
3: +    PyObject * get_array(const std::vector < Numeric > & v)
3: +    {
3: +      npy_intp vsize = v.size();
3: +      NPY_TYPES type = select_npy_type < Numeric > ::type;
3: +      if (type == NPY_NOTYPE) {
3: +        size_t memsize = v.size() * sizeof(double);
3: +        double * dp = static_cast < double * > (::malloc(memsize));
3: +        for (size_t i = 0; i < v.size(); ++i) {
3: +          dp[i] = v[i];
3: +        }
3: +        PyObject * varray = PyArray_SimpleNewFromData(1, &vsize, NPY_DOUBLE, dp);
3: +        PyArray_UpdateFlags(reinterpret_cast < PyArrayObject * > (varray), NPY_ARRAY_OWNDATA);
3: @@ -361,16 +375,16 @@
3: -    }
3: -    
3: -    PyObject* varray = PyArray_SimpleNewFromData(1, &vsize, type, (void*)(v.data()));
3: -    return varray;
3: -}
3: -
3: -
3: -template<typename Numeric>
3: -PyObject* get_2darray(const std::vector<::std::vector<Numeric>>& v)
3: -{
3: -    if (v.size() < 1) throw std::runtime_error("get_2d_array v too small");
3: -
3: -    npy_intp vsize[2] = {static_cast<npy_intp>(v.size()),
3: -                         static_cast<npy_intp>(v[0].size())};
3: -
3: -    PyArrayObject *varray =
3: +      }
3: +
3: +      PyObject * varray = PyArray_SimpleNewFromData(1, &vsize, type, (void *)(v.data()));
3: +      return varray;
3: +    }
3: +
3: +
3: +    template < typename Numeric >
3: +    PyObject * get_2darray(const std::vector < ::std::vector < Numeric >> & v)
3: +    {
3: +      if (v.size() < 1) {throw std::runtime_error("get_2d_array v too small");}
3: +
3: +      npy_intp vsize[2] = {static_cast < npy_intp > (v.size()),
3: +        static_cast < npy_intp > (v[0].size())};
3: +
3: +      PyArrayObject * varray =
3: @@ -379,11 +393,12 @@
3: -    double *vd_begin = static_cast<double *>(PyArray_DATA(varray));
3: -
3: -    for (const ::std::vector<Numeric> &v_row : v) {
3: -      if (v_row.size() != static_cast<size_t>(vsize[1]))
3: -        throw std::runtime_error("Missmatched array size");
3: -      std::copy(v_row.begin(), v_row.end(), vd_begin);
3: -      vd_begin += vsize[1];
3: -    }
3: -
3: -    return reinterpret_cast<PyObject *>(varray);
3: -}
3: +      double * vd_begin = static_cast < double * > (PyArray_DATA(varray));
3: +
3: +      for (const ::std::vector < Numeric > & v_row : v) {
3: +        if (v_row.size() != static_cast < size_t > (vsize[1])) {
3: +          throw std::runtime_error("Missmatched array size");
3: +        }
3: +        std::copy(v_row.begin(), v_row.end(), vd_begin);
3: +        vd_begin += vsize[1];
3: +      }
3: +
3: +      return reinterpret_cast < PyObject * > (varray);
3: +    }
3: @@ -393,5 +408,5 @@
3: -template<typename Numeric>
3: -PyObject* get_array(const std::vector<Numeric>& v)
3: -{
3: -    PyObject* list = PyList_New(v.size());
3: -    for(size_t i = 0; i < v.size(); ++i) {
3: +    template < typename Numeric >
3: +    PyObject * get_array(const std::vector < Numeric > & v)
3: +    {
3: +      PyObject * list = PyList_New(v.size());
3: +      for (size_t i = 0; i < v.size(); ++i) {
3: @@ -399,3 +414,3 @@
3: -    }
3: -    return list;
3: -}
3: +      }
3: +      return list;
3: +    }
3: @@ -406,8 +421,8 @@
3: -inline PyObject * get_array(const std::vector<std::string>& strings)
3: -{
3: -  PyObject* list = PyList_New(strings.size());
3: -  for (std::size_t i = 0; i < strings.size(); ++i) {
3: -    PyList_SetItem(list, i, PyString_FromString(strings[i].c_str()));
3: -  }
3: -  return list;
3: -}
3: +    inline PyObject * get_array(const std::vector < std::string > & strings)
3: +    {
3: +      PyObject * list = PyList_New(strings.size());
3: +      for (std::size_t i = 0; i < strings.size(); ++i) {
3: +        PyList_SetItem(list, i, PyString_FromString(strings[i].c_str()));
3: +      }
3: +      return list;
3: +    }
3: @@ -416,11 +431,11 @@
3: -template<typename Numeric>
3: -PyObject* get_listlist(const std::vector<std::vector<Numeric>>& ll)
3: -{
3: -  PyObject* listlist = PyList_New(ll.size());
3: -  for (std::size_t i = 0; i < ll.size(); ++i) {
3: -    PyList_SetItem(listlist, i, get_array(ll[i]));
3: -  }
3: -  return listlist;
3: -}
3: -
3: -} // namespace detail
3: +    template < typename Numeric >
3: +    PyObject * get_listlist(const std::vector < std::vector < Numeric >> & ll)
3: +    {
3: +      PyObject * listlist = PyList_New(ll.size());
3: +      for (std::size_t i = 0; i < ll.size(); ++i) {
3: +        PyList_SetItem(listlist, i, get_array(ll[i]));
3: +      }
3: +      return listlist;
3: +    }
3: +
3: +  } // namespace detail
3: @@ -429 +444 @@
3: -/// 
3: +///
3: @@ -431,3 +446,5 @@
3: -template<typename Numeric>
3: -bool plot(const std::vector<Numeric> &x, const std::vector<Numeric> &y, const std::map<std::string, std::string>& keywords)
3: -{
3: +  template < typename Numeric >
3: +  bool plot(
3: +    const std::vector < Numeric > & x, const std::vector < Numeric > & y,
3: +    const std::map < std::string, std::string > & keywords)
3: +  {
3: @@ -439,2 +456,2 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: @@ -443 +460 @@
3: -    PyObject* args = PyTuple_New(2);
3: +    PyObject * args = PyTuple_New(2);
3: @@ -448,11 +465,13 @@
3: -    PyObject* kwargs = PyDict_New();
3: -    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
3: -    {
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_plot, args, kwargs);
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -    if(res) Py_DECREF(res);
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res =
3: +      PyObject_Call(detail::_interpreter::get().s_python_function_plot, args, kwargs);
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +    if (res) {Py_DECREF(res);}
3: @@ -461 +480 @@
3: -}
3: +  }
3: @@ -466,183 +485,31 @@
3: -template <typename Numeric>
3: -void plot_surface(const std::vector<::std::vector<Numeric>> &x,
3: -                  const std::vector<::std::vector<Numeric>> &y,
3: -                  const std::vector<::std::vector<Numeric>> &z,
3: -                  const std::map<std::string, std::string> &keywords =
3: -                      std::map<std::string, std::string>())
3: -{
3: -  detail::_interpreter::get();
3: -
3: -  // We lazily load the modules here the first time this function is called
3: -  // because I'm not sure that we can assume "matplotlib installed" implies
3: -  // "mpl_toolkits installed" on all platforms, and we don't want to require
3: -  // it for people who don't need 3d plots.
3: -  static PyObject *mpl_toolkitsmod = nullptr, *axis3dmod = nullptr;
3: -  if (!mpl_toolkitsmod) {
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* mpl_toolkits = PyString_FromString("mpl_toolkits");
3: -    PyObject* axis3d = PyString_FromString("mpl_toolkits.mplot3d");
3: -    if (!mpl_toolkits || !axis3d) { throw std::runtime_error("couldnt create string"); }
3: -
3: -    mpl_toolkitsmod = PyImport_Import(mpl_toolkits);
3: -    Py_DECREF(mpl_toolkits);
3: -    if (!mpl_toolkitsmod) { throw std::runtime_error("Error loading module mpl_toolkits!"); }
3: -
3: -    axis3dmod = PyImport_Import(axis3d);
3: -    Py_DECREF(axis3d);
3: -    if (!axis3dmod) { throw std::runtime_error("Error loading module mpl_toolkits.mplot3d!"); }
3: -  }
3: -
3: -  assert(x.size() == y.size());
3: -  assert(y.size() == z.size());
3: -
3: -  // using numpy arrays
3: -  PyObject *xarray = detail::get_2darray(x);
3: -  PyObject *yarray = detail::get_2darray(y);
3: -  PyObject *zarray = detail::get_2darray(z);
3: -
3: -  // construct positional args
3: -  PyObject *args = PyTuple_New(3);
3: -  PyTuple_SetItem(args, 0, xarray);
3: -  PyTuple_SetItem(args, 1, yarray);
3: -  PyTuple_SetItem(args, 2, zarray);
3: -
3: -  // Build up the kw args.
3: -  PyObject *kwargs = PyDict_New();
3: -  PyDict_SetItemString(kwargs, "rstride", PyInt_FromLong(1));
3: -  PyDict_SetItemString(kwargs, "cstride", PyInt_FromLong(1));
3: -
3: -  PyObject *python_colormap_coolwarm = PyObject_GetAttrString(
3: -      detail::_interpreter::get().s_python_colormap, "coolwarm");
3: -
3: -  PyDict_SetItemString(kwargs, "cmap", python_colormap_coolwarm);
3: -
3: -  for (std::map<std::string, std::string>::const_iterator it = keywords.begin();
3: -       it != keywords.end(); ++it) {
3: -    PyDict_SetItemString(kwargs, it->first.c_str(),
3: -                         PyString_FromString(it->second.c_str()));
3: -  }
3: -
3: -
3: -  PyObject *fig =
3: -      PyObject_CallObject(detail::_interpreter::get().s_python_function_figure,
3: -                          detail::_interpreter::get().s_python_empty_tuple);
3: -  if (!fig) throw std::runtime_error("Call to figure() failed.");
3: -
3: -  PyObject *gca_kwargs = PyDict_New();
3: -  PyDict_SetItemString(gca_kwargs, "projection", PyString_FromString("3d"));
3: -
3: -  PyObject *gca = PyObject_GetAttrString(fig, "gca");
3: -  if (!gca) throw std::runtime_error("No gca");
3: -  Py_INCREF(gca);
3: -  PyObject *axis = PyObject_Call(
3: -      gca, detail::_interpreter::get().s_python_empty_tuple, gca_kwargs);
3: -
3: -  if (!axis) throw std::runtime_error("No axis");
3: -  Py_INCREF(axis);
3: -
3: -  Py_DECREF(gca);
3: -  Py_DECREF(gca_kwargs);
3: -
3: -  PyObject *plot_surface = PyObject_GetAttrString(axis, "plot_surface");
3: -  if (!plot_surface) throw std::runtime_error("No surface");
3: -  Py_INCREF(plot_surface);
3: -  PyObject *res = PyObject_Call(plot_surface, args, kwargs);
3: -  if (!res) throw std::runtime_error("failed surface");
3: -  Py_DECREF(plot_surface);
3: -
3: -  Py_DECREF(axis);
3: -  Py_DECREF(args);
3: -  Py_DECREF(kwargs);
3: -  if (res) Py_DECREF(res);
3: -}
3: -#endif // WITHOUT_NUMPY
3: -
3: -template <typename Numeric>
3: -void plot3(const std::vector<Numeric> &x,
3: -                  const std::vector<Numeric> &y,
3: -                  const std::vector<Numeric> &z,
3: -                  const std::map<std::string, std::string> &keywords =
3: -                      std::map<std::string, std::string>())
3: -{
3: -  detail::_interpreter::get();
3: -
3: -  // Same as with plot_surface: We lazily load the modules here the first time 
3: -  // this function is called because I'm not sure that we can assume "matplotlib 
3: -  // installed" implies "mpl_toolkits installed" on all platforms, and we don't 
3: -  // want to require it for people who don't need 3d plots.
3: -  static PyObject *mpl_toolkitsmod = nullptr, *axis3dmod = nullptr;
3: -  if (!mpl_toolkitsmod) {
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* mpl_toolkits = PyString_FromString("mpl_toolkits");
3: -    PyObject* axis3d = PyString_FromString("mpl_toolkits.mplot3d");
3: -    if (!mpl_toolkits || !axis3d) { throw std::runtime_error("couldnt create string"); }
3: -
3: -    mpl_toolkitsmod = PyImport_Import(mpl_toolkits);
3: -    Py_DECREF(mpl_toolkits);
3: -    if (!mpl_toolkitsmod) { throw std::runtime_error("Error loading module mpl_toolkits!"); }
3: -
3: -    axis3dmod = PyImport_Import(axis3d);
3: -    Py_DECREF(axis3d);
3: -    if (!axis3dmod) { throw std::runtime_error("Error loading module mpl_toolkits.mplot3d!"); }
3: -  }
3: -
3: -  assert(x.size() == y.size());
3: -  assert(y.size() == z.size());
3: -
3: -  PyObject *xarray = detail::get_array(x);
3: -  PyObject *yarray = detail::get_array(y);
3: -  PyObject *zarray = detail::get_array(z);
3: -
3: -  // construct positional args
3: -  PyObject *args = PyTuple_New(3);
3: -  PyTuple_SetItem(args, 0, xarray);
3: -  PyTuple_SetItem(args, 1, yarray);
3: -  PyTuple_SetItem(args, 2, zarray);
3: -
3: -  // Build up the kw args.
3: -  PyObject *kwargs = PyDict_New();
3: -
3: -  for (std::map<std::string, std::string>::const_iterator it = keywords.begin();
3: -       it != keywords.end(); ++it) {
3: -    PyDict_SetItemString(kwargs, it->first.c_str(),
3: -                         PyString_FromString(it->second.c_str()));
3: -  }
3: -
3: -  PyObject *fig =
3: -      PyObject_CallObject(detail::_interpreter::get().s_python_function_figure,
3: -                          detail::_interpreter::get().s_python_empty_tuple);
3: -  if (!fig) throw std::runtime_error("Call to figure() failed.");
3: -
3: -  PyObject *gca_kwargs = PyDict_New();
3: -  PyDict_SetItemString(gca_kwargs, "projection", PyString_FromString("3d"));
3: -
3: -  PyObject *gca = PyObject_GetAttrString(fig, "gca");
3: -  if (!gca) throw std::runtime_error("No gca");
3: -  Py_INCREF(gca);
3: -  PyObject *axis = PyObject_Call(
3: -      gca, detail::_interpreter::get().s_python_empty_tuple, gca_kwargs);
3: -
3: -  if (!axis) throw std::runtime_error("No axis");
3: -  Py_INCREF(axis);
3: -
3: -  Py_DECREF(gca);
3: -  Py_DECREF(gca_kwargs);
3: -
3: -  PyObject *plot3 = PyObject_GetAttrString(axis, "plot");
3: -  if (!plot3) throw std::runtime_error("No 3D line plot");
3: -  Py_INCREF(plot3);
3: -  PyObject *res = PyObject_Call(plot3, args, kwargs);
3: -  if (!res) throw std::runtime_error("Failed 3D line plot");
3: -  Py_DECREF(plot3);
3: -
3: -  Py_DECREF(axis);
3: -  Py_DECREF(args);
3: -  Py_DECREF(kwargs);
3: -  if (res) Py_DECREF(res);
3: -}
3: -
3: -template<typename Numeric>
3: -bool stem(const std::vector<Numeric> &x, const std::vector<Numeric> &y, const std::map<std::string, std::string>& keywords)
3: -{
3: +  template < typename Numeric >
3: +  void plot_surface(
3: +    const std::vector < ::std::vector < Numeric >> & x,
3: +    const std::vector < ::std::vector < Numeric >> & y,
3: +    const std::vector < ::std::vector < Numeric >> & z,
3: +    const std::map < std::string, std::string > & keywords =
3: +    std::map < std::string, std::string > ())
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    // We lazily load the modules here the first time this function is called
3: +    // because I'm not sure that we can assume "matplotlib installed" implies
3: +    // "mpl_toolkits installed" on all platforms, and we don't want to require
3: +    // it for people who don't need 3d plots.
3: +    static PyObject * mpl_toolkitsmod = nullptr, * axis3dmod = nullptr;
3: +    if (!mpl_toolkitsmod) {
3: +      detail::_interpreter::get();
3: +
3: +      PyObject * mpl_toolkits = PyString_FromString("mpl_toolkits");
3: +      PyObject * axis3d = PyString_FromString("mpl_toolkits.mplot3d");
3: +      if (!mpl_toolkits || !axis3d) {throw std::runtime_error("couldnt create string");}
3: +
3: +      mpl_toolkitsmod = PyImport_Import(mpl_toolkits);
3: +      Py_DECREF(mpl_toolkits);
3: +      if (!mpl_toolkitsmod) {throw std::runtime_error("Error loading module mpl_toolkits!");}
3: +
3: +      axis3dmod = PyImport_Import(axis3d);
3: +      Py_DECREF(axis3d);
3: +      if (!axis3dmod) {throw std::runtime_error("Error loading module mpl_toolkits.mplot3d!");}
3: +    }
3: +
3: @@ -650,2 +517 @@
3: -
3: -    detail::_interpreter::get();
3: +    assert(y.size() == z.size());
3: @@ -654,2 +520,3 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: +    PyObject * xarray = detail::get_2darray(x);
3: +    PyObject * yarray = detail::get_2darray(y);
3: +    PyObject * zarray = detail::get_2darray(z);
3: @@ -658 +525 @@
3: -    PyObject* args = PyTuple_New(2);
3: +    PyObject * args = PyTuple_New(3);
3: @@ -661,23 +528,87 @@
3: -
3: -    // construct keyword args
3: -    PyObject* kwargs = PyDict_New();
3: -    for (std::map<std::string, std::string>::const_iterator it =
3: -            keywords.begin(); it != keywords.end(); ++it) {
3: -        PyDict_SetItemString(kwargs, it->first.c_str(),
3: -                PyString_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(
3: -            detail::_interpreter::get().s_python_function_stem, args, kwargs);
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -    if (res)
3: -        Py_DECREF(res);
3: -
3: -    return res;
3: -}
3: -
3: -template< typename Numeric >
3: -bool fill(const std::vector<Numeric>& x, const std::vector<Numeric>& y, const std::map<std::string, std::string>& keywords)
3: -{
3: +    PyTuple_SetItem(args, 2, zarray);
3: +
3: +    // Build up the kw args.
3: +    PyObject * kwargs = PyDict_New();
3: +    PyDict_SetItemString(kwargs, "rstride", PyInt_FromLong(1));
3: +    PyDict_SetItemString(kwargs, "cstride", PyInt_FromLong(1));
3: +
3: +    PyObject * python_colormap_coolwarm = PyObject_GetAttrString(
3: +      detail::_interpreter::get().s_python_colormap, "coolwarm");
3: +
3: +    PyDict_SetItemString(kwargs, "cmap", python_colormap_coolwarm);
3: +
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(
3: +        kwargs, it->first.c_str(),
3: +        PyString_FromString(it->second.c_str()));
3: +    }
3: +
3: +
3: +    PyObject * fig =
3: +      PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_figure,
3: +      detail::_interpreter::get().s_python_empty_tuple);
3: +    if (!fig) {throw std::runtime_error("Call to figure() failed.");}
3: +
3: +    PyObject * gca_kwargs = PyDict_New();
3: +    PyDict_SetItemString(gca_kwargs, "projection", PyString_FromString("3d"));
3: +
3: +    PyObject * gca = PyObject_GetAttrString(fig, "gca");
3: +    if (!gca) {throw std::runtime_error("No gca");}
3: +    Py_INCREF(gca);
3: +    PyObject * axis = PyObject_Call(
3: +      gca, detail::_interpreter::get().s_python_empty_tuple, gca_kwargs);
3: +
3: +    if (!axis) {throw std::runtime_error("No axis");}
3: +    Py_INCREF(axis);
3: +
3: +    Py_DECREF(gca);
3: +    Py_DECREF(gca_kwargs);
3: +
3: +    PyObject * plot_surface = PyObject_GetAttrString(axis, "plot_surface");
3: +    if (!plot_surface) {throw std::runtime_error("No surface");}
3: +    Py_INCREF(plot_surface);
3: +    PyObject * res = PyObject_Call(plot_surface, args, kwargs);
3: +    if (!res) {throw std::runtime_error("failed surface");}
3: +    Py_DECREF(plot_surface);
3: +
3: +    Py_DECREF(axis);
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +    if (res) {Py_DECREF(res);}
3: +  }
3: +#endif // WITHOUT_NUMPY
3: +
3: +  template < typename Numeric >
3: +  void plot3(
3: +    const std::vector < Numeric > & x,
3: +    const std::vector < Numeric > & y,
3: +    const std::vector < Numeric > & z,
3: +    const std::map < std::string, std::string > & keywords =
3: +    std::map < std::string, std::string > ())
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    // Same as with plot_surface: We lazily load the modules here the first time
3: +    // this function is called because I'm not sure that we can assume "matplotlib
3: +    // installed" implies "mpl_toolkits installed" on all platforms, and we don't
3: +    // want to require it for people who don't need 3d plots.
3: +    static PyObject * mpl_toolkitsmod = nullptr, * axis3dmod = nullptr;
3: +    if (!mpl_toolkitsmod) {
3: +      detail::_interpreter::get();
3: +
3: +      PyObject * mpl_toolkits = PyString_FromString("mpl_toolkits");
3: +      PyObject * axis3d = PyString_FromString("mpl_toolkits.mplot3d");
3: +      if (!mpl_toolkits || !axis3d) {throw std::runtime_error("couldnt create string");}
3: +
3: +      mpl_toolkitsmod = PyImport_Import(mpl_toolkits);
3: +      Py_DECREF(mpl_toolkits);
3: +      if (!mpl_toolkitsmod) {throw std::runtime_error("Error loading module mpl_toolkits!");}
3: +
3: +      axis3dmod = PyImport_Import(axis3d);
3: +      Py_DECREF(axis3d);
3: +      if (!axis3dmod) {throw std::runtime_error("Error loading module mpl_toolkits.mplot3d!");}
3: +    }
3: +
3: @@ -685,6 +616,5 @@
3: -
3: -    detail::_interpreter::get();
3: -
3: -    // using numpy arrays
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: +    assert(y.size() == z.size());
3: +
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +    PyObject * zarray = detail::get_array(z);
3: @@ -693 +623 @@
3: -    PyObject* args = PyTuple_New(2);
3: +    PyObject * args = PyTuple_New(3);
3: @@ -695,0 +626,64 @@
3: +    PyTuple_SetItem(args, 2, zarray);
3: +
3: +    // Build up the kw args.
3: +    PyObject * kwargs = PyDict_New();
3: +
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(
3: +        kwargs, it->first.c_str(),
3: +        PyString_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * fig =
3: +      PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_figure,
3: +      detail::_interpreter::get().s_python_empty_tuple);
3: +    if (!fig) {throw std::runtime_error("Call to figure() failed.");}
3: +
3: +    PyObject * gca_kwargs = PyDict_New();
3: +    PyDict_SetItemString(gca_kwargs, "projection", PyString_FromString("3d"));
3: +
3: +    PyObject * gca = PyObject_GetAttrString(fig, "gca");
3: +    if (!gca) {throw std::runtime_error("No gca");}
3: +    Py_INCREF(gca);
3: +    PyObject * axis = PyObject_Call(
3: +      gca, detail::_interpreter::get().s_python_empty_tuple, gca_kwargs);
3: +
3: +    if (!axis) {throw std::runtime_error("No axis");}
3: +    Py_INCREF(axis);
3: +
3: +    Py_DECREF(gca);
3: +    Py_DECREF(gca_kwargs);
3: +
3: +    PyObject * plot3 = PyObject_GetAttrString(axis, "plot");
3: +    if (!plot3) {throw std::runtime_error("No 3D line plot");}
3: +    Py_INCREF(plot3);
3: +    PyObject * res = PyObject_Call(plot3, args, kwargs);
3: +    if (!res) {throw std::runtime_error("Failed 3D line plot");}
3: +    Py_DECREF(plot3);
3: +
3: +    Py_DECREF(axis);
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +    if (res) {Py_DECREF(res);}
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool stem(
3: +    const std::vector < Numeric > & x, const std::vector < Numeric > & y,
3: +    const std::map < std::string, std::string > & keywords)
3: +  {
3: +    assert(x.size() == y.size());
3: +
3: +    detail::_interpreter::get();
3: +
3: +    // using numpy arrays
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    // construct positional args
3: +    PyObject * args = PyTuple_New(2);
3: +    PyTuple_SetItem(args, 0, xarray);
3: +    PyTuple_SetItem(args, 1, yarray);
3: @@ -698 +692,41 @@
3: -    PyObject* kwargs = PyDict_New();
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, std::string > ::const_iterator it =
3: +      keywords.begin(); it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(
3: +        kwargs, it->first.c_str(),
3: +        PyString_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_stem, args, kwargs);
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +    if (res) {
3: +      Py_DECREF(res);
3: +    }
3: +
3: +    return res;
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool fill(
3: +    const std::vector < Numeric > & x, const std::vector < Numeric > & y,
3: +    const std::map < std::string, std::string > & keywords)
3: +  {
3: +    assert(x.size() == y.size());
3: +
3: +    detail::_interpreter::get();
3: +
3: +    // using numpy arrays
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    // construct positional args
3: +    PyObject * args = PyTuple_New(2);
3: +    PyTuple_SetItem(args, 0, xarray);
3: +    PyTuple_SetItem(args, 1, yarray);
3: +
3: +    // construct keyword args
3: +    PyObject * kwargs = PyDict_New();
3: @@ -700,9 +734,10 @@
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_fill, args, kwargs);
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -
3: -    if (res) Py_DECREF(res);
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res =
3: +      PyObject_Call(detail::_interpreter::get().s_python_function_fill, args, kwargs);
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +
3: +    if (res) {Py_DECREF(res);}
3: @@ -711,5 +746,8 @@
3: -}
3: -
3: -template< typename Numeric >
3: -bool fill_between(const std::vector<Numeric>& x, const std::vector<Numeric>& y1, const std::vector<Numeric>& y2, const std::map<std::string, std::string>& keywords)
3: -{
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool fill_between(
3: +    const std::vector < Numeric > & x, const std::vector < Numeric > & y1,
3: +    const std::vector < Numeric > & y2, const std::map < std::string,
3: +    std::string > & keywords)
3: +  {
3: @@ -722,3 +760,3 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* y1array = detail::get_array(y1);
3: -    PyObject* y2array = detail::get_array(y2);
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * y1array = detail::get_array(y1);
3: +    PyObject * y2array = detail::get_array(y2);
3: @@ -727 +765 @@
3: -    PyObject* args = PyTuple_New(3);
3: +    PyObject * args = PyTuple_New(3);
3: @@ -733,10 +771,13 @@
3: -    PyObject* kwargs = PyDict_New();
3: -    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it) {
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_fill_between, args, kwargs);
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -    if(res) Py_DECREF(res);
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_fill_between, args, kwargs);
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +    if (res) {Py_DECREF(res);}
3: @@ -745,11 +786,13 @@
3: -}
3: -
3: -template <typename Numeric>
3: -bool arrow(Numeric x, Numeric y, Numeric end_x, Numeric end_y, const std::string& fc = "r",
3: -           const std::string ec = "k", Numeric head_length = 0.25, Numeric head_width = 0.1625) {
3: -    PyObject* obj_x = PyFloat_FromDouble(x);
3: -    PyObject* obj_y = PyFloat_FromDouble(y);
3: -    PyObject* obj_end_x = PyFloat_FromDouble(end_x);
3: -    PyObject* obj_end_y = PyFloat_FromDouble(end_y);
3: -
3: -    PyObject* kwargs = PyDict_New();
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool arrow(
3: +    Numeric x, Numeric y, Numeric end_x, Numeric end_y, const std::string & fc = "r",
3: +    const std::string ec = "k", Numeric head_length = 0.25, Numeric head_width = 0.1625)
3: +  {
3: +    PyObject * obj_x = PyFloat_FromDouble(x);
3: +    PyObject * obj_y = PyFloat_FromDouble(y);
3: +    PyObject * obj_end_x = PyFloat_FromDouble(end_x);
3: +    PyObject * obj_end_y = PyFloat_FromDouble(end_y);
3: +
3: +    PyObject * kwargs = PyDict_New();
3: @@ -761 +804 @@
3: -    PyObject* plot_args = PyTuple_New(4);
3: +    PyObject * plot_args = PyTuple_New(4);
3: @@ -767,2 +810,2 @@
3: -    PyObject* res =
3: -            PyObject_Call(detail::_interpreter::get().s_python_function_arrow, plot_args, kwargs);
3: +    PyObject * res =
3: +      PyObject_Call(detail::_interpreter::get().s_python_function_arrow, plot_args, kwargs);
3: @@ -772,2 +815,3 @@
3: -    if (res)
3: -        Py_DECREF(res);
3: +    if (res) {
3: +      Py_DECREF(res);
3: +    }
3: @@ -776,11 +820,12 @@
3: -}
3: -
3: -template< typename Numeric>
3: -bool hist(const std::vector<Numeric>& y, long bins=10,std::string color="b",
3: -          double alpha=1.0, bool cumulative=false)
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* yarray = detail::get_array(y);
3: -
3: -    PyObject* kwargs = PyDict_New();
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool hist(
3: +    const std::vector < Numeric > & y, long bins = 10, std::string color = "b",
3: +    double alpha = 1.0, bool cumulative = false)
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * kwargs = PyDict_New();
3: @@ -792 +837 @@
3: -    PyObject* plot_args = PyTuple_New(1);
3: +    PyObject * plot_args = PyTuple_New(1);
3: @@ -797 +842,2 @@
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_hist, plot_args, kwargs);
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_hist, plot_args, kwargs);
3: @@ -802 +848 @@
3: -    if(res) Py_DECREF(res);
3: +    if (res) {Py_DECREF(res);}
3: @@ -805 +851 @@
3: -}
3: +  }
3: @@ -808,18 +854,22 @@
3: -namespace detail {
3: -
3: -inline void imshow(void *ptr, const NPY_TYPES type, const int rows, const int columns, const int colors, const std::map<std::string, std::string> &keywords, PyObject** out)
3: -{
3: -    assert(type == NPY_UINT8 || type == NPY_FLOAT);
3: -    assert(colors == 1 || colors == 3 || colors == 4);
3: -
3: -    detail::_interpreter::get();
3: -
3: -    // construct args
3: -    npy_intp dims[3] = { rows, columns, colors };
3: -    PyObject *args = PyTuple_New(1);
3: -    PyTuple_SetItem(args, 0, PyArray_SimpleNewFromData(colors == 1 ? 2 : 3, dims, type, ptr));
3: -
3: -    // construct keyword args
3: -    PyObject* kwargs = PyDict_New();
3: -    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
3: -    {
3: +  namespace detail {
3: +
3: +    inline void imshow(
3: +      void * ptr, const NPY_TYPES type, const int rows, const int columns,
3: +      const int colors, const std::map < std::string, std::string > & keywords,
3: +      PyObject ** out)
3: +    {
3: +      assert(type == NPY_UINT8 || type == NPY_FLOAT);
3: +      assert(colors == 1 || colors == 3 || colors == 4);
3: +
3: +      detail::_interpreter::get();
3: +
3: +      // construct args
3: +      npy_intp dims[3] = {rows, columns, colors};
3: +      PyObject * args = PyTuple_New(1);
3: +      PyTuple_SetItem(args, 0, PyArray_SimpleNewFromData(colors == 1 ? 2 : 3, dims, type, ptr));
3: +
3: +      // construct keyword args
3: +      PyObject * kwargs = PyDict_New();
3: +      for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +        it != keywords.end(); ++it)
3: +      {
3: @@ -827,6 +877,7 @@
3: -    }
3: -
3: -    PyObject *res = PyObject_Call(detail::_interpreter::get().s_python_function_imshow, args, kwargs);
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -    if (!res)
3: +      }
3: +
3: +      PyObject * res = PyObject_Call(
3: +        detail::_interpreter::get().s_python_function_imshow, args, kwargs);
3: +      Py_DECREF(args);
3: +      Py_DECREF(kwargs);
3: +      if (!res) {
3: @@ -834 +885,2 @@
3: -    if (out)
3: +      }
3: +      if (out) {
3: @@ -836 +888 @@
3: -    else
3: +      } else {
3: @@ -838,6 +890,10 @@
3: -}
3: -
3: -} // namespace detail
3: -
3: -inline void imshow(const unsigned char *ptr, const int rows, const int columns, const int colors, const std::map<std::string, std::string> &keywords = {}, PyObject** out = nullptr)
3: -{
3: +      }
3: +    }
3: +
3: +  } // namespace detail
3: +
3: +  inline void imshow(
3: +    const unsigned char * ptr, const int rows, const int columns, const int colors,
3: +    const std::map < std::string, std::string > & keywords = {},
3: +    PyObject ** out = nullptr)
3: +  {
3: @@ -845,4 +901,7 @@
3: -}
3: -
3: -inline void imshow(const float *ptr, const int rows, const int columns, const int colors, const std::map<std::string, std::string> &keywords = {}, PyObject** out = nullptr)
3: -{
3: +  }
3: +
3: +  inline void imshow(
3: +    const float * ptr, const int rows, const int columns, const int colors,
3: +    const std::map < std::string, std::string > & keywords = {},
3: +    PyObject ** out = nullptr)
3: +  {
3: @@ -850 +909 @@
3: -}
3: +  }
3: @@ -853,2 +912,2 @@
3: -void imshow(const cv::Mat &image, const std::map<std::string, std::string> &keywords = {})
3: -{
3: +  void imshow(const cv::Mat & image, const std::map < std::string, std::string > & keywords = {})
3: +  {
3: @@ -859 +918 @@
3: -    case CV_8U:
3: +      case CV_8U:
3: @@ -862 +921 @@
3: -    case CV_32F:
3: +      case CV_32F:
3: @@ -866 +925 @@
3: -    default:
3: +      default:
3: @@ -872 +931 @@
3: -    case 3:
3: +      case 3:
3: @@ -875 +934 @@
3: -    case 4:
3: +      case 4:
3: @@ -880 +939 @@
3: -}
3: +  }
3: @@ -884,6 +943,7 @@
3: -template<typename NumericX, typename NumericY>
3: -bool scatter(const std::vector<NumericX>& x,
3: -             const std::vector<NumericY>& y,
3: -             const double s=1.0, // The marker size in points**2
3: -             const std::map<std::string, std::string> & keywords = {})
3: -{
3: +  template < typename NumericX, typename NumericY >
3: +  bool scatter(
3: +    const std::vector < NumericX > & x,
3: +    const std::vector < NumericY > & y,
3: +    const double s = 1.0,        // The marker size in points**2
3: +    const std::map < std::string, std::string > & keywords = {})
3: +  {
3: @@ -894,4 +954,4 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: -
3: -    PyObject* kwargs = PyDict_New();
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * kwargs = PyDict_New();
3: @@ -899,6 +959,5 @@
3: -    for (const auto& it : keywords)
3: -    {
3: -        PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));
3: -    }
3: -
3: -    PyObject* plot_args = PyTuple_New(2);
3: +    for (const auto & it : keywords) {
3: +      PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));
3: +    }
3: +
3: +    PyObject * plot_args = PyTuple_New(2);
3: @@ -908 +967,2 @@
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_scatter, plot_args, kwargs);
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_scatter, plot_args, kwargs);
3: @@ -912 +972 @@
3: -    if(res) Py_DECREF(res);
3: +    if (res) {Py_DECREF(res);}
3: @@ -915,11 +975,12 @@
3: -}
3: -
3: -template<typename Numeric>
3: -bool boxplot(const std::vector<std::vector<Numeric>>& data,
3: -             const std::vector<std::string>& labels = {},
3: -             const std::map<std::string, std::string> & keywords = {})
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* listlist = detail::get_listlist(data);
3: -    PyObject* args = PyTuple_New(1);
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool boxplot(
3: +    const std::vector < std::vector < Numeric >> & data,
3: +    const std::vector < std::string > & labels = {},
3: +    const std::map < std::string, std::string > & keywords = {})
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * listlist = detail::get_listlist(data);
3: +    PyObject * args = PyTuple_New(1);
3: @@ -928 +989 @@
3: -    PyObject* kwargs = PyDict_New();
3: +    PyObject * kwargs = PyDict_New();
3: @@ -932 +993 @@
3: -        PyDict_SetItemString(kwargs, "labels", detail::get_array(labels));
3: +      PyDict_SetItemString(kwargs, "labels", detail::get_array(labels));
3: @@ -936,11 +997,11 @@
3: -    for (const auto& it : keywords)
3: -    {
3: -        PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_boxplot, args, kwargs);
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -
3: -    if(res) Py_DECREF(res);
3: +    for (const auto & it : keywords) {
3: +      PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_boxplot, args, kwargs);
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +
3: +    if (res) {Py_DECREF(res);}
3: @@ -949,10 +1010,11 @@
3: -}
3: -
3: -template<typename Numeric>
3: -bool boxplot(const std::vector<Numeric>& data,
3: -             const std::map<std::string, std::string> & keywords = {})
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* vector = detail::get_array(data);
3: -    PyObject* args = PyTuple_New(1);
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool boxplot(
3: +    const std::vector < Numeric > & data,
3: +    const std::map < std::string, std::string > & keywords = {})
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * vector = detail::get_array(data);
3: +    PyObject * args = PyTuple_New(1);
3: @@ -961,12 +1023,12 @@
3: -    PyObject* kwargs = PyDict_New();
3: -    for (const auto& it : keywords)
3: -    {
3: -        PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_boxplot, args, kwargs);
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -
3: -    if(res) Py_DECREF(res);
3: +    PyObject * kwargs = PyDict_New();
3: +    for (const auto & it : keywords) {
3: +      PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_boxplot, args, kwargs);
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +
3: +    if (res) {Py_DECREF(res);}
3: @@ -975,67 +1037,17 @@
3: -}
3: -
3: -template <typename Numeric>
3: -bool bar(const std::vector<Numeric> &               x,
3: -         const std::vector<Numeric> &               y,
3: -         std::string                                ec       = "black",
3: -         std::string                                ls       = "-",
3: -         double                                     lw       = 1.0,
3: -         const std::map<std::string, std::string> & keywords = {})
3: -{
3: -  detail::_interpreter::get();
3: -
3: -  PyObject * xarray = detail::get_array(x);
3: -  PyObject * yarray = detail::get_array(y);
3: -
3: -  PyObject * kwargs = PyDict_New();
3: -
3: -  PyDict_SetItemString(kwargs, "ec", PyString_FromString(ec.c_str()));
3: -  PyDict_SetItemString(kwargs, "ls", PyString_FromString(ls.c_str()));
3: -  PyDict_SetItemString(kwargs, "lw", PyFloat_FromDouble(lw));
3: -
3: -  for (std::map<std::string, std::string>::const_iterator it =
3: -         keywords.begin();
3: -       it != keywords.end();
3: -       ++it) {
3: -    PyDict_SetItemString(
3: -      kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: -  }
3: -
3: -  PyObject * plot_args = PyTuple_New(2);
3: -  PyTuple_SetItem(plot_args, 0, xarray);
3: -  PyTuple_SetItem(plot_args, 1, yarray);
3: -
3: -  PyObject * res = PyObject_Call(
3: -    detail::_interpreter::get().s_python_function_bar, plot_args, kwargs);
3: -
3: -  Py_DECREF(plot_args);
3: -  Py_DECREF(kwargs);
3: -  if (res) Py_DECREF(res);
3: -
3: -  return res;
3: -}
3: -
3: -template <typename Numeric>
3: -bool bar(const std::vector<Numeric> &               y,
3: -         std::string                                ec       = "black",
3: -         std::string                                ls       = "-",
3: -         double                                     lw       = 1.0,
3: -         const std::map<std::string, std::string> & keywords = {})
3: -{
3: -  using T = typename std::remove_reference<decltype(y)>::type::value_type;
3: -
3: -  detail::_interpreter::get();
3: -
3: -  std::vector<T> x;
3: -  for (std::size_t i = 0; i < y.size(); i++) { x.push_back(i); }
3: -
3: -  return bar(x, y, ec, ls, lw, keywords);
3: -}
3: -
3: -
3: -template<typename Numeric>
3: -bool barh(const std::vector<Numeric> &x, const std::vector<Numeric> &y, std::string ec = "black", std::string ls = "-", double lw = 1.0, const std::map<std::string, std::string> &keywords = { }) {
3: -    PyObject *xarray = detail::get_array(x);
3: -    PyObject *yarray = detail::get_array(y);
3: -
3: -    PyObject *kwargs = PyDict_New();
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool bar(
3: +    const std::vector < Numeric > & x,
3: +    const std::vector < Numeric > & y,
3: +    std::string ec = "black",
3: +    std::string ls = "-",
3: +    double lw = 1.0,
3: +    const std::map < std::string, std::string > & keywords = {})
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * kwargs = PyDict_New();
3: @@ -1047,5 +1059,10 @@
3: -    for (std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it) {
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject *plot_args = PyTuple_New(2);
3: +    for (std::map < std::string, std::string > ::const_iterator it =
3: +      keywords.begin();
3: +      it != keywords.end();
3: +      ++it)
3: +    {
3: +      PyDict_SetItemString(
3: +        kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * plot_args = PyTuple_New(2);
3: @@ -1055 +1072,2 @@
3: -    PyObject *res = PyObject_Call(detail::_interpreter::get().s_python_function_barh, plot_args, kwargs);
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_bar, plot_args, kwargs);
3: @@ -1059 +1077 @@
3: -    if (res) Py_DECREF(res);
3: +    if (res) {Py_DECREF(res);}
3: @@ -1062,18 +1080,50 @@
3: -}
3: -
3: -
3: -inline bool subplots_adjust(const std::map<std::string, double>& keywords = {})
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* kwargs = PyDict_New();
3: -    for (std::map<std::string, double>::const_iterator it =
3: -            keywords.begin(); it != keywords.end(); ++it) {
3: -        PyDict_SetItemString(kwargs, it->first.c_str(),
3: -                             PyFloat_FromDouble(it->second));
3: -    }
3: -
3: -
3: -    PyObject* plot_args = PyTuple_New(0);
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_subplots_adjust, plot_args, kwargs);
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool bar(
3: +    const std::vector < Numeric > & y,
3: +    std::string ec = "black",
3: +    std::string ls = "-",
3: +    double lw = 1.0,
3: +    const std::map < std::string, std::string > & keywords = {})
3: +  {
3: +    using T = typename std::remove_reference < decltype(y) > ::type::value_type;
3: +
3: +    detail::_interpreter::get();
3: +
3: +    std::vector < T > x;
3: +    for (std::size_t i = 0; i < y.size(); i++) {
3: +      x.push_back(i);
3: +    }
3: +
3: +    return bar(x, y, ec, ls, lw, keywords);
3: +  }
3: +
3: +
3: +  template < typename Numeric >
3: +  bool barh(
3: +    const std::vector < Numeric > & x, const std::vector < Numeric > & y,
3: +    std::string ec = "black", std::string ls = "-", double lw = 1.0,
3: +    const std::map < std::string, std::string > & keywords = {})
3: +  {
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * kwargs = PyDict_New();
3: +
3: +    PyDict_SetItemString(kwargs, "ec", PyString_FromString(ec.c_str()));
3: +    PyDict_SetItemString(kwargs, "ls", PyString_FromString(ls.c_str()));
3: +    PyDict_SetItemString(kwargs, "lw", PyFloat_FromDouble(lw));
3: +
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * plot_args = PyTuple_New(2);
3: +    PyTuple_SetItem(plot_args, 0, xarray);
3: +    PyTuple_SetItem(plot_args, 1, yarray);
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_barh, plot_args, kwargs);
3: @@ -1083 +1133 @@
3: -    if(res) Py_DECREF(res);
3: +    if (res) {Py_DECREF(res);}
3: @@ -1086,10 +1136,39 @@
3: -}
3: -
3: -template< typename Numeric>
3: -bool named_hist(std::string label,const std::vector<Numeric>& y, long bins=10, std::string color="b", double alpha=1.0)
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* yarray = detail::get_array(y);
3: -
3: -    PyObject* kwargs = PyDict_New();
3: +  }
3: +
3: +
3: +  inline bool subplots_adjust(const std::map < std::string, double > & keywords = {})
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, double > ::const_iterator it =
3: +      keywords.begin(); it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(
3: +        kwargs, it->first.c_str(),
3: +        PyFloat_FromDouble(it->second));
3: +    }
3: +
3: +
3: +    PyObject * plot_args = PyTuple_New(0);
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_subplots_adjust, plot_args, kwargs);
3: +
3: +    Py_DECREF(plot_args);
3: +    Py_DECREF(kwargs);
3: +    if (res) {Py_DECREF(res);}
3: +
3: +    return res;
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool named_hist(
3: +    std::string label, const std::vector < Numeric > & y, long bins = 10,
3: +    std::string color = "b", double alpha = 1.0)
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * kwargs = PyDict_New();
3: @@ -1102 +1181 @@
3: -    PyObject* plot_args = PyTuple_New(1);
3: +    PyObject * plot_args = PyTuple_New(1);
3: @@ -1105 +1184,2 @@
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_hist, plot_args, kwargs);
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_hist, plot_args, kwargs);
3: @@ -1109 +1189 @@
3: -    if(res) Py_DECREF(res);
3: +    if (res) {Py_DECREF(res);}
3: @@ -1112,5 +1192,7 @@
3: -}
3: -
3: -template<typename NumericX, typename NumericY>
3: -bool plot(const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::string& s = "")
3: -{
3: +  }
3: +
3: +  template < typename NumericX, typename NumericY >
3: +  bool plot(
3: +    const std::vector < NumericX > & x, const std::vector < NumericY > & y,
3: +    const std::string & s = "")
3: +  {
3: @@ -1121,6 +1203,6 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: -
3: -    PyObject* pystring = PyString_FromString(s.c_str());
3: -
3: -    PyObject* plot_args = PyTuple_New(3);
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * pystring = PyString_FromString(s.c_str());
3: +
3: +    PyObject * plot_args = PyTuple_New(3);
3: @@ -1131 +1213,2 @@
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_plot, plot_args);
3: +    PyObject * res = PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_plot, plot_args);
3: @@ -1134 +1217 @@
3: -    if(res) Py_DECREF(res);
3: +    if (res) {Py_DECREF(res);}
3: @@ -1137,6 +1220,8 @@
3: -}
3: -
3: -template <typename NumericX, typename NumericY, typename NumericZ>
3: -bool contour(const std::vector<NumericX>& x, const std::vector<NumericY>& y,
3: -             const std::vector<NumericZ>& z,
3: -             const std::map<std::string, std::string>& keywords = {}) {
3: +  }
3: +
3: +  template < typename NumericX, typename NumericY, typename NumericZ >
3: +  bool contour(
3: +    const std::vector < NumericX > & x, const std::vector < NumericY > & y,
3: +    const std::vector < NumericZ > & z,
3: +    const std::map < std::string, std::string > & keywords = {})
3: +  {
3: @@ -1145,5 +1230,5 @@
3: -    PyObject* xarray = get_array(x);
3: -    PyObject* yarray = get_array(y);
3: -    PyObject* zarray = get_array(z);
3: -
3: -    PyObject* plot_args = PyTuple_New(3);
3: +    PyObject * xarray = get_array(x);
3: +    PyObject * yarray = get_array(y);
3: +    PyObject * zarray = get_array(z);
3: +
3: +    PyObject * plot_args = PyTuple_New(3);
3: @@ -1155,8 +1240,9 @@
3: -    PyObject* kwargs = PyDict_New();
3: -    for (std::map<std::string, std::string>::const_iterator it = keywords.begin();
3: -         it != keywords.end(); ++it) {
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res =
3: -            PyObject_Call(detail::_interpreter::get().s_python_function_contour, plot_args, kwargs);
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res =
3: +      PyObject_Call(detail::_interpreter::get().s_python_function_contour, plot_args, kwargs);
3: @@ -1166,2 +1252,3 @@
3: -    if (res)
3: -        Py_DECREF(res);
3: +    if (res) {
3: +      Py_DECREF(res);
3: +    }
3: @@ -1170,5 +1257,8 @@
3: -}
3: -
3: -template<typename NumericX, typename NumericY, typename NumericU, typename NumericW>
3: -bool quiver(const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::vector<NumericU>& u, const std::vector<NumericW>& w, const std::map<std::string, std::string>& keywords = {})
3: -{
3: +  }
3: +
3: +  template < typename NumericX, typename NumericY, typename NumericU, typename NumericW >
3: +  bool quiver(
3: +    const std::vector < NumericX > & x, const std::vector < NumericY > & y,
3: +    const std::vector < NumericU > & u, const std::vector < NumericW > & w,
3: +    const std::map < std::string, std::string > & keywords = {})
3: +  {
3: @@ -1179,6 +1269,6 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: -    PyObject* uarray = detail::get_array(u);
3: -    PyObject* warray = detail::get_array(w);
3: -
3: -    PyObject* plot_args = PyTuple_New(4);
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +    PyObject * uarray = detail::get_array(u);
3: +    PyObject * warray = detail::get_array(w);
3: +
3: +    PyObject * plot_args = PyTuple_New(4);
3: @@ -1191,8 +1281,9 @@
3: -    PyObject* kwargs = PyDict_New();
3: -    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
3: -    {
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(
3: -            detail::_interpreter::get().s_python_function_quiver, plot_args, kwargs);
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_quiver, plot_args, kwargs);
3: @@ -1202,2 +1293,3 @@
3: -    if (res)
3: -        Py_DECREF(res);
3: +    if (res) {
3: +      Py_DECREF(res);
3: +    }
3: @@ -1206,5 +1298,7 @@
3: -}
3: -
3: -template<typename NumericX, typename NumericY>
3: -bool stem(const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::string& s = "")
3: -{
3: +  }
3: +
3: +  template < typename NumericX, typename NumericY >
3: +  bool stem(
3: +    const std::vector < NumericX > & x, const std::vector < NumericY > & y,
3: +    const std::string & s = "")
3: +  {
3: @@ -1215,6 +1309,6 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: -
3: -    PyObject* pystring = PyString_FromString(s.c_str());
3: -
3: -    PyObject* plot_args = PyTuple_New(3);
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * pystring = PyString_FromString(s.c_str());
3: +
3: +    PyObject * plot_args = PyTuple_New(3);
3: @@ -1225,2 +1319,2 @@
3: -    PyObject* res = PyObject_CallObject(
3: -            detail::_interpreter::get().s_python_function_stem, plot_args);
3: +    PyObject * res = PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_stem, plot_args);
3: @@ -1229,2 +1323,3 @@
3: -    if (res)
3: -        Py_DECREF(res);
3: +    if (res) {
3: +      Py_DECREF(res);
3: +    }
3: @@ -1233,5 +1328,7 @@
3: -}
3: -
3: -template<typename NumericX, typename NumericY>
3: -bool semilogx(const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::string& s = "")
3: -{
3: +  }
3: +
3: +  template < typename NumericX, typename NumericY >
3: +  bool semilogx(
3: +    const std::vector < NumericX > & x, const std::vector < NumericY > & y,
3: +    const std::string & s = "")
3: +  {
3: @@ -1242,6 +1339,6 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: -
3: -    PyObject* pystring = PyString_FromString(s.c_str());
3: -
3: -    PyObject* plot_args = PyTuple_New(3);
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * pystring = PyString_FromString(s.c_str());
3: +
3: +    PyObject * plot_args = PyTuple_New(3);
3: @@ -1252 +1349,2 @@
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_semilogx, plot_args);
3: +    PyObject * res = PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_semilogx, plot_args);
3: @@ -1255 +1353 @@
3: -    if(res) Py_DECREF(res);
3: +    if (res) {Py_DECREF(res);}
3: @@ -1258,5 +1356,7 @@
3: -}
3: -
3: -template<typename NumericX, typename NumericY>
3: -bool semilogy(const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::string& s = "")
3: -{
3: +  }
3: +
3: +  template < typename NumericX, typename NumericY >
3: +  bool semilogy(
3: +    const std::vector < NumericX > & x, const std::vector < NumericY > & y,
3: +    const std::string & s = "")
3: +  {
3: @@ -1267,6 +1367,6 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: -
3: -    PyObject* pystring = PyString_FromString(s.c_str());
3: -
3: -    PyObject* plot_args = PyTuple_New(3);
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * pystring = PyString_FromString(s.c_str());
3: +
3: +    PyObject * plot_args = PyTuple_New(3);
3: @@ -1277 +1377,2 @@
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_semilogy, plot_args);
3: +    PyObject * res = PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_semilogy, plot_args);
3: @@ -1280 +1381 @@
3: -    if(res) Py_DECREF(res);
3: +    if (res) {Py_DECREF(res);}
3: @@ -1283,5 +1384,7 @@
3: -}
3: -
3: -template<typename NumericX, typename NumericY>
3: -bool loglog(const std::vector<NumericX>& x, const std::vector<NumericY>& y, const std::string& s = "")
3: -{
3: +  }
3: +
3: +  template < typename NumericX, typename NumericY >
3: +  bool loglog(
3: +    const std::vector < NumericX > & x, const std::vector < NumericY > & y,
3: +    const std::string & s = "")
3: +  {
3: @@ -1292,6 +1395,6 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: -
3: -    PyObject* pystring = PyString_FromString(s.c_str());
3: -
3: -    PyObject* plot_args = PyTuple_New(3);
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * pystring = PyString_FromString(s.c_str());
3: +
3: +    PyObject * plot_args = PyTuple_New(3);
3: @@ -1302 +1405,2 @@
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_loglog, plot_args);
3: +    PyObject * res = PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_loglog, plot_args);
3: @@ -1305 +1409 @@
3: -    if(res) Py_DECREF(res);
3: +    if (res) {Py_DECREF(res);}
3: @@ -1308,5 +1412,8 @@
3: -}
3: -
3: -template<typename NumericX, typename NumericY>
3: -bool errorbar(const std::vector<NumericX> &x, const std::vector<NumericY> &y, const std::vector<NumericX> &yerr, const std::map<std::string, std::string> &keywords = {})
3: -{
3: +  }
3: +
3: +  template < typename NumericX, typename NumericY >
3: +  bool errorbar(
3: +    const std::vector < NumericX > & x, const std::vector < NumericY > & y,
3: +    const std::vector < NumericX > & yerr, const std::map < std::string,
3: +    std::string > & keywords = {})
3: +  {
3: @@ -1317,3 +1424,3 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: -    PyObject* yerrarray = detail::get_array(yerr);
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +    PyObject * yerrarray = detail::get_array(yerr);
3: @@ -1322,4 +1429,5 @@
3: -    PyObject* kwargs = PyDict_New();
3: -    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
3: -    {
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: @@ -1330 +1438 @@
3: -    PyObject *plot_args = PyTuple_New(2);
3: +    PyObject * plot_args = PyTuple_New(2);
3: @@ -1334 +1442,2 @@
3: -    PyObject *res = PyObject_Call(detail::_interpreter::get().s_python_function_errorbar, plot_args, kwargs);
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_errorbar, plot_args, kwargs);
3: @@ -1339,4 +1448,5 @@
3: -    if (res)
3: -        Py_DECREF(res);
3: -    else
3: -        throw std::runtime_error("Call to errorbar() failed.");
3: +    if (res) {
3: +      Py_DECREF(res);
3: +    } else {
3: +      throw std::runtime_error("Call to errorbar() failed.");
3: +    }
3: @@ -1345,8 +1455,10 @@
3: -}
3: -
3: -template<typename Numeric>
3: -bool named_plot(const std::string& name, const std::vector<Numeric>& y, const std::string& format = "")
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* kwargs = PyDict_New();
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool named_plot(
3: +    const std::string & name, const std::vector < Numeric > & y,
3: +    const std::string & format = "")
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * kwargs = PyDict_New();
3: @@ -1355,5 +1467,5 @@
3: -    PyObject* yarray = detail::get_array(y);
3: -
3: -    PyObject* pystring = PyString_FromString(format.c_str());
3: -
3: -    PyObject* plot_args = PyTuple_New(2);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * pystring = PyString_FromString(format.c_str());
3: +
3: +    PyObject * plot_args = PyTuple_New(2);
3: @@ -1364 +1476,2 @@
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);
3: @@ -1368 +1481 @@
3: -    if (res) Py_DECREF(res);
3: +    if (res) {Py_DECREF(res);}
3: @@ -1371,8 +1484,10 @@
3: -}
3: -
3: -template<typename Numeric>
3: -bool named_plot(const std::string& name, const std::vector<Numeric>& x, const std::vector<Numeric>& y, const std::string& format = "")
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* kwargs = PyDict_New();
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool named_plot(
3: +    const std::string & name, const std::vector < Numeric > & x,
3: +    const std::vector < Numeric > & y, const std::string & format = "")
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * kwargs = PyDict_New();
3: @@ -1381,6 +1496,6 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: -
3: -    PyObject* pystring = PyString_FromString(format.c_str());
3: -
3: -    PyObject* plot_args = PyTuple_New(3);
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * pystring = PyString_FromString(format.c_str());
3: +
3: +    PyObject * plot_args = PyTuple_New(3);
3: @@ -1391 +1506,2 @@
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);
3: @@ -1395 +1511 @@
3: -    if (res) Py_DECREF(res);
3: +    if (res) {Py_DECREF(res);}
3: @@ -1398,8 +1514,10 @@
3: -}
3: -
3: -template<typename Numeric>
3: -bool named_semilogx(const std::string& name, const std::vector<Numeric>& x, const std::vector<Numeric>& y, const std::string& format = "")
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* kwargs = PyDict_New();
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool named_semilogx(
3: +    const std::string & name, const std::vector < Numeric > & x,
3: +    const std::vector < Numeric > & y, const std::string & format = "")
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * kwargs = PyDict_New();
3: @@ -1408,6 +1526,6 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: -
3: -    PyObject* pystring = PyString_FromString(format.c_str());
3: -
3: -    PyObject* plot_args = PyTuple_New(3);
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * pystring = PyString_FromString(format.c_str());
3: +
3: +    PyObject * plot_args = PyTuple_New(3);
3: @@ -1418 +1536,2 @@
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_semilogx, plot_args, kwargs);
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_semilogx, plot_args, kwargs);
3: @@ -1422 +1541 @@
3: -    if (res) Py_DECREF(res);
3: +    if (res) {Py_DECREF(res);}
3: @@ -1425,8 +1544,10 @@
3: -}
3: -
3: -template<typename Numeric>
3: -bool named_semilogy(const std::string& name, const std::vector<Numeric>& x, const std::vector<Numeric>& y, const std::string& format = "")
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* kwargs = PyDict_New();
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool named_semilogy(
3: +    const std::string & name, const std::vector < Numeric > & x,
3: +    const std::vector < Numeric > & y, const std::string & format = "")
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * kwargs = PyDict_New();
3: @@ -1435,6 +1556,6 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: -
3: -    PyObject* pystring = PyString_FromString(format.c_str());
3: -
3: -    PyObject* plot_args = PyTuple_New(3);
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * pystring = PyString_FromString(format.c_str());
3: +
3: +    PyObject * plot_args = PyTuple_New(3);
3: @@ -1445 +1566,2 @@
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_semilogy, plot_args, kwargs);
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_semilogy, plot_args, kwargs);
3: @@ -1449 +1571 @@
3: -    if (res) Py_DECREF(res);
3: +    if (res) {Py_DECREF(res);}
3: @@ -1452,8 +1574,10 @@
3: -}
3: -
3: -template<typename Numeric>
3: -bool named_loglog(const std::string& name, const std::vector<Numeric>& x, const std::vector<Numeric>& y, const std::string& format = "")
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* kwargs = PyDict_New();
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool named_loglog(
3: +    const std::string & name, const std::vector < Numeric > & x,
3: +    const std::vector < Numeric > & y, const std::string & format = "")
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * kwargs = PyDict_New();
3: @@ -1462,6 +1586,6 @@
3: -    PyObject* xarray = detail::get_array(x);
3: -    PyObject* yarray = detail::get_array(y);
3: -
3: -    PyObject* pystring = PyString_FromString(format.c_str());
3: -
3: -    PyObject* plot_args = PyTuple_New(3);
3: +    PyObject * xarray = detail::get_array(x);
3: +    PyObject * yarray = detail::get_array(y);
3: +
3: +    PyObject * pystring = PyString_FromString(format.c_str());
3: +
3: +    PyObject * plot_args = PyTuple_New(3);
3: @@ -1471 +1595,2 @@
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_loglog, plot_args, kwargs);
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_loglog, plot_args, kwargs);
3: @@ -1475 +1600 @@
3: -    if (res) Py_DECREF(res);
3: +    if (res) {Py_DECREF(res);}
3: @@ -1478,23 +1603,31 @@
3: -}
3: -
3: -template<typename Numeric>
3: -bool plot(const std::vector<Numeric>& y, const std::string& format = "")
3: -{
3: -    std::vector<Numeric> x(y.size());
3: -    for(size_t i=0; i<x.size(); ++i) x.at(i) = i;
3: -    return plot(x,y,format);
3: -}
3: -
3: -template<typename Numeric>
3: -bool plot(const std::vector<Numeric>& y, const std::map<std::string, std::string>& keywords)
3: -{
3: -    std::vector<Numeric> x(y.size());
3: -    for(size_t i=0; i<x.size(); ++i) x.at(i) = i;
3: -    return plot(x,y,keywords);
3: -}
3: -
3: -template<typename Numeric>
3: -bool stem(const std::vector<Numeric>& y, const std::string& format = "")
3: -{
3: -    std::vector<Numeric> x(y.size());
3: -    for (size_t i = 0; i < x.size(); ++i) x.at(i) = i;
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool plot(const std::vector < Numeric > & y, const std::string & format = "")
3: +  {
3: +    std::vector < Numeric > x(y.size());
3: +    for (size_t i = 0; i < x.size(); ++i) {
3: +      x.at(i) = i;
3: +    }
3: +    return plot(x, y, format);
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool plot(
3: +    const std::vector < Numeric > & y, const std::map < std::string,
3: +    std::string > & keywords)
3: +  {
3: +    std::vector < Numeric > x(y.size());
3: +    for (size_t i = 0; i < x.size(); ++i) {
3: +      x.at(i) = i;
3: +    }
3: +    return plot(x, y, keywords);
3: +  }
3: +
3: +  template < typename Numeric >
3: +  bool stem(const std::vector < Numeric > & y, const std::string & format = "")
3: +  {
3: +    std::vector < Numeric > x(y.size());
3: +    for (size_t i = 0; i < x.size(); ++i) {
3: +      x.at(i) = i;
3: +    }
3: @@ -1502,8 +1635,8 @@
3: -}
3: -
3: -template<typename Numeric>
3: -void text(Numeric x, Numeric y, const std::string& s = "")
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* args = PyTuple_New(3);
3: +  }
3: +
3: +  template < typename Numeric >
3: +  void text(Numeric x, Numeric y, const std::string & s = "")
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * args = PyTuple_New(3);
3: @@ -1514,15 +1647,19 @@
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_text, args);
3: -    if(!res) throw std::runtime_error("Call to text() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void colorbar(PyObject* mappable = NULL, const std::map<std::string, float>& keywords = {})
3: -{
3: -    if (mappable == NULL)
3: -        throw std::runtime_error("Must call colorbar with PyObject* returned from an image, contour, surface, etc.");
3: -
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* args = PyTuple_New(1);
3: +    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_text, args);
3: +    if (!res) {throw std::runtime_error("Call to text() failed.");}
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void colorbar(
3: +    PyObject * mappable = NULL, const std::map < std::string,
3: +    float > & keywords = {})
3: +  {
3: +    if (mappable == NULL) {
3: +      throw std::runtime_error(
3: +        "Must call colorbar with PyObject* returned from an image, contour, surface, etc.");
3: +    }
3: +
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * args = PyTuple_New(1);
3: @@ -1531,38 +1668,42 @@
3: -    PyObject* kwargs = PyDict_New();
3: -    for(std::map<std::string, float>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
3: -    {
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyFloat_FromDouble(it->second));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_colorbar, args, kwargs);
3: -    if(!res) throw std::runtime_error("Call to colorbar() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -    Py_DECREF(res);
3: -}
3: -
3: -
3: -inline long figure(long number = -1)
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject *res;
3: -    if (number == -1)
3: -        res = PyObject_CallObject(detail::_interpreter::get().s_python_function_figure, detail::_interpreter::get().s_python_empty_tuple);
3: -    else {
3: -        assert(number > 0);
3: -
3: -        // Make sure interpreter is initialised
3: -        detail::_interpreter::get();
3: -
3: -        PyObject *args = PyTuple_New(1);
3: -        PyTuple_SetItem(args, 0, PyLong_FromLong(number));
3: -        res = PyObject_CallObject(detail::_interpreter::get().s_python_function_figure, args);
3: -        Py_DECREF(args);
3: -    }
3: -
3: -    if(!res) throw std::runtime_error("Call to figure() failed.");
3: -
3: -    PyObject* num = PyObject_GetAttrString(res, "number");
3: -    if (!num) throw std::runtime_error("Could not get number attribute of figure object");
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, float > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyFloat_FromDouble(it->second));
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_colorbar, args, kwargs);
3: +    if (!res) {throw std::runtime_error("Call to colorbar() failed.");}
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +
3: +  inline long figure(long number = -1)
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * res;
3: +    if (number == -1) {
3: +      res = PyObject_CallObject(
3: +        detail::_interpreter::get().s_python_function_figure,
3: +        detail::_interpreter::get().s_python_empty_tuple);
3: +    } else {
3: +      assert(number > 0);
3: +
3: +      // Make sure interpreter is initialised
3: +      detail::_interpreter::get();
3: +
3: +      PyObject * args = PyTuple_New(1);
3: +      PyTuple_SetItem(args, 0, PyLong_FromLong(number));
3: +      res = PyObject_CallObject(detail::_interpreter::get().s_python_function_figure, args);
3: +      Py_DECREF(args);
3: +    }
3: +
3: +    if (!res) {throw std::runtime_error("Call to figure() failed.");}
3: +
3: +    PyObject * num = PyObject_GetAttrString(res, "number");
3: +    if (!num) {throw std::runtime_error("Could not get number attribute of figure object");}
3: @@ -1575,7 +1716,7 @@
3: -}
3: -
3: -inline bool fignum_exists(long number)
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject *args = PyTuple_New(1);
3: +  }
3: +
3: +  inline bool fignum_exists(long number)
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * args = PyTuple_New(1);
3: @@ -1583,2 +1724,3 @@
3: -    PyObject *res = PyObject_CallObject(detail::_interpreter::get().s_python_function_fignum_exists, args);
3: -    if(!res) throw std::runtime_error("Call to fignum_exists() failed.");
3: +    PyObject * res = PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_fignum_exists, args);
3: +    if (!res) {throw std::runtime_error("Call to fignum_exists() failed.");}
3: @@ -1591,4 +1733,4 @@
3: -}
3: -
3: -inline void figure_size(size_t w, size_t h)
3: -{
3: +  }
3: +
3: +  inline void figure_size(size_t w, size_t h)
3: +  {
3: @@ -1598 +1740 @@
3: -    PyObject* size = PyTuple_New(2);
3: +    PyObject * size = PyTuple_New(2);
3: @@ -1602 +1744 @@
3: -    PyObject* kwargs = PyDict_New();
3: +    PyObject * kwargs = PyDict_New();
3: @@ -1606,43 +1748,49 @@
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_figure,
3: -            detail::_interpreter::get().s_python_empty_tuple, kwargs);
3: -
3: -    Py_DECREF(kwargs);
3: -
3: -    if(!res) throw std::runtime_error("Call to figure_size() failed.");
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void legend()
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_legend, detail::_interpreter::get().s_python_empty_tuple);
3: -    if(!res) throw std::runtime_error("Call to legend() failed.");
3: -
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void legend(const std::map<std::string, std::string>& keywords)
3: -{
3: -  detail::_interpreter::get();
3: -
3: -  // construct keyword args
3: -  PyObject* kwargs = PyDict_New();
3: -  for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
3: -  {
3: -    PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: -  }
3: -
3: -  PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_legend, detail::_interpreter::get().s_python_empty_tuple, kwargs);
3: -  if(!res) throw std::runtime_error("Call to legend() failed.");
3: -
3: -  Py_DECREF(kwargs);
3: -  Py_DECREF(res);  
3: -}
3: -
3: -template<typename Numeric>
3: -void ylim(Numeric left, Numeric right)
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* list = PyList_New(2);
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_figure,
3: +      detail::_interpreter::get().s_python_empty_tuple, kwargs);
3: +
3: +    Py_DECREF(kwargs);
3: +
3: +    if (!res) {throw std::runtime_error("Call to figure_size() failed.");}
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void legend()
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * res = PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_legend,
3: +      detail::_interpreter::get().s_python_empty_tuple);
3: +    if (!res) {throw std::runtime_error("Call to legend() failed.");}
3: +
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void legend(const std::map < std::string, std::string > & keywords)
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    // construct keyword args
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_legend,
3: +      detail::_interpreter::get().s_python_empty_tuple, kwargs);
3: +    if (!res) {throw std::runtime_error("Call to legend() failed.");}
3: +
3: +    Py_DECREF(kwargs);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  template < typename Numeric >
3: +  void ylim(Numeric left, Numeric right)
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * list = PyList_New(2);
3: @@ -1652 +1800 @@
3: -    PyObject* args = PyTuple_New(1);
3: +    PyObject * args = PyTuple_New(1);
3: @@ -1655,13 +1803,13 @@
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_ylim, args);
3: -    if(!res) throw std::runtime_error("Call to ylim() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(res);
3: -}
3: -
3: -template<typename Numeric>
3: -void xlim(Numeric left, Numeric right)
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* list = PyList_New(2);
3: +    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_ylim, args);
3: +    if (!res) {throw std::runtime_error("Call to ylim() failed.");}
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  template < typename Numeric >
3: +  void xlim(Numeric left, Numeric right)
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * list = PyList_New(2);
3: @@ -1671 +1819 @@
3: -    PyObject* args = PyTuple_New(1);
3: +    PyObject * args = PyTuple_New(1);
3: @@ -1674,18 +1822,18 @@
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_xlim, args);
3: -    if(!res) throw std::runtime_error("Call to xlim() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(res);
3: -}
3: -
3: -
3: -inline double* xlim()
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* args = PyTuple_New(0);
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_xlim, args);
3: -    PyObject* left = PyTuple_GetItem(res,0);
3: -    PyObject* right = PyTuple_GetItem(res,1);
3: -
3: -    double* arr = new double[2];
3: +    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_xlim, args);
3: +    if (!res) {throw std::runtime_error("Call to xlim() failed.");}
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +
3: +  inline double * xlim()
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * args = PyTuple_New(0);
3: +    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_xlim, args);
3: +    PyObject * left = PyTuple_GetItem(res, 0);
3: +    PyObject * right = PyTuple_GetItem(res, 1);
3: +
3: +    double * arr = new double[2];
3: @@ -1695 +1843 @@
3: -    if(!res) throw std::runtime_error("Call to xlim() failed.");
3: +    if (!res) {throw std::runtime_error("Call to xlim() failed.");}
3: @@ -1699,13 +1847,13 @@
3: -}
3: -
3: -
3: -inline double* ylim()
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* args = PyTuple_New(0);
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_ylim, args);
3: -    PyObject* left = PyTuple_GetItem(res,0);
3: -    PyObject* right = PyTuple_GetItem(res,1);
3: -
3: -    double* arr = new double[2];
3: +  }
3: +
3: +
3: +  inline double * ylim()
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * args = PyTuple_New(0);
3: +    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_ylim, args);
3: +    PyObject * left = PyTuple_GetItem(res, 0);
3: +    PyObject * right = PyTuple_GetItem(res, 1);
3: +
3: +    double * arr = new double[2];
3: @@ -1715 +1863 @@
3: -    if(!res) throw std::runtime_error("Call to ylim() failed.");
3: +    if (!res) {throw std::runtime_error("Call to ylim() failed.");}
3: @@ -1719,5 +1867,8 @@
3: -}
3: -
3: -template<typename Numeric>
3: -inline void xticks(const std::vector<Numeric> &ticks, const std::vector<std::string> &labels = {}, const std::map<std::string, std::string>& keywords = {})
3: -{
3: +  }
3: +
3: +  template < typename Numeric >
3: +  inline void xticks(
3: +    const std::vector < Numeric > & ticks,
3: +    const std::vector < std::string > & labels = {}, const std::map < std::string,
3: +    std::string > & keywords = {})
3: +  {
3: @@ -1729,7 +1880,7 @@
3: -    PyObject* ticksarray = detail::get_array(ticks);
3: -
3: -    PyObject* args;
3: -    if(labels.size() == 0) {
3: -        // construct positional args
3: -        args = PyTuple_New(1);
3: -        PyTuple_SetItem(args, 0, ticksarray);
3: +    PyObject * ticksarray = detail::get_array(ticks);
3: +
3: +    PyObject * args;
3: +    if (labels.size() == 0) {
3: +      // construct positional args
3: +      args = PyTuple_New(1);
3: +      PyTuple_SetItem(args, 0, ticksarray);
3: @@ -1737,9 +1888,10 @@
3: -        // make tuple of tick labels
3: -        PyObject* labelstuple = PyTuple_New(labels.size());
3: -        for (size_t i = 0; i < labels.size(); i++)
3: -            PyTuple_SetItem(labelstuple, i, PyUnicode_FromString(labels[i].c_str()));
3: -
3: -        // construct positional args
3: -        args = PyTuple_New(2);
3: -        PyTuple_SetItem(args, 0, ticksarray);
3: -        PyTuple_SetItem(args, 1, labelstuple);
3: +      // make tuple of tick labels
3: +      PyObject * labelstuple = PyTuple_New(labels.size());
3: +      for (size_t i = 0; i < labels.size(); i++) {
3: +        PyTuple_SetItem(labelstuple, i, PyUnicode_FromString(labels[i].c_str()));
3: +      }
3: +
3: +      // construct positional args
3: +      args = PyTuple_New(2);
3: +      PyTuple_SetItem(args, 0, ticksarray);
3: +      PyTuple_SetItem(args, 1, labelstuple);
3: @@ -1749,18 +1901,22 @@
3: -    PyObject* kwargs = PyDict_New();
3: -    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
3: -    {
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_xticks, args, kwargs);
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -    if(!res) throw std::runtime_error("Call to xticks() failed");
3: -
3: -    Py_DECREF(res);
3: -}
3: -
3: -template<typename Numeric>
3: -inline void xticks(const std::vector<Numeric> &ticks, const std::map<std::string, std::string>& keywords)
3: -{
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_xticks, args, kwargs);
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +    if (!res) {throw std::runtime_error("Call to xticks() failed");}
3: +
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  template < typename Numeric >
3: +  inline void xticks(
3: +    const std::vector < Numeric > & ticks, const std::map < std::string,
3: +    std::string > & keywords)
3: +  {
3: @@ -1768,5 +1924,8 @@
3: -}
3: -
3: -template<typename Numeric>
3: -inline void yticks(const std::vector<Numeric> &ticks, const std::vector<std::string> &labels = {}, const std::map<std::string, std::string>& keywords = {})
3: -{
3: +  }
3: +
3: +  template < typename Numeric >
3: +  inline void yticks(
3: +    const std::vector < Numeric > & ticks,
3: +    const std::vector < std::string > & labels = {}, const std::map < std::string,
3: +    std::string > & keywords = {})
3: +  {
3: @@ -1778,7 +1937,7 @@
3: -    PyObject* ticksarray = detail::get_array(ticks);
3: -
3: -    PyObject* args;
3: -    if(labels.size() == 0) {
3: -        // construct positional args
3: -        args = PyTuple_New(1);
3: -        PyTuple_SetItem(args, 0, ticksarray);
3: +    PyObject * ticksarray = detail::get_array(ticks);
3: +
3: +    PyObject * args;
3: +    if (labels.size() == 0) {
3: +      // construct positional args
3: +      args = PyTuple_New(1);
3: +      PyTuple_SetItem(args, 0, ticksarray);
3: @@ -1786,9 +1945,10 @@
3: -        // make tuple of tick labels
3: -        PyObject* labelstuple = PyTuple_New(labels.size());
3: -        for (size_t i = 0; i < labels.size(); i++)
3: -            PyTuple_SetItem(labelstuple, i, PyUnicode_FromString(labels[i].c_str()));
3: -
3: -        // construct positional args
3: -        args = PyTuple_New(2);
3: -        PyTuple_SetItem(args, 0, ticksarray);
3: -        PyTuple_SetItem(args, 1, labelstuple);
3: +      // make tuple of tick labels
3: +      PyObject * labelstuple = PyTuple_New(labels.size());
3: +      for (size_t i = 0; i < labels.size(); i++) {
3: +        PyTuple_SetItem(labelstuple, i, PyUnicode_FromString(labels[i].c_str()));
3: +      }
3: +
3: +      // construct positional args
3: +      args = PyTuple_New(2);
3: +      PyTuple_SetItem(args, 0, ticksarray);
3: +      PyTuple_SetItem(args, 1, labelstuple);
3: @@ -1798,18 +1958,22 @@
3: -    PyObject* kwargs = PyDict_New();
3: -    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
3: -    {
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_yticks, args, kwargs);
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -    if(!res) throw std::runtime_error("Call to yticks() failed");
3: -
3: -    Py_DECREF(res);
3: -}
3: -
3: -template<typename Numeric>
3: -inline void yticks(const std::vector<Numeric> &ticks, const std::map<std::string, std::string>& keywords)
3: -{
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_yticks, args, kwargs);
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +    if (!res) {throw std::runtime_error("Call to yticks() failed");}
3: +
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  template < typename Numeric >
3: +  inline void yticks(
3: +    const std::vector < Numeric > & ticks, const std::map < std::string,
3: +    std::string > & keywords)
3: +  {
3: @@ -1817,4 +1981,4 @@
3: -}
3: -
3: -template <typename Numeric> inline void margins(Numeric margin)
3: -{
3: +  }
3: +
3: +  template < typename Numeric > inline void margins(Numeric margin)
3: +  {
3: @@ -1822 +1986 @@
3: -    PyObject* args = PyTuple_New(1);
3: +    PyObject * args = PyTuple_New(1);
3: @@ -1825,11 +1989,12 @@
3: -    PyObject* res =
3: -            PyObject_CallObject(detail::_interpreter::get().s_python_function_margins, args);
3: -    if (!res)
3: -        throw std::runtime_error("Call to margins() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(res);
3: -}
3: -
3: -template <typename Numeric> inline void margins(Numeric margin_x, Numeric margin_y)
3: -{
3: +    PyObject * res =
3: +      PyObject_CallObject(detail::_interpreter::get().s_python_function_margins, args);
3: +    if (!res) {
3: +      throw std::runtime_error("Call to margins() failed.");
3: +    }
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  template < typename Numeric > inline void margins(Numeric margin_x, Numeric margin_y)
3: +  {
3: @@ -1837 +2002 @@
3: -    PyObject* args = PyTuple_New(2);
3: +    PyObject * args = PyTuple_New(2);
3: @@ -1841,40 +2006,17 @@
3: -    PyObject* res =
3: -            PyObject_CallObject(detail::_interpreter::get().s_python_function_margins, args);
3: -    if (!res)
3: -        throw std::runtime_error("Call to margins() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(res);
3: -}
3: -
3: -
3: -inline void tick_params(const std::map<std::string, std::string>& keywords, const std::string axis = "both")
3: -{
3: -  detail::_interpreter::get();
3: -
3: -  // construct positional args
3: -  PyObject* args;
3: -  args = PyTuple_New(1);
3: -  PyTuple_SetItem(args, 0, PyString_FromString(axis.c_str()));
3: -
3: -  // construct keyword args
3: -  PyObject* kwargs = PyDict_New();
3: -  for (std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
3: -  {
3: -    PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: -  }
3: -
3: -
3: -  PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_tick_params, args, kwargs);
3: -
3: -  Py_DECREF(args);
3: -  Py_DECREF(kwargs);
3: -  if (!res) throw std::runtime_error("Call to tick_params() failed");
3: -
3: -  Py_DECREF(res);
3: -}
3: -
3: -inline void subplot(long nrows, long ncols, long plot_number)
3: -{
3: -    detail::_interpreter::get();
3: -    
3: +    PyObject * res =
3: +      PyObject_CallObject(detail::_interpreter::get().s_python_function_margins, args);
3: +    if (!res) {
3: +      throw std::runtime_error("Call to margins() failed.");
3: +    }
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +
3: +  inline void tick_params(
3: +    const std::map < std::string, std::string > & keywords,
3: +    const std::string axis = "both")
3: +  {
3: +    detail::_interpreter::get();
3: +
3: @@ -1882 +2024,29 @@
3: -    PyObject* args = PyTuple_New(3);
3: +    PyObject * args;
3: +    args = PyTuple_New(1);
3: +    PyTuple_SetItem(args, 0, PyString_FromString(axis.c_str()));
3: +
3: +    // construct keyword args
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: +    }
3: +
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_tick_params, args, kwargs);
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +    if (!res) {throw std::runtime_error("Call to tick_params() failed");}
3: +
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void subplot(long nrows, long ncols, long plot_number)
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    // construct positional args
3: +    PyObject * args = PyTuple_New(3);
3: @@ -1887,12 +2057,15 @@
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_subplot, args);
3: -    if(!res) throw std::runtime_error("Call to subplot() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void subplot2grid(long nrows, long ncols, long rowid=0, long colid=0, long rowspan=1, long colspan=1)
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* shape = PyTuple_New(2);
3: +    PyObject * res =
3: +      PyObject_CallObject(detail::_interpreter::get().s_python_function_subplot, args);
3: +    if (!res) {throw std::runtime_error("Call to subplot() failed.");}
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void subplot2grid(
3: +    long nrows, long ncols, long rowid = 0, long colid = 0, long rowspan = 1,
3: +    long colspan = 1)
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * shape = PyTuple_New(2);
3: @@ -1902 +2075 @@
3: -    PyObject* loc = PyTuple_New(2);
3: +    PyObject * loc = PyTuple_New(2);
3: @@ -1906 +2079 @@
3: -    PyObject* args = PyTuple_New(4);
3: +    PyObject * args = PyTuple_New(4);
3: @@ -1912,2 +2085,3 @@
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_subplot2grid, args);
3: -    if(!res) throw std::runtime_error("Call to subplot2grid() failed.");
3: +    PyObject * res = PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_subplot2grid, args);
3: +    if (!res) {throw std::runtime_error("Call to subplot2grid() failed.");}
3: @@ -1919,8 +2093,10 @@
3: -}
3: -
3: -inline void title(const std::string &titlestr, const std::map<std::string, std::string> &keywords = {})
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* pytitlestr = PyString_FromString(titlestr.c_str());
3: -    PyObject* args = PyTuple_New(1);
3: +  }
3: +
3: +  inline void title(
3: +    const std::string & titlestr, const std::map < std::string,
3: +    std::string > & keywords = {})
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * pytitlestr = PyString_FromString(titlestr.c_str());
3: +    PyObject * args = PyTuple_New(1);
3: @@ -1929 +2105 @@
3: -    PyObject* kwargs = PyDict_New();
3: +    PyObject * kwargs = PyDict_New();
3: @@ -1931,17 +2107,20 @@
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_title, args, kwargs);
3: -    if(!res) throw std::runtime_error("Call to title() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void suptitle(const std::string &suptitlestr, const std::map<std::string, std::string> &keywords = {})
3: -{
3: -    detail::_interpreter::get();
3: -    
3: -    PyObject* pysuptitlestr = PyString_FromString(suptitlestr.c_str());
3: -    PyObject* args = PyTuple_New(1);
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res =
3: +      PyObject_Call(detail::_interpreter::get().s_python_function_title, args, kwargs);
3: +    if (!res) {throw std::runtime_error("Call to title() failed.");}
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void suptitle(
3: +    const std::string & suptitlestr, const std::map < std::string,
3: +    std::string > & keywords = {})
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * pysuptitlestr = PyString_FromString(suptitlestr.c_str());
3: +    PyObject * args = PyTuple_New(1);
3: @@ -1950 +2129 @@
3: -    PyObject* kwargs = PyDict_New();
3: +    PyObject * kwargs = PyDict_New();
3: @@ -1952,17 +2131,18 @@
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_suptitle, args, kwargs);
3: -    if(!res) throw std::runtime_error("Call to suptitle() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void axis(const std::string &axisstr)
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* str = PyString_FromString(axisstr.c_str());
3: -    PyObject* args = PyTuple_New(1);
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_suptitle, args, kwargs);
3: +    if (!res) {throw std::runtime_error("Call to suptitle() failed.");}
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void axis(const std::string & axisstr)
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * str = PyString_FromString(axisstr.c_str());
3: +    PyObject * args = PyTuple_New(1);
3: @@ -1971,9 +2151,11 @@
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_axis, args);
3: -    if(!res) throw std::runtime_error("Call to title() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void axvline(double x, double ymin = 0., double ymax = 1., const std::map<std::string, std::string>& keywords = std::map<std::string, std::string>())
3: -{
3: +    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_axis, args);
3: +    if (!res) {throw std::runtime_error("Call to title() failed.");}
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void axvline(
3: +    double x, double ymin = 0., double ymax = 1., const std::map < std::string,
3: +    std::string > & keywords = std::map < std::string, std::string > ())
3: +  {
3: @@ -1983 +2165 @@
3: -    PyObject* args = PyTuple_New(3);
3: +    PyObject * args = PyTuple_New(3);
3: @@ -1989,16 +2171,21 @@
3: -    PyObject* kwargs = PyDict_New();
3: -    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
3: -    {
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_axvline, args, kwargs);
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -
3: -    if(res) Py_DECREF(res);
3: -}
3: -
3: -inline void axvspan(double xmin, double xmax, double ymin = 0., double ymax = 1., const std::map<std::string, std::string>& keywords = std::map<std::string, std::string>())
3: -{
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_axvline, args, kwargs);
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +
3: +    if (res) {Py_DECREF(res);}
3: +  }
3: +
3: +  inline void axvspan(
3: +    double xmin, double xmax, double ymin = 0., double ymax = 1.,
3: +    const std::map < std::string,
3: +    std::string > & keywords = std::map < std::string, std::string > ())
3: +  {
3: @@ -2006 +2193 @@
3: -    PyObject* args = PyTuple_New(4);
3: +    PyObject * args = PyTuple_New(4);
3: @@ -2013,22 +2200,27 @@
3: -    PyObject* kwargs = PyDict_New();
3: -    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
3: -    {
3: -    if (it->first == "linewidth" || it->first == "alpha")
3: -            PyDict_SetItemString(kwargs, it->first.c_str(), PyFloat_FromDouble(std::stod(it->second)));
3: -    else
3: -            PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_axvspan, args, kwargs);
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -
3: -    if(res) Py_DECREF(res);
3: -}
3: -
3: -inline void xlabel(const std::string &str, const std::map<std::string, std::string> &keywords = {})
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* pystr = PyString_FromString(str.c_str());
3: -    PyObject* args = PyTuple_New(1);
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      if (it->first == "linewidth" || it->first == "alpha") {
3: +        PyDict_SetItemString(kwargs, it->first.c_str(), PyFloat_FromDouble(std::stod(it->second)));
3: +      } else {
3: +        PyDict_SetItemString(kwargs, it->first.c_str(), PyString_FromString(it->second.c_str()));
3: +      }
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_axvspan, args, kwargs);
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +
3: +    if (res) {Py_DECREF(res);}
3: +  }
3: +
3: +  inline void xlabel(
3: +    const std::string & str, const std::map < std::string,
3: +    std::string > & keywords = {})
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * pystr = PyString_FromString(str.c_str());
3: +    PyObject * args = PyTuple_New(1);
3: @@ -2037 +2229 @@
3: -    PyObject* kwargs = PyDict_New();
3: +    PyObject * kwargs = PyDict_New();
3: @@ -2039,17 +2231,20 @@
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_xlabel, args, kwargs);
3: -    if(!res) throw std::runtime_error("Call to xlabel() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void ylabel(const std::string &str, const std::map<std::string, std::string>& keywords = {})
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* pystr = PyString_FromString(str.c_str());
3: -    PyObject* args = PyTuple_New(1);
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_xlabel, args, kwargs);
3: +    if (!res) {throw std::runtime_error("Call to xlabel() failed.");}
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void ylabel(
3: +    const std::string & str, const std::map < std::string,
3: +    std::string > & keywords = {})
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * pystr = PyString_FromString(str.c_str());
3: +    PyObject * args = PyTuple_New(1);
3: @@ -2058 +2253 @@
3: -    PyObject* kwargs = PyDict_New();
3: +    PyObject * kwargs = PyDict_New();
3: @@ -2060,18 +2255,21 @@
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_ylabel, args, kwargs);
3: -    if(!res) throw std::runtime_error("Call to ylabel() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(kwargs);
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void set_zlabel(const std::string &str, const std::map<std::string, std::string>& keywords = {})
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    // Same as with plot_surface: We lazily load the modules here the first time 
3: -    // this function is called because I'm not sure that we can assume "matplotlib 
3: -    // installed" implies "mpl_toolkits installed" on all platforms, and we don't 
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_ylabel, args, kwargs);
3: +    if (!res) {throw std::runtime_error("Call to ylabel() failed.");}
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(kwargs);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void set_zlabel(
3: +    const std::string & str, const std::map < std::string,
3: +    std::string > & keywords = {})
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    // Same as with plot_surface: We lazily load the modules here the first time
3: +    // this function is called because I'm not sure that we can assume "matplotlib
3: +    // installed" implies "mpl_toolkits installed" on all platforms, and we don't
3: @@ -2079 +2277 @@
3: -    static PyObject *mpl_toolkitsmod = nullptr, *axis3dmod = nullptr;
3: +    static PyObject * mpl_toolkitsmod = nullptr, * axis3dmod = nullptr;
3: @@ -2081,15 +2279,15 @@
3: -        PyObject* mpl_toolkits = PyString_FromString("mpl_toolkits");
3: -        PyObject* axis3d = PyString_FromString("mpl_toolkits.mplot3d");
3: -        if (!mpl_toolkits || !axis3d) { throw std::runtime_error("couldnt create string"); }
3: -
3: -        mpl_toolkitsmod = PyImport_Import(mpl_toolkits);
3: -        Py_DECREF(mpl_toolkits);
3: -        if (!mpl_toolkitsmod) { throw std::runtime_error("Error loading module mpl_toolkits!"); }
3: -
3: -        axis3dmod = PyImport_Import(axis3d);
3: -        Py_DECREF(axis3d);
3: -        if (!axis3dmod) { throw std::runtime_error("Error loading module mpl_toolkits.mplot3d!"); }
3: -    }
3: -
3: -    PyObject* pystr = PyString_FromString(str.c_str());
3: -    PyObject* args = PyTuple_New(1);
3: +      PyObject * mpl_toolkits = PyString_FromString("mpl_toolkits");
3: +      PyObject * axis3d = PyString_FromString("mpl_toolkits.mplot3d");
3: +      if (!mpl_toolkits || !axis3d) {throw std::runtime_error("couldnt create string");}
3: +
3: +      mpl_toolkitsmod = PyImport_Import(mpl_toolkits);
3: +      Py_DECREF(mpl_toolkits);
3: +      if (!mpl_toolkitsmod) {throw std::runtime_error("Error loading module mpl_toolkits!");}
3: +
3: +      axis3dmod = PyImport_Import(axis3d);
3: +      Py_DECREF(axis3d);
3: +      if (!axis3dmod) {throw std::runtime_error("Error loading module mpl_toolkits.mplot3d!");}
3: +    }
3: +
3: +    PyObject * pystr = PyString_FromString(str.c_str());
3: +    PyObject * args = PyTuple_New(1);
3: @@ -2098 +2296 @@
3: -    PyObject* kwargs = PyDict_New();
3: +    PyObject * kwargs = PyDict_New();
3: @@ -2100,5 +2298,6 @@
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject *ax =
3: -    PyObject_CallObject(detail::_interpreter::get().s_python_function_gca,
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * ax =
3: +      PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_gca,
3: @@ -2106 +2305 @@
3: -    if (!ax) throw std::runtime_error("Call to gca() failed.");
3: +    if (!ax) {throw std::runtime_error("Call to gca() failed.");}
3: @@ -2109,2 +2308,2 @@
3: -    PyObject *zlabel = PyObject_GetAttrString(ax, "set_zlabel");
3: -    if (!zlabel) throw std::runtime_error("Attribute set_zlabel not found.");
3: +    PyObject * zlabel = PyObject_GetAttrString(ax, "set_zlabel");
3: +    if (!zlabel) {throw std::runtime_error("Attribute set_zlabel not found.");}
3: @@ -2113,2 +2312,2 @@
3: -    PyObject *res = PyObject_Call(zlabel, args, kwargs);
3: -    if (!res) throw std::runtime_error("Call to set_zlabel() failed.");
3: +    PyObject * res = PyObject_Call(zlabel, args, kwargs);
3: +    if (!res) {throw std::runtime_error("Call to set_zlabel() failed.");}
3: @@ -2120,8 +2319,8 @@
3: -    if (res) Py_DECREF(res);
3: -}
3: -
3: -inline void grid(bool flag)
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* pyflag = flag ? Py_True : Py_False;
3: +    if (res) {Py_DECREF(res);}
3: +  }
3: +
3: +  inline void grid(bool flag)
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * pyflag = flag ? Py_True : Py_False;
3: @@ -2130 +2329 @@
3: -    PyObject* args = PyTuple_New(1);
3: +    PyObject * args = PyTuple_New(1);
3: @@ -2133,68 +2332,15 @@
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_grid, args);
3: -    if(!res) throw std::runtime_error("Call to grid() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void show(const bool block = true)
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* res;
3: -    if(block)
3: -    {
3: -        res = PyObject_CallObject(
3: -                detail::_interpreter::get().s_python_function_show,
3: -                detail::_interpreter::get().s_python_empty_tuple);
3: -    }
3: -    else
3: -    {
3: -        PyObject *kwargs = PyDict_New();
3: -        PyDict_SetItemString(kwargs, "block", Py_False);
3: -        res = PyObject_Call( detail::_interpreter::get().s_python_function_show, detail::_interpreter::get().s_python_empty_tuple, kwargs);
3: -       Py_DECREF(kwargs);
3: -    }
3: -
3: -
3: -    if (!res) throw std::runtime_error("Call to show() failed.");
3: -
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void close()
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* res = PyObject_CallObject(
3: -            detail::_interpreter::get().s_python_function_close,
3: -            detail::_interpreter::get().s_python_empty_tuple);
3: -
3: -    if (!res) throw std::runtime_error("Call to close() failed.");
3: -
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void xkcd() {
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* res;
3: -    PyObject *kwargs = PyDict_New();
3: -
3: -    res = PyObject_Call(detail::_interpreter::get().s_python_function_xkcd,
3: -            detail::_interpreter::get().s_python_empty_tuple, kwargs);
3: -
3: -    Py_DECREF(kwargs);
3: -
3: -    if (!res)
3: -        throw std::runtime_error("Call to show() failed.");
3: -
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void draw()
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* res = PyObject_CallObject(
3: -        detail::_interpreter::get().s_python_function_draw,
3: +    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_grid, args);
3: +    if (!res) {throw std::runtime_error("Call to grid() failed.");}
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void show(const bool block = true)
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * res;
3: +    if (block) {
3: +      res = PyObject_CallObject(
3: +        detail::_interpreter::get().s_python_function_show,
3: @@ -2202,12 +2348,67 @@
3: -
3: -    if (!res) throw std::runtime_error("Call to draw() failed.");
3: -
3: -    Py_DECREF(res);
3: -}
3: -
3: -template<typename Numeric>
3: -inline void pause(Numeric interval)
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* args = PyTuple_New(1);
3: +    } else {
3: +      PyObject * kwargs = PyDict_New();
3: +      PyDict_SetItemString(kwargs, "block", Py_False);
3: +      res = PyObject_Call(
3: +        detail::_interpreter::get().s_python_function_show,
3: +        detail::_interpreter::get().s_python_empty_tuple, kwargs);
3: +      Py_DECREF(kwargs);
3: +    }
3: +
3: +
3: +    if (!res) {throw std::runtime_error("Call to show() failed.");}
3: +
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void close()
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * res = PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_close,
3: +      detail::_interpreter::get().s_python_empty_tuple);
3: +
3: +    if (!res) {throw std::runtime_error("Call to close() failed.");}
3: +
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void xkcd()
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * res;
3: +    PyObject * kwargs = PyDict_New();
3: +
3: +    res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_xkcd,
3: +      detail::_interpreter::get().s_python_empty_tuple, kwargs);
3: +
3: +    Py_DECREF(kwargs);
3: +
3: +    if (!res) {
3: +      throw std::runtime_error("Call to show() failed.");
3: +    }
3: +
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void draw()
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * res = PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_draw,
3: +      detail::_interpreter::get().s_python_empty_tuple);
3: +
3: +    if (!res) {throw std::runtime_error("Call to draw() failed.");}
3: +
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  template < typename Numeric >
3: +  inline void pause(Numeric interval)
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * args = PyTuple_New(1);
3: @@ -2216,14 +2417,14 @@
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_pause, args);
3: -    if(!res) throw std::runtime_error("Call to pause() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void save(const std::string& filename)
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* pyfilename = PyString_FromString(filename.c_str());
3: -
3: -    PyObject* args = PyTuple_New(1);
3: +    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_pause, args);
3: +    if (!res) {throw std::runtime_error("Call to pause() failed.");}
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void save(const std::string & filename)
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * pyfilename = PyString_FromString(filename.c_str());
3: +
3: +    PyObject * args = PyTuple_New(1);
3: @@ -2232,48 +2433,56 @@
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_save, args);
3: -    if (!res) throw std::runtime_error("Call to save() failed.");
3: -
3: -    Py_DECREF(args);
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void clf() {
3: -    detail::_interpreter::get();
3: -
3: -    PyObject *res = PyObject_CallObject(
3: -        detail::_interpreter::get().s_python_function_clf,
3: -        detail::_interpreter::get().s_python_empty_tuple);
3: -
3: -    if (!res) throw std::runtime_error("Call to clf() failed.");
3: -
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void cla() {
3: -    detail::_interpreter::get();
3: -
3: -    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_cla,
3: -                                        detail::_interpreter::get().s_python_empty_tuple);
3: -
3: -    if (!res)
3: -        throw std::runtime_error("Call to cla() failed.");
3: -
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline void ion() {
3: -    detail::_interpreter::get();
3: -
3: -    PyObject *res = PyObject_CallObject(
3: -        detail::_interpreter::get().s_python_function_ion,
3: -        detail::_interpreter::get().s_python_empty_tuple);
3: -
3: -    if (!res) throw std::runtime_error("Call to ion() failed.");
3: -
3: -    Py_DECREF(res);
3: -}
3: -
3: -inline std::vector<std::array<double, 2>> ginput(const int numClicks = 1, const std::map<std::string, std::string>& keywords = {})
3: -{
3: -    detail::_interpreter::get();
3: -
3: -    PyObject *args = PyTuple_New(1);
3: +    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_save, args);
3: +    if (!res) {throw std::runtime_error("Call to save() failed.");}
3: +
3: +    Py_DECREF(args);
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void clf()
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * res = PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_clf,
3: +      detail::_interpreter::get().s_python_empty_tuple);
3: +
3: +    if (!res) {throw std::runtime_error("Call to clf() failed.");}
3: +
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void cla()
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * res = PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_cla,
3: +      detail::_interpreter::get().s_python_empty_tuple);
3: +
3: +    if (!res) {
3: +      throw std::runtime_error("Call to cla() failed.");
3: +    }
3: +
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline void ion()
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * res = PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_ion,
3: +      detail::_interpreter::get().s_python_empty_tuple);
3: +
3: +    if (!res) {throw std::runtime_error("Call to ion() failed.");}
3: +
3: +    Py_DECREF(res);
3: +  }
3: +
3: +  inline std::vector < std::array < double, 2 >> ginput(
3: +    const int numClicks = 1,
3: +    const std::map < std::string,
3: +    std::string > & keywords = {})
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * args = PyTuple_New(1);
3: @@ -2283,12 +2492,13 @@
3: -    PyObject* kwargs = PyDict_New();
3: -    for(std::map<std::string, std::string>::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
3: -    {
3: -        PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: -    }
3: -
3: -    PyObject* res = PyObject_Call(
3: -        detail::_interpreter::get().s_python_function_ginput, args, kwargs);
3: -
3: -    Py_DECREF(kwargs);
3: -    Py_DECREF(args);
3: -    if (!res) throw std::runtime_error("Call to ginput() failed.");
3: +    PyObject * kwargs = PyDict_New();
3: +    for (std::map < std::string, std::string > ::const_iterator it = keywords.begin();
3: +      it != keywords.end(); ++it)
3: +    {
3: +      PyDict_SetItemString(kwargs, it->first.c_str(), PyUnicode_FromString(it->second.c_str()));
3: +    }
3: +
3: +    PyObject * res = PyObject_Call(
3: +      detail::_interpreter::get().s_python_function_ginput, args, kwargs);
3: +
3: +    Py_DECREF(kwargs);
3: +    Py_DECREF(args);
3: +    if (!res) {throw std::runtime_error("Call to ginput() failed.");}
3: @@ -2297 +2507 @@
3: -    std::vector<std::array<double, 2>> out;
3: +    std::vector < std::array < double, 2 >> out;
3: @@ -2300,5 +2510,5 @@
3: -        PyObject *current = PyList_GetItem(res, i);
3: -        std::array<double, 2> position;
3: -        position[0] = PyFloat_AsDouble(PyTuple_GetItem(current, 0));
3: -        position[1] = PyFloat_AsDouble(PyTuple_GetItem(current, 1));
3: -        out.push_back(position);
3: +      PyObject * current = PyList_GetItem(res, i);
3: +      std::array < double, 2 > position;
3: +      position[0] = PyFloat_AsDouble(PyTuple_GetItem(current, 0));
3: +      position[1] = PyFloat_AsDouble(PyTuple_GetItem(current, 1));
3: +      out.push_back(position);
3: @@ -2309 +2519 @@
3: -}
3: +  }
3: @@ -2312,11 +2522,12 @@
3: -inline void tight_layout() {
3: -    detail::_interpreter::get();
3: -
3: -    PyObject *res = PyObject_CallObject(
3: -        detail::_interpreter::get().s_python_function_tight_layout,
3: -        detail::_interpreter::get().s_python_empty_tuple);
3: -
3: -    if (!res) throw std::runtime_error("Call to tight_layout() failed.");
3: -
3: -    Py_DECREF(res);
3: -}
3: +  inline void tight_layout()
3: +  {
3: +    detail::_interpreter::get();
3: +
3: +    PyObject * res = PyObject_CallObject(
3: +      detail::_interpreter::get().s_python_function_tight_layout,
3: +      detail::_interpreter::get().s_python_empty_tuple);
3: +
3: +    if (!res) {throw std::runtime_error("Call to tight_layout() failed.");}
3: +
3: +    Py_DECREF(res);
3: +  }
3: @@ -2326,27 +2537,28 @@
3: -namespace detail {
3: -
3: -template<typename T>
3: -using is_function = typename std::is_function<std::remove_pointer<std::remove_reference<T>>>::type;
3: -
3: -template<bool obj, typename T>
3: -struct is_callable_impl;
3: -
3: -template<typename T>
3: -struct is_callable_impl<false, T>
3: -{
3: -    typedef is_function<T> type;
3: -}; // a non-object is callable iff it is a function
3: -
3: -template<typename T>
3: -struct is_callable_impl<true, T>
3: -{
3: -    struct Fallback { void operator()(); };
3: -    struct Derived : T, Fallback { };
3: -
3: -    template<typename U, U> struct Check;
3: -
3: -    template<typename U>
3: -    static std::true_type test( ... ); // use a variadic function to make sure (1) it accepts everything and (2) its always the worst match
3: -
3: -    template<typename U>
3: -    static std::false_type test( Check<void(Fallback::*)(), &U::operator()>* );
3: +  namespace detail {
3: +
3: +    template < typename T >
3: +    using is_function = typename std::is_function < std::remove_pointer < std::remove_reference <
3: +      T >> > ::type;
3: +
3: +    template < bool obj, typename T >
3: +    struct is_callable_impl;
3: +
3: +    template < typename T >
3: +    struct is_callable_impl < false, T >
3: +    {
3: +      typedef is_function < T > type;
3: +    } // a non-object is callable iff it is a function
3: +
3: +    template < typename T >
3: +    struct is_callable_impl < true, T >
3: +    {
3: +      struct Fallback { void operator()(); };
3: +      struct Derived : T, Fallback {};
3: +
3: +      template < typename U, U > struct Check;
3: +
3: +      template < typename U >
3: +      static std::true_type test(...); // use a variadic function to make sure (1) it accepts everything and (2) its always the worst match
3: +
3: +      template < typename U >
3: +      static std::false_type test(Check < void (Fallback::*)(), & U::operator() > *);
3: @@ -2355,21 +2567,21 @@
3: -    typedef decltype(test<Derived>(nullptr)) type;
3: -    typedef decltype(&Fallback::operator()) dtype;
3: -    static constexpr bool value = type::value;
3: -}; // an object is callable iff it defines operator()
3: -
3: -template<typename T>
3: -struct is_callable
3: -{
3: -    // dispatch to is_callable_impl<true, T> or is_callable_impl<false, T> depending on whether T is of class type or not
3: -    typedef typename is_callable_impl<std::is_class<T>::value, T>::type type;
3: -};
3: -
3: -template<typename IsYDataCallable>
3: -struct plot_impl { };
3: -
3: -template<>
3: -struct plot_impl<std::false_type>
3: -{
3: -    template<typename IterableX, typename IterableY>
3: -    bool operator()(const IterableX& x, const IterableY& y, const std::string& format)
3: -    {
3: +      typedef decltype(test < Derived > (nullptr)) type;
3: +      typedef decltype( & Fallback::operator ()) dtype;
3: +      static constexpr bool value = type::value;
3: +    } // an object is callable iff it defines operator()
3: +
3: +    template < typename T >
3: +    struct is_callable
3: +    {
3: +      // dispatch to is_callable_impl<true, T> or is_callable_impl<false, T> depending on whether T is of class type or not
3: +      typedef typename is_callable_impl < std::is_class < T > ::value, T > ::type type;
3: +    };
3: +
3: +    template < typename IsYDataCallable >
3: +    struct plot_impl {};
3: +
3: +    template < >
3: +    struct plot_impl < std::false_type >
3: +    {
3: +      template < typename IterableX, typename IterableY >
3: +      bool operator()(const IterableX & x, const IterableY & y, const std::string & format)
3: +      {
3: @@ -2387,3 +2599,3 @@
3: -        PyObject* xlist = PyList_New(xs);
3: -        PyObject* ylist = PyList_New(ys);
3: -        PyObject* pystring = PyString_FromString(format.c_str());
3: +        PyObject * xlist = PyList_New(xs);
3: +        PyObject * ylist = PyList_New(ys);
3: +        PyObject * pystring = PyString_FromString(format.c_str());
3: @@ -2392,3 +2604,3 @@
3: -        for(size_t i = 0; i < xs; ++i) {
3: -            PyList_SetItem(xlist, i, PyFloat_FromDouble(*itx++));
3: -            PyList_SetItem(ylist, i, PyFloat_FromDouble(*ity++));
3: +        for (size_t i = 0; i < xs; ++i) {
3: +          PyList_SetItem(xlist, i, PyFloat_FromDouble(*itx++));
3: +          PyList_SetItem(ylist, i, PyFloat_FromDouble(*ity++));
3: @@ -2397 +2609 @@
3: -        PyObject* plot_args = PyTuple_New(3);
3: +        PyObject * plot_args = PyTuple_New(3);
3: @@ -2402 +2614,2 @@
3: -        PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_plot, plot_args);
3: +        PyObject * res = PyObject_CallObject(
3: +          detail::_interpreter::get().s_python_function_plot, plot_args);
3: @@ -2405 +2618 @@
3: -        if(res) Py_DECREF(res);
3: +        if (res) {Py_DECREF(res);}
3: @@ -2408,10 +2621,10 @@
3: -    }
3: -};
3: -
3: -template<>
3: -struct plot_impl<std::true_type>
3: -{
3: -    template<typename Iterable, typename Callable>
3: -    bool operator()(const Iterable& ticks, const Callable& f, const std::string& format)
3: -    {
3: -        if(begin(ticks) == end(ticks)) return true;
3: +      }
3: +    }
3: +
3: +    template < >
3: +    struct plot_impl < std::true_type >
3: +    {
3: +      template < typename Iterable, typename Callable >
3: +      bool operator()(const Iterable & ticks, const Callable & f, const std::string & format)
3: +      {
3: +        if (begin(ticks) == end(ticks)) {return true;}
3: @@ -2421,7 +2634,9 @@
3: -        std::vector<double> y;
3: -        for(auto x : ticks) y.push_back(f(x));
3: -        return plot_impl<std::false_type>()(ticks,y,format);
3: -    }
3: -};
3: -
3: -} // end namespace detail
3: +        std::vector < double > y;
3: +        for (auto x : ticks) {
3: +          y.push_back(f(x));
3: +        }
3: +        return plot_impl < std::false_type > ()(ticks, y, format);
3: +      }
3: +    }
3: +
3: +  } // end namespace detail
3: @@ -2430,8 +2645,9 @@
3: -template<typename... Args>
3: -bool plot() { return true; }
3: -
3: -template<typename A, typename B, typename... Args>
3: -bool plot(const A& a, const B& b, const std::string& format, Args... args)
3: -{
3: -    return detail::plot_impl<typename detail::is_callable<B>::type>()(a,b,format) && plot(args...);
3: -}
3: +  template < typename ... Args >
3: +  bool plot() {return true;}
3: +
3: +  template < typename A, typename B, typename ... Args >
3: +  bool plot(const A & a, const B & b, const std::string & format, Args... args)
3: +  {
3: +    return detail::plot_impl < typename detail::is_callable < B > ::type > ()(a, b, format) && plot(
3: +      args ...);
3: +  }
3: @@ -2443,11 +2659,18 @@
3: -inline bool plot(const std::vector<double>& x, const std::vector<double>& y, const std::string& format = "") {
3: -    return plot<double,double>(x,y,format);
3: -}
3: -
3: -inline bool plot(const std::vector<double>& y, const std::string& format = "") {
3: -    return plot<double>(y,format);
3: -}
3: -
3: -inline bool plot(const std::vector<double>& x, const std::vector<double>& y, const std::map<std::string, std::string>& keywords) {
3: -    return plot<double>(x,y,keywords);
3: -}
3: +  inline bool plot(
3: +    const std::vector < double > & x, const std::vector < double > & y,
3: +    const std::string & format = "")
3: +  {
3: +    return plot < double, double > (x, y, format);
3: +  }
3: +
3: +  inline bool plot(const std::vector < double > & y, const std::string & format = "")
3: +  {
3: +    return plot < double > (y, format);
3: +  }
3: +
3: +  inline bool plot(
3: +    const std::vector < double > & x, const std::vector < double > & y,
3: +    const std::map < std::string, std::string > & keywords)
3: +  {
3: +    return plot < double > (x, y, keywords);
3: +  }
3: @@ -2458,2 +2681,2 @@
3: -class Plot
3: -{
3: +  class Plot
3: +  {
3: @@ -2462,16 +2685,56 @@
3: -    template<typename Numeric>
3: -    Plot(const std::string& name, const std::vector<Numeric>& x, const std::vector<Numeric>& y, const std::string& format = "") {
3: -        detail::_interpreter::get();
3: -
3: -        assert(x.size() == y.size());
3: -
3: -        PyObject* kwargs = PyDict_New();
3: -        if(name != "")
3: -            PyDict_SetItemString(kwargs, "label", PyString_FromString(name.c_str()));
3: -
3: -        PyObject* xarray = detail::get_array(x);
3: -        PyObject* yarray = detail::get_array(y);
3: -
3: -        PyObject* pystring = PyString_FromString(format.c_str());
3: -
3: -        PyObject* plot_args = PyTuple_New(3);
3: +    template < typename Numeric >
3: +    Plot(
3: +      const std::string & name, const std::vector < Numeric > &x,
3: +      const std::vector < Numeric > &y, const std::string & format = "") {
3: +      detail::_interpreter::get();
3: +
3: +      assert(x.size() == y.size());
3: +
3: +      PyObject * kwargs = PyDict_New();
3: +      if (name != "") {
3: +        PyDict_SetItemString(kwargs, "label", PyString_FromString(name.c_str()));
3: +      }
3: +
3: +      PyObject * xarray = detail::get_array(x);
3: +      PyObject * yarray = detail::get_array(y);
3: +
3: +      PyObject * pystring = PyString_FromString(format.c_str());
3: +
3: +      PyObject * plot_args = PyTuple_New(3);
3: +      PyTuple_SetItem(plot_args, 0, xarray);
3: +      PyTuple_SetItem(plot_args, 1, yarray);
3: +      PyTuple_SetItem(plot_args, 2, pystring);
3: +
3: +      PyObject * res = PyObject_Call(
3: +        detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);
3: +
3: +      Py_DECREF(kwargs);
3: +      Py_DECREF(plot_args);
3: +
3: +      if (res) {
3: +        line = PyList_GetItem(res, 0);
3: +
3: +        if (line) {
3: +          set_data_fct = PyObject_GetAttrString(line, "set_data");
3: +        } else {
3: +          Py_DECREF(line);
3: +        }
3: +        Py_DECREF(res);
3: +      }
3: +    }
3: +
3: +    // shorter initialization with name or format only
3: +    // basically calls line, = plot([], [])
3: +    Plot(const std::string & name = "", const std::string & format = "")
3: +      : Plot(name, std::vector < double > (), std::vector < double > (), format) {
3: +    }
3: +
3: +    template < typename Numeric >
3: +    bool update(const std::vector < Numeric > & x, const std::vector < Numeric > & y)
3: +    {
3: +      assert(x.size() == y.size());
3: +      if (set_data_fct) {
3: +        PyObject * xarray = detail::get_array(x);
3: +        PyObject * yarray = detail::get_array(y);
3: +
3: +        PyObject * plot_args = PyTuple_New(2);
3: @@ -2480,41 +2743,6 @@
3: -        PyTuple_SetItem(plot_args, 2, pystring);
3: -
3: -        PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);
3: -
3: -        Py_DECREF(kwargs);
3: -        Py_DECREF(plot_args);
3: -
3: -        if(res)
3: -        {
3: -            line= PyList_GetItem(res, 0);
3: -
3: -            if(line)
3: -                set_data_fct = PyObject_GetAttrString(line,"set_data");
3: -            else
3: -                Py_DECREF(line);
3: -            Py_DECREF(res);
3: -        }
3: -    }
3: -
3: -    // shorter initialization with name or format only
3: -    // basically calls line, = plot([], [])
3: -    Plot(const std::string& name = "", const std::string& format = "")
3: -        : Plot(name, std::vector<double>(), std::vector<double>(), format) {}
3: -
3: -    template<typename Numeric>
3: -    bool update(const std::vector<Numeric>& x, const std::vector<Numeric>& y) {
3: -        assert(x.size() == y.size());
3: -        if(set_data_fct)
3: -        {
3: -            PyObject* xarray = detail::get_array(x);
3: -            PyObject* yarray = detail::get_array(y);
3: -
3: -            PyObject* plot_args = PyTuple_New(2);
3: -            PyTuple_SetItem(plot_args, 0, xarray);
3: -            PyTuple_SetItem(plot_args, 1, yarray);
3: -
3: -            PyObject* res = PyObject_CallObject(set_data_fct, plot_args);
3: -            if (res) Py_DECREF(res);
3: -            return res;
3: -        }
3: -        return false;
3: +
3: +        PyObject * res = PyObject_CallObject(set_data_fct, plot_args);
3: +        if (res) {Py_DECREF(res);}
3: +        return res;
3: +      }
3: +      return false;
3: @@ -2524,2 +2752,3 @@
3: -    bool clear() {
3: -        return update(std::vector<double>(), std::vector<double>());
3: +    bool clear()
3: +    {
3: +      return update(std::vector < double > (), std::vector < double > ());
3: @@ -2529,9 +2758,9 @@
3: -    void remove() {
3: -        if(line)
3: -        {
3: -            auto remove_fct = PyObject_GetAttrString(line,"remove");
3: -            PyObject* args = PyTuple_New(0);
3: -            PyObject* res = PyObject_CallObject(remove_fct, args);
3: -            if (res) Py_DECREF(res);
3: -        }
3: -        decref();
3: +    void remove()
3: +    {
3: +      if (line) {
3: +        auto remove_fct = PyObject_GetAttrString(line, "remove");
3: +        PyObject * args = PyTuple_New(0);
3: +        PyObject * res = PyObject_CallObject(remove_fct, args);
3: +        if (res) {Py_DECREF(res);}
3: +      }
3: +      decref();
3: @@ -2541,2 +2770,3 @@
3: -        decref();
3: -    }
3: +      decref();
3: +    }
3: +
3: @@ -2544,12 +2774,14 @@
3: -
3: -    void decref() {
3: -        if(line)
3: -            Py_DECREF(line);
3: -        if(set_data_fct)
3: -            Py_DECREF(set_data_fct);
3: -    }
3: -
3: -
3: -    PyObject* line = nullptr;
3: -    PyObject* set_data_fct = nullptr;
3: -};
3: +    void decref()
3: +    {
3: +      if (line) {
3: +        Py_DECREF(line);
3: +      }
3: +      if (set_data_fct) {
3: +        Py_DECREF(set_data_fct);
3: +      }
3: +    }
3: +
3: +
3: +    PyObject * line = nullptr;
3: +    PyObject * set_data_fct = nullptr;
3: +  };
3: 
3: Code style divergence in file 'include/thirdParty/quadProgpp/Array.hh':
3: 
3: --- include/thirdParty/quadProgpp/Array.hh
3: +++ include/thirdParty/quadProgpp/Array.hh.uncrustify
3: @@ -4 +4 @@
3: -// Copyright (C) 2001--2008 Andrea Schaerf, Luca Di Gaspero. 
3: +// Copyright (C) 2001--2008 Andrea Schaerf, Luca Di Gaspero.
3: @@ -21,113 +21,121 @@
3: -enum MType { DIAG };
3: -
3: -template <typename T>
3: -class Vector
3: -{
3: -public: 
3: -  Vector(); 
3: -  Vector(const unsigned int n);  
3: -  Vector(const T& a, const unsigned int n); //initialize to constant value 
3: -  Vector(const T* a, const unsigned int n); // Initialize to array 
3: -  Vector(const Vector &rhs); // copy constructor 
3: -  ~Vector(); // destructor
3: -	
3: -  inline void set(const T* a, const unsigned int n);
3: -  Vector<T> extract(const std::set<unsigned int>& indexes) const;
3: -  inline T& operator[](const unsigned int& i); //i-th element 
3: -  inline const T& operator[](const unsigned int& i) const; 
3: -	
3: -  inline unsigned int size() const;
3: -  inline void resize(const unsigned int n);
3: -  inline void resize(const T& a, const unsigned int n);
3: -	
3: -  Vector<T>& operator=(const Vector<T>& rhs); //assignment 
3: -  Vector<T>& operator=(const T& a); //assign a to every element 
3: -  inline Vector<T>& operator+=(const Vector<T>& rhs);
3: -  inline Vector<T>& operator-=(const Vector<T>& rhs);
3: -  inline Vector<T>& operator*=(const Vector<T>& rhs);
3: -  inline Vector<T>& operator/=(const Vector<T>& rhs);
3: -  inline Vector<T>& operator^=(const Vector<T>& rhs);
3: -  inline Vector<T>& operator+=(const T& a);
3: -  inline Vector<T>& operator-=(const T& a);
3: -  inline Vector<T>& operator*=(const T& a);
3: -  inline Vector<T>& operator/=(const T& a);
3: -  inline Vector<T>& operator^=(const T& a);
3: -private: 
3: -  unsigned int n; // size of array. upper index is n-1 
3: -  T* v; // storage for data
3: -}; 
3: -
3: -template <typename T> 
3: -Vector<T>::Vector() 
3: -  : n(0), v(0) 
3: -{} 
3: -
3: -template <typename T> 
3: -Vector<T>::Vector(const unsigned int n) 
3: -  : v(new T[n]) 
3: -{
3: -  this->n = n;
3: -} 
3: -
3: -template <typename T> 
3: -Vector<T>::Vector(const T& a, const unsigned int n) 
3: -  : v(new T[n])
3: -{ 
3: -  this->n = n;
3: -  for (unsigned int i = 0; i < n; i++) 
3: -    v[i] = a; 
3: -} 
3: -
3: -template <typename T> 
3: -Vector<T>::Vector(const T* a, const unsigned int n) 
3: -  : v(new T[n])
3: -{ 
3: -  this->n = n;
3: -  for (unsigned int i = 0; i < n; i++) 
3: -    v[i] = *a++; 
3: -} 
3: -
3: -template <typename T> 
3: -Vector<T>::Vector(const Vector<T>& rhs) 
3: -  : v(new T[rhs.n])
3: -{ 
3: -  this->n = rhs.n;
3: -  for (unsigned int	i = 0; i < n; i++) 
3: -    v[i] = rhs[i]; 
3: -} 
3: -
3: -template <typename T> 
3: -Vector<T>::~Vector() 
3: -{ 
3: -  if (v != 0) 
3: -    delete[] (v); 
3: -} 
3: -
3: -template <typename T> 
3: -void Vector<T>::resize(const unsigned int n) 
3: -{
3: -  if (n == this->n)
3: -    return;
3: -  if (v != 0) 
3: -    delete[] (v); 
3: -  v = new T[n];
3: -  this->n = n;
3: -} 
3: -
3: -template <typename T> 
3: -void Vector<T>::resize(const T& a, const unsigned int n) 
3: -{
3: -  resize(n);
3: -  for (unsigned int i = 0; i < n; i++)
3: -    v[i] = a;
3: -} 
3: -
3: -
3: -template <typename T> 
3: -inline Vector<T>& Vector<T>::operator=(const Vector<T>& rhs) 
3: -// postcondition: normal assignment via copying has been performed; 
3: -// if vector and rhs were different sizes, vector 
3: -// has been resized to match the size of rhs 
3: -{ 
3: -  if (this != &rhs) 
3: -    { 
3: +  enum MType { DIAG };
3: +
3: +  template < typename T >
3: +  class Vector
3: +  {
3: +public:
3: +    Vector();
3: +    Vector(const unsigned int n);
3: +    Vector(const T & a, const unsigned int n); //initialize to constant value
3: +    Vector(const T * a, const unsigned int n); // Initialize to array
3: +    Vector(const Vector & rhs); // copy constructor
3: +    ~Vector(); // destructor
3: +
3: +    inline void set(const T * a, const unsigned int n);
3: +    Vector < T > extract(const std::set < unsigned int > &indexes) const;
3: +    inline T & operator[] (const unsigned int & i); //i-th element
3: +    inline const T & operator[] (const unsigned int & i) const;
3: +
3: +    inline unsigned int size() const;
3: +    inline void resize(const unsigned int n);
3: +    inline void resize(const T & a, const unsigned int n);
3: +
3: +    Vector < T > & operator = (const Vector < T > &rhs); //assignment
3: +    Vector < T > & operator = (const T & a); //assign a to every element
3: +    inline Vector < T > & operator += (const Vector < T > &rhs);
3: +    inline Vector < T > & operator -= (const Vector < T > &rhs);
3: +    inline Vector < T > & operator *= (const Vector < T > &rhs);
3: +    inline Vector < T > & operator /= (const Vector < T > &rhs);
3: +    inline Vector < T > & operator ^= (const Vector < T > &rhs);
3: +    inline Vector < T > & operator += (const T & a);
3: +    inline Vector < T > & operator -= (const T & a);
3: +    inline Vector < T > & operator *= (const T & a);
3: +    inline Vector < T > & operator /= (const T & a);
3: +    inline Vector < T > & operator ^= (const T & a);
3: +
3: +private:
3: +    unsigned int n; // size of array. upper index is n-1
3: +    T * v; // storage for data
3: +  };
3: +
3: +  template < typename T >
3: +  Vector < T > ::Vector()
3: +    : n(0), v(0)
3: +  {
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > ::Vector(const unsigned int n)
3: +    : v(new T[n])
3: +  {
3: +    this->n = n;
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > ::Vector(const T & a, const unsigned int n)
3: +    : v(new T[n])
3: +  {
3: +    this->n = n;
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] = a;
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > ::Vector(const T * a, const unsigned int n)
3: +    : v(new T[n])
3: +  {
3: +    this->n = n;
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] = *a++;
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > ::Vector(const Vector < T > &rhs)
3: +    : v(new T[rhs.n])
3: +  {
3: +    this->n = rhs.n;
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] = rhs[i];
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > ::~Vector()
3: +  {
3: +    if (v != 0) {
3: +      delete[] (v);
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  void Vector < T > ::resize(const unsigned int n)
3: +  {
3: +    if (n == this->n) {
3: +      return;
3: +    }
3: +    if (v != 0) {
3: +      delete[] (v);
3: +    }
3: +    v = new T[n];
3: +    this->n = n;
3: +  }
3: +
3: +  template < typename T >
3: +  void Vector < T > ::resize(const T & a, const unsigned int n)
3: +  {
3: +    resize(n);
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] = a;
3: +    }
3: +  }
3: +
3: +
3: +  template < typename T >
3: +  inline Vector < T > & Vector < T > ::operator = (const Vector < T > &rhs)
3: +// postcondition: normal assignment via copying has been performed;
3: +// if vector and rhs were different sizes, vector
3: +// has been resized to match the size of rhs
3: +  {
3: +    if (this != &rhs) {
3: @@ -135,47 +143,51 @@
3: -      for (unsigned int i = 0; i < n; i++) 
3: -	v[i] = rhs[i]; 
3: -    } 
3: -  return *this; 
3: -} 
3: -
3: -template <typename T> 
3: -inline Vector<T> & Vector<T>::operator=(const T& a) //assign a to every element 
3: -{ 
3: -  for (unsigned int i = 0; i < n; i++) 
3: -    v[i] = a; 
3: -  return *this; 
3: -} 
3: -
3: -template <typename T> 
3: -inline T & Vector<T>::operator[](const unsigned int& i) //subscripting 
3: -{ 
3: -  return v[i]; 
3: -}
3: -
3: -template <typename T>
3: -inline const T& Vector<T>::operator[](const unsigned int& i) const //subscripting 
3: -{ 
3: -  return v[i]; 
3: -} 
3: -
3: -template <typename T> 
3: -inline unsigned int Vector<T>::size() const 
3: -{ 
3: -  return n; 
3: -}
3: -
3: -template <typename T> 
3: -inline void Vector<T>::set(const T* a, unsigned int n) 
3: -{ 
3: -  resize(n);
3: -  for (unsigned int i = 0; i < n; i++) 
3: -    v[i] = a[i]; 
3: -} 
3: -
3: -template <typename T> 
3: -inline Vector<T> Vector<T>::extract(const std::set<unsigned int>& indexes) const
3: -{
3: -  Vector<T> tmp(indexes.size());
3: -  unsigned int i = 0;
3: -	
3: -  for (std::set<unsigned int>::const_iterator el = indexes.begin(); el != indexes.end(); el++)
3: +      for (unsigned int i = 0; i < n; i++) {
3: +        v[i] = rhs[i];
3: +      }
3: +    }
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > & Vector < T > ::operator = (const T & a) //assign a to every element
3: +  {
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] = a;
3: +    }
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  inline T & Vector < T > ::operator[] (const unsigned int & i) //subscripting
3: +  {
3: +    return v[i];
3: +  }
3: +
3: +  template < typename T >
3: +  inline const T & Vector < T > ::operator[] (const unsigned int & i) const //subscripting
3: +  {
3: +    return v[i];
3: +  }
3: +
3: +  template < typename T >
3: +  inline unsigned int Vector < T > ::size() const
3: +  {
3: +    return n;
3: +  }
3: +
3: +  template < typename T >
3: +  inline void Vector < T > ::set(const T * a, unsigned int n)
3: +  {
3: +    resize(n);
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] = a[i];
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > Vector < T > ::extract(const std::set < unsigned int > &indexes) const
3: +  {
3: +    Vector < T > tmp(indexes.size());
3: +    unsigned int i = 0;
3: +
3: +    for (std::set < unsigned int > ::const_iterator el = indexes.begin(); el != indexes.end();
3: +      el++)
3: @@ -183,2 +195,3 @@
3: -      if (*el >= n)
3: -	throw std::logic_error("Error extracting subvector: the indexes are out of vector bounds");
3: +      if (*el >= n) {
3: +        throw std::logic_error("Error extracting subvector: the indexes are out of vector bounds");
3: +      }
3: @@ -187,345 +200,398 @@
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T> 
3: -inline Vector<T>& Vector<T>::operator+=(const Vector<T>& rhs)
3: -{
3: -  if (this->size() != rhs.size())
3: -    throw std::logic_error("Operator+=: vectors have different sizes");
3: -  for (unsigned int i = 0; i < n; i++)
3: -    v[i] += rhs[i];
3: -	
3: -  return *this;
3: -}
3: -
3: -
3: -template <typename T> 
3: -inline Vector<T>& Vector<T>::operator+=(const T& a)
3: -{
3: -  for (unsigned int i = 0; i < n; i++)
3: -    v[i] += a;
3: -	
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator+(const Vector<T>& rhs)
3: -{
3: -  return rhs;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator+(const Vector<T>& lhs, const Vector<T>& rhs)
3: -{
3: -  if (lhs.size() != rhs.size())
3: -    throw std::logic_error("Operator+: vectors have different sizes");
3: -  Vector<T> tmp(lhs.size());
3: -  for (unsigned int i = 0; i < lhs.size(); i++)
3: -    tmp[i] = lhs[i] + rhs[i];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator+(const Vector<T>& lhs, const T& a)
3: -{
3: -  Vector<T> tmp(lhs.size());
3: -  for (unsigned int i = 0; i < lhs.size(); i++)
3: -    tmp[i] = lhs[i] + a;
3: -		
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator+(const T& a, const Vector<T>& rhs)
3: -{
3: -  Vector<T> tmp(rhs.size());
3: -  for (unsigned int i = 0; i < rhs.size(); i++)
3: -    tmp[i] = a + rhs[i];
3: -		
3: -  return tmp;
3: -}
3: -
3: -template <typename T> 
3: -inline Vector<T>& Vector<T>::operator-=(const Vector<T>& rhs)
3: -{
3: -  if (this->size() != rhs.size())
3: -    throw std::logic_error("Operator-=: vectors have different sizes");
3: -  for (unsigned int i = 0; i < n; i++)
3: -    v[i] -= rhs[i];
3: -	
3: -  return *this;
3: -}
3: -
3: -
3: -template <typename T> 
3: -inline Vector<T>& Vector<T>::operator-=(const T& a)
3: -{
3: -  for (unsigned int i = 0; i < n; i++)
3: -    v[i] -= a;
3: -	
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator-(const Vector<T>& rhs)
3: -{
3: -  return (T)(-1) * rhs;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator-(const Vector<T>& lhs, const Vector<T>& rhs)
3: -{
3: -  if (lhs.size() != rhs.size())
3: -    throw std::logic_error("Operator-: vectors have different sizes");
3: -  Vector<T> tmp(lhs.size());
3: -  for (unsigned int i = 0; i < lhs.size(); i++)
3: -    tmp[i] = lhs[i] - rhs[i];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator-(const Vector<T>& lhs, const T& a)
3: -{
3: -  Vector<T> tmp(lhs.size());
3: -  for (unsigned int i = 0; i < lhs.size(); i++)
3: -    tmp[i] = lhs[i] - a;
3: -		
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator-(const T& a, const Vector<T>& rhs)
3: -{
3: -  Vector<T> tmp(rhs.size());
3: -  for (unsigned int i = 0; i < rhs.size(); i++)
3: -    tmp[i] = a - rhs[i];
3: -		
3: -  return tmp;
3: -}
3: -
3: -template <typename T> 
3: -inline Vector<T>& Vector<T>::operator*=(const Vector<T>& rhs)
3: -{
3: -  if (this->size() != rhs.size())
3: -    throw std::logic_error("Operator*=: vectors have different sizes");
3: -  for (unsigned int i = 0; i < n; i++)
3: -    v[i] *= rhs[i];
3: -	
3: -  return *this;
3: -}
3: -
3: -
3: -template <typename T> 
3: -inline Vector<T>& Vector<T>::operator*=(const T& a)
3: -{
3: -  for (unsigned int i = 0; i < n; i++)
3: -    v[i] *= a;
3: -	
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator*(const Vector<T>& lhs, const Vector<T>& rhs)
3: -{
3: -  if (lhs.size() != rhs.size())
3: -    throw std::logic_error("Operator*: vectors have different sizes");
3: -  Vector<T> tmp(lhs.size());
3: -  for (unsigned int i = 0; i < lhs.size(); i++)
3: -    tmp[i] = lhs[i] * rhs[i];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator*(const Vector<T>& lhs, const T& a)
3: -{
3: -  Vector<T> tmp(lhs.size());
3: -  for (unsigned int i = 0; i < lhs.size(); i++)
3: -    tmp[i] = lhs[i] * a;
3: -		
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator*(const T& a, const Vector<T>& rhs)
3: -{
3: -  Vector<T> tmp(rhs.size());
3: -  for (unsigned int i = 0; i < rhs.size(); i++)
3: -    tmp[i] = a * rhs[i];
3: -		
3: -  return tmp;
3: -}
3: -
3: -template <typename T> 
3: -inline Vector<T>& Vector<T>::operator/=(const Vector<T>& rhs)
3: -{
3: -  if (this->size() != rhs.size())
3: -    throw std::logic_error("Operator/=: vectors have different sizes");
3: -  for (unsigned int i = 0; i < n; i++)
3: -    v[i] /= rhs[i];
3: -	
3: -  return *this;
3: -}
3: -
3: -
3: -template <typename T> 
3: -inline Vector<T>& Vector<T>::operator/=(const T& a)
3: -{
3: -  for (unsigned int i = 0; i < n; i++)
3: -    v[i] /= a;
3: -	
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator/(const Vector<T>& lhs, const Vector<T>& rhs)
3: -{
3: -  if (lhs.size() != rhs.size())
3: -    throw std::logic_error("Operator/: vectors have different sizes");
3: -  Vector<T> tmp(lhs.size());
3: -  for (unsigned int i = 0; i < lhs.size(); i++)
3: -    tmp[i] = lhs[i] / rhs[i];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator/(const Vector<T>& lhs, const T& a)
3: -{
3: -  Vector<T> tmp(lhs.size());
3: -  for (unsigned int i = 0; i < lhs.size(); i++)
3: -    tmp[i] = lhs[i] / a;
3: -		
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator/(const T& a, const Vector<T>& rhs)
3: -{
3: -  Vector<T> tmp(rhs.size());
3: -  for (unsigned int i = 0; i < rhs.size(); i++)
3: -    tmp[i] = a / rhs[i];
3: -		
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator^(const Vector<T>& lhs, const Vector<T>& rhs)
3: -{
3: -  if (lhs.size() != rhs.size())
3: -    throw std::logic_error("Operator^: vectors have different sizes");
3: -  Vector<T> tmp(lhs.size());
3: -  for (unsigned int i = 0; i < lhs.size(); i++)
3: -    tmp[i] = pow(lhs[i], rhs[i]);
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator^(const Vector<T>& lhs, const T& a)
3: -{
3: -  Vector<T> tmp(lhs.size());
3: -  for (unsigned int i = 0; i < lhs.size(); i++)
3: -    tmp[i] = pow(lhs[i], a);
3: -		
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> operator^(const T& a, const Vector<T>& rhs)
3: -{
3: -  Vector<T> tmp(rhs.size());
3: -  for (unsigned int i = 0; i < rhs.size(); i++)
3: -    tmp[i] = pow(a, rhs[i]);
3: -		
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T>& Vector<T>::operator^=(const Vector<T>& rhs)
3: -{
3: -  if (this->size() != rhs.size())
3: -    throw std::logic_error("Operator^=: vectors have different sizes");
3: -  for (unsigned int i = 0; i < n; i++)
3: -    v[i] = pow(v[i], rhs[i]);
3: -		
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T>& Vector<T>::operator^=(const T& a)
3: -{
3: -  for (unsigned int i = 0; i < n; i++)
3: -    v[i] = pow(v[i], a);
3: -		
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -inline bool operator==(const Vector<T>& v, const Vector<T>& w)
3: -{
3: -  if (v.size() != w.size())
3: -    throw std::logic_error("Vectors of different size are not confrontable");
3: -  for (unsigned i = 0; i < v.size(); i++)
3: -    if (v[i] != w[i])
3: -      return false;
3: -  return true;
3: -}
3: -
3: -template <typename T>
3: -inline bool operator!=(const Vector<T>& v, const Vector<T>& w)
3: -{
3: -  if (v.size() != w.size())
3: -    throw std::logic_error("Vectors of different size are not confrontable");
3: -  for (unsigned i = 0; i < v.size(); i++)
3: -    if (v[i] != w[i])
3: -      return true;
3: -  return false;
3: -}
3: -
3: -template <typename T>
3: -inline bool operator<(const Vector<T>& v, const Vector<T>& w)
3: -{
3: -  if (v.size() != w.size())
3: -    throw std::logic_error("Vectors of different size are not confrontable");
3: -  for (unsigned i = 0; i < v.size(); i++)
3: -    if (v[i] >= w[i])
3: -      return false;
3: -  return true;
3: -}
3: -
3: -template <typename T>
3: -inline bool operator<=(const Vector<T>& v, const Vector<T>& w)
3: -{
3: -  if (v.size() != w.size())
3: -    throw std::logic_error("Vectors of different size are not confrontable");
3: -  for (unsigned i = 0; i < v.size(); i++)
3: -    if (v[i] > w[i])
3: -      return false;
3: -  return true;
3: -}
3: -
3: -template <typename T>
3: -inline bool operator>(const Vector<T>& v, const Vector<T>& w)
3: -{
3: -  if (v.size() != w.size())
3: -    throw std::logic_error("Vectors of different size are not confrontable");
3: -  for (unsigned i = 0; i < v.size(); i++)
3: -    if (v[i] <= w[i])
3: -      return false;
3: -  return true;
3: -}
3: -
3: -template <typename T>
3: -inline bool operator>=(const Vector<T>& v, const Vector<T>& w)
3: -{
3: -  if (v.size() != w.size())
3: -    throw std::logic_error("Vectors of different size are not confrontable");
3: -  for (unsigned i = 0; i < v.size(); i++)
3: -    if (v[i] < w[i])
3: -      return false;
3: -  return true;
3: -}
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > & Vector < T > ::operator += (const Vector < T > &rhs)
3: +  {
3: +    if (this->size() != rhs.size()) {
3: +      throw std::logic_error("Operator+=: vectors have different sizes");
3: +    }
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] += rhs[i];
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +
3: +  template < typename T >
3: +  inline Vector < T > & Vector < T > ::operator += (const T & a)
3: +  {
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] += a;
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator + (const Vector < T > &rhs)
3: +  {
3: +    return rhs;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator + (const Vector < T > &lhs, const Vector < T > &rhs)
3: +  {
3: +    if (lhs.size() != rhs.size()) {
3: +      throw std::logic_error("Operator+: vectors have different sizes");
3: +    }
3: +    Vector < T > tmp(lhs.size());
3: +    for (unsigned int i = 0; i < lhs.size(); i++) {
3: +      tmp[i] = lhs[i] + rhs[i];
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator + (const Vector < T > &lhs, const T & a)
3: +  {
3: +    Vector < T > tmp(lhs.size());
3: +    for (unsigned int i = 0; i < lhs.size(); i++) {
3: +      tmp[i] = lhs[i] + a;
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator + (const T & a, const Vector < T > &rhs)
3: +  {
3: +    Vector < T > tmp(rhs.size());
3: +    for (unsigned int i = 0; i < rhs.size(); i++) {
3: +      tmp[i] = a + rhs[i];
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > & Vector < T > ::operator -= (const Vector < T > &rhs)
3: +  {
3: +    if (this->size() != rhs.size()) {
3: +      throw std::logic_error("Operator-=: vectors have different sizes");
3: +    }
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] -= rhs[i];
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +
3: +  template < typename T >
3: +  inline Vector < T > & Vector < T > ::operator -= (const T & a)
3: +  {
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] -= a;
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator - (const Vector < T > &rhs)
3: +  {
3: +    return (T)(-1) * rhs;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator - (const Vector < T > &lhs, const Vector < T > &rhs)
3: +  {
3: +    if (lhs.size() != rhs.size()) {
3: +      throw std::logic_error("Operator-: vectors have different sizes");
3: +    }
3: +    Vector < T > tmp(lhs.size());
3: +    for (unsigned int i = 0; i < lhs.size(); i++) {
3: +      tmp[i] = lhs[i] - rhs[i];
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator - (const Vector < T > &lhs, const T & a)
3: +  {
3: +    Vector < T > tmp(lhs.size());
3: +    for (unsigned int i = 0; i < lhs.size(); i++) {
3: +      tmp[i] = lhs[i] - a;
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator - (const T & a, const Vector < T > &rhs)
3: +  {
3: +    Vector < T > tmp(rhs.size());
3: +    for (unsigned int i = 0; i < rhs.size(); i++) {
3: +      tmp[i] = a - rhs[i];
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > & Vector < T > ::operator *= (const Vector < T > &rhs)
3: +  {
3: +    if (this->size() != rhs.size()) {
3: +      throw std::logic_error("Operator*=: vectors have different sizes");
3: +    }
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] *= rhs[i];
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +
3: +  template < typename T >
3: +  inline Vector < T > & Vector < T > ::operator *= (const T & a)
3: +  {
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] *= a;
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator * (const Vector < T > &lhs, const Vector < T > &rhs)
3: +  {
3: +    if (lhs.size() != rhs.size()) {
3: +      throw std::logic_error("Operator*: vectors have different sizes");
3: +    }
3: +    Vector < T > tmp(lhs.size());
3: +    for (unsigned int i = 0; i < lhs.size(); i++) {
3: +      tmp[i] = lhs[i] * rhs[i];
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator * (const Vector < T > &lhs, const T & a)
3: +  {
3: +    Vector < T > tmp(lhs.size());
3: +    for (unsigned int i = 0; i < lhs.size(); i++) {
3: +      tmp[i] = lhs[i] * a;
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator * (const T & a, const Vector < T > &rhs)
3: +  {
3: +    Vector < T > tmp(rhs.size());
3: +    for (unsigned int i = 0; i < rhs.size(); i++) {
3: +      tmp[i] = a * rhs[i];
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > & Vector < T > ::operator /= (const Vector < T > &rhs)
3: +  {
3: +    if (this->size() != rhs.size()) {
3: +      throw std::logic_error("Operator/=: vectors have different sizes");
3: +    }
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] /= rhs[i];
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +
3: +  template < typename T >
3: +  inline Vector < T > & Vector < T > ::operator /= (const T & a)
3: +  {
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] /= a;
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator / (const Vector < T > &lhs, const Vector < T > &rhs)
3: +  {
3: +    if (lhs.size() != rhs.size()) {
3: +      throw std::logic_error("Operator/: vectors have different sizes");
3: +    }
3: +    Vector < T > tmp(lhs.size());
3: +    for (unsigned int i = 0; i < lhs.size(); i++) {
3: +      tmp[i] = lhs[i] / rhs[i];
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator / (const Vector < T > &lhs, const T & a)
3: +  {
3: +    Vector < T > tmp(lhs.size());
3: +    for (unsigned int i = 0; i < lhs.size(); i++) {
3: +      tmp[i] = lhs[i] / a;
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator / (const T & a, const Vector < T > &rhs)
3: +  {
3: +    Vector < T > tmp(rhs.size());
3: +    for (unsigned int i = 0; i < rhs.size(); i++) {
3: +      tmp[i] = a / rhs[i];
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator ^ (const Vector < T > &lhs, const Vector < T > &rhs)
3: +  {
3: +    if (lhs.size() != rhs.size()) {
3: +      throw std::logic_error("Operator^: vectors have different sizes");
3: +    }
3: +    Vector < T > tmp(lhs.size());
3: +    for (unsigned int i = 0; i < lhs.size(); i++) {
3: +      tmp[i] = pow(lhs[i], rhs[i]);
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator ^ (const Vector < T > &lhs, const T & a)
3: +  {
3: +    Vector < T > tmp(lhs.size());
3: +    for (unsigned int i = 0; i < lhs.size(); i++) {
3: +      tmp[i] = pow(lhs[i], a);
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > operator ^ (const T & a, const Vector < T > &rhs)
3: +  {
3: +    Vector < T > tmp(rhs.size());
3: +    for (unsigned int i = 0; i < rhs.size(); i++) {
3: +      tmp[i] = pow(a, rhs[i]);
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > & Vector < T > ::operator ^= (const Vector < T > &rhs)
3: +  {
3: +    if (this->size() != rhs.size()) {
3: +      throw std::logic_error("Operator^=: vectors have different sizes");
3: +    }
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] = pow(v[i], rhs[i]);
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > & Vector < T > ::operator ^= (const T & a)
3: +  {
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      v[i] = pow(v[i], a);
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  inline bool operator == (const Vector < T > &v, const Vector < T > &w)
3: +  {
3: +    if (v.size() != w.size()) {
3: +      throw std::logic_error("Vectors of different size are not confrontable");
3: +    }
3: +    for (unsigned i = 0; i < v.size(); i++) {
3: +      if (v[i] != w[i]) {
3: +        return false;
3: +      }
3: +    }
3: +    return true;
3: +  }
3: +
3: +  template < typename T >
3: +  inline bool operator != (const Vector < T > &v, const Vector < T > &w)
3: +  {
3: +    if (v.size() != w.size()) {
3: +      throw std::logic_error("Vectors of different size are not confrontable");
3: +    }
3: +    for (unsigned i = 0; i < v.size(); i++) {
3: +      if (v[i] != w[i]) {
3: +        return true;
3: +      }
3: +    }
3: +    return false;
3: +  }
3: +
3: +  template < typename T >
3: +  inline bool operator < (const Vector < T > &v, const Vector < T > &w)
3: +  {
3: +    if (v.size() != w.size()) {
3: +      throw std::logic_error("Vectors of different size are not confrontable");
3: +    }
3: +    for (unsigned i = 0; i < v.size(); i++) {
3: +      if (v[i] >= w[i]) {
3: +        return false;
3: +      }
3: +    }
3: +    return true;
3: +  }
3: +
3: +  template < typename T >
3: +  inline bool operator <= (const Vector < T > &v, const Vector < T > &w)
3: +  {
3: +    if (v.size() != w.size()) {
3: +      throw std::logic_error("Vectors of different size are not confrontable");
3: +    }
3: +    for (unsigned i = 0; i < v.size(); i++) {
3: +      if (v[i] > w[i]) {
3: +        return false;
3: +      }
3: +    }
3: +    return true;
3: +  }
3: +
3: +  template < typename T >
3: +  inline bool operator > (const Vector < T > &v, const Vector < T > &w)
3: +  {
3: +    if (v.size() != w.size()) {
3: +      throw std::logic_error("Vectors of different size are not confrontable");
3: +    }
3: +    for (unsigned i = 0; i < v.size(); i++) {
3: +      if (v[i] <= w[i]) {
3: +        return false;
3: +      }
3: +    }
3: +    return true;
3: +  }
3: +
3: +  template < typename T >
3: +  inline bool operator >= (const Vector < T > &v, const Vector < T > &w)
3: +  {
3: +    if (v.size() != w.size()) {
3: +      throw std::logic_error("Vectors of different size are not confrontable");
3: +    }
3: +    for (unsigned i = 0; i < v.size(); i++) {
3: +      if (v[i] < w[i]) {
3: +        return false;
3: +      }
3: +    }
3: +    return true;
3: +  }
3: @@ -534 +600 @@
3: -   Input/Output 
3: +   Input/Output
3: @@ -536,35 +602,37 @@
3: -template <typename T>
3: -inline std::ostream& operator<<(std::ostream& os, const Vector<T>& v)
3: -{
3: -  os << std::endl << v.size() << std::endl;
3: -  for (unsigned int i = 0; i < v.size() - 1; i++)
3: -    os << std::setw(20) << std::setprecision(16) << v[i] << ", ";
3: -  os << std::setw(20) << std::setprecision(16) << v[v.size() - 1] << std::endl;
3: -	
3: -  return os;
3: -}
3: -
3: -template <typename T>
3: -std::istream& operator>>(std::istream& is, Vector<T>& v)
3: -{
3: -  int elements;
3: -  char comma;
3: -  is >> elements;
3: -  v.resize(elements);
3: -  for (unsigned int i = 0; i < elements; i++)
3: -    is >> v[i] >> comma;
3: -	
3: -  return is;
3: -}
3: -
3: -/**
3: -   Index utilities
3: -*/
3: -
3: -std::set<unsigned int> seq(unsigned int s, unsigned int e);
3: -
3: -std::set<unsigned int> singleton(unsigned int i);
3: -
3: -template <typename T>
3: -class CanonicalBaseVector : public Vector<T>
3: -{
3: +  template < typename T >
3: +  inline std::ostream & operator << (std::ostream & os, const Vector < T > &v)
3: +      {
3: +      os << std::endl << v.size() << std::endl;
3: +      for (unsigned int i = 0; i < v.size() - 1; i++) {
3: +        os << std::setw(20) << std::setprecision(16) << v[i] << ", ";
3: +      }
3: +      os << std::setw(20) << std::setprecision(16) << v[v.size() - 1] << std::endl;
3: +
3: +      return os;
3: +    }
3: +
3: +    template < typename T >
3: +    std::istream & operator >> (std::istream & is, Vector < T > &v)
3: +      {
3: +      int elements;
3: +      char comma;
3: +      is >> elements;
3: +      v.resize(elements);
3: +      for (unsigned int i = 0; i < elements; i++) {
3: +        is >> v[i] >> comma;
3: +      }
3: +
3: +      return is;
3: +    }
3: +
3: +    /**
3: +       Index utilities
3: +    */
3: +
3: +    std::set < unsigned int > seq(unsigned int s, unsigned int e);
3: +
3: +  std::set < unsigned int > singleton(unsigned int i);
3: +
3: +  template < typename T >
3: +  class CanonicalBaseVector: public Vector < T >
3: +  {
3: @@ -572,2 +640,3 @@
3: -  CanonicalBaseVector(unsigned int i, unsigned int n);
3: -  inline void reset(unsigned int i);
3: +    CanonicalBaseVector(unsigned int i, unsigned int n);
3: +    inline void reset(unsigned int i);
3: +
3: @@ -575,15 +644,17 @@
3: -  unsigned int e;
3: -};
3: -
3: -template <typename T>
3: -CanonicalBaseVector<T>::CanonicalBaseVector(unsigned int i, unsigned int n)
3: -  : Vector<T>((T)0, n), e(i)
3: -{ (*this)[e] = (T)1; }
3: -
3: -template <typename T>
3: -inline void CanonicalBaseVector<T>::reset(unsigned int i)
3: -{ 
3: -  (*this)[e] = (T)0; 
3: -  e = i; 
3: -  (*this)[e] = (T)1;
3: -}
3: +    unsigned int e;
3: +  }
3: +
3: +  template < typename T >
3: +  CanonicalBaseVector < T > ::CanonicalBaseVector(unsigned int i, unsigned int n)
3: +    : Vector < T > ((T)0, n), e(i)
3: +  {
3: +    (*this)[e] = (T)1;
3: +  }
3: +
3: +  template < typename T >
3: +  inline void CanonicalBaseVector < T > ::reset(unsigned int i)
3: +  {
3: +    (*this)[e] = (T)0;
3: +    e = i;
3: +    (*this)[e] = (T)1;
3: +  }
3: @@ -593,52 +664,55 @@
3: -template <typename T>
3: -inline T sum(const Vector<T>& v)
3: -{
3: -  T tmp = (T)0;
3: -  for (unsigned int i = 0; i < v.size(); i++)
3: -    tmp += v[i];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline T prod(const Vector<T>& v)
3: -{
3: -  T tmp = (T)1;
3: -  for (unsigned int i = 0; i < v.size(); i++)
3: -    tmp *= v[i];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline T mean(const Vector<T>& v)
3: -{
3: -  T sum = (T)0;
3: -  for (unsigned int i = 0; i < v.size(); i++)
3: -    sum += v[i];
3: -  return sum / v.size();
3: -}
3: -
3: -template <typename T>
3: -inline T median(const Vector<T>& v)
3: -{
3: -  Vector<T> tmp = sort(v);
3: -  if (v.size() % 2 == 1) // it is an odd-sized vector
3: -    return tmp[v.size() / 2];
3: -  else
3: -    return 0.5 * (tmp[v.size() / 2 - 1] + tmp[v.size() / 2]);
3: -}
3: -
3: -template <typename T>
3: -inline T stdev(const Vector<T>& v, bool sample_correction = false)
3: -{
3: -  return sqrt(var(v, sample_correction));
3: -}
3: -
3: -template <typename T>
3: -inline T var(const Vector<T>& v, bool sample_correction = false)
3: -{
3: -  T sum = (T)0, ssum = (T)0;
3: -  unsigned int n = v.size();
3: -  for (unsigned int i = 0; i < n; i++)
3: -    {	
3: +  template < typename T >
3: +  inline T sum(const Vector < T > & v)
3: +  {
3: +    T tmp = (T)0;
3: +    for (unsigned int i = 0; i < v.size(); i++) {
3: +      tmp += v[i];
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline T prod(const Vector < T > & v)
3: +  {
3: +    T tmp = (T)1;
3: +    for (unsigned int i = 0; i < v.size(); i++) {
3: +      tmp *= v[i];
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline T mean(const Vector < T > & v)
3: +  {
3: +    T sum = (T)0;
3: +    for (unsigned int i = 0; i < v.size(); i++) {
3: +      sum += v[i];
3: +    }
3: +    return sum / v.size();
3: +  }
3: +
3: +  template < typename T >
3: +  inline T median(const Vector < T > & v)
3: +  {
3: +    Vector < T > tmp = sort(v);
3: +    if (v.size() % 2 == 1) { // it is an odd-sized vector
3: +      return tmp[v.size() / 2];
3: +    } else {
3: +      return 0.5 * (tmp[v.size() / 2 - 1] + tmp[v.size() / 2]);
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  inline T stdev(const Vector < T > & v, bool sample_correction = false)
3: +  {
3: +    return sqrt(var(v, sample_correction));
3: +  }
3: +
3: +  template < typename T >
3: +  inline T var(const Vector < T > & v, bool sample_correction = false)
3: +  {
3: +    T sum = (T)0, ssum = (T)0;
3: +    unsigned int n = v.size();
3: +    for (unsigned int i = 0; i < n; i++) {
3: @@ -648,60 +722,69 @@
3: -  if (!sample_correction)
3: -    return (ssum / n) - (sum / n) * (sum / n);
3: -  else
3: -    return n * ((ssum / n) - (sum / n) * (sum / n)) / (n - 1);
3: -}
3: -
3: -template <typename T>
3: -inline T max(const Vector<T>& v)
3: -{
3: -  T value = v[0];
3: -  for (unsigned int i = 1; i < v.size(); i++)
3: -    value = std::max(v[i], value);
3: -	
3: -  return value;
3: -}
3: -
3: -template <typename T>
3: -inline T min(const Vector<T>& v)
3: -{
3: -  T value = v[0];
3: -  for (unsigned int i = 1; i < v.size(); i++)
3: -    value = std::min(v[i], value);
3: -	
3: -  return value;
3: -}
3: -
3: -template <typename T>
3: -inline unsigned int index_max(const Vector<T>& v)
3: -{
3: -  unsigned int max = 0;
3: -  for (unsigned int i = 1; i < v.size(); i++)
3: -    if (v[i] > v[max])
3: -      max = i;
3: -	
3: -  return max;
3: -}
3: -
3: -template <typename T>
3: -inline unsigned int index_min(const Vector<T>& v)
3: -{
3: -  unsigned int min = 0;
3: -  for (unsigned int i = 1; i < v.size(); i++)
3: -    if (v[i] < v[min])
3: -      min = i;
3: -	
3: -  return min;
3: -}
3: -
3: -
3: -template <typename T>
3: -inline T dot_prod(const Vector<T>& a, const Vector<T>& b)
3: -{
3: -  T sum = (T)0;
3: -  if (a.size() != b.size())
3: -    throw std::logic_error("Dotprod error: the vectors are not the same size");
3: -  for (unsigned int i = 0; i < a.size(); i++)
3: -    sum += a[i] * b[i];
3: -	
3: -  return sum;
3: -}
3: +    if (!sample_correction) {
3: +      return (ssum / n) - (sum / n) * (sum / n);
3: +    } else {
3: +      return n * ((ssum / n) - (sum / n) * (sum / n)) / (n - 1);
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  inline T max(const Vector < T > & v)
3: +  {
3: +    T value = v[0];
3: +    for (unsigned int i = 1; i < v.size(); i++) {
3: +      value = std::max(v[i], value);
3: +    }
3: +
3: +    return value;
3: +  }
3: +
3: +  template < typename T >
3: +  inline T min(const Vector < T > & v)
3: +  {
3: +    T value = v[0];
3: +    for (unsigned int i = 1; i < v.size(); i++) {
3: +      value = std::min(v[i], value);
3: +    }
3: +
3: +    return value;
3: +  }
3: +
3: +  template < typename T >
3: +  inline unsigned int index_max(const Vector < T > & v)
3: +  {
3: +    unsigned int max = 0;
3: +    for (unsigned int i = 1; i < v.size(); i++) {
3: +      if (v[i] > v[max]) {
3: +        max = i;
3: +      }
3: +    }
3: +
3: +    return max;
3: +  }
3: +
3: +  template < typename T >
3: +  inline unsigned int index_min(const Vector < T > & v)
3: +  {
3: +    unsigned int min = 0;
3: +    for (unsigned int i = 1; i < v.size(); i++) {
3: +      if (v[i] < v[min]) {
3: +        min = i;
3: +      }
3: +    }
3: +
3: +    return min;
3: +  }
3: +
3: +
3: +  template < typename T >
3: +  inline T dot_prod(const Vector < T > & a, const Vector < T > & b)
3: +  {
3: +    T sum = (T)0;
3: +    if (a.size() != b.size()) {
3: +      throw std::logic_error("Dotprod error: the vectors are not the same size");
3: +    }
3: +    for (unsigned int i = 0; i < a.size(); i++) {
3: +      sum += a[i] * b[i];
3: +    }
3: +
3: +    return sum;
3: +  }
3: @@ -713,67 +796,72 @@
3: -template <typename T>
3: -inline Vector<T> exp(const Vector<T>& v)
3: -{
3: -  Vector<T> tmp(v.size());
3: -  for (unsigned int i = 0; i < v.size(); i++)
3: -    tmp[i] = exp(v[i]);
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> log(const Vector<T>& v)
3: -{
3: -  Vector<T> tmp(v.size());
3: -  for (unsigned int i = 0; i < v.size(); i++)
3: -    tmp[i] = log(v[i]);
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> vec_sqrt(const Vector<T>& v)
3: -{
3: -  Vector<T> tmp(v.size());
3: -  for (unsigned int i = 0; i < v.size(); i++)
3: -    tmp[i] = sqrt(v[i]);
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> pow(const Vector<T>& v, double a)
3: -{
3: -  Vector<T> tmp(v.size());
3: -  for (unsigned int i = 0; i < v.size(); i++)
3: -    tmp[i] = pow(v[i], a);
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> abs(const Vector<T>& v)
3: -{
3: -  Vector<T> tmp(v.size());
3: -  for (unsigned int i = 0; i < v.size(); i++)
3: -    tmp[i] = (T)fabs(v[i]);
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> sign(const Vector<T>& v)
3: -{
3: -  Vector<T> tmp(v.size());
3: -  for (unsigned int i = 0; i < v.size(); i++)
3: -    tmp[i] = v[i] > 0 ? +1 : v[i] == 0 ? 0 : -1;
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline unsigned int partition(Vector<T>& v, unsigned int begin, unsigned int end)
3: -{
3: -  unsigned int i = begin + 1, j = begin + 1;
3: -  T pivot = v[begin];
3: -  while (j <= end) 
3: -    {
3: +  template < typename T >
3: +  inline Vector < T > exp(const Vector < T > &v)
3: +  {
3: +    Vector < T > tmp(v.size());
3: +    for (unsigned int i = 0; i < v.size(); i++) {
3: +      tmp[i] = exp(v[i]);
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > log(const Vector < T > &v)
3: +  {
3: +    Vector < T > tmp(v.size());
3: +    for (unsigned int i = 0; i < v.size(); i++) {
3: +      tmp[i] = log(v[i]);
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > vec_sqrt(const Vector < T > &v)
3: +  {
3: +    Vector < T > tmp(v.size());
3: +    for (unsigned int i = 0; i < v.size(); i++) {
3: +      tmp[i] = sqrt(v[i]);
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > pow(const Vector < T > &v, double a)
3: +  {
3: +    Vector < T > tmp(v.size());
3: +    for (unsigned int i = 0; i < v.size(); i++) {
3: +      tmp[i] = pow(v[i], a);
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > abs(const Vector < T > &v)
3: +  {
3: +    Vector < T > tmp(v.size());
3: +    for (unsigned int i = 0; i < v.size(); i++) {
3: +      tmp[i] = (T)fabs(v[i]);
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > sign(const Vector < T > &v)
3: +  {
3: +    Vector < T > tmp(v.size());
3: +    for (unsigned int i = 0; i < v.size(); i++) {
3: +      tmp[i] = v[i] > 0 ? +1 : v[i] == 0 ? 0 : -1;
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline unsigned int partition(Vector < T > & v, unsigned int begin, unsigned int end)
3: +  {
3: +    unsigned int i = begin + 1, j = begin + 1;
3: +    T pivot = v[begin];
3: +    while (j <= end) {
3: @@ -781,2 +869,2 @@
3: -	std::swap(v[i], v[j]);
3: -	i++;
3: +        std::swap(v[i], v[j]);
3: +        i++;
3: @@ -786,11 +874,10 @@
3: -  v[begin] = v[i - 1];
3: -  v[i - 1] = pivot;
3: -  return i - 2;
3: -}
3: -	
3: -
3: -template <typename T>
3: -inline void quicksort(Vector<T>& v, unsigned int begin, unsigned int end)
3: -{
3: -  if (end > begin)
3: -    {
3: +    v[begin] = v[i - 1];
3: +    v[i - 1] = pivot;
3: +    return i - 2;
3: +  }
3: +
3: +
3: +  template < typename T >
3: +  inline void quicksort(Vector < T > & v, unsigned int begin, unsigned int end)
3: +  {
3: +    if (end > begin) {
3: @@ -801,19 +888,341 @@
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> sort(const Vector<T>& v)
3: -{
3: -  Vector<T> tmp(v);
3: -  
3: -  quicksort<T>(tmp, 0, tmp.size() - 1);
3: -  
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<double> rank(const Vector<T>& v)
3: -{
3: -  Vector<T> tmp(v);
3: -  Vector<double> tmp_rank(0.0, v.size());	
3: -	
3: -  for (unsigned int i = 0; i < tmp.size(); i++)
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > sort(const Vector < T > &v)
3: +  {
3: +    Vector < T > tmp(v);
3: +
3: +    quicksort < T > (tmp, 0, tmp.size() - 1);
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < double > rank(const Vector < T > &v)
3: +  {
3: +    Vector < T > tmp(v);
3: +    Vector < double > tmp_rank(0.0, v.size());
3: +
3: +    for (unsigned int i = 0; i < tmp.size(); i++) {
3: +      unsigned int smaller = 0, equal = 0;
3: +      for (unsigned int j = 0; j < tmp.size(); j++) {
3: +        if (i == j) {
3: +          continue;
3: +        } else if (tmp[j] < tmp[i]) {
3: +          smaller++;
3: +        } else if (tmp[j] == tmp[i]) {
3: +          equal++;
3: +        }
3: +      }
3: +      tmp_rank[i] = smaller + 1;
3: +      if (equal > 0) {
3: +        for (unsigned int j = 1; j <= equal; j++) {
3: +          tmp_rank[i] += smaller + 1 + j;
3: +        }
3: +        tmp_rank[i] /= (double)(equal + 1);
3: +      }
3: +    }
3: +
3: +    return tmp_rank;
3: +  }
3: +
3: +//enum MType { DIAG };
3: +
3: +  template < typename T >
3: +  class Matrix
3: +  {
3: +public:
3: +    Matrix(); // Default constructor
3: +    Matrix(const unsigned int n, const unsigned int m); // Construct a n x m matrix
3: +    Matrix(const T & a, const unsigned int n, const unsigned int m); // Initialize the content to constant a
3: +    Matrix(MType t, const T & a, const T & o, const unsigned int n, const unsigned int m);
3: +    Matrix(MType t, const Vector < T > &v, const T & o, const unsigned int n, const unsigned int m);
3: +    Matrix(const T * a, const unsigned int n, const unsigned int m); // Initialize to array
3: +    Matrix(const Matrix < T > &rhs); // Copy constructor
3: +    ~Matrix(); // destructor
3: +
3: +    inline T * operator[] (const unsigned int & i) {return v[i];} // Subscripting: row i
3: +    inline const T * operator[] (const unsigned int & i) const {return v[i];} // const subsctipting
3: +
3: +    inline void resize(const unsigned int n, const unsigned int m);
3: +    inline void resize(const T & a, const unsigned int n, const unsigned int m);
3: +
3: +
3: +    inline Vector < T > extractRow(const unsigned int i) const;
3: +    inline Vector < T > extractColumn(const unsigned int j) const;
3: +    inline Vector < T > extractDiag() const;
3: +    inline Matrix < T > extractRows(const std::set < unsigned int > &indexes) const;
3: +    inline Matrix < T > extractColumns(const std::set < unsigned int > &indexes) const;
3: +    inline Matrix < T > extract(
3: +      const std::set < unsigned int > &r_indexes,
3: +      const std::set < unsigned int > &c_indexes) const;
3: +
3: +    inline void set(const T * a, unsigned int n, unsigned int m);
3: +    inline void set(
3: +      const std::set < unsigned int > & r_indexes,
3: +      const std::set < unsigned int > & c_indexes, const Matrix < T > & m);
3: +    inline void setRow(const unsigned int index, const Vector < T > & v);
3: +    inline void setRow(const unsigned int index, const Matrix < T > & v);
3: +    inline void setRows(const std::set < unsigned int > & indexes, const Matrix < T > & m);
3: +    inline void setColumn(const unsigned int index, const Vector < T > & v);
3: +    inline void setColumn(const unsigned int index, const Matrix < T > & v);
3: +    inline void setColumns(const std::set < unsigned int > & indexes, const Matrix < T > & m);
3: +
3: +
3: +    inline unsigned int nrows() const {return n;} // number of rows
3: +    inline unsigned int ncols() const {return m;} // number of columns
3: +
3: +    inline Matrix < T > & operator = (const Matrix < T > &rhs); // Assignment operator
3: +    inline Matrix < T > & operator = (const T & a); // Assign to every element value a
3: +    inline Matrix < T > & operator += (const Matrix < T > &rhs);
3: +    inline Matrix < T > & operator -= (const Matrix < T > &rhs);
3: +    inline Matrix < T > & operator *= (const Matrix < T > &rhs);
3: +    inline Matrix < T > & operator /= (const Matrix < T > &rhs);
3: +    inline Matrix < T > & operator ^= (const Matrix < T > &rhs);
3: +    inline Matrix < T > & operator += (const T & a);
3: +    inline Matrix < T > & operator -= (const T & a);
3: +    inline Matrix < T > & operator *= (const T & a);
3: +    inline Matrix < T > & operator /= (const T & a);
3: +    inline Matrix < T > & operator ^= (const T & a);
3: +    inline operator Vector < T > ();
3: +
3: +private:
3: +    unsigned int n; // number of rows
3: +    unsigned int m; // number of columns
3: +    T ** v; // storage for data
3: +  };
3: +
3: +  template < typename T >
3: +  Matrix < T > ::Matrix()
3: +    : n(0), m(0), v(0)
3: +  {
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > ::Matrix(unsigned int n, unsigned int m)
3: +    : v(new T *[n])
3: +  {
3: +    this->n = n; this->m = m;
3: +    v[0] = new T[m * n];
3: +    for (unsigned int i = 1; i < n; i++) {
3: +      v[i] = v[i - 1] + m;
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > ::Matrix(const T & a, unsigned int n, unsigned int m)
3: +    : v(new T *[n])
3: +  {
3: +    this->n = n; this->m = m;
3: +    v[0] = new T[m * n];
3: +    for (unsigned int i = 1; i < n; i++) {
3: +      v[i] = v[i - 1] + m;
3: +    }
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] = a;
3: +      }
3: +    }
3: +  }
3: +
3: +  template < class T >
3: +  Matrix < T > ::Matrix(const T * a, unsigned int n, unsigned int m)
3: +    : v(new T *[n])
3: +  {
3: +    this->n = n; this->m = m;
3: +    v[0] = new T[m * n];
3: +    for (unsigned int i = 1; i < n; i++) {
3: +      v[i] = v[i - 1] + m;
3: +    }
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] = *a++;
3: +      }
3: +    }
3: +  }
3: +
3: +  template < class T >
3: +  Matrix < T > ::Matrix(MType t, const T & a, const T & o, unsigned int n, unsigned int m)
3: +    : v(new T *[n])
3: +  {
3: +    this->n = n; this->m = m;
3: +    v[0] = new T[m * n];
3: +    for (unsigned int i = 1; i < n; i++) {
3: +      v[i] = v[i - 1] + m;
3: +    }
3: +    switch (t) {
3: +      case DIAG:
3: +        for (unsigned int i = 0; i < n; i++) {
3: +          for (unsigned int j = 0; j < m; j++) {
3: +            if (i != j) {
3: +              v[i][j] = o;
3: +            } else {
3: +              v[i][j] = a;
3: +            }
3: +          }
3: +        }
3: +        break;
3: +      default:
3: +        throw std::logic_error("Matrix type not supported");
3: +    }
3: +  }
3: +
3: +  template < class T >
3: +  Matrix < T > ::Matrix(MType t, const Vector < T > &a, const T & o, unsigned int n, unsigned int m)
3: +    : v(new T *[n])
3: +  {
3: +    this->n = n; this->m = m;
3: +    v[0] = new T[m * n];
3: +    for (unsigned int i = 1; i < n; i++) {
3: +      v[i] = v[i - 1] + m;
3: +    }
3: +    switch (t) {
3: +      case DIAG:
3: +        for (unsigned int i = 0; i < n; i++) {
3: +          for (unsigned int j = 0; j < m; j++) {
3: +            if (i != j) {
3: +              v[i][j] = o;
3: +            } else {
3: +              v[i][j] = a[i];
3: +            }
3: +          }
3: +        }
3: +        break;
3: +      default:
3: +        throw std::logic_error("Matrix type not supported");
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > ::Matrix(const Matrix < T > &rhs)
3: +    : v(new T *[rhs.n])
3: +  {
3: +    n = rhs.n; m = rhs.m;
3: +    v[0] = new T[m * n];
3: +    for (unsigned int i = 1; i < n; i++) {
3: +      v[i] = v[i - 1] + m;
3: +    }
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] = rhs[i][j];
3: +      }
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > ::~Matrix()
3: +  {
3: +    if (v != 0) {
3: +      delete[] (v[0]);
3: +      delete[] (v);
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > & Matrix < T > ::operator = (const Matrix < T > &rhs)
3: +// postcondition: normal assignment via copying has been performed;
3: +// if matrix and rhs were different sizes, matrix
3: +// has been resized to match the size of rhs
3: +  {
3: +    if (this != &rhs) {
3: +      resize(rhs.n, rhs.m);
3: +      for (unsigned int i = 0; i < n; i++) {
3: +        for (unsigned int j = 0; j < m; j++) {
3: +          v[i][j] = rhs[i][j];
3: +        }
3: +      }
3: +    }
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > & Matrix < T > ::operator = (const T & a) // assign a to every element
3: +  {
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] = a;
3: +      }
3: +    }
3: +    return *this;
3: +  }
3: +
3: +
3: +  template < typename T >
3: +  inline void Matrix < T > ::resize(const unsigned int n, const unsigned int m)
3: +  {
3: +    if (n == this->n && m == this->m) {
3: +      return;
3: +    }
3: +    if (v != 0) {
3: +      delete[] (v[0]);
3: +      delete[] (v);
3: +    }
3: +    this->n = n; this->m = m;
3: +    v = new T *[n];
3: +    v[0] = new T[m * n];
3: +    for (unsigned int i = 1; i < n; i++) {
3: +      v[i] = v[i - 1] + m;
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  inline void Matrix < T > ::resize(const T & a, const unsigned int n, const unsigned int m)
3: +  {
3: +    resize(n, m);
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] = a;
3: +      }
3: +    }
3: +  }
3: +
3: +
3: +  template < typename T >
3: +  inline Vector < T > Matrix < T > ::extractRow(const unsigned int i) const
3: +  {
3: +    if (i >= n) {
3: +      throw std::logic_error("Error in extractRow: trying to extract a row out of matrix bounds");
3: +    }
3: +    Vector < T > tmp(v[i], m);
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > Matrix < T > ::extractColumn(const unsigned int j) const
3: +  {
3: +    if (j >= m) {
3: +      throw std::logic_error("Error in extractRow: trying to extract a row out of matrix bounds");
3: +    }
3: +    Vector < T > tmp(n);
3: +
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      tmp[i] = v[i][j];
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Vector < T > Matrix < T > ::extractDiag() const
3: +  {
3: +    unsigned int d = std::min(n, m);
3: +
3: +    Vector < T > tmp(d);
3: +
3: +    for (unsigned int i = 0; i < d; i++) {
3: +      tmp[i] = v[i][i];
3: +    }
3: +
3: +    return tmp;
3: +
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > Matrix < T > ::extractRows(const std::set < unsigned int > &indexes) const
3: +  {
3: +    Matrix < T > tmp(indexes.size(), m);
3: +    unsigned int i = 0;
3: +
3: +    for (std::set < unsigned int > ::const_iterator el = indexes.begin(); el != indexes.end();
3: +      el++)
3: @@ -821,132 +1230,20 @@
3: -      unsigned int smaller = 0, equal = 0;
3: -      for (unsigned int j = 0; j < tmp.size(); j++)
3: -	if (i == j)
3: -	  continue;
3: -	else
3: -	  if (tmp[j] < tmp[i])
3: -	    smaller++;
3: -	  else if (tmp[j] == tmp[i])
3: -	    equal++;
3: -      tmp_rank[i] = smaller + 1;
3: -      if (equal > 0)
3: -	{
3: -	  for (unsigned int j = 1; j <= equal; j++)
3: -	    tmp_rank[i] += smaller + 1 + j;
3: -	  tmp_rank[i] /= (double)(equal + 1);
3: -	}
3: -    }
3: -	
3: -  return tmp_rank;
3: -}
3: -
3: -//enum MType { DIAG };
3: -
3: -template <typename T>
3: -class Matrix 
3: -{
3: -public:
3: -  Matrix(); // Default constructor
3: -  Matrix(const unsigned int n, const unsigned int m); // Construct a n x m matrix
3: -  Matrix(const T& a, const unsigned int n, const unsigned int m); // Initialize the content to constant a
3: -  Matrix(MType t, const T& a, const T& o, const unsigned int n, const unsigned int m);
3: -  Matrix(MType t, const Vector<T>& v, const T& o, const unsigned int n, const unsigned int m);
3: -  Matrix(const T* a, const unsigned int n, const unsigned int m); // Initialize to array 
3: -  Matrix(const Matrix<T>& rhs); // Copy constructor
3: -  ~Matrix(); // destructor
3: -	
3: -  inline T* operator[](const unsigned int& i) { return v[i]; } // Subscripting: row i
3: -  inline const T* operator[](const unsigned int& i) const { return v[i]; }; // const subsctipting
3: -	
3: -  inline void resize(const unsigned int n, const unsigned int m);
3: -  inline void resize(const T& a, const unsigned int n, const unsigned int m);
3: -	
3: -	
3: -  inline Vector<T> extractRow(const unsigned int i) const; 
3: -  inline Vector<T> extractColumn(const unsigned int j) const;
3: -  inline Vector<T> extractDiag() const;
3: -  inline Matrix<T> extractRows(const std::set<unsigned int>& indexes) const;
3: -  inline Matrix<T> extractColumns(const std::set<unsigned int>& indexes) const;
3: -  inline Matrix<T> extract(const std::set<unsigned int>& r_indexes, const std::set<unsigned int>& c_indexes) const;
3: -	
3: -  inline void set(const T* a, unsigned int n, unsigned int m);
3: -  inline void set(const std::set<unsigned int>& r_indexes, const std::set<unsigned int>& c_indexes, const Matrix<T>& m);
3: -  inline void setRow(const unsigned int index, const Vector<T>& v);
3: -  inline void setRow(const unsigned int index, const Matrix<T>& v);
3: -  inline void setRows(const std::set<unsigned int>& indexes, const Matrix<T>& m);
3: -  inline void setColumn(const unsigned int index, const Vector<T>& v);
3: -  inline void setColumn(const unsigned int index, const Matrix<T>& v);
3: -  inline void setColumns(const std::set<unsigned int>& indexes, const Matrix<T>& m);
3: -	
3: -	
3: -  inline unsigned int nrows() const { return n; } // number of rows
3: -  inline unsigned int ncols() const { return m; } // number of columns
3: -	
3: -  inline Matrix<T>& operator=(const Matrix<T>& rhs); // Assignment operator
3: -  inline Matrix<T>& operator=(const T& a); // Assign to every element value a
3: -  inline Matrix<T>& operator+=(const Matrix<T>& rhs);
3: -  inline Matrix<T>& operator-=(const Matrix<T>& rhs);
3: -  inline Matrix<T>& operator*=(const Matrix<T>& rhs);
3: -  inline Matrix<T>& operator/=(const Matrix<T>& rhs);
3: -  inline Matrix<T>& operator^=(const Matrix<T>& rhs);
3: -  inline Matrix<T>& operator+=(const T& a);
3: -  inline Matrix<T>& operator-=(const T& a);
3: -  inline Matrix<T>& operator*=(const T& a);
3: -  inline Matrix<T>& operator/=(const T& a);
3: -  inline Matrix<T>& operator^=(const T& a);
3: -  inline operator Vector<T>();
3: -private:
3: -  unsigned int n; // number of rows
3: -  unsigned int m; // number of columns
3: -  T **v; // storage for data
3: -};
3: -
3: -template <typename T>
3: -Matrix<T>::Matrix() 
3: -  : n(0), m(0), v(0)
3: -{}
3: -
3: -template <typename T>
3: -Matrix<T>::Matrix(unsigned int n, unsigned int m)
3: -  : v(new T*[n])
3: -{
3: -  this->n = n; this->m = m;
3: -  v[0] = new T[m * n];
3: -  for (unsigned int i = 1; i < n; i++)
3: -    v[i] = v[i - 1] + m;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T>::Matrix(const T& a, unsigned int n, unsigned int m)
3: -  : v(new T*[n])
3: -{
3: -  this->n = n; this->m = m;
3: -  v[0] = new T[m * n];
3: -  for (unsigned int i = 1; i < n; i++)
3: -    v[i] = v[i - 1] + m;
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] = a;
3: -}
3: -
3: -template <class T> 
3: -Matrix<T>::Matrix(const T* a, unsigned int n, unsigned int m) 
3: -  : v(new T*[n])
3: -{ 
3: -  this->n = n; this->m = m;
3: -  v[0] = new T[m * n]; 
3: -  for (unsigned int i = 1; i < n; i++)
3: -    v[i] = v[i - 1] + m; 
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] = *a++; 
3: -} 
3: -
3: -template <class T> 
3: -Matrix<T>::Matrix(MType t, const T& a, const T& o, unsigned int n, unsigned int m) 
3: -  : v(new T*[n])
3: -{ 
3: -  this->n = n; this->m = m;
3: -  v[0] = new T[m * n]; 
3: -  for (unsigned int i = 1; i < n; i++)
3: -    v[i] = v[i - 1] + m; 
3: -  switch (t)
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        if (*el >= n) {
3: +          throw std::logic_error("Error extracting rows: the indexes are out of matrix bounds");
3: +        }
3: +        tmp[i][j] = v[*el][j];
3: +      }
3: +      i++;
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > Matrix < T > ::extractColumns(const std::set < unsigned int > &indexes) const
3: +  {
3: +    Matrix < T > tmp(n, indexes.size());
3: +    unsigned int j = 0;
3: +
3: +    for (std::set < unsigned int > ::const_iterator el = indexes.begin(); el != indexes.end();
3: +      el++)
3: @@ -954,22 +1251,22 @@
3: -    case DIAG:
3: -      for (unsigned int i = 0; i < n; i++)
3: -	for (unsigned int j = 0; j < m; j++)
3: -	  if (i != j)
3: -	    v[i][j] = o; 
3: -	  else
3: -	    v[i][j] = a;
3: -      break;
3: -    default:
3: -      throw std::logic_error("Matrix type not supported");
3: -    }
3: -} 
3: -
3: -template <class T> 
3: -Matrix<T>::Matrix(MType t, const Vector<T>& a, const T& o, unsigned int n, unsigned int m) 
3: -  : v(new T*[n])
3: -{ 
3: -  this->n = n; this->m = m;
3: -  v[0] = new T[m * n]; 
3: -  for (unsigned int i = 1; i < n; i++)
3: -    v[i] = v[i - 1] + m; 
3: -  switch (t)
3: +      for (unsigned int i = 0; i < n; i++) {
3: +        if (*el >= m) {
3: +          throw std::logic_error("Error extracting columns: the indexes are out of matrix bounds");
3: +        }
3: +        tmp[i][j] = v[i][*el];
3: +      }
3: +      j++;
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > Matrix < T > ::extract(
3: +    const std::set < unsigned int > &r_indexes,
3: +    const std::set < unsigned int > &c_indexes) const
3: +  {
3: +    Matrix < T > tmp(r_indexes.size(), c_indexes.size());
3: +    unsigned int i = 0, j;
3: +
3: +    for (std::set < unsigned int > ::const_iterator r_el = r_indexes.begin();
3: +      r_el != r_indexes.end(); r_el++)
3: @@ -977,42 +1274,61 @@
3: -    case DIAG:
3: -      for (unsigned int i = 0; i < n; i++)
3: -	for (unsigned int j = 0; j < m; j++)
3: -	  if (i != j)
3: -	    v[i][j] = o; 
3: -	  else
3: -	    v[i][j] = a[i];
3: -      break;
3: -    default:
3: -      throw std::logic_error("Matrix type not supported");
3: -    }
3: -} 
3: -
3: -template <typename T>
3: -Matrix<T>::Matrix(const Matrix<T>& rhs)
3: -  : v(new T*[rhs.n])
3: -{
3: -  n = rhs.n; m = rhs.m;
3: -  v[0] = new T[m * n]; 
3: -  for (unsigned int i = 1; i < n; i++)
3: -    v[i] = v[i - 1] + m;
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] = rhs[i][j];
3: -}
3: -
3: -template <typename T> 
3: -Matrix<T>::~Matrix() 
3: -{ 
3: -  if (v != 0) { 
3: -    delete[] (v[0]); 
3: -    delete[] (v); 
3: -  } 
3: -}
3: -				
3: -template <typename T> 
3: -inline Matrix<T>& Matrix<T>::operator=(const Matrix<T> &rhs) 
3: -// postcondition: normal assignment via copying has been performed; 
3: -// if matrix and rhs were different sizes, matrix 
3: -// has been resized to match the size of rhs 
3: -{ 
3: -  if (this != &rhs) 
3: +      if (*r_el >= n) {
3: +        throw std::logic_error("Error extracting submatrix: the indexes are out of matrix bounds");
3: +      }
3: +      j = 0;
3: +      for (std::set < unsigned int > ::const_iterator c_el = c_indexes.begin();
3: +        c_el != c_indexes.end(); c_el++)
3: +      {
3: +        if (*c_el >= m) {
3: +          throw std::logic_error("Error extracting rows: the indexes are out of matrix bounds");
3: +        }
3: +        tmp[i][j] = v[*r_el][*c_el];
3: +        j++;
3: +      }
3: +      i++;
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline void Matrix < T > ::setRow(unsigned int i, const Vector < T > &a)
3: +  {
3: +    if (i >= n) {
3: +      throw std::logic_error("Error in setRow: trying to set a row out of matrix bounds");
3: +    }
3: +    if (this->m != a.size()) {
3: +      throw std::logic_error("Error setting matrix row: ranges are not compatible");
3: +    }
3: +    for (unsigned int j = 0; j < ncols(); j++) {
3: +      v[i][j] = a[j];
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  inline void Matrix < T > ::setRow(unsigned int i, const Matrix < T > &a)
3: +  {
3: +    if (i >= n) {
3: +      throw std::logic_error("Error in setRow: trying to set a row out of matrix bounds");
3: +    }
3: +    if (this->m != a.ncols()) {
3: +      throw std::logic_error("Error setting matrix column: ranges are not compatible");
3: +    }
3: +    if (a.nrows() != 1) {
3: +      throw std::logic_error("Error setting matrix column with a non-row matrix");
3: +    }
3: +    for (unsigned int j = 0; j < ncols(); j++) {
3: +      v[i][j] = a[0][j];
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  inline void Matrix < T >
3: +  ::setRows(const std::set < unsigned int > &indexes, const Matrix < T > &m)
3: +  {
3: +    unsigned int i = 0;
3: +
3: +    if (indexes.size() != m.nrows() || this->m != m.ncols()) {
3: +      throw std::logic_error("Error setting matrix rows: ranges are not compatible");
3: +    }
3: +    for (std::set < unsigned int > ::const_iterator el = indexes.begin(); el != indexes.end();
3: +      el++)
3: @@ -1020,90 +1336,54 @@
3: -      resize(rhs.n, rhs.m);
3: -      for (unsigned int i = 0; i < n; i++)
3: -	for (unsigned int j = 0; j < m; j++)
3: -	  v[i][j] = rhs[i][j]; 
3: -    } 
3: -  return *this; 
3: -} 
3: -
3: -template <typename T> 
3: -inline Matrix<T>& Matrix<T>::operator=(const T& a) // assign a to every element 
3: -{ 
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] = a; 
3: -  return *this; 
3: -} 
3: -
3: -
3: -template <typename T> 
3: -inline void Matrix<T>::resize(const unsigned int n, const unsigned int m) 
3: -{
3: -  if (n == this->n && m == this->m)
3: -    return;
3: -  if (v != 0) 
3: -    { 
3: -      delete[] (v[0]); 
3: -      delete[] (v); 
3: -    } 
3: -  this->n = n; this->m = m;
3: -  v = new T*[n]; 
3: -  v[0] = new T[m * n];  
3: -  for (unsigned int i = 1; i < n; i++)
3: -    v[i] = v[i - 1] + m;
3: -} 
3: -
3: -template <typename T> 
3: -inline void Matrix<T>::resize(const T& a, const unsigned int n, const unsigned int m) 
3: -{
3: -  resize(n, m);
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] = a;
3: -} 
3: -
3: -
3: -
3: -template <typename T> 
3: -inline Vector<T> Matrix<T>::extractRow(const unsigned int i) const
3: -{
3: -  if (i >= n)
3: -    throw std::logic_error("Error in extractRow: trying to extract a row out of matrix bounds");
3: -  Vector<T> tmp(v[i], m);
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T> 
3: -inline Vector<T> Matrix<T>::extractColumn(const unsigned int j) const
3: -{
3: -  if (j >= m)
3: -    throw std::logic_error("Error in extractRow: trying to extract a row out of matrix bounds");
3: -  Vector<T> tmp(n);
3: -	
3: -  for (unsigned int i = 0; i < n; i++)
3: -    tmp[i] = v[i][j];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Vector<T> Matrix<T>::extractDiag() const
3: -{
3: -  unsigned int d = std::min(n, m);
3: -  
3: -  Vector<T> tmp(d);
3: -	
3: -  for (unsigned int i = 0; i < d; i++)
3: -    tmp[i] = v[i][i];
3: -	
3: -  return tmp;
3: -	
3: -}
3: -
3: -template <typename T> 
3: -inline Matrix<T> Matrix<T>::extractRows(const std::set<unsigned int>& indexes) const
3: -{
3: -  Matrix<T> tmp(indexes.size(), m);
3: -  unsigned int i = 0;
3: -	
3: -  for (std::set<unsigned int>::const_iterator el = indexes.begin(); el != indexes.end(); el++)
3: +      for (unsigned int j = 0; j < ncols(); j++) {
3: +        if (*el >= n) {
3: +          throw std::logic_error("Error in setRows: trying to set a row out of matrix bounds");
3: +        }
3: +        v[*el][j] = m[i][j];
3: +      }
3: +      i++;
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  inline void Matrix < T > ::setColumn(unsigned int j, const Vector < T > &a)
3: +  {
3: +    if (j >= m) {
3: +      throw std::logic_error("Error in setColumn: trying to set a column out of matrix bounds");
3: +    }
3: +    if (this->n != a.size()) {
3: +      throw std::logic_error("Error setting matrix column: ranges are not compatible");
3: +    }
3: +    for (unsigned int i = 0; i < nrows(); i++) {
3: +      v[i][j] = a[i];
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  inline void Matrix < T > ::setColumn(unsigned int j, const Matrix < T > &a)
3: +  {
3: +    if (j >= m) {
3: +      throw std::logic_error("Error in setColumn: trying to set a column out of matrix bounds");
3: +    }
3: +    if (this->n != a.nrows()) {
3: +      throw std::logic_error("Error setting matrix column: ranges are not compatible");
3: +    }
3: +    if (a.ncols() != 1) {
3: +      throw std::logic_error("Error setting matrix column with a non-column matrix");
3: +    }
3: +    for (unsigned int i = 0; i < nrows(); i++) {
3: +      v[i][j] = a[i][0];
3: +    }
3: +  }
3: +
3: +
3: +  template < typename T >
3: +  inline void Matrix < T > ::setColumns(
3: +    const std::set < unsigned int > &indexes,
3: +    const Matrix < T > &a)
3: +  {
3: +    unsigned int j = 0;
3: +
3: +    if (indexes.size() != a.ncols() || this->n != a.nrows()) {
3: +      throw std::logic_error("Error setting matrix columns: ranges are not compatible");
3: +    }
3: +    for (std::set < unsigned int > ::const_iterator el = indexes.begin(); el != indexes.end();
3: +      el++)
3: @@ -1111,6 +1391,37 @@
3: -      for (unsigned int j = 0; j < m; j++)
3: -	{
3: -	  if (*el >= n)
3: -	    throw std::logic_error("Error extracting rows: the indexes are out of matrix bounds");
3: -	  tmp[i][j] = v[*el][j];
3: -	}
3: +      for (unsigned int i = 0; i < nrows(); i++) {
3: +        if (*el >= m) {
3: +          throw std::logic_error(
3: +            "Error in setColumns: trying to set a column out of matrix bounds");
3: +        }
3: +        v[i][*el] = a[i][j];
3: +      }
3: +      j++;
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  inline void Matrix < T > ::set(
3: +    const std::set < unsigned int > &r_indexes,
3: +    const std::set < unsigned int > &c_indexes, const Matrix < T > &a)
3: +  {
3: +    unsigned int i = 0, j;
3: +    if (c_indexes.size() != a.ncols() || r_indexes.size() != a.nrows()) {
3: +      throw std::logic_error("Error setting matrix elements: ranges are not compatible");
3: +    }
3: +
3: +    for (std::set < unsigned int > ::const_iterator r_el = r_indexes.begin();
3: +      r_el != r_indexes.end(); r_el++)
3: +    {
3: +      if (*r_el >= n) {
3: +        throw std::logic_error("Error in set: trying to set a row out of matrix bounds");
3: +      }
3: +      j = 0;
3: +      for (std::set < unsigned int > ::const_iterator c_el = c_indexes.begin();
3: +        c_el != c_indexes.end(); c_el++)
3: +      {
3: +        if (*c_el >= m) {
3: +          throw std::logic_error("Error in set: trying to set a column out of matrix bounds");
3: +        }
3: +        v[*r_el][*c_el] = a[i][j];
3: +        j++;
3: +      }
3: @@ -1119,479 +1430,391 @@
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T> 
3: -inline Matrix<T> Matrix<T>::extractColumns(const std::set<unsigned int>& indexes) const
3: -{
3: -  Matrix<T> tmp(n, indexes.size());
3: -  unsigned int j = 0;
3: -	
3: -  for (std::set<unsigned int>::const_iterator el = indexes.begin(); el != indexes.end(); el++)
3: -    {
3: -      for (unsigned int i = 0; i < n; i++)
3: -	{
3: -	  if (*el >= m)
3: -	    throw std::logic_error("Error extracting columns: the indexes are out of matrix bounds");
3: -	  tmp[i][j] = v[i][*el];
3: -	}
3: -      j++;
3: -    }
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T> 
3: -inline Matrix<T> Matrix<T>::extract(const std::set<unsigned int>& r_indexes, const std::set<unsigned int>& c_indexes) const
3: -{
3: -  Matrix<T> tmp(r_indexes.size(), c_indexes.size());
3: -  unsigned int i = 0, j;
3: -	
3: -  for (std::set<unsigned int>::const_iterator r_el = r_indexes.begin(); r_el != r_indexes.end(); r_el++)
3: -    {
3: -      if (*r_el >= n)
3: -	throw std::logic_error("Error extracting submatrix: the indexes are out of matrix bounds");
3: -      j = 0;
3: -      for (std::set<unsigned int>::const_iterator c_el = c_indexes.begin(); c_el != c_indexes.end(); c_el++)
3: -	{
3: -	  if (*c_el >= m)
3: -	    throw std::logic_error("Error extracting rows: the indexes are out of matrix bounds");
3: -	  tmp[i][j] = v[*r_el][*c_el];
3: -	  j++;
3: -	}
3: -      i++;
3: -    }
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T> 
3: -inline void Matrix<T>::setRow(unsigned int i, const Vector<T>& a)
3: -{	
3: -  if (i >= n)
3: -    throw std::logic_error("Error in setRow: trying to set a row out of matrix bounds");
3: -  if (this->m != a.size())
3: -    throw std::logic_error("Error setting matrix row: ranges are not compatible");
3: -  for (unsigned int j = 0; j < ncols(); j++)
3: -    v[i][j] = a[j];
3: -}
3: -
3: -template <typename T> 
3: -inline void Matrix<T>::setRow(unsigned int i, const Matrix<T>& a)
3: -{	
3: -  if (i >= n)
3: -    throw std::logic_error("Error in setRow: trying to set a row out of matrix bounds");
3: -  if (this->m != a.ncols())
3: -    throw std::logic_error("Error setting matrix column: ranges are not compatible");
3: -  if (a.nrows() != 1)
3: -    throw std::logic_error("Error setting matrix column with a non-row matrix");
3: -  for (unsigned int j = 0; j < ncols(); j++)
3: -    v[i][j] = a[0][j];
3: -}
3: -
3: -template <typename T> 
3: -inline void Matrix<T>::setRows(const std::set<unsigned int>& indexes, const Matrix<T>& m)
3: -{
3: -  unsigned int i = 0;
3: -	
3: -  if (indexes.size() != m.nrows() || this->m != m.ncols())
3: -    throw std::logic_error("Error setting matrix rows: ranges are not compatible");
3: -  for (std::set<unsigned int>::const_iterator el = indexes.begin(); el != indexes.end(); el++)
3: -    {
3: -      for (unsigned int j = 0; j < ncols(); j++)
3: -	{
3: -	  if (*el >= n)
3: -	    throw std::logic_error("Error in setRows: trying to set a row out of matrix bounds");
3: -	  v[*el][j] = m[i][j];
3: -	}
3: -      i++;
3: -    }
3: -}
3: -
3: -template <typename T> 
3: -inline void Matrix<T>::setColumn(unsigned int j, const Vector<T>& a)
3: -{	
3: -  if (j >= m)
3: -    throw std::logic_error("Error in setColumn: trying to set a column out of matrix bounds");
3: -  if (this->n != a.size())
3: -    throw std::logic_error("Error setting matrix column: ranges are not compatible");
3: -  for (unsigned int i = 0; i < nrows(); i++)
3: -    v[i][j] = a[i];
3: -}
3: -
3: -template <typename T> 
3: -inline void Matrix<T>::setColumn(unsigned int j, const Matrix<T>& a)
3: -{	
3: -  if (j >= m)
3: -    throw std::logic_error("Error in setColumn: trying to set a column out of matrix bounds");
3: -  if (this->n != a.nrows())
3: -    throw std::logic_error("Error setting matrix column: ranges are not compatible");
3: -  if (a.ncols() != 1)
3: -    throw std::logic_error("Error setting matrix column with a non-column matrix");
3: -  for (unsigned int i = 0; i < nrows(); i++)
3: -    v[i][j] = a[i][0];
3: -}
3: -
3: -
3: -template <typename T> 
3: -inline void Matrix<T>::setColumns(const std::set<unsigned int>& indexes, const Matrix<T>& a)
3: -{
3: -  unsigned int j = 0;
3: -	
3: -  if (indexes.size() != a.ncols() || this->n != a.nrows())
3: -    throw std::logic_error("Error setting matrix columns: ranges are not compatible");
3: -  for (std::set<unsigned int>::const_iterator el = indexes.begin(); el != indexes.end(); el++)
3: -    {
3: -      for (unsigned int i = 0; i < nrows(); i++)
3: -	{
3: -	  if (*el >= m)
3: -	    throw std::logic_error("Error in setColumns: trying to set a column out of matrix bounds");
3: -	  v[i][*el] = a[i][j];
3: -	}
3: -      j++;
3: -    }
3: -}
3: -
3: -template <typename T> 
3: -inline void Matrix<T>::set(const std::set<unsigned int>& r_indexes, const std::set<unsigned int>& c_indexes, const Matrix<T>& a)
3: -{
3: -  unsigned int i = 0, j;
3: -  if (c_indexes.size() != a.ncols() || r_indexes.size() != a.nrows())
3: -    throw std::logic_error("Error setting matrix elements: ranges are not compatible");
3: -	
3: -  for (std::set<unsigned int>::const_iterator r_el = r_indexes.begin(); r_el != r_indexes.end(); r_el++)
3: -    {
3: -      if (*r_el >= n)
3: -	throw std::logic_error("Error in set: trying to set a row out of matrix bounds");
3: -      j = 0;
3: -      for (std::set<unsigned int>::const_iterator c_el = c_indexes.begin(); c_el != c_indexes.end(); c_el++)
3: -	{
3: -	  if (*c_el >= m)
3: -	    throw std::logic_error("Error in set: trying to set a column out of matrix bounds");
3: -	  v[*r_el][*c_el] = a[i][j];
3: -	  j++;
3: -	}
3: -      i++;
3: -    }
3: -}
3: -
3: -template <typename T> 
3: -inline void Matrix<T>::set(const T* a, unsigned int n, unsigned int m)
3: -{
3: -  if (this->n != n || this->m != m)
3: -    resize(n, m);
3: -  unsigned int k = 0;
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] = a[k++];
3: -}
3: -
3: -
3: -template <typename T>
3: -Matrix<T> operator+(const Matrix<T>& rhs)
3: -{
3: -  return rhs;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> operator+(const Matrix<T>& lhs, const Matrix<T>& rhs)
3: -{
3: -  if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows())
3: -    throw std::logic_error("Operator+: matrices have different sizes");
3: -  Matrix<T> tmp(lhs.nrows(), lhs.ncols());
3: -  for (unsigned int i = 0; i < lhs.nrows(); i++)
3: -    for (unsigned int j = 0; j < lhs.ncols(); j++)
3: -      tmp[i][j] = lhs[i][j] + rhs[i][j];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> operator+(const Matrix<T>& lhs, const T& a)
3: -{
3: -  Matrix<T> tmp(lhs.nrows(), lhs.ncols());
3: -  for (unsigned int i = 0; i < lhs.nrows(); i++)
3: -    for (unsigned int j = 0; j < lhs.ncols(); j++)
3: -      tmp[i][j] = lhs[i][j] + a;
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> operator+(const T& a, const Matrix<T>& rhs)
3: -{
3: -  Matrix<T> tmp(rhs.nrows(), rhs.ncols());
3: -  for (unsigned int i = 0; i < rhs.nrows(); i++)
3: -    for (unsigned int j = 0; j < rhs.ncols(); j++)
3: -      tmp[i][j] = a + rhs[i][j];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Matrix<T>& Matrix<T>::operator+=(const Matrix<T>& rhs)
3: -{
3: -  if (m != rhs.ncols() || n != rhs.nrows())
3: -    throw std::logic_error("Operator+=: matrices have different sizes");
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] += rhs[i][j];
3: -	
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -inline Matrix<T>& Matrix<T>::operator+=(const T& a)
3: -{
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] += a;
3: -	
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> operator-(const Matrix<T>& rhs)
3: -{	
3: -  return (T)(-1) * rhs;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> operator-(const Matrix<T>& lhs, const Matrix<T>& rhs)
3: -{
3: -  if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows())
3: -    throw std::logic_error("Operator-: matrices have different sizes");
3: -  Matrix<T> tmp(lhs.nrows(), lhs.ncols());
3: -  for (unsigned int i = 0; i < lhs.nrows(); i++)
3: -    for (unsigned int j = 0; j < lhs.ncols(); j++)
3: -      tmp[i][j] = lhs[i][j] - rhs[i][j];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> operator-(const Matrix<T>& lhs, const T& a)
3: -{
3: -  Matrix<T> tmp(lhs.nrows(), lhs.ncols());
3: -  for (unsigned int i = 0; i < lhs.nrows(); i++)
3: -    for (unsigned int j = 0; j < lhs.ncols(); j++)
3: -      tmp[i][j] = lhs[i][j] - a;
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> operator-(const T& a, const Matrix<T>& rhs)
3: -{
3: -  Matrix<T> tmp(rhs.nrows(), rhs.ncols());
3: -  for (unsigned int i = 0; i < rhs.nrows(); i++)
3: -    for (unsigned int j = 0; j < rhs.ncols(); j++)
3: -      tmp[i][j] = a - rhs[i][j];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Matrix<T>& Matrix<T>::operator-=(const Matrix<T>& rhs)
3: -{
3: -  if (m != rhs.ncols() || n != rhs.nrows())
3: -    throw std::logic_error("Operator-=: matrices have different sizes");
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] -= rhs[i][j];
3: -	
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -inline Matrix<T>& Matrix<T>::operator-=(const T& a)
3: -{
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] -= a;
3: -	
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> operator*(const Matrix<T>& lhs, const Matrix<T>& rhs)
3: -{
3: -  if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows())
3: -    throw std::logic_error("Operator*: matrices have different sizes");
3: -  Matrix<T> tmp(lhs.nrows(), lhs.ncols());
3: -  for (unsigned int i = 0; i < lhs.nrows(); i++)
3: -    for (unsigned int j = 0; j < lhs.ncols(); j++)
3: -      tmp[i][j] = lhs[i][j] * rhs[i][j];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> operator*(const Matrix<T>& lhs, const T& a)
3: -{
3: -  Matrix<T> tmp(lhs.nrows(), lhs.ncols());
3: -  for (unsigned int i = 0; i < lhs.nrows(); i++)
3: -    for (unsigned int j = 0; j < lhs.ncols(); j++)
3: -      tmp[i][j] = lhs[i][j] * a;
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> operator*(const T& a, const Matrix<T>& rhs)
3: -{
3: -  Matrix<T> tmp(rhs.nrows(), rhs.ncols());
3: -  for (unsigned int i = 0; i < rhs.nrows(); i++)
3: -    for (unsigned int j = 0; j < rhs.ncols(); j++)
3: -      tmp[i][j] = a * rhs[i][j];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Matrix<T>& Matrix<T>::operator*=(const Matrix<T>& rhs)
3: -{
3: -  if (m != rhs.ncols() || n != rhs.nrows())
3: -    throw std::logic_error("Operator*=: matrices have different sizes");
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] *= rhs[i][j];
3: -	
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -inline Matrix<T>& Matrix<T>::operator*=(const T& a)
3: -{
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] *= a;
3: -	
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> operator/(const Matrix<T>& lhs, const Matrix<T>& rhs)
3: -{
3: -  if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows())
3: -    throw std::logic_error("Operator+: matrices have different sizes");
3: -  Matrix<T> tmp(lhs.nrows(), lhs.ncols());
3: -  for (unsigned int i = 0; i < lhs.nrows(); i++)
3: -    for (unsigned int j = 0; j < lhs.ncols(); j++)
3: -      tmp[i][j] = lhs[i][j] / rhs[i][j];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> operator/(const Matrix<T>& lhs, const T& a)
3: -{
3: -  Matrix<T> tmp(lhs.nrows(), lhs.ncols());
3: -  for (unsigned int i = 0; i < lhs.nrows(); i++)
3: -    for (unsigned int j = 0; j < lhs.ncols(); j++)
3: -      tmp[i][j] = lhs[i][j] / a;
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> operator/(const T& a, const Matrix<T>& rhs)
3: -{
3: -  Matrix<T> tmp(rhs.nrows(), rhs.ncols());
3: -  for (unsigned int i = 0; i < rhs.nrows(); i++)
3: -    for (unsigned int j = 0; j < rhs.ncols(); j++)
3: -      tmp[i][j] = a / rhs[i][j];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Matrix<T>& Matrix<T>::operator/=(const Matrix<T>& rhs)
3: -{
3: -  if (m != rhs.ncols() || n != rhs.nrows())
3: -    throw std::logic_error("Operator+=: matrices have different sizes");
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] /= rhs[i][j];
3: -	
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -inline Matrix<T>& Matrix<T>::operator/=(const T& a)
3: -{
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] /= a;
3: -	
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> operator^(const Matrix<T>& lhs, const T& a)
3: -{
3: -  Matrix<T> tmp(lhs.nrows(), lhs.ncols());
3: -  for (unsigned int i = 0; i < lhs.nrows(); i++)
3: -    for (unsigned int j = 0; j < lhs.ncols(); j++)
3: -      tmp[i][j] = pow(lhs[i][j], a);
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Matrix<T>& Matrix<T>::operator^=(const Matrix<T>& rhs)
3: -{
3: -  if (m != rhs.ncols() || n != rhs.nrows())
3: -    throw std::logic_error("Operator^=: matrices have different sizes");
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] = pow(v[i][j], rhs[i][j]);
3: -	
3: -  return *this;
3: -}
3: -
3: -
3: -template <typename T>
3: -inline Matrix<T>& Matrix<T>::operator^=(const T& a)
3: -{
3: -  for (unsigned int i = 0; i < n; i++)
3: -    for (unsigned int j = 0; j < m; j++)
3: -      v[i][j] = pow(v[i][j], a);
3: -	
3: -  return *this;
3: -}
3: -
3: -template <typename T>
3: -inline Matrix<T>::operator Vector<T>()
3: -{
3: -  if (n > 1 && m > 1)
3: -    throw std::logic_error("Error matrix cast to vector: trying to cast a multi-dimensional matrix");
3: -  if (n == 1)
3: -    return extractRow(0);
3: -  else
3: -    return extractColumn(0);
3: -}
3: -
3: -template <typename T>
3: -inline bool operator==(const Matrix<T>& a, const Matrix<T>& b)
3: -{
3: -  if (a.nrows() != b.nrows() || a.ncols() != b.ncols())
3: -    throw std::logic_error("Matrices of different size are not confrontable");
3: -  for (unsigned i = 0; i < a.nrows(); i++)
3: -    for (unsigned j = 0; j < a.ncols(); j++)
3: -      if (a[i][j] != b[i][j])
3: -	return false;
3: -  return true;
3: -}
3: -
3: -template <typename T>
3: -inline bool operator!=(const Matrix<T>& a, const Matrix<T>& b)
3: -{
3: -  if (a.nrows() != b.nrows() || a.ncols() != b.ncols())
3: -    throw std::logic_error("Matrices of different size are not confrontable");
3: -  for (unsigned i = 0; i < a.nrows(); i++)
3: -    for (unsigned j = 0; j < a.ncols(); j++)
3: -      if (a[i][j] != b[i][j])
3: -	return true;
3: -  return false;
3: -}
3: -
3: +  }
3: +
3: +  template < typename T >
3: +  inline void Matrix < T > ::set(const T * a, unsigned int n, unsigned int m)
3: +  {
3: +    if (this->n != n || this->m != m) {
3: +      resize(n, m);
3: +    }
3: +    unsigned int k = 0;
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] = a[k++];
3: +      }
3: +    }
3: +  }
3: +
3: +
3: +  template < typename T >
3: +  Matrix < T > operator + (const Matrix < T > &rhs)
3: +  {
3: +    return rhs;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > operator + (const Matrix < T > &lhs, const Matrix < T > &rhs)
3: +  {
3: +    if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows()) {
3: +      throw std::logic_error("Operator+: matrices have different sizes");
3: +    }
3: +    Matrix < T > tmp(lhs.nrows(), lhs.ncols());
3: +    for (unsigned int i = 0; i < lhs.nrows(); i++) {
3: +      for (unsigned int j = 0; j < lhs.ncols(); j++) {
3: +        tmp[i][j] = lhs[i][j] + rhs[i][j];
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > operator + (const Matrix < T > &lhs, const T & a)
3: +  {
3: +    Matrix < T > tmp(lhs.nrows(), lhs.ncols());
3: +    for (unsigned int i = 0; i < lhs.nrows(); i++) {
3: +      for (unsigned int j = 0; j < lhs.ncols(); j++) {
3: +        tmp[i][j] = lhs[i][j] + a;
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > operator + (const T & a, const Matrix < T > &rhs)
3: +  {
3: +    Matrix < T > tmp(rhs.nrows(), rhs.ncols());
3: +    for (unsigned int i = 0; i < rhs.nrows(); i++) {
3: +      for (unsigned int j = 0; j < rhs.ncols(); j++) {
3: +        tmp[i][j] = a + rhs[i][j];
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > & Matrix < T > ::operator += (const Matrix < T > &rhs)
3: +  {
3: +    if (m != rhs.ncols() || n != rhs.nrows()) {
3: +      throw std::logic_error("Operator+=: matrices have different sizes");
3: +    }
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] += rhs[i][j];
3: +      }
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > & Matrix < T > ::operator += (const T & a)
3: +  {
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] += a;
3: +      }
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > operator - (const Matrix < T > &rhs)
3: +  {
3: +    return (T)(-1) * rhs;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > operator - (const Matrix < T > &lhs, const Matrix < T > &rhs)
3: +  {
3: +    if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows()) {
3: +      throw std::logic_error("Operator-: matrices have different sizes");
3: +    }
3: +    Matrix < T > tmp(lhs.nrows(), lhs.ncols());
3: +    for (unsigned int i = 0; i < lhs.nrows(); i++) {
3: +      for (unsigned int j = 0; j < lhs.ncols(); j++) {
3: +        tmp[i][j] = lhs[i][j] - rhs[i][j];
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > operator - (const Matrix < T > &lhs, const T & a)
3: +  {
3: +    Matrix < T > tmp(lhs.nrows(), lhs.ncols());
3: +    for (unsigned int i = 0; i < lhs.nrows(); i++) {
3: +      for (unsigned int j = 0; j < lhs.ncols(); j++) {
3: +        tmp[i][j] = lhs[i][j] - a;
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > operator - (const T & a, const Matrix < T > &rhs)
3: +  {
3: +    Matrix < T > tmp(rhs.nrows(), rhs.ncols());
3: +    for (unsigned int i = 0; i < rhs.nrows(); i++) {
3: +      for (unsigned int j = 0; j < rhs.ncols(); j++) {
3: +        tmp[i][j] = a - rhs[i][j];
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > & Matrix < T > ::operator -= (const Matrix < T > &rhs)
3: +  {
3: +    if (m != rhs.ncols() || n != rhs.nrows()) {
3: +      throw std::logic_error("Operator-=: matrices have different sizes");
3: +    }
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] -= rhs[i][j];
3: +      }
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > & Matrix < T > ::operator -= (const T & a)
3: +  {
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] -= a;
3: +      }
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > operator * (const Matrix < T > &lhs, const Matrix < T > &rhs)
3: +  {
3: +    if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows()) {
3: +      throw std::logic_error("Operator*: matrices have different sizes");
3: +    }
3: +    Matrix < T > tmp(lhs.nrows(), lhs.ncols());
3: +    for (unsigned int i = 0; i < lhs.nrows(); i++) {
3: +      for (unsigned int j = 0; j < lhs.ncols(); j++) {
3: +        tmp[i][j] = lhs[i][j] * rhs[i][j];
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > operator * (const Matrix < T > &lhs, const T & a)
3: +  {
3: +    Matrix < T > tmp(lhs.nrows(), lhs.ncols());
3: +    for (unsigned int i = 0; i < lhs.nrows(); i++) {
3: +      for (unsigned int j = 0; j < lhs.ncols(); j++) {
3: +        tmp[i][j] = lhs[i][j] * a;
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > operator * (const T & a, const Matrix < T > &rhs)
3: +  {
3: +    Matrix < T > tmp(rhs.nrows(), rhs.ncols());
3: +    for (unsigned int i = 0; i < rhs.nrows(); i++) {
3: +      for (unsigned int j = 0; j < rhs.ncols(); j++) {
3: +        tmp[i][j] = a * rhs[i][j];
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > & Matrix < T > ::operator *= (const Matrix < T > &rhs)
3: +  {
3: +    if (m != rhs.ncols() || n != rhs.nrows()) {
3: +      throw std::logic_error("Operator*=: matrices have different sizes");
3: +    }
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] *= rhs[i][j];
3: +      }
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > & Matrix < T > ::operator *= (const T & a)
3: +  {
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] *= a;
3: +      }
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > operator / (const Matrix < T > &lhs, const Matrix < T > &rhs)
3: +  {
3: +    if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows()) {
3: +      throw std::logic_error("Operator+: matrices have different sizes");
3: +    }
3: +    Matrix < T > tmp(lhs.nrows(), lhs.ncols());
3: +    for (unsigned int i = 0; i < lhs.nrows(); i++) {
3: +      for (unsigned int j = 0; j < lhs.ncols(); j++) {
3: +        tmp[i][j] = lhs[i][j] / rhs[i][j];
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > operator / (const Matrix < T > &lhs, const T & a)
3: +  {
3: +    Matrix < T > tmp(lhs.nrows(), lhs.ncols());
3: +    for (unsigned int i = 0; i < lhs.nrows(); i++) {
3: +      for (unsigned int j = 0; j < lhs.ncols(); j++) {
3: +        tmp[i][j] = lhs[i][j] / a;
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > operator / (const T & a, const Matrix < T > &rhs)
3: +  {
3: +    Matrix < T > tmp(rhs.nrows(), rhs.ncols());
3: +    for (unsigned int i = 0; i < rhs.nrows(); i++) {
3: +      for (unsigned int j = 0; j < rhs.ncols(); j++) {
3: +        tmp[i][j] = a / rhs[i][j];
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > & Matrix < T > ::operator /= (const Matrix < T > &rhs)
3: +  {
3: +    if (m != rhs.ncols() || n != rhs.nrows()) {
3: +      throw std::logic_error("Operator+=: matrices have different sizes");
3: +    }
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] /= rhs[i][j];
3: +      }
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > & Matrix < T > ::operator /= (const T & a)
3: +  {
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] /= a;
3: +      }
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > operator ^ (const Matrix < T > &lhs, const T & a)
3: +  {
3: +    Matrix < T > tmp(lhs.nrows(), lhs.ncols());
3: +    for (unsigned int i = 0; i < lhs.nrows(); i++) {
3: +      for (unsigned int j = 0; j < lhs.ncols(); j++) {
3: +        tmp[i][j] = pow(lhs[i][j], a);
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > & Matrix < T > ::operator ^= (const Matrix < T > &rhs)
3: +  {
3: +    if (m != rhs.ncols() || n != rhs.nrows()) {
3: +      throw std::logic_error("Operator^=: matrices have different sizes");
3: +    }
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] = pow(v[i][j], rhs[i][j]);
3: +      }
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +
3: +  template < typename T >
3: +  inline Matrix < T > & Matrix < T > ::operator ^= (const T & a)
3: +  {
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = 0; j < m; j++) {
3: +        v[i][j] = pow(v[i][j], a);
3: +      }
3: +    }
3: +
3: +    return *this;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < T > ::operator Vector < T > ()
3: +  {
3: +    if (n > 1 && m > 1) {
3: +      throw std::logic_error(
3: +        "Error matrix cast to vector: trying to cast a multi-dimensional matrix");
3: +    }
3: +    if (n == 1) {
3: +      return extractRow(0);
3: +    } else {
3: +      return extractColumn(0);
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  inline bool operator == (const Matrix < T > &a, const Matrix < T > &b)
3: +  {
3: +    if (a.nrows() != b.nrows() || a.ncols() != b.ncols()) {
3: +      throw std::logic_error("Matrices of different size are not confrontable");
3: +    }
3: +    for (unsigned i = 0; i < a.nrows(); i++) {
3: +      for (unsigned j = 0; j < a.ncols(); j++) {
3: +        if (a[i][j] != b[i][j]) {
3: +          return false;
3: +        }
3: +      }
3: +    }
3: +    return true;
3: +  }
3: +
3: +  template < typename T >
3: +  inline bool operator != (const Matrix < T > &a, const Matrix < T > &b)
3: +  {
3: +    if (a.nrows() != b.nrows() || a.ncols() != b.ncols()) {
3: +      throw std::logic_error("Matrices of different size are not confrontable");
3: +    }
3: +    for (unsigned i = 0; i < a.nrows(); i++) {
3: +      for (unsigned j = 0; j < a.ncols(); j++) {
3: +        if (a[i][j] != b[i][j]) {
3: +          return true;
3: +        }
3: +      }
3: +    }
3: +    return false;
3: +  }
3: @@ -1601 +1824 @@
3: -   Input/Output 
3: +   Input/Output
3: @@ -1603,300 +1826,297 @@
3: -template <typename T>
3: -std::ostream& operator<<(std::ostream& os, const Matrix<T>& m)
3: -{
3: -  os << std::endl << m.nrows() << " " << m.ncols() << std::endl;
3: -  for (unsigned int i = 0; i < m.nrows(); i++)
3: -    {
3: -      for (unsigned int j = 0; j < m.ncols() - 1; j++)
3: -	os << std::setw(20) << std::setprecision(16) << m[i][j] << ", ";
3: -      os << std::setw(20) << std::setprecision(16) << m[i][m.ncols() - 1] << std::endl;
3: -    }
3: -	
3: -  return os;
3: -}
3: -
3: -template <typename T>
3: -std::istream& operator>>(std::istream& is, Matrix<T>& m)
3: -{
3: -  int rows, cols;
3: -  char comma;
3: -  is >> rows >> cols;
3: -  m.resize(rows, cols);
3: -  for (unsigned int i = 0; i < rows; i++)
3: -    for (unsigned int j = 0; j < cols; j++)
3: -      is >> m[i][j] >> comma;
3: -	
3: -  return is;
3: -}
3: -
3: -template <typename T>
3: -T sign(const T& v)
3: -{
3: -  if (v >= (T)0.0)
3: -    return (T)1.0;
3: -  else
3: -    return (T)-1.0;
3: -}
3: -
3: -template <typename T>
3: -T dist(const T& a, const T& b)
3: -{
3: -  T abs_a = (T)fabs(a), abs_b = (T)fabs(b);
3: -  if (abs_a > abs_b)
3: -    return abs_a * sqrt((T)1.0 + (abs_b / abs_a) * (abs_b / abs_a));
3: -  else
3: -    return (abs_b == (T)0.0 ? (T)0.0 : abs_b * sqrt((T)1.0 + (abs_a / abs_b) * (abs_a / abs_b)));
3: -}
3: -
3: -template <typename T>
3: -void svd(const Matrix<T>& A, Matrix<T>& U, Vector<T>& W, Matrix<T>& V)
3: -{
3: -  int m = A.nrows(), n = A.ncols(), i, j, k, l, jj, nm;
3: -  const unsigned int max_its = 30;
3: -  bool flag;
3: -  Vector<T> rv1(n);
3: -  U = A;
3: -  W.resize(n);
3: -  V.resize(n, n);
3: -  T anorm, c, f, g, h, s, scale, x, y, z;
3: -  g = scale = anorm = (T)0.0;
3: -	
3: -  // Householder reduction to bidiagonal form
3: -  for (i = 0; i < n; i++)
3: -    {
3: -      l = i + 1;
3: -      rv1[i] = scale * g;
3: -      g = s = scale = (T)0.0;
3: -      if (i < m)
3: -	{
3: -	  for (k = i; k < m; k++)
3: -	    scale += fabs(U[k][i]);
3: -	  if (scale != (T)0.0)
3: -	    {
3: -	      for (k = i; k < m; k++)
3: -		{
3: -		  U[k][i] /= scale;
3: -		  s += U[k][i] * U[k][i];
3: -		}
3: -	      f = U[i][i];
3: -	      g = -sign(f) * sqrt(s);
3: -	      h = f * g - s;
3: -	      U[i][i] = f - g;
3: -	      for (j = l; j < n; j++)
3: -		{
3: -		  s = (T)0.0;
3: -		  for (k = i; k < m; k++)
3: -		    s += U[k][i] * U[k][j];
3: -		  f = s / h;
3: -		  for (k = i; k < m; k++)
3: -		    U[k][j] += f * U[k][i];
3: -		}
3: -	      for (k = i; k < m; k++)
3: -		U[k][i] *= scale;
3: -	    }
3: -	}
3: -      W[i] = scale * g;
3: -      g = s = scale = (T)0.0;
3: -      if (i < m && i != n - 1)
3: -	{
3: -	  for (k = l; k < n; k++)
3: -	    scale += fabs(U[i][k]);
3: -	  if (scale != (T)0.0)
3: -	    {
3: -	      for (k = l; k < n; k++)
3: -		{
3: -		  U[i][k] /= scale;
3: -		  s += U[i][k] * U[i][k];					
3: -		}
3: -	      f = U[i][l];
3: -	      g = -sign(f) * sqrt(s);
3: -	      h = f * g - s;
3: -	      U[i][l] = f - g;
3: -	      for (k = l; k <n; k++)
3: -		rv1[k] = U[i][k] / h;
3: -	      for (j = l; j < m; j++)
3: -		{
3: -		  s = (T)0.0;
3: -		  for (k = l; k < n; k++)
3: -		    s += U[j][k] * U[i][k];
3: -		  for (k = l; k < n; k++)
3: -		    U[j][k] += s * rv1[k];
3: -		}
3: -	      for (k = l; k < n; k++)
3: -		U[i][k] *= scale;
3: -	    }
3: -	}
3: -      anorm = std::max(anorm, fabs(W[i]) + fabs(rv1[i]));
3: -    }
3: -  // Accumulation of right-hand transformations
3: -  for (i = n - 1; i >= 0; i--)
3: -    {
3: -      if (i < n - 1) 
3: -	{
3: -	  if (g != (T)0.0)
3: -	    {
3: -	      for (j = l; j < n; j++)
3: -		V[j][i] = (U[i][j] / U[i][l]) / g;
3: -	      for (j = l; j < n; j++)
3: -		{
3: -		  s = (T)0.0;
3: -		  for (k = l; k < n; k++)
3: -		    s += U[i][k] * V[k][j];
3: -		  for (k = l; k < n; k++)
3: -		    V[k][j] += s * V[k][i];
3: -		}
3: -	    }
3: -	  for (j = l; j < n; j++)
3: -	    V[i][j] = V[j][i] = (T)0.0;
3: -	}
3: -      V[i][i] = (T)1.0;
3: -      g = rv1[i];
3: -      l = i;
3: -    }
3: -  // Accumulation of left-hand transformations
3: -  for (i = std::min(m, n) - 1; i >= 0; i--)
3: -    {
3: -      l = i + 1;
3: -      g = W[i];
3: -      for (j = l; j < n; j++)
3: -	U[i][j] = (T)0.0;
3: -      if (g != (T)0.0)
3: -	{
3: -	  g = (T)1.0 / g;
3: -	  for (j = l; j < n; j++)
3: -	    {
3: -	      s = (T)0.0;
3: -	      for (k = l; k < m; k++)
3: -		s += U[k][i] * U[k][j];
3: -	      f = (s / U[i][i]) * g;
3: -	      for (k = i; k < m; k++)
3: -		U[k][j] += f * U[k][i];
3: -	    }
3: -	  for (j = i; j < m; j++)
3: -	    U[j][i] *= g;
3: -	}
3: -      else
3: -	for (j = i; j < m; j++)
3: -	  U[j][i] = (T)0.0;
3: -      U[i][i]++;
3: -    }
3: -  // Diagonalization of the bidiagonal form: loop over singular values, and over allowed iterations.
3: -  for (k = n - 1; k >= 0; k--)
3: -    {
3: -      for (unsigned int its = 0; its < max_its; its++)
3: -	{
3: -	  flag = true;
3: -	  for (l = k; l >= 0; l--) // FIXME: in NR it was l >= 1 but there subscripts start from one
3: -	    { // Test for splitting
3: -	      nm = l - 1; // Note that rV[0] is always zero
3: -	      if ((T)(fabs(rv1[l]) + anorm) == anorm)
3: -		{
3: -		  flag = false;
3: -		  break;
3: -		}
3: -	      if ((T)(fabs(W[nm]) + anorm) == anorm)
3: -		break;
3: -	    }
3: -	  if (flag)
3: -	    {
3: -	      // Cancellation of rv1[l], if l > 0 FIXME: it was l > 1 in NR
3: -	      c = (T)0.0;
3: -	      s = (T)1.0;
3: -	      for (i = l; i <= k; i++)
3: -		{
3: -		  f = s * rv1[i];
3: -		  rv1[i] *= c;
3: -		  if ((T)(fabs(f) + anorm) == anorm)
3: -		    break;
3: -		  g = W[i];
3: -		  h = dist(f, g);
3: -		  W[i] = h;
3: -		  h = (T)1.0 / h;
3: -		  c = g * h;
3: -		  s = -f * h;
3: -		  for (j = 0; j < m; j++)
3: -		    {
3: -		      y = U[j][nm];
3: -		      z = U[j][i];
3: -		      U[j][nm] = y * c + z * s;
3: -		      U[j][i] = z * c - y * s;
3: -		    }
3: -		}
3: -	    }
3: -	  z = W[k];
3: -	  if (l == k)
3: -	    {  // Convergence
3: -	      if (z < (T)0.0)
3: -		{ // Singular value is made nonnegative
3: -		  W[k] = -z;
3: -		  for (j = 0; j < n; j++)
3: -		    V[j][k] = -V[j][k];
3: -		}
3: -	      break;
3: -	    }
3: -	  if (its == max_its)
3: -	    throw std::logic_error("Error svd: no convergence in the maximum number of iterations");
3: -	  x = W[l];
3: -	  nm = k - 1;
3: -	  y = W[nm];
3: -	  g = rv1[nm];
3: -	  h = rv1[k];
3: -	  f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);
3: -	  g = dist(f, (T)1.0);
3: -	  f = ((x - z) * (x + z) + h * ((y / (f + sign(f)*fabs(g))) - h)) / x;
3: -	  c = s = (T)1.0; // Next QR transformation
3: -	  for (j = l; j <= nm; j++)
3: -	    {
3: -	      i = j + 1;
3: -	      g = rv1[i];
3: -	      y = W[i];
3: -	      h = s * g;
3: -	      g *= c;
3: -	      z = dist(f, h);
3: -	      rv1[j] = z;
3: -	      c = f / z;
3: -	      s = h / z;
3: -	      f = x * c + g * s;
3: -	      g = g * c - x * s;
3: -	      h = y * s;
3: -	      y *= c;
3: -	      for (jj = 0; jj < n; jj++)
3: -		{
3: -		  x = V[jj][j];
3: -		  z = V[jj][i];
3: -		  V[jj][j] = x * c + z * s;
3: -		  V[jj][i] = z * c - x * s;
3: -		}
3: -	      z = dist(f, h);
3: -	      W[j] = z; 
3: -	      if (z != 0) // Rotation can be arbitrary if z = 0
3: -		{
3: -		  z = (T)1.0 / z;
3: -		  c = f * z;
3: -		  s = h * z;
3: -		}
3: -	      f = c * g + s * y;
3: -	      x = c * y - s * g;
3: -	      for (jj = 0; jj < m; jj++)
3: -		{
3: -		  y = U[jj][j];
3: -		  z = U[jj][i];
3: -		  U[jj][j] = y * c + z * s;
3: -		  U[jj][i] = z * c - y * s;
3: -		}
3: -	    }
3: -	  rv1[l] = (T)0.0;
3: -	  rv1[k] = f;
3: -	  W[k] = x;
3: -	}
3: -    }	
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> pinv(const Matrix<T>& A)
3: -{
3: -  Matrix<T> U, V, x, tmp(A.ncols(), A.nrows());
3: -  Vector<T> W;
3: -  CanonicalBaseVector<T> e(0, A.nrows());
3: -  svd(A, U, W, V);
3: -  for (unsigned int i = 0; i < A.nrows(); i++)
3: -    {
3: +  template < typename T >
3: +  std::ostream & operator << (std::ostream & os, const Matrix < T > &m)
3: +      {
3: +      os << std::endl << m.nrows() << " " << m.ncols() << std::endl;
3: +      for (unsigned int i = 0; i < m.nrows(); i++) {
3: +        for (unsigned int j = 0; j < m.ncols() - 1; j++) {
3: +          os << std::setw(20) << std::setprecision(16) << m[i][j] << ", ";
3: +        }
3: +        os << std::setw(20) << std::setprecision(16) << m[i][m.ncols() - 1] << std::endl;
3: +      }
3: +
3: +      return os;
3: +    }
3: +
3: +    template < typename T >
3: +    std::istream & operator >> (std::istream & is, Matrix < T > &m)
3: +      {
3: +      int rows, cols;
3: +      char comma;
3: +      is >> rows >> cols;
3: +      m.resize(rows, cols);
3: +      for (unsigned int i = 0; i < rows; i++) {
3: +        for (unsigned int j = 0; j < cols; j++) {
3: +          is >> m[i][j] >> comma;
3: +        }
3: +      }
3: +
3: +      return is;
3: +    }
3: +
3: +    template < typename T >
3: +    T sign(const T & v)
3: +      {
3: +      if (v >= (T)0.0) {
3: +        return (T)1.0;
3: +      } else {
3: +        return (T)-1.0;
3: +      }
3: +    }
3: +
3: +    template < typename T >
3: +    T dist(const T & a, const T & b)
3: +      {
3: +      T abs_a = (T)fabs(a), abs_b = (T)fabs(b);
3: +      if (abs_a > abs_b) {
3: +        return abs_a * sqrt((T)1.0 + (abs_b / abs_a) * (abs_b / abs_a));
3: +      } else {
3: +        return abs_b == (T)0.0 ? (T)0.0 : abs_b * sqrt((T)1.0 + (abs_a / abs_b) * (abs_a / abs_b));
3: +      }
3: +    }
3: +
3: +    template < typename T >
3: +    void svd(const Matrix < T > & A, Matrix < T > & U, Vector < T > & W, Matrix < T > & V)
3: +      {
3: +      int m = A.nrows(), n = A.ncols(), i, j, k, l, jj, nm;
3: +      const unsigned int max_its = 30;
3: +      bool flag;
3: +      Vector < T > rv1(n);
3: +      U = A;
3: +      W.resize(n);
3: +      V.resize(n, n);
3: +      T anorm, c, f, g, h, s, scale, x, y, z;
3: +      g = scale = anorm = (T)0.0;
3: +
3: +      // Householder reduction to bidiagonal form
3: +      for (i = 0; i < n; i++) {
3: +        l = i + 1;
3: +        rv1[i] = scale * g;
3: +        g = s = scale = (T)0.0;
3: +        if (i < m) {
3: +          for (k = i; k < m; k++) {
3: +            scale += fabs(U[k][i]);
3: +          }
3: +          if (scale != (T)0.0) {
3: +            for (k = i; k < m; k++) {
3: +              U[k][i] /= scale;
3: +              s += U[k][i] * U[k][i];
3: +            }
3: +            f = U[i][i];
3: +            g = -sign(f) * sqrt(s);
3: +            h = f * g - s;
3: +            U[i][i] = f - g;
3: +            for (j = l; j < n; j++) {
3: +              s = (T)0.0;
3: +              for (k = i; k < m; k++) {
3: +                s += U[k][i] * U[k][j];
3: +              }
3: +              f = s / h;
3: +              for (k = i; k < m; k++) {
3: +                U[k][j] += f * U[k][i];
3: +              }
3: +            }
3: +            for (k = i; k < m; k++) {
3: +              U[k][i] *= scale;
3: +            }
3: +          }
3: +        }
3: +        W[i] = scale * g;
3: +        g = s = scale = (T)0.0;
3: +        if (i < m && i != n - 1) {
3: +          for (k = l; k < n; k++) {
3: +            scale += fabs(U[i][k]);
3: +          }
3: +          if (scale != (T)0.0) {
3: +            for (k = l; k < n; k++) {
3: +              U[i][k] /= scale;
3: +              s += U[i][k] * U[i][k];
3: +            }
3: +            f = U[i][l];
3: +            g = -sign(f) * sqrt(s);
3: +            h = f * g - s;
3: +            U[i][l] = f - g;
3: +            for (k = l; k < n; k++) {
3: +              rv1[k] = U[i][k] / h;
3: +            }
3: +            for (j = l; j < m; j++) {
3: +              s = (T)0.0;
3: +              for (k = l; k < n; k++) {
3: +                s += U[j][k] * U[i][k];
3: +              }
3: +              for (k = l; k < n; k++) {
3: +                U[j][k] += s * rv1[k];
3: +              }
3: +            }
3: +            for (k = l; k < n; k++) {
3: +              U[i][k] *= scale;
3: +            }
3: +          }
3: +        }
3: +        anorm = std::max(anorm, fabs(W[i]) + fabs(rv1[i]));
3: +      }
3: +      // Accumulation of right-hand transformations
3: +      for (i = n - 1; i >= 0; i--) {
3: +        if (i < n - 1) {
3: +          if (g != (T)0.0) {
3: +            for (j = l; j < n; j++) {
3: +              V[j][i] = (U[i][j] / U[i][l]) / g;
3: +            }
3: +            for (j = l; j < n; j++) {
3: +              s = (T)0.0;
3: +              for (k = l; k < n; k++) {
3: +                s += U[i][k] * V[k][j];
3: +              }
3: +              for (k = l; k < n; k++) {
3: +                V[k][j] += s * V[k][i];
3: +              }
3: +            }
3: +          }
3: +          for (j = l; j < n; j++) {
3: +            V[i][j] = V[j][i] = (T)0.0;
3: +          }
3: +        }
3: +        V[i][i] = (T)1.0;
3: +        g = rv1[i];
3: +        l = i;
3: +      }
3: +      // Accumulation of left-hand transformations
3: +      for (i = std::min(m, n) - 1; i >= 0; i--) {
3: +        l = i + 1;
3: +        g = W[i];
3: +        for (j = l; j < n; j++) {
3: +          U[i][j] = (T)0.0;
3: +        }
3: +        if (g != (T)0.0) {
3: +          g = (T)1.0 / g;
3: +          for (j = l; j < n; j++) {
3: +            s = (T)0.0;
3: +            for (k = l; k < m; k++) {
3: +              s += U[k][i] * U[k][j];
3: +            }
3: +            f = (s / U[i][i]) * g;
3: +            for (k = i; k < m; k++) {
3: +              U[k][j] += f * U[k][i];
3: +            }
3: +          }
3: +          for (j = i; j < m; j++) {
3: +            U[j][i] *= g;
3: +          }
3: +        } else {
3: +          for (j = i; j < m; j++) {
3: +            U[j][i] = (T)0.0;
3: +          }
3: +        }
3: +        U[i][i]++;
3: +      }
3: +      // Diagonalization of the bidiagonal form: loop over singular values, and over allowed iterations.
3: +      for (k = n - 1; k >= 0; k--) {
3: +        for (unsigned int its = 0; its < max_its; its++) {
3: +          flag = true;
3: +          for (l = k; l >= 0; l--) { // FIXME: in NR it was l >= 1 but there subscripts start from one
3: +            // Test for splitting
3: +            nm = l - 1;   // Note that rV[0] is always zero
3: +            if ((T)(fabs(rv1[l]) + anorm) == anorm) {
3: +              flag = false;
3: +              break;
3: +            }
3: +            if ((T)(fabs(W[nm]) + anorm) == anorm) {
3: +              break;
3: +            }
3: +          }
3: +          if (flag) {
3: +            // Cancellation of rv1[l], if l > 0 FIXME: it was l > 1 in NR
3: +            c = (T)0.0;
3: +            s = (T)1.0;
3: +            for (i = l; i <= k; i++) {
3: +              f = s * rv1[i];
3: +              rv1[i] *= c;
3: +              if ((T)(fabs(f) + anorm) == anorm) {
3: +                break;
3: +              }
3: +              g = W[i];
3: +              h = dist(f, g);
3: +              W[i] = h;
3: +              h = (T)1.0 / h;
3: +              c = g * h;
3: +              s = -f * h;
3: +              for (j = 0; j < m; j++) {
3: +                y = U[j][nm];
3: +                z = U[j][i];
3: +                U[j][nm] = y * c + z * s;
3: +                U[j][i] = z * c - y * s;
3: +              }
3: +            }
3: +          }
3: +          z = W[k];
3: +          if (l == k) { // Convergence
3: +            if (z < (T)0.0) { // Singular value is made nonnegative
3: +              W[k] = -z;
3: +              for (j = 0; j < n; j++) {
3: +                V[j][k] = -V[j][k];
3: +              }
3: +            }
3: +            break;
3: +          }
3: +          if (its == max_its) {
3: +            throw std::logic_error("Error svd: no convergence in the maximum number of iterations");
3: +          }
3: +          x = W[l];
3: +          nm = k - 1;
3: +          y = W[nm];
3: +          g = rv1[nm];
3: +          h = rv1[k];
3: +          f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);
3: +          g = dist(f, (T)1.0);
3: +          f = ((x - z) * (x + z) + h * ((y / (f + sign(f) * fabs(g))) - h)) / x;
3: +          c = s = (T)1.0; // Next QR transformation
3: +          for (j = l; j <= nm; j++) {
3: +            i = j + 1;
3: +            g = rv1[i];
3: +            y = W[i];
3: +            h = s * g;
3: +            g *= c;
3: +            z = dist(f, h);
3: +            rv1[j] = z;
3: +            c = f / z;
3: +            s = h / z;
3: +            f = x * c + g * s;
3: +            g = g * c - x * s;
3: +            h = y * s;
3: +            y *= c;
3: +            for (jj = 0; jj < n; jj++) {
3: +              x = V[jj][j];
3: +              z = V[jj][i];
3: +              V[jj][j] = x * c + z * s;
3: +              V[jj][i] = z * c - x * s;
3: +            }
3: +            z = dist(f, h);
3: +            W[j] = z;
3: +            if (z != 0) { // Rotation can be arbitrary if z = 0
3: +              z = (T)1.0 / z;
3: +              c = f * z;
3: +              s = h * z;
3: +            }
3: +            f = c * g + s * y;
3: +            x = c * y - s * g;
3: +            for (jj = 0; jj < m; jj++) {
3: +              y = U[jj][j];
3: +              z = U[jj][i];
3: +              U[jj][j] = y * c + z * s;
3: +              U[jj][i] = z * c - y * s;
3: +            }
3: +          }
3: +          rv1[l] = (T)0.0;
3: +          rv1[k] = f;
3: +          W[k] = x;
3: +        }
3: +      }
3: +      }
3: +
3: +  template < typename T >
3: +  Matrix < T > pinv(const Matrix < T > &A)
3: +  {
3: +    Matrix < T > U, V, x, tmp(A.ncols(), A.nrows());
3: +    Vector < T > W;
3: +    CanonicalBaseVector < T > e(0, A.nrows());
3: +    svd(A, U, W, V);
3: +    for (unsigned int i = 0; i < A.nrows(); i++) {
3: @@ -1904,20 +2124,25 @@
3: -      tmp.setColumn(i, dot_prod(dot_prod(dot_prod(V, Matrix<double>(DIAG, 1.0 / W, 0.0, W.size(), W.size())), t(U)), e));
3: -    }
3: -		
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -int lu(const Matrix<T>& A, Matrix<T>& LU, Vector<unsigned int>& index)
3: -{
3: -  if (A.ncols() != A.nrows())
3: -    throw std::logic_error("Error in LU decomposition: matrix must be squared");
3: -  int i, p, j, k, n = A.ncols(), ex;
3: -  T val, tmp;
3: -  Vector<T> d(n);
3: -  LU = A;
3: -  index.resize(n);
3: -	
3: -  ex = 1;
3: -  for (i = 0; i < n; i++)
3: -    {
3: +      tmp.setColumn(
3: +        i,
3: +        dot_prod(
3: +          dot_prod(
3: +            dot_prod(V, Matrix < double > (DIAG, 1.0 / W, 0.0, W.size(), W.size())),
3: +            t(U)), e));
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  int lu(const Matrix < T > & A, Matrix < T > & LU, Vector < unsigned int > & index)
3: +  {
3: +    if (A.ncols() != A.nrows()) {
3: +      throw std::logic_error("Error in LU decomposition: matrix must be squared");
3: +    }
3: +    int i, p, j, k, n = A.ncols(), ex;
3: +    T val, tmp;
3: +    Vector < T > d(n);
3: +    LU = A;
3: +    index.resize(n);
3: +
3: +    ex = 1;
3: +    for (i = 0; i < n; i++) {
3: @@ -1926,4 +2151,6 @@
3: -      for (j = 0; j < n; j++)
3: -	val = std::max(val, (T)fabs(LU[i][j]));
3: -      if (val == (T)0.0)
3: -	std::logic_error("Error in LU decomposition: matrix was singular");
3: +      for (j = 0; j < n; j++) {
3: +        val = std::max(val, (T)fabs(LU[i][j]));
3: +      }
3: +      if (val == (T)0.0) {
3: +        std::logic_error("Error in LU decomposition: matrix was singular");
3: +      }
3: @@ -1933,2 +2160 @@
3: -  for (k = 0; k < n - 1; k++)
3: -    {
3: +    for (k = 0; k < n - 1; k++) {
3: @@ -1937,50 +2163,54 @@
3: -      for (i = k + 1; i < n; i++)
3: -	{
3: -	  tmp = fabs(LU[i][k]) / d[i];
3: -	  if (tmp > val)
3: -	    {
3: -	      val = tmp;
3: -	      p = i;
3: -	    }
3: -	}
3: -      if (val == (T)0.0)
3: -	std::logic_error("Error in LU decomposition: matrix was singular");
3: -      if (p > k)
3: -	{
3: -	  ex = -ex;
3: -	  std::swap(index[k], index[p]);
3: -	  std::swap(d[k], d[p]);
3: -	  for (j = 0; j < n; j++)
3: -	    std::swap(LU[k][j], LU[p][j]);
3: -	}
3: -		
3: -      for (i = k + 1; i < n; i++)
3: -	{
3: -	  LU[i][k] /= LU[k][k];
3: -	  for (j = k + 1; j < n; j++)
3: -	    LU[i][j] -= LU[i][k] * LU[k][j];
3: -	}
3: -    }
3: -  if (LU[n - 1][n - 1] == (T)0.0)
3: -    std::logic_error("Error in LU decomposition: matrix was singular");
3: -		
3: -  return ex;
3: -}
3: -
3: -template <typename T>
3: -Vector<T> lu_solve(const Matrix<T>& LU, const Vector<T>& b, Vector<unsigned int>& index)
3: -{
3: -  if (LU.ncols() != LU.nrows())
3: -    throw std::logic_error("Error in LU solve: LU matrix should be squared");
3: -  unsigned int n = LU.ncols();
3: -  if (b.size() != n)
3: -    throw std::logic_error("Error in LU solve: b vector must be of the same dimensions of LU matrix");
3: -  Vector<T> x((T)0.0, n);
3: -  int i, j, p;
3: -  T sum;
3: -	
3: -  p = index[0];
3: -  x[0] = b[p];
3: -	
3: -  for (i = 1; i < n; i++)
3: -    {
3: +      for (i = k + 1; i < n; i++) {
3: +        tmp = fabs(LU[i][k]) / d[i];
3: +        if (tmp > val) {
3: +          val = tmp;
3: +          p = i;
3: +        }
3: +      }
3: +      if (val == (T)0.0) {
3: +        std::logic_error("Error in LU decomposition: matrix was singular");
3: +      }
3: +      if (p > k) {
3: +        ex = -ex;
3: +        std::swap(index[k], index[p]);
3: +        std::swap(d[k], d[p]);
3: +        for (j = 0; j < n; j++) {
3: +          std::swap(LU[k][j], LU[p][j]);
3: +        }
3: +      }
3: +
3: +      for (i = k + 1; i < n; i++) {
3: +        LU[i][k] /= LU[k][k];
3: +        for (j = k + 1; j < n; j++) {
3: +          LU[i][j] -= LU[i][k] * LU[k][j];
3: +        }
3: +      }
3: +    }
3: +    if (LU[n - 1][n - 1] == (T)0.0) {
3: +      std::logic_error("Error in LU decomposition: matrix was singular");
3: +    }
3: +
3: +    return ex;
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > lu_solve(
3: +    const Matrix < T > &LU, const Vector < T > &b,
3: +    Vector < unsigned int > &index)
3: +  {
3: +    if (LU.ncols() != LU.nrows()) {
3: +      throw std::logic_error("Error in LU solve: LU matrix should be squared");
3: +    }
3: +    unsigned int n = LU.ncols();
3: +    if (b.size() != n) {
3: +      throw std::logic_error(
3: +        "Error in LU solve: b vector must be of the same dimensions of LU matrix");
3: +    }
3: +    Vector < T > x((T)0.0, n);
3: +    int i, j, p;
3: +    T sum;
3: +
3: +    p = index[0];
3: +    x[0] = b[p];
3: +
3: +    for (i = 1; i < n; i++) {
3: @@ -1988,2 +2218,3 @@
3: -      for (j = 0; j < i; j++)
3: -	sum += LU[i][j] * x[j];
3: +      for (j = 0; j < i; j++) {
3: +        sum += LU[i][j] * x[j];
3: +      }
3: @@ -1993,3 +2224,2 @@
3: -  x[n - 1] /= LU[n - 1][n - 1];
3: -  for (i = n - 2; i >= 0; i--)
3: -    {
3: +    x[n - 1] /= LU[n - 1][n - 1];
3: +    for (i = n - 2; i >= 0; i--) {
3: @@ -1997,2 +2227,3 @@
3: -      for (j = i + 1; j < n; j++)
3: -	sum += LU[i][j] * x[j];
3: +      for (j = i + 1; j < n; j++) {
3: +        sum += LU[i][j] * x[j];
3: +      }
3: @@ -2001,22 +2232,24 @@
3: -  return x;
3: -}
3: -
3: -template <typename T>
3: -void lu_solve(const Matrix<T>& LU, Vector<T>& x, const Vector<T>& b, Vector<unsigned int>& index)
3: -{
3: -  x = lu_solve(LU, b, index);
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> lu_inverse(const Matrix<T>& A)
3: -{
3: -  if (A.ncols() != A.nrows())
3: -    throw std::logic_error("Error in LU invert: matrix must be squared");	
3: -  unsigned int n = A.ncols();
3: -  Matrix<T> A1(n, n), LU;
3: -  Vector<unsigned int> index;
3: -	
3: -  lu(A, LU, index);
3: -  CanonicalBaseVector<T> e(0, n);
3: -  for (unsigned i = 0; i < n; i++)
3: -    {
3: +    return x;
3: +  }
3: +
3: +  template < typename T >
3: +  void lu_solve(
3: +    const Matrix < T > & LU, Vector < T > & x, const Vector < T > & b,
3: +    Vector < unsigned int > & index)
3: +  {
3: +    x = lu_solve(LU, b, index);
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > lu_inverse(const Matrix < T > &A)
3: +  {
3: +    if (A.ncols() != A.nrows()) {
3: +      throw std::logic_error("Error in LU invert: matrix must be squared");
3: +    }
3: +    unsigned int n = A.ncols();
3: +    Matrix < T > A1(n, n), LU;
3: +    Vector < unsigned int > index;
3: +
3: +    lu(A, LU, index);
3: +    CanonicalBaseVector < T > e(0, n);
3: +    for (unsigned i = 0; i < n; i++) {
3: @@ -2026,94 +2259,103 @@
3: -	
3: -  return A1;
3: -}
3: -
3: -template <typename T>
3: -T lu_det(const Matrix<T>& A)
3: -{
3: -  if (A.ncols() != A.nrows())
3: -    throw std::logic_error("Error in LU determinant: matrix must be squared");	
3: -  unsigned int d;
3: -  Matrix<T> LU;
3: -  Vector<unsigned int> index;
3: -	
3: -  d = lu(A, LU, index);
3: -	
3: -  return d * prod(LU.extractDiag());
3: -}
3: -
3: -template <typename T>
3: -void cholesky(const Matrix<T> A, Matrix<T>& LL) 
3: -{
3: -  if (A.ncols() != A.nrows())
3: -    throw std::logic_error("Error in Cholesky decomposition: matrix must be squared");
3: -  int n = A.ncols();
3: -  double sum;
3: -  LL = A;
3: -	
3: -  for (unsigned int i = 0; i < n; i++)
3: -    {
3: -      for (unsigned int j = i; j < n; j++)
3: -	{
3: -	  sum = LL[i][j];
3: -	  for (int k = i - 1; k >= 0; k--)
3: -	    sum -= LL[i][k] * LL[j][k];
3: -	  if (i == j) 
3: -	    {
3: -	      if (sum <= 0.0)
3: -		throw std::logic_error("Error in Cholesky decomposition: matrix is not postive definite");
3: -	      LL[i][i] = sqrt(sum);
3: -	    }
3: -	  else
3: -	    LL[j][i] = sum / LL[i][i];
3: -	}
3: -      for (unsigned int k = i + 1; k < n; k++)
3: -	LL[i][k] = LL[k][i];
3: -    } 
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> cholesky(const Matrix<T> A) 
3: -{
3: -  Matrix<T> LL;
3: -  cholesky(A, LL);
3: -	
3: -  return LL;
3: -}
3: -
3: -template <typename T>
3: -Vector<T> cholesky_solve(const Matrix<T>& LL, const Vector<T>& b)
3: -{
3: -  if (LL.ncols() != LL.nrows())
3: -    throw std::logic_error("Error in Cholesky solve: matrix must be squared");
3: -  unsigned int n = LL.ncols();
3: -  if (b.size() != n)
3: -    throw std::logic_error("Error in Cholesky decomposition: b vector must be of the same dimensions of LU matrix");
3: -  Vector<T> x, y;
3: -	
3: -  /* Solve L * y = b */
3: -  forward_elimination(LL, y, b);
3: -  /* Solve L^T * x = y */
3: -  backward_elimination(LL, x, y);
3: -	
3: -  return x;
3: -}
3: -
3: -template <typename T>
3: -void cholesky_solve(const Matrix<T>& LL, Vector<T>& x, const Vector<T>& b)
3: -{
3: -  x = cholesky_solve(LL, b);
3: -}
3: -
3: -template <typename T>
3: -void forward_elimination(const Matrix<T>& L, Vector<T>& y, const Vector<T> b)
3: -{
3: -  if (L.ncols() != L.nrows())
3: -    throw std::logic_error("Error in Forward elimination: matrix must be squared (lower triangular)");
3: -  if (b.size() != L.nrows())
3: -    throw std::logic_error("Error in Forward elimination: b vector must be of the same dimensions of L matrix");
3: -  unsigned int n = b.size();
3: -  y.resize(n);
3: -	
3: -  y[0] = b[0] / L[0][0];
3: -  for (unsigned int i = 1; i < n; i++)
3: -    {
3: +
3: +    return A1;
3: +  }
3: +
3: +  template < typename T >
3: +  T lu_det(const Matrix < T > & A)
3: +  {
3: +    if (A.ncols() != A.nrows()) {
3: +      throw std::logic_error("Error in LU determinant: matrix must be squared");
3: +    }
3: +    unsigned int d;
3: +    Matrix < T > LU;
3: +    Vector < unsigned int > index;
3: +
3: +    d = lu(A, LU, index);
3: +
3: +    return d * prod(LU.extractDiag());
3: +  }
3: +
3: +  template < typename T >
3: +  void cholesky(const Matrix < T > A, Matrix < T > & LL)
3: +  {
3: +    if (A.ncols() != A.nrows()) {
3: +      throw std::logic_error("Error in Cholesky decomposition: matrix must be squared");
3: +    }
3: +    int n = A.ncols();
3: +    double sum;
3: +    LL = A;
3: +
3: +    for (unsigned int i = 0; i < n; i++) {
3: +      for (unsigned int j = i; j < n; j++) {
3: +        sum = LL[i][j];
3: +        for (int k = i - 1; k >= 0; k--) {
3: +          sum -= LL[i][k] * LL[j][k];
3: +        }
3: +        if (i == j) {
3: +          if (sum <= 0.0) {
3: +            throw std::logic_error(
3: +              "Error in Cholesky decomposition: matrix is not postive definite");
3: +          }
3: +          LL[i][i] = sqrt(sum);
3: +        } else {
3: +          LL[j][i] = sum / LL[i][i];
3: +        }
3: +      }
3: +      for (unsigned int k = i + 1; k < n; k++) {
3: +        LL[i][k] = LL[k][i];
3: +      }
3: +    }
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > cholesky(const Matrix < T > A)
3: +  {
3: +    Matrix < T > LL;
3: +    cholesky(A, LL);
3: +
3: +    return LL;
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > cholesky_solve(const Matrix < T > &LL, const Vector < T > &b)
3: +  {
3: +    if (LL.ncols() != LL.nrows()) {
3: +      throw std::logic_error("Error in Cholesky solve: matrix must be squared");
3: +    }
3: +    unsigned int n = LL.ncols();
3: +    if (b.size() != n) {
3: +      throw std::logic_error(
3: +        "Error in Cholesky decomposition: b vector must be of the same dimensions of LU matrix");
3: +    }
3: +    Vector < T > x, y;
3: +
3: +    /* Solve L * y = b */
3: +    forward_elimination(LL, y, b);
3: +    /* Solve L^T * x = y */
3: +    backward_elimination(LL, x, y);
3: +
3: +    return x;
3: +  }
3: +
3: +  template < typename T >
3: +  void cholesky_solve(const Matrix < T > & LL, Vector < T > & x, const Vector < T > & b)
3: +  {
3: +    x = cholesky_solve(LL, b);
3: +  }
3: +
3: +  template < typename T >
3: +  void forward_elimination(const Matrix < T > & L, Vector < T > & y, const Vector < T > b)
3: +  {
3: +    if (L.ncols() != L.nrows()) {
3: +      throw std::logic_error(
3: +        "Error in Forward elimination: matrix must be squared (lower triangular)");
3: +    }
3: +    if (b.size() != L.nrows()) {
3: +      throw std::logic_error(
3: +        "Error in Forward elimination: b vector must be of the same dimensions of L matrix");
3: +    }
3: +    unsigned int n = b.size();
3: +    y.resize(n);
3: +
3: +    y[0] = b[0] / L[0][0];
3: +    for (unsigned int i = 1; i < n; i++) {
3: @@ -2121,2 +2363,3 @@
3: -      for (unsigned int j = 0; j < i; j++)
3: -	y[i] -= L[i][j] * y[j];
3: +      for (unsigned int j = 0; j < i; j++) {
3: +        y[i] -= L[i][j] * y[j];
3: +      }
3: @@ -2125,24 +2368,27 @@
3: -}
3: -
3: -template <typename T>
3: -Vector<T> forward_elimination(const Matrix<T>& L, const Vector<T> b)
3: -{
3: -  Vector<T> y;
3: -  forward_elimination(L, y, b);
3: -	
3: -  return y;
3: -}
3: -
3: -template <typename T>
3: -void backward_elimination(const Matrix<T>& U, Vector<T>& x, const Vector<T>& y)
3: -{
3: -  if (U.ncols() != U.nrows())
3: -    throw std::logic_error("Error in Backward elimination: matrix must be squared (upper triangular)");
3: -  if (y.size() != U.nrows())
3: -    throw std::logic_error("Error in Backward elimination: b vector must be of the same dimensions of U matrix");
3: -  int n = y.size();
3: -  x.resize(n);
3: -	
3: -  x[n - 1] = y[n - 1] / U[n - 1][n - 1];
3: -  for (int i = n - 2; i >= 0; i--)
3: -    {
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > forward_elimination(const Matrix < T > &L, const Vector < T > b)
3: +  {
3: +    Vector < T > y;
3: +    forward_elimination(L, y, b);
3: +
3: +    return y;
3: +  }
3: +
3: +  template < typename T >
3: +  void backward_elimination(const Matrix < T > & U, Vector < T > & x, const Vector < T > & y)
3: +  {
3: +    if (U.ncols() != U.nrows()) {
3: +      throw std::logic_error(
3: +        "Error in Backward elimination: matrix must be squared (upper triangular)");
3: +    }
3: +    if (y.size() != U.nrows()) {
3: +      throw std::logic_error(
3: +        "Error in Backward elimination: b vector must be of the same dimensions of U matrix");
3: +    }
3: +    int n = y.size();
3: +    x.resize(n);
3: +
3: +    x[n - 1] = y[n - 1] / U[n - 1][n - 1];
3: +    for (int i = n - 2; i >= 0; i--) {
3: @@ -2150,2 +2396,3 @@
3: -      for (int j = i + 1; j < n; j++)
3: -	x[i] -= U[i][j] * x[j];
3: +      for (int j = i + 1; j < n; j++) {
3: +        x[i] -= U[i][j] * x[j];
3: +      }
3: @@ -2154,10 +2401,10 @@
3: -}
3: -
3: -template <typename T>
3: -Vector<T> backward_elimination(const Matrix<T>& U, const Vector<T> y)
3: -{
3: -  Vector<T> x;
3: -  forward_elimination(U, x, y);
3: -	
3: -  return x;
3: -}
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > backward_elimination(const Matrix < T > &U, const Vector < T > y)
3: +  {
3: +    Vector < T > x;
3: +    forward_elimination(U, x, y);
3: +
3: +    return x;
3: +  }
3: @@ -2173,7 +2420,9 @@
3: -template <typename T>
3: -void random(Matrix<T>& m)
3: -{
3: -  for (unsigned int i = 0; i < m.nrows(); i++)
3: -    for (unsigned int j = 0; j < m.ncols(); j++)
3: -      m[i][j] = (T)(rand() / double(RAND_MAX));
3: -}
3: +  template < typename T >
3: +  void random(Matrix < T > & m)
3: +  {
3: +    for (unsigned int i = 0; i < m.nrows(); i++) {
3: +      for (unsigned int j = 0; j < m.ncols(); j++) {
3: +        m[i][j] = (T)(rand() / double(RAND_MAX));
3: +      }
3: +    }
3: +  }
3: @@ -2185,68 +2434,80 @@
3: -template <typename T>
3: -Vector<T> sum(const Matrix<T>& m)
3: -{
3: -  Vector<T> tmp((T)0, m.ncols());
3: -  for (unsigned int j = 0; j < m.ncols(); j++)
3: -    for (unsigned int i = 0; i < m.nrows(); i++)
3: -      tmp[j] += m[i][j];
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Vector<T> r_sum(const Matrix<T>& m)
3: -{
3: -  Vector<T> tmp((T)0, m.nrows());
3: -  for (unsigned int i = 0; i < m.nrows(); i++)
3: -    for (unsigned int j = 0; j < m.ncols(); j++)
3: -      tmp[i] += m[i][j];
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -T all_sum(const Matrix<T>& m)
3: -{
3: -  T tmp = (T)0;
3: -  for (unsigned int i = 0; i < m.nrows(); i++)
3: -    for (unsigned int j = 0; j < m.ncols(); j++)
3: -      tmp += m[i][j];
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Vector<T> prod(const Matrix<T>& m)
3: -{
3: -  Vector<T> tmp((T)1, m.ncols());
3: -  for (unsigned int j = 0; j < m.ncols(); j++)
3: -    for (unsigned int i = 0; i < m.nrows(); i++)
3: -      tmp[j] *= m[i][j];
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Vector<T> r_prod(const Matrix<T>& m)
3: -{
3: -  Vector<T> tmp((T)1, m.nrows());
3: -  for (unsigned int i = 0; i < m.nrows(); i++)
3: -    for (unsigned int j = 0; j < m.ncols(); j++)
3: -      tmp[i] *= m[i][j];
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -T all_prod(const Matrix<T>& m)
3: -{
3: -  T tmp = (T)1;
3: -  for (unsigned int i = 0; i < m.nrows(); i++)
3: -    for (unsigned int j = 0; j < m.ncols(); j++)
3: -      tmp *= m[i][j];
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Vector<T> mean(const Matrix<T>& m)
3: -{
3: -  Vector<T> res((T)0, m.ncols());
3: -  for (unsigned int j = 0; j < m.ncols(); j++)
3: -    {
3: -      for (unsigned int i = 0; i < m.nrows(); i++)
3: -	res[j] += m[i][j];
3: +  template < typename T >
3: +  Vector < T > sum(const Matrix < T > &m)
3: +  {
3: +    Vector < T > tmp((T)0, m.ncols());
3: +    for (unsigned int j = 0; j < m.ncols(); j++) {
3: +      for (unsigned int i = 0; i < m.nrows(); i++) {
3: +        tmp[j] += m[i][j];
3: +      }
3: +    }
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > r_sum(const Matrix < T > &m)
3: +  {
3: +    Vector < T > tmp((T)0, m.nrows());
3: +    for (unsigned int i = 0; i < m.nrows(); i++) {
3: +      for (unsigned int j = 0; j < m.ncols(); j++) {
3: +        tmp[i] += m[i][j];
3: +      }
3: +    }
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  T all_sum(const Matrix < T > & m)
3: +  {
3: +    T tmp = (T)0;
3: +    for (unsigned int i = 0; i < m.nrows(); i++) {
3: +      for (unsigned int j = 0; j < m.ncols(); j++) {
3: +        tmp += m[i][j];
3: +      }
3: +    }
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > prod(const Matrix < T > &m)
3: +  {
3: +    Vector < T > tmp((T)1, m.ncols());
3: +    for (unsigned int j = 0; j < m.ncols(); j++) {
3: +      for (unsigned int i = 0; i < m.nrows(); i++) {
3: +        tmp[j] *= m[i][j];
3: +      }
3: +    }
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > r_prod(const Matrix < T > &m)
3: +  {
3: +    Vector < T > tmp((T)1, m.nrows());
3: +    for (unsigned int i = 0; i < m.nrows(); i++) {
3: +      for (unsigned int j = 0; j < m.ncols(); j++) {
3: +        tmp[i] *= m[i][j];
3: +      }
3: +    }
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  T all_prod(const Matrix < T > & m)
3: +  {
3: +    T tmp = (T)1;
3: +    for (unsigned int i = 0; i < m.nrows(); i++) {
3: +      for (unsigned int j = 0; j < m.ncols(); j++) {
3: +        tmp *= m[i][j];
3: +      }
3: +    }
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > mean(const Matrix < T > &m)
3: +  {
3: +    Vector < T > res((T)0, m.ncols());
3: +    for (unsigned int j = 0; j < m.ncols(); j++) {
3: +      for (unsigned int i = 0; i < m.nrows(); i++) {
3: +        res[j] += m[i][j];
3: +      }
3: @@ -2255,12 +2516,12 @@
3: -	
3: -  return res;
3: -}
3: -
3: -template <typename T>
3: -Vector<T> r_mean(const Matrix<T>& m)
3: -{
3: -  Vector<T> res((T)0, m.rows());
3: -  for (unsigned int i = 0; i < m.nrows(); i++)
3: -    {
3: -      for (unsigned int j = 0; j < m.ncols(); j++)
3: -	res[i] += m[i][j];
3: +
3: +    return res;
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > r_mean(const Matrix < T > &m)
3: +  {
3: +    Vector < T > res((T)0, m.rows());
3: +    for (unsigned int i = 0; i < m.nrows(); i++) {
3: +      for (unsigned int j = 0; j < m.ncols(); j++) {
3: +        res[i] += m[i][j];
3: +      }
3: @@ -2269,22 +2530,23 @@
3: -	
3: -  return res;
3: -}
3: -
3: -template <typename T>
3: -T all_mean(const Matrix<T>& m)
3: -{
3: -  T tmp = (T)0;
3: -  for (unsigned int i = 0; i < m.nrows(); i++)
3: -    for (unsigned int j = 0; j < m.ncols(); j++)
3: -      tmp += m[i][j];
3: -  return tmp / (m.nrows() * m.ncols());
3: -}
3: -
3: -template <typename T>
3: -Vector<T> var(const Matrix<T>& m, bool sample_correction = false)
3: -{
3: -  Vector<T> res((T)0, m.ncols());
3: -  unsigned int n = m.nrows();
3: -  double sum, ssum;
3: -  for (unsigned int j = 0; j < m.ncols(); j++)
3: -    {	
3: +
3: +    return res;
3: +  }
3: +
3: +  template < typename T >
3: +  T all_mean(const Matrix < T > & m)
3: +  {
3: +    T tmp = (T)0;
3: +    for (unsigned int i = 0; i < m.nrows(); i++) {
3: +      for (unsigned int j = 0; j < m.ncols(); j++) {
3: +        tmp += m[i][j];
3: +      }
3: +    }
3: +    return tmp / (m.nrows() * m.ncols());
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > var(const Matrix < T > &m, bool sample_correction = false)
3: +  {
3: +    Vector < T > res((T)0, m.ncols());
3: +    unsigned int n = m.nrows();
3: +    double sum, ssum;
3: +    for (unsigned int j = 0; j < m.ncols(); j++) {
3: @@ -2292,28 +2554,27 @@
3: -      for (unsigned int i = 0; i < m.nrows(); i++)
3: -	{
3: -	  sum += m[i][j];
3: -	  ssum += (m[i][j] * m[i][j]);
3: -	}
3: -      if (!sample_correction)
3: -	res[j] = (ssum / n) - (sum / n) * (sum / n);
3: -      else
3: -	res[j] = n * ((ssum / n) - (sum / n) * (sum / n)) / (n - 1);		 
3: -    }
3: -	
3: -  return res;
3: -}
3: -
3: -template <typename T>
3: -Vector<T> stdev(const Matrix<T>& m, bool sample_correction = false)
3: -{
3: -  return vec_sqrt(var(m, sample_correction));
3: -}
3: -
3: -template <typename T>
3: -Vector<T> r_var(const Matrix<T>& m, bool sample_correction = false)
3: -{
3: -  Vector<T> res((T)0, m.nrows());
3: -  double sum, ssum;
3: -  unsigned int n = m.ncols();
3: -  for (unsigned int i = 0; i < m.nrows(); i++)
3: -    {	
3: +      for (unsigned int i = 0; i < m.nrows(); i++) {
3: +        sum += m[i][j];
3: +        ssum += (m[i][j] * m[i][j]);
3: +      }
3: +      if (!sample_correction) {
3: +        res[j] = (ssum / n) - (sum / n) * (sum / n);
3: +      } else {
3: +        res[j] = n * ((ssum / n) - (sum / n) * (sum / n)) / (n - 1);
3: +      }
3: +    }
3: +
3: +    return res;
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > stdev(const Matrix < T > &m, bool sample_correction = false)
3: +  {
3: +    return vec_sqrt(var(m, sample_correction));
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > r_var(const Matrix < T > &m, bool sample_correction = false)
3: +  {
3: +    Vector < T > res((T)0, m.nrows());
3: +    double sum, ssum;
3: +    unsigned int n = m.ncols();
3: +    for (unsigned int i = 0; i < m.nrows(); i++) {
3: @@ -2321,27 +2582,26 @@
3: -      for (unsigned int j = 0; j < m.ncols(); j++)
3: -	{
3: -	  sum += m[i][j];
3: -	  ssum += (m[i][j] * m[i][j]);
3: -	}
3: -      if (!sample_correction)
3: -	res[i] = (ssum / n) - (sum / n) * (sum / n);
3: -      else
3: -	res[i] = n * ((ssum / n) - (sum / n) * (sum / n)) / (n - 1);
3: -    }
3: -	
3: -  return res;
3: -}
3: -
3: -template <typename T>
3: -Vector<T> r_stdev(const Matrix<T>& m, bool sample_correction = false)
3: -{
3: -  return vec_sqrt(r_var(m, sample_correction));
3: -}
3: -
3: -template <typename T>
3: -Vector<T> max(const Matrix<T>& m)
3: -{
3: -  Vector<T> res(m.ncols());
3: -  double value;
3: -  for (unsigned int j = 0; j < m.ncols(); j++)
3: -    {
3: +      for (unsigned int j = 0; j < m.ncols(); j++) {
3: +        sum += m[i][j];
3: +        ssum += (m[i][j] * m[i][j]);
3: +      }
3: +      if (!sample_correction) {
3: +        res[i] = (ssum / n) - (sum / n) * (sum / n);
3: +      } else {
3: +        res[i] = n * ((ssum / n) - (sum / n) * (sum / n)) / (n - 1);
3: +      }
3: +    }
3: +
3: +    return res;
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > r_stdev(const Matrix < T > &m, bool sample_correction = false)
3: +  {
3: +    return vec_sqrt(r_var(m, sample_correction));
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > max(const Matrix < T > &m)
3: +  {
3: +    Vector < T > res(m.ncols());
3: +    double value;
3: +    for (unsigned int j = 0; j < m.ncols(); j++) {
3: @@ -2349,2 +2609,3 @@
3: -      for (unsigned int i = 1; i < m.nrows(); i++)
3: -	value = std::max(m[i][j], value);
3: +      for (unsigned int i = 1; i < m.nrows(); i++) {
3: +        value = std::max(m[i][j], value);
3: +      }
3: @@ -2353,11 +2614,10 @@
3: -	
3: -  return res;
3: -}
3: -
3: -template <typename T>
3: -Vector<T> r_max(const Matrix<T>& m)
3: -{
3: -  Vector<T> res(m.nrows());
3: -  double value;
3: -  for (unsigned int i = 0; i < m.nrows(); i++)
3: -    {
3: +
3: +    return res;
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > r_max(const Matrix < T > &m)
3: +  {
3: +    Vector < T > res(m.nrows());
3: +    double value;
3: +    for (unsigned int i = 0; i < m.nrows(); i++) {
3: @@ -2365,2 +2625,3 @@
3: -      for (unsigned int j = 1; j < m.ncols(); j++)
3: -	value = std::max(m[i][j], value);
3: +      for (unsigned int j = 1; j < m.ncols(); j++) {
3: +        value = std::max(m[i][j], value);
3: +      }
3: @@ -2369,11 +2630,10 @@
3: -	
3: -  return res;
3: -}
3: -
3: -template <typename T>
3: -Vector<T> min(const Matrix<T>& m)
3: -{
3: -  Vector<T> res(m.ncols());
3: -  double value;
3: -  for (unsigned int j = 0; j < m.ncols(); j++)
3: -    {
3: +
3: +    return res;
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > min(const Matrix < T > &m)
3: +  {
3: +    Vector < T > res(m.ncols());
3: +    double value;
3: +    for (unsigned int j = 0; j < m.ncols(); j++) {
3: @@ -2381,2 +2641,3 @@
3: -      for (unsigned int i = 1; i < m.nrows(); i++)
3: -	value = std::min(m[i][j], value);
3: +      for (unsigned int i = 1; i < m.nrows(); i++) {
3: +        value = std::min(m[i][j], value);
3: +      }
3: @@ -2385,11 +2646,10 @@
3: -	
3: -  return res;
3: -}
3: -
3: -template <typename T>
3: -Vector<T> r_min(const Matrix<T>& m)
3: -{
3: -  Vector<T> res(m.nrows());
3: -  double value;
3: -  for (unsigned int i = 0; i < m.nrows(); i++)
3: -    {
3: +
3: +    return res;
3: +  }
3: +
3: +  template < typename T >
3: +  Vector < T > r_min(const Matrix < T > &m)
3: +  {
3: +    Vector < T > res(m.nrows());
3: +    double value;
3: +    for (unsigned int i = 0; i < m.nrows(); i++) {
3: @@ -2397,2 +2657,3 @@
3: -      for (unsigned int j = 1; j < m.ncols(); j++)
3: -	value = std::min(m[i][j], value);
3: +      for (unsigned int j = 1; j < m.ncols(); j++) {
3: +        value = std::min(m[i][j], value);
3: +      }
3: @@ -2401,4 +2662,3 @@
3: -	
3: -  return res;
3: -}
3: -
3: +
3: +    return res;
3: +  }
3: @@ -2411,23 +2671,27 @@
3: -template <typename T>
3: -Matrix<T> exp(const Matrix<T>&m)
3: -{
3: -  Matrix<T> tmp(m.nrows(), m.ncols());
3: -	
3: -  for (unsigned int i = 0; i < m.nrows(); i++)
3: -    for (unsigned int j = 0; j < m.ncols(); j++)
3: -      tmp[i][j] = exp(m[i][j]);
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> mat_sqrt(const Matrix<T>&m)
3: -{
3: -  Matrix<T> tmp(m.nrows(), m.ncols());
3: -	
3: -  for (unsigned int i = 0; i < m.nrows(); i++)
3: -    for (unsigned int j = 0; j < m.ncols(); j++)
3: -      tmp[i][j] = sqrt(m[i][j]);
3: -	
3: -  return tmp;
3: -}
3: +  template < typename T >
3: +  Matrix < T > exp(const Matrix < T > &m)
3: +  {
3: +    Matrix < T > tmp(m.nrows(), m.ncols());
3: +
3: +    for (unsigned int i = 0; i < m.nrows(); i++) {
3: +      for (unsigned int j = 0; j < m.ncols(); j++) {
3: +        tmp[i][j] = exp(m[i][j]);
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > mat_sqrt(const Matrix < T > &m)
3: +  {
3: +    Matrix < T > tmp(m.nrows(), m.ncols());
3: +
3: +    for (unsigned int i = 0; i < m.nrows(); i++) {
3: +      for (unsigned int j = 0; j < m.ncols(); j++) {
3: +        tmp[i][j] = sqrt(m[i][j]);
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: @@ -2439,47 +2703,55 @@
3: -template <typename T>
3: -Matrix<T> kron(const Vector<T>& b, const Vector<T>& a)
3: -{
3: -  Matrix<T> tmp(b.size(), a.size());
3: -  for (unsigned int i = 0; i < b.size(); i++)
3: -    for (unsigned int j = 0; j < a.size(); j++)
3: -      tmp[i][j] = a[j] * b[i];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> t(const Matrix<T>& a)
3: -{
3: -  Matrix<T> tmp(a.ncols(), a.nrows());
3: -  for (unsigned int i = 0; i < a.nrows(); i++)
3: -    for (unsigned int j = 0; j < a.ncols(); j++)
3: -      tmp[j][i] = a[i][j];
3: -	
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> dot_prod(const Matrix<T>& a, const Matrix<T>& b)
3: -{
3: -  if (a.ncols() != b.nrows())
3: -    throw std::logic_error("Error matrix dot product: dimensions of the matrices are not compatible");
3: -  Matrix<T> tmp(a.nrows(), b.ncols());
3: -  for (unsigned int i = 0; i < tmp.nrows(); i++)
3: -    for (unsigned int j = 0; j < tmp.ncols(); j++)
3: -      {
3: -	tmp[i][j] = (T)0;
3: -	for (unsigned int k = 0; k < a.ncols(); k++)
3: -	  tmp[i][j] += a[i][k] * b[k][j];
3: -      }
3: -			
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> dot_prod(const Matrix<T>& a, const Vector<T>& b)
3: -{
3: -  if (a.ncols() != b.size())
3: -    throw std::logic_error("Error matrix dot product: dimensions of the matrix and the vector are not compatible");
3: -  Matrix<T> tmp(a.nrows(), 1);
3: -  for (unsigned int i = 0; i < tmp.nrows(); i++)
3: -    {
3: +  template < typename T >
3: +  Matrix < T > kron(const Vector < T > &b, const Vector < T > &a)
3: +  {
3: +    Matrix < T > tmp(b.size(), a.size());
3: +    for (unsigned int i = 0; i < b.size(); i++) {
3: +      for (unsigned int j = 0; j < a.size(); j++) {
3: +        tmp[i][j] = a[j] * b[i];
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > t(const Matrix < T > &a)
3: +  {
3: +    Matrix < T > tmp(a.ncols(), a.nrows());
3: +    for (unsigned int i = 0; i < a.nrows(); i++) {
3: +      for (unsigned int j = 0; j < a.ncols(); j++) {
3: +        tmp[j][i] = a[i][j];
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > dot_prod(const Matrix < T > &a, const Matrix < T > &b)
3: +  {
3: +    if (a.ncols() != b.nrows()) {
3: +      throw std::logic_error(
3: +        "Error matrix dot product: dimensions of the matrices are not compatible");
3: +    }
3: +    Matrix < T > tmp(a.nrows(), b.ncols());
3: +    for (unsigned int i = 0; i < tmp.nrows(); i++) {
3: +      for (unsigned int j = 0; j < tmp.ncols(); j++) {
3: +        tmp[i][j] = (T)0;
3: +        for (unsigned int k = 0; k < a.ncols(); k++) {
3: +          tmp[i][j] += a[i][k] * b[k][j];
3: +        }
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > dot_prod(const Matrix < T > &a, const Vector < T > &b)
3: +  {
3: +    if (a.ncols() != b.size()) {
3: +      throw std::logic_error(
3: +        "Error matrix dot product: dimensions of the matrix and the vector are not compatible");
3: +    }
3: +    Matrix < T > tmp(a.nrows(), 1);
3: +    for (unsigned int i = 0; i < tmp.nrows(); i++) {
3: @@ -2487,15 +2759,17 @@
3: -      for (unsigned int k = 0; k < a.ncols(); k++)
3: -	tmp[i][0] += a[i][k] * b[k];
3: -    }
3: -		
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -Matrix<T> dot_prod(const Vector<T>& a, const Matrix<T>& b)
3: -{
3: -  if (a.size() != b.nrows())
3: -    throw std::logic_error("Error matrix dot product: dimensions of the vector and matrix are not compatible");
3: -  Matrix<T> tmp(1, b.ncols());
3: -  for (unsigned int j = 0; j < tmp.ncols(); j++)
3: -    {
3: +      for (unsigned int k = 0; k < a.ncols(); k++) {
3: +        tmp[i][0] += a[i][k] * b[k];
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  Matrix < T > dot_prod(const Vector < T > &a, const Matrix < T > &b)
3: +  {
3: +    if (a.size() != b.nrows()) {
3: +      throw std::logic_error(
3: +        "Error matrix dot product: dimensions of the vector and matrix are not compatible");
3: +    }
3: +    Matrix < T > tmp(1, b.ncols());
3: +    for (unsigned int j = 0; j < tmp.ncols(); j++) {
3: @@ -2503,26 +2777,29 @@
3: -      for (unsigned int k = 0; k < a.size(); k++)
3: -	tmp[0][j] += a[k] * b[k][j];
3: -    }
3: -		
3: -  return tmp;
3: -}
3: -
3: -template <typename T>
3: -inline Matrix<double> rank(const Matrix<T> m)
3: -{
3: -  Matrix<double> tmp(m.nrows(), m.ncols());
3: -  for (unsigned int j = 0; j < m.ncols(); j++)
3: -    tmp.setColumn(j, rank<T>(m.extractColumn(j)));
3: -  
3: -  return tmp;                  
3: -}
3: -
3: -template <typename T>
3: -inline Matrix<double> r_rank(const Matrix<T> m)
3: -{
3: -  Matrix<double> tmp(m.nrows(), m.ncols());
3: -  for (unsigned int i = 0; i < m.nrows(); i++)
3: -    tmp.setRow(i, rank<T>(m.extractRow(i)));
3: -  
3: -  return tmp;                  
3: -}
3: +      for (unsigned int k = 0; k < a.size(); k++) {
3: +        tmp[0][j] += a[k] * b[k][j];
3: +      }
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < double > rank(const Matrix < T > m)
3: +  {
3: +    Matrix < double > tmp(m.nrows(), m.ncols());
3: +    for (unsigned int j = 0; j < m.ncols(); j++) {
3: +      tmp.setColumn(j, rank < T > (m.extractColumn(j)));
3: +    }
3: +
3: +    return tmp;
3: +  }
3: +
3: +  template < typename T >
3: +  inline Matrix < double > r_rank(const Matrix < T > m)
3: +  {
3: +    Matrix < double > tmp(m.nrows(), m.ncols());
3: +    for (unsigned int i = 0; i < m.nrows(); i++) {
3: +      tmp.setRow(i, rank < T > (m.extractRow(i)));
3: +    }
3: +
3: +    return tmp;
3: +  }
3: 
3: Code style divergence in file 'include/thirdParty/quadProgpp/QuadProg++.hh':
3: 
3: --- include/thirdParty/quadProgpp/QuadProg++.hh
3: +++ include/thirdParty/quadProgpp/QuadProg++.hh.uncrustify
3: @@ -2,3 +2,3 @@
3: - File $Id: QuadProg++.hh 232 2007-06-21 12:29:00Z digasper $ 
3: - 
3: - The quadprog_solve() function implements the algorithm of Goldfarb and Idnani 
3: + File $Id: QuadProg++.hh 232 2007-06-21 12:29:00Z digasper $
3: +
3: + The quadprog_solve() function implements the algorithm of Goldfarb and Idnani
3: @@ -7 +7 @@
3: -	 
3: +
3: @@ -14 +14 @@
3: -	 
3: +
3: @@ -18 +18 @@
3: -				
3: +
3: @@ -21 +21 @@
3: -				
3: +
3: @@ -26 +26 @@
3: - 
3: +
3: @@ -30 +30 @@
3: - 
3: +
3: @@ -35,2 +35,2 @@
3: -  1. pay attention in setting up the vectors ce0 and ci0. 
3: -	   If the constraints of your problem are specified in the form 
3: +  1. pay attention in setting up the vectors ce0 and ci0.
3: +	   If the constraints of your problem are specified in the form
3: @@ -38,2 +38,2 @@
3: -  2. The matrices have column dimension equal to MATRIX_DIM, 
3: -     a constant set to 20 in this file (by means of a #define macro). 
3: +  2. The matrices have column dimension equal to MATRIX_DIM,
3: +     a constant set to 20 in this file (by means of a #define macro).
3: @@ -43 +43 @@
3: -     the G = L^T L cholesky factorization for further computations inside the function. 
3: +     the G = L^T L cholesky factorization for further computations inside the function.
3: @@ -46 +46 @@
3: -    
3: +
3: @@ -48 +48 @@
3: -  			 DIEGM - University of Udine, Italy
3: +                         DIEGM - University of Udine, Italy
3: @@ -51 +51 @@
3: - 
3: +
3: @@ -54 +54 @@
3: - 
3: +
3: @@ -56 +56 @@
3: - 
3: +
3: @@ -70,4 +70,5 @@
3: -double solve_quadprog(Matrix<double>& G, Vector<double>& g0, 
3: -                      const Matrix<double>& CE, const Vector<double>& ce0,  
3: -                      const Matrix<double>& CI, const Vector<double>& ci0, 
3: -                      Vector<double>& x);
3: +  double solve_quadprog(
3: +    Matrix < double > & G, Vector < double > & g0,
3: +    const Matrix < double > & CE, const Vector < double > & ce0,
3: +    const Matrix < double > & CI, const Vector < double > & ci0,
3: +    Vector < double > & x);
3: 
3: Code style divergence in file 'src/FSM/FSM.cpp':
3: 
3: --- src/FSM/FSM.cpp
3: +++ src/FSM/FSM.cpp.uncrustify
3: @@ -7,2 +7,3 @@
3: -FSM::FSM(CtrlComponents *ctrlComp)
3: -    :_ctrlComp(ctrlComp){
3: +FSM::FSM(CtrlComponents * ctrlComp)
3: +: _ctrlComp(ctrlComp)
3: +{
3: @@ -10,8 +11,8 @@
3: -    _stateList.invalid = nullptr;
3: -    _stateList.passive = new State_Passive(_ctrlComp);
3: -    _stateList.fixedStand = new State_FixedStand(_ctrlComp);
3: -    _stateList.freeStand = new State_FreeStand(_ctrlComp);
3: -    _stateList.trotting = new State_Trotting(_ctrlComp);
3: -    _stateList.balanceTest = new State_BalanceTest(_ctrlComp);
3: -    _stateList.swingTest = new State_SwingTest(_ctrlComp);
3: -    _stateList.stepTest = new State_StepTest(_ctrlComp);
3: +  _stateList.invalid = nullptr;
3: +  _stateList.passive = new State_Passive(_ctrlComp);
3: +  _stateList.fixedStand = new State_FixedStand(_ctrlComp);
3: +  _stateList.freeStand = new State_FreeStand(_ctrlComp);
3: +  _stateList.trotting = new State_Trotting(_ctrlComp);
3: +  _stateList.balanceTest = new State_BalanceTest(_ctrlComp);
3: +  _stateList.swingTest = new State_SwingTest(_ctrlComp);
3: +  _stateList.stepTest = new State_StepTest(_ctrlComp);
3: @@ -19 +20 @@
3: -    _stateList.moveBase = new State_move_base(_ctrlComp);
3: +  _stateList.moveBase = new State_move_base(_ctrlComp);
3: @@ -22 +23 @@
3: -    _stateList.moveBase = new State_move_base(_ctrlComp);
3: +  _stateList.moveBase = new State_move_base(_ctrlComp);
3: @@ -24 +25 @@
3: -    initialize();
3: +  initialize();
3: @@ -27,2 +28,3 @@
3: -FSM::~FSM(){
3: -    _stateList.deletePtr();
3: +FSM::~FSM()
3: +{
3: +  _stateList.deletePtr();
3: @@ -31,5 +33,6 @@
3: -void FSM::initialize(){
3: -    _currentState = _stateList.passive;
3: -    _currentState -> enter();
3: -    _nextState = _currentState;
3: -    _mode = FSMMode::NORMAL;
3: +void FSM::initialize()
3: +{
3: +  _currentState = _stateList.passive;
3: +  _currentState->enter();
3: +  _nextState = _currentState;
3: +  _mode = FSMMode::NORMAL;
3: @@ -38,7 +41,18 @@
3: -void FSM::run(){
3: -    _startTime = getSystemTime();
3: -    _ctrlComp->sendRecv();
3: -    _ctrlComp->runWaveGen();
3: -    _ctrlComp->estimator->run();
3: -    if(!checkSafty()){
3: -        _ctrlComp->ioInter->setPassive();
3: +void FSM::run()
3: +{
3: +  _startTime = getSystemTime();
3: +  _ctrlComp->sendRecv();
3: +  _ctrlComp->runWaveGen();
3: +  _ctrlComp->estimator->run();
3: +  if (!checkSafty()) {
3: +    _ctrlComp->ioInter->setPassive();
3: +  }
3: +
3: +  if (_mode == FSMMode::NORMAL) {
3: +    _currentState->run();
3: +    _nextStateName = _currentState->checkChange();
3: +    if (_nextStateName != _currentState->_stateName) {
3: +      _mode = FSMMode::CHANGE;
3: +      _nextState = getNextState(_nextStateName);
3: +      std::cout << "Switched from " << _currentState->_stateNameString
3: +                << " to " << _nextState->_stateNameString << std::endl;
3: @@ -45,0 +60,7 @@
3: +  } else if (_mode == FSMMode::CHANGE) {
3: +    _currentState->exit();
3: +    _currentState = _nextState;
3: +    _currentState->enter();
3: +    _mode = FSMMode::NORMAL;
3: +    _currentState->run();
3: +  }
3: @@ -47,19 +68 @@
3: -    if(_mode == FSMMode::NORMAL){
3: -        _currentState->run();
3: -        _nextStateName = _currentState->checkChange();
3: -        if(_nextStateName != _currentState->_stateName){
3: -            _mode = FSMMode::CHANGE;
3: -            _nextState = getNextState(_nextStateName);
3: -            std::cout << "Switched from " << _currentState->_stateNameString
3: -                      << " to " << _nextState->_stateNameString << std::endl;
3: -        }
3: -    }
3: -    else if(_mode == FSMMode::CHANGE){
3: -        _currentState->exit();
3: -        _currentState = _nextState;
3: -        _currentState->enter();
3: -        _mode = FSMMode::NORMAL;
3: -        _currentState->run();
3: -    }
3: -
3: -    absoluteWait(_startTime, (long long)(_ctrlComp->dt * 1000000));
3: +  absoluteWait(_startTime, (long long)(_ctrlComp->dt * 1000000));
3: @@ -68,3 +71,3 @@
3: -FSMState* FSM::getNextState(FSMStateName stateName){
3: -    switch (stateName)
3: -    {
3: +FSMState * FSM::getNextState(FSMStateName stateName)
3: +{
3: +  switch (stateName) {
3: @@ -72,2 +75,2 @@
3: -        return _stateList.invalid;
3: -        break;
3: +      return _stateList.invalid;
3: +      break;
3: @@ -75,2 +78,2 @@
3: -        return _stateList.passive;
3: -        break;
3: +      return _stateList.passive;
3: +      break;
3: @@ -78,2 +81,2 @@
3: -        return _stateList.fixedStand;
3: -        break;
3: +      return _stateList.fixedStand;
3: +      break;
3: @@ -81,2 +84,2 @@
3: -        return _stateList.freeStand;
3: -        break;
3: +      return _stateList.freeStand;
3: +      break;
3: @@ -84,2 +87,2 @@
3: -        return _stateList.trotting;
3: -        break;
3: +      return _stateList.trotting;
3: +      break;
3: @@ -87,2 +90,2 @@
3: -        return _stateList.balanceTest;
3: -        break;
3: +      return _stateList.balanceTest;
3: +      break;
3: @@ -90,2 +93,2 @@
3: -        return _stateList.swingTest;
3: -        break;
3: +      return _stateList.swingTest;
3: +      break;
3: @@ -93,2 +96,2 @@
3: -        return _stateList.stepTest;
3: -        break;
3: +      return _stateList.stepTest;
3: +      break;
3: @@ -97,2 +100,2 @@
3: -        return _stateList.moveBase;
3: -        break;
3: +      return _stateList.moveBase;
3: +      break;
3: @@ -102,2 +105,2 @@
3: -        return _stateList.moveBase;
3: -        break;
3: +      return _stateList.moveBase;
3: +      break;
3: @@ -106,3 +109,3 @@
3: -        return _stateList.invalid;
3: -        break;
3: -    }
3: +      return _stateList.invalid;
3: +      break;
3: +  }
3: @@ -111,8 +114,9 @@
3: -bool FSM::checkSafty(){
3: -    // The angle with z axis less than 60 degree
3: -    if(_ctrlComp->lowState->getRotMat()(2,2) < 0.5 ){
3: -        return false;
3: -    }else{
3: -        return true;
3: -    }
3: -}
3: +bool FSM::checkSafty()
3: +{
3: +  // The angle with z axis less than 60 degree
3: +  if (_ctrlComp->lowState->getRotMat()(2, 2) < 0.5) {
3: +    return false;
3: +  } else {
3: +    return true;
3: +  }
3: +}
3: 
3: Code style divergence in file 'src/FSM/FSMState.cpp':
3: 
3: --- src/FSM/FSMState.cpp
3: +++ src/FSM/FSMState.cpp.uncrustify
3: @@ -6,5 +6,6 @@
3: -FSMState::FSMState(CtrlComponents *ctrlComp, FSMStateName stateName, std::string stateNameString)
3: -            :_ctrlComp(ctrlComp), _stateName(stateName), _stateNameString(stateNameString){
3: -    _lowCmd = _ctrlComp->lowCmd;
3: -    _lowState = _ctrlComp->lowState;
3: -}
3: +FSMState::FSMState(CtrlComponents * ctrlComp, FSMStateName stateName, std::string stateNameString)
3: +: _ctrlComp(ctrlComp), _stateName(stateName), _stateNameString(stateNameString)
3: +{
3: +  _lowCmd = _ctrlComp->lowCmd;
3: +  _lowState = _ctrlComp->lowState;
3: +}
3: 
3: Code style divergence in file 'src/FSM/State_BalanceTest.cpp':
3: 
3: --- src/FSM/State_BalanceTest.cpp
3: +++ src/FSM/State_BalanceTest.cpp.uncrustify
3: @@ -6,4 +6,5 @@
3: -State_BalanceTest::State_BalanceTest(CtrlComponents *ctrlComp)
3: -                  :FSMState(ctrlComp, FSMStateName::BALANCETEST, "balanceTest"),
3: -                  _est(ctrlComp->estimator), _robModel(ctrlComp->robotModel), 
3: -                  _balCtrl(ctrlComp->balCtrl), _contact(ctrlComp->contact){
3: +State_BalanceTest::State_BalanceTest(CtrlComponents * ctrlComp)
3: +: FSMState(ctrlComp, FSMStateName::BALANCETEST, "balanceTest"),
3: +  _est(ctrlComp->estimator), _robModel(ctrlComp->robotModel),
3: +  _balCtrl(ctrlComp->balCtrl), _contact(ctrlComp->contact)
3: +{
3: @@ -11,8 +12,8 @@
3: -    _xMax = 0.05;
3: -    _xMin = -_xMax;
3: -    _yMax = 0.05;
3: -    _yMin = -_yMax;
3: -    _zMax = 0.04;
3: -    _zMin = -_zMax;
3: -    _yawMax = 20 * M_PI / 180;
3: -    _yawMin = -_yawMax;
3: +  _xMax = 0.05;
3: +  _xMin = -_xMax;
3: +  _yMax = 0.05;
3: +  _yMin = -_yMax;
3: +  _zMax = 0.04;
3: +  _zMin = -_zMax;
3: +  _yawMax = 20 * M_PI / 180;
3: +  _yawMin = -_yawMax;
3: @@ -20,2 +21,2 @@
3: -    _Kpp = Vec3(150, 150, 150).asDiagonal();
3: -    _Kdp = Vec3(25, 25, 25).asDiagonal();
3: +  _Kpp = Vec3(150, 150, 150).asDiagonal();
3: +  _Kdp = Vec3(25, 25, 25).asDiagonal();
3: @@ -23,2 +24,2 @@
3: -    _kpw = 200;
3: -    _Kdw = Vec3(30, 30, 30).asDiagonal();
3: +  _kpw = 200;
3: +  _Kdw = Vec3(30, 30, 30).asDiagonal();
3: @@ -27,4 +28,5 @@
3: -void State_BalanceTest::enter(){
3: -    _pcdInit = _est->getPosition();
3: -    _pcd = _pcdInit;
3: -    _RdInit = _lowState->getRotMat();
3: +void State_BalanceTest::enter()
3: +{
3: +  _pcdInit = _est->getPosition();
3: +  _pcd = _pcdInit;
3: +  _RdInit = _lowState->getRotMat();
3: @@ -32,2 +34,2 @@
3: -    _ctrlComp->setAllStance();
3: -    _ctrlComp->ioInter->zeroCmdPanel();
3: +  _ctrlComp->setAllStance();
3: +  _ctrlComp->ioInter->zeroCmdPanel();
3: @@ -36,2 +38,3 @@
3: -void State_BalanceTest::run(){
3: -    _userValue = _lowState->userValue;
3: +void State_BalanceTest::run()
3: +{
3: +  _userValue = _lowState->userValue;
3: @@ -39,3 +42,3 @@
3: -    _pcd(0) = _pcdInit(0) + invNormalize(_userValue.ly, _xMin, _xMax);
3: -    _pcd(1) = _pcdInit(1) - invNormalize(_userValue.lx, _yMin, _yMax);
3: -    _pcd(2) = _pcdInit(2) + invNormalize(_userValue.ry, _zMin, _zMax);
3: +  _pcd(0) = _pcdInit(0) + invNormalize(_userValue.ly, _xMin, _xMax);
3: +  _pcd(1) = _pcdInit(1) - invNormalize(_userValue.lx, _yMin, _yMax);
3: +  _pcd(2) = _pcdInit(2) + invNormalize(_userValue.ry, _zMin, _zMax);
3: @@ -43,2 +46,2 @@
3: -    float yaw = invNormalize(_userValue.rx, _yawMin, _yawMax);
3: -    _Rd = rpyToRotMat(0, 0, yaw)*_RdInit;
3: +  float yaw = invNormalize(_userValue.rx, _yawMin, _yawMax);
3: +  _Rd = rpyToRotMat(0, 0, yaw) * _RdInit;
3: @@ -46,2 +49,2 @@
3: -    _posBody = _est->getPosition();
3: -    _velBody = _est->getVelocity();
3: +  _posBody = _est->getPosition();
3: +  _velBody = _est->getVelocity();
3: @@ -49,2 +52,2 @@
3: -    _B2G_RotMat = _lowState->getRotMat();
3: -    _G2B_RotMat = _B2G_RotMat.transpose();
3: +  _B2G_RotMat = _lowState->getRotMat();
3: +  _G2B_RotMat = _B2G_RotMat.transpose();
3: @@ -52 +55 @@
3: -    calcTau();
3: +  calcTau();
3: @@ -54,3 +57,3 @@
3: -    _lowCmd->setStableGain();
3: -    _lowCmd->setTau(_tau);
3: -    _lowCmd->setQ(_q);
3: +  _lowCmd->setStableGain();
3: +  _lowCmd->setTau(_tau);
3: +  _lowCmd->setQ(_q);
3: @@ -59,2 +62,3 @@
3: -void State_BalanceTest::exit(){
3: -    _ctrlComp->ioInter->zeroCmdPanel();
3: +void State_BalanceTest::exit()
3: +{
3: +  _ctrlComp->ioInter->zeroCmdPanel();
3: @@ -63,10 +67,9 @@
3: -FSMStateName State_BalanceTest::checkChange(){
3: -    if(_lowState->userCmd == UserCommand::L2_B){
3: -        return FSMStateName::PASSIVE;
3: -    }
3: -    else if(_lowState->userCmd == UserCommand::L2_A){
3: -        return FSMStateName::FIXEDSTAND;
3: -    }
3: -    else{
3: -        return FSMStateName::BALANCETEST;
3: -    }
3: +FSMStateName State_BalanceTest::checkChange()
3: +{
3: +  if (_lowState->userCmd == UserCommand::L2_B) {
3: +    return FSMStateName::PASSIVE;
3: +  } else if (_lowState->userCmd == UserCommand::L2_A) {
3: +    return FSMStateName::FIXEDSTAND;
3: +  } else {
3: +    return FSMStateName::BALANCETEST;
3: +  }
3: @@ -75 +78,2 @@
3: -void State_BalanceTest::calcTau(){
3: +void State_BalanceTest::calcTau()
3: +{
3: @@ -77,2 +81,3 @@
3: -    _ddPcd = _Kpp*(_pcd - _posBody) + _Kdp * (Vec3(0, 0, 0) - _velBody);
3: -    _dWbd  = _kpw*rotMatToExp(_Rd*_G2B_RotMat) + _Kdw * (Vec3(0, 0, 0) - _lowState->getGyroGlobal());
3: +  _ddPcd = _Kpp * (_pcd - _posBody) + _Kdp * (Vec3(0, 0, 0) - _velBody);
3: +  _dWbd = _kpw * rotMatToExp(_Rd * _G2B_RotMat) + _Kdw *
3: +    (Vec3(0, 0, 0) - _lowState->getGyroGlobal());
3: @@ -80 +85 @@
3: -    _posFeet2BGlobal = _est->getPosFeet2BGlobal();
3: +  _posFeet2BGlobal = _est->getPosFeet2BGlobal();
3: @@ -82,2 +87,2 @@
3: -    _forceFeetGlobal = - _balCtrl->calF(_ddPcd, _dWbd, _B2G_RotMat, _posFeet2BGlobal, *_contact);
3: -    _forceFeetBody = _G2B_RotMat * _forceFeetGlobal;
3: +  _forceFeetGlobal = -_balCtrl->calF(_ddPcd, _dWbd, _B2G_RotMat, _posFeet2BGlobal, *_contact);
3: +  _forceFeetBody = _G2B_RotMat * _forceFeetGlobal;
3: @@ -85,3 +90,3 @@
3: -    _q = vec34ToVec12(_lowState->getQ());
3: -    _tau = _robModel->getTau(_q, _forceFeetBody);
3: -}
3: +  _q = vec34ToVec12(_lowState->getQ());
3: +  _tau = _robModel->getTau(_q, _forceFeetBody);
3: +}
3: 
3: Code style divergence in file 'src/FSM/State_FixedStand.cpp':
3: 
3: --- src/FSM/State_FixedStand.cpp
3: +++ src/FSM/State_FixedStand.cpp.uncrustify
3: @@ -7,2 +7,2 @@
3: -State_FixedStand::State_FixedStand(CtrlComponents *ctrlComp)
3: -                :FSMState(ctrlComp, FSMStateName::FIXEDSTAND, "fixed stand"){}
3: +State_FixedStand::State_FixedStand(CtrlComponents * ctrlComp)
3: +: FSMState(ctrlComp, FSMStateName::FIXEDSTAND, "fixed stand") {}
3: @@ -10,10 +10,7 @@
3: -void State_FixedStand::enter(){
3: -    for(int i=0; i<4; i++){
3: -        if(_ctrlComp->ctrlPlatform == CtrlPlatform::GAZEBO){
3: -            _lowCmd->setSimStanceGain(i);
3: -        }
3: -        else if(_ctrlComp->ctrlPlatform == CtrlPlatform::REALROBOT){
3: -            _lowCmd->setRealStanceGain(i);
3: -        }
3: -        _lowCmd->setZeroDq(i);
3: -        _lowCmd->setZeroTau(i);
3: +void State_FixedStand::enter()
3: +{
3: +  for (int i = 0; i < 4; i++) {
3: +    if (_ctrlComp->ctrlPlatform == CtrlPlatform::GAZEBO) {
3: +      _lowCmd->setSimStanceGain(i);
3: +    } else if (_ctrlComp->ctrlPlatform == CtrlPlatform::REALROBOT) {
3: +      _lowCmd->setRealStanceGain(i);
3: @@ -21,5 +18,8 @@
3: -    for(int i=0; i<12; i++){
3: -        _lowCmd->motorCmd[i].q = _lowState->motorState[i].q;
3: -        _startPos[i] = _lowState->motorState[i].q;
3: -    }
3: -    _ctrlComp->setAllStance();
3: +    _lowCmd->setZeroDq(i);
3: +    _lowCmd->setZeroTau(i);
3: +  }
3: +  for (int i = 0; i < 12; i++) {
3: +    _lowCmd->motorCmd[i].q = _lowState->motorState[i].q;
3: +    _startPos[i] = _lowState->motorState[i].q;
3: +  }
3: +  _ctrlComp->setAllStance();
3: @@ -28,6 +28,7 @@
3: -void State_FixedStand::run(){
3: -    _percent += (float)1/_duration;
3: -    _percent = _percent > 1 ? 1 : _percent;
3: -    for(int j=0; j<12; j++){
3: -        _lowCmd->motorCmd[j].q = (1 - _percent)*_startPos[j] + _percent*_targetPos[j]; 
3: -    }
3: +void State_FixedStand::run()
3: +{
3: +  _percent += (float)1 / _duration;
3: +  _percent = _percent > 1 ? 1 : _percent;
3: +  for (int j = 0; j < 12; j++) {
3: +    _lowCmd->motorCmd[j].q = (1 - _percent) * _startPos[j] + _percent * _targetPos[j];
3: +  }
3: @@ -36,2 +37,3 @@
3: -void State_FixedStand::exit(){
3: -    _percent = 0;
3: +void State_FixedStand::exit()
3: +{
3: +  _percent = 0;
3: @@ -40,19 +42,15 @@
3: -FSMStateName State_FixedStand::checkChange(){
3: -    if(_lowState->userCmd == UserCommand::L2_B){
3: -        return FSMStateName::PASSIVE;
3: -    }
3: -    else if(_lowState->userCmd == UserCommand::L2_X){
3: -        return FSMStateName::FREESTAND;
3: -    }
3: -    else if(_lowState->userCmd == UserCommand::START){
3: -        return FSMStateName::TROTTING;
3: -    }
3: -    else if(_lowState->userCmd == UserCommand::L1_X){
3: -        return FSMStateName::BALANCETEST;
3: -    }
3: -    else if(_lowState->userCmd == UserCommand::L1_A){
3: -        return FSMStateName::SWINGTEST;
3: -    }
3: -    else if(_lowState->userCmd == UserCommand::L1_Y){
3: -        return FSMStateName::STEPTEST;
3: -    }
3: +FSMStateName State_FixedStand::checkChange()
3: +{
3: +  if (_lowState->userCmd == UserCommand::L2_B) {
3: +    return FSMStateName::PASSIVE;
3: +  } else if (_lowState->userCmd == UserCommand::L2_X) {
3: +    return FSMStateName::FREESTAND;
3: +  } else if (_lowState->userCmd == UserCommand::START) {
3: +    return FSMStateName::TROTTING;
3: +  } else if (_lowState->userCmd == UserCommand::L1_X) {
3: +    return FSMStateName::BALANCETEST;
3: +  } else if (_lowState->userCmd == UserCommand::L1_A) {
3: +    return FSMStateName::SWINGTEST;
3: +  } else if (_lowState->userCmd == UserCommand::L1_Y) {
3: +    return FSMStateName::STEPTEST;
3: +  }
3: @@ -60,3 +58,3 @@
3: -    else if(_lowState->userCmd == UserCommand::L2_Y){
3: -        return FSMStateName::MOVE_BASE;
3: -    }
3: +  else if (_lowState->userCmd == UserCommand::L2_Y) {
3: +    return FSMStateName::MOVE_BASE;
3: +  }
3: @@ -66,3 +64,3 @@
3: -    else if(_lowState->userCmd == UserCommand::L2_Y){
3: -        return FSMStateName::MOVE_BASE;
3: -    }
3: +  else if (_lowState->userCmd == UserCommand::L2_Y) {
3: +    return FSMStateName::MOVE_BASE;
3: +  }
3: @@ -70,4 +68,4 @@
3: -    else{
3: -        return FSMStateName::FIXEDSTAND;
3: -    }
3: -}
3: +  else {
3: +    return FSMStateName::FIXEDSTAND;
3: +  }
3: +}
3: 
3: Code style divergence in file 'src/FSM/State_FreeStand.cpp':
3: 
3: --- src/FSM/State_FreeStand.cpp
3: +++ src/FSM/State_FreeStand.cpp.uncrustify
3: @@ -6,10 +6,11 @@
3: -State_FreeStand::State_FreeStand(CtrlComponents *ctrlComp)
3: -             :FSMState(ctrlComp, FSMStateName::FREESTAND, "free stand"){
3: -    _rowMax = 20 * M_PI / 180;
3: -    _rowMin = -_rowMax;
3: -    _pitchMax = 15 * M_PI / 180;
3: -    _pitchMin = -_pitchMax;
3: -    _yawMax = 20 * M_PI / 180;
3: -    _yawMin = -_yawMax;
3: -    _heightMax = 0.04;
3: -    _heightMin = -_heightMax;
3: +State_FreeStand::State_FreeStand(CtrlComponents * ctrlComp)
3: +: FSMState(ctrlComp, FSMStateName::FREESTAND, "free stand")
3: +{
3: +  _rowMax = 20 * M_PI / 180;
3: +  _rowMin = -_rowMax;
3: +  _pitchMax = 15 * M_PI / 180;
3: +  _pitchMin = -_pitchMax;
3: +  _yawMax = 20 * M_PI / 180;
3: +  _yawMin = -_yawMax;
3: +  _heightMax = 0.04;
3: +  _heightMin = -_heightMax;
3: @@ -18,10 +19,7 @@
3: -void State_FreeStand::enter(){
3: -    for(int i=0; i<4; i++){
3: -        if(_ctrlComp->ctrlPlatform == CtrlPlatform::GAZEBO){
3: -            _lowCmd->setSimStanceGain(i);
3: -        }
3: -        else if(_ctrlComp->ctrlPlatform == CtrlPlatform::REALROBOT){
3: -            _lowCmd->setRealStanceGain(i);
3: -        }
3: -        _lowCmd->setZeroDq(i);
3: -        _lowCmd->setZeroTau(i);
3: +void State_FreeStand::enter()
3: +{
3: +  for (int i = 0; i < 4; i++) {
3: +    if (_ctrlComp->ctrlPlatform == CtrlPlatform::GAZEBO) {
3: +      _lowCmd->setSimStanceGain(i);
3: +    } else if (_ctrlComp->ctrlPlatform == CtrlPlatform::REALROBOT) {
3: +      _lowCmd->setRealStanceGain(i);
3: @@ -28,0 +27,3 @@
3: +    _lowCmd->setZeroDq(i);
3: +    _lowCmd->setZeroTau(i);
3: +  }
3: @@ -30,5 +31,5 @@
3: -    for(int i=0; i<12; i++){
3: -        _lowCmd->motorCmd[i].q = _lowState->motorState[i].q;
3: -    }
3: -    _initVecOX = _ctrlComp->robotModel->getX(*_lowState);
3: -    _initVecXP = _ctrlComp->robotModel->getVecXP(*_lowState);
3: +  for (int i = 0; i < 12; i++) {
3: +    _lowCmd->motorCmd[i].q = _lowState->motorState[i].q;
3: +  }
3: +  _initVecOX = _ctrlComp->robotModel->getX(*_lowState);
3: +  _initVecXP = _ctrlComp->robotModel->getVecXP(*_lowState);
3: @@ -36,2 +37,2 @@
3: -    _ctrlComp->setAllStance();
3: -    _ctrlComp->ioInter->zeroCmdPanel();
3: +  _ctrlComp->setAllStance();
3: +  _ctrlComp->ioInter->zeroCmdPanel();
3: @@ -40,3 +41,4 @@
3: -void State_FreeStand::run(){
3: -    Vec34 vecOP;
3: -    _userValue = _lowState->userValue;
3: +void State_FreeStand::run()
3: +{
3: +  Vec34 vecOP;
3: +  _userValue = _lowState->userValue;
3: @@ -44,5 +46,6 @@
3: -    vecOP = _calcOP( invNormalize(_userValue.lx, _rowMin, _rowMax),
3: -                     invNormalize(_userValue.ly, _pitchMin, _pitchMax),
3: -                    -invNormalize(_userValue.rx, _yawMin, _yawMax),
3: -                     invNormalize(_userValue.ry, _heightMin, _heightMax) );
3: -    _calcCmd(vecOP);
3: +  vecOP = _calcOP(
3: +    invNormalize(_userValue.lx, _rowMin, _rowMax),
3: +    invNormalize(_userValue.ly, _pitchMin, _pitchMax),
3: +    -invNormalize(_userValue.rx, _yawMin, _yawMax),
3: +    invNormalize(_userValue.ry, _heightMin, _heightMax) );
3: +  _calcCmd(vecOP);
3: @@ -51,2 +54,3 @@
3: -void State_FreeStand::exit(){
3: -    _ctrlComp->ioInter->zeroCmdPanel();
3: +void State_FreeStand::exit()
3: +{
3: +  _ctrlComp->ioInter->zeroCmdPanel();
3: @@ -55,13 +59,11 @@
3: -FSMStateName State_FreeStand::checkChange(){
3: -    if(_lowState->userCmd == UserCommand::L2_A){
3: -        return FSMStateName::FIXEDSTAND;
3: -    }
3: -    else if(_lowState->userCmd == UserCommand::L2_B){
3: -        return FSMStateName::PASSIVE;
3: -    }
3: -    else if(_lowState->userCmd == UserCommand::START){
3: -        return FSMStateName::TROTTING;
3: -    }
3: -    else{
3: -        return FSMStateName::FREESTAND;
3: -    }
3: +FSMStateName State_FreeStand::checkChange()
3: +{
3: +  if (_lowState->userCmd == UserCommand::L2_A) {
3: +    return FSMStateName::FIXEDSTAND;
3: +  } else if (_lowState->userCmd == UserCommand::L2_B) {
3: +    return FSMStateName::PASSIVE;
3: +  } else if (_lowState->userCmd == UserCommand::START) {
3: +    return FSMStateName::TROTTING;
3: +  } else {
3: +    return FSMStateName::FREESTAND;
3: +  }
3: @@ -70,3 +72,4 @@
3: -Vec34 State_FreeStand::_calcOP(float row, float pitch, float yaw, float height){
3: -    Vec3 vecXO = -_initVecOX;
3: -    vecXO(2) += height;
3: +Vec34 State_FreeStand::_calcOP(float row, float pitch, float yaw, float height)
3: +{
3: +  Vec3 vecXO = -_initVecOX;
3: +  vecXO(2) += height;
3: @@ -74 +77 @@
3: -    RotMat rotM = rpyToRotMat(row, pitch, yaw);
3: +  RotMat rotM = rpyToRotMat(row, pitch, yaw);
3: @@ -76,2 +79,2 @@
3: -    HomoMat Tsb = homoMatrix(vecXO, rotM);
3: -    HomoMat Tbs = homoMatrixInverse(Tsb);
3: +  HomoMat Tsb = homoMatrix(vecXO, rotM);
3: +  HomoMat Tbs = homoMatrixInverse(Tsb);
3: @@ -79,6 +82,6 @@
3: -    Vec4 tempVec4;
3: -    Vec34 vecOP;
3: -    for(int i(0); i<4; ++i){
3: -        tempVec4 = Tbs * homoVec(_initVecXP.col(i));
3: -        vecOP.col(i) = noHomoVec(tempVec4);
3: -    }
3: +  Vec4 tempVec4;
3: +  Vec34 vecOP;
3: +  for (int i(0); i < 4; ++i) {
3: +    tempVec4 = Tbs * homoVec(_initVecXP.col(i));
3: +    vecOP.col(i) = noHomoVec(tempVec4);
3: +  }
3: @@ -86 +89 @@
3: -    return vecOP;
3: +  return vecOP;
3: @@ -89,4 +92,5 @@
3: -void State_FreeStand::_calcCmd(Vec34 vecOP){
3: -    Vec12 q = _ctrlComp->robotModel->getQ(vecOP, FrameType::BODY);
3: -    _lowCmd->setQ(q);
3: -}
3: +void State_FreeStand::_calcCmd(Vec34 vecOP)
3: +{
3: +  Vec12 q = _ctrlComp->robotModel->getQ(vecOP, FrameType::BODY);
3: +  _lowCmd->setQ(q);
3: +}
3: 
3: Code style divergence in file 'src/FSM/State_Passive.cpp':
3: 
3: --- src/FSM/State_Passive.cpp
3: +++ src/FSM/State_Passive.cpp.uncrustify
3: @@ -6,2 +6,2 @@
3: -State_Passive::State_Passive(CtrlComponents *ctrlComp)
3: -             :FSMState(ctrlComp, FSMStateName::PASSIVE, "passive"){}
3: +State_Passive::State_Passive(CtrlComponents * ctrlComp)
3: +: FSMState(ctrlComp, FSMStateName::PASSIVE, "passive") {}
3: @@ -9,10 +9,10 @@
3: -void State_Passive::enter(){
3: -    if(_ctrlComp->ctrlPlatform == CtrlPlatform::GAZEBO){
3: -        for(int i=0; i<12; i++){
3: -            _lowCmd->motorCmd[i].mode = 10;
3: -            _lowCmd->motorCmd[i].q = 0;
3: -            _lowCmd->motorCmd[i].dq = 0;
3: -            _lowCmd->motorCmd[i].Kp = 0;
3: -            _lowCmd->motorCmd[i].Kd = 8;
3: -            _lowCmd->motorCmd[i].tau = 0;
3: -        }
3: +void State_Passive::enter()
3: +{
3: +  if (_ctrlComp->ctrlPlatform == CtrlPlatform::GAZEBO) {
3: +    for (int i = 0; i < 12; i++) {
3: +      _lowCmd->motorCmd[i].mode = 10;
3: +      _lowCmd->motorCmd[i].q = 0;
3: +      _lowCmd->motorCmd[i].dq = 0;
3: +      _lowCmd->motorCmd[i].Kp = 0;
3: +      _lowCmd->motorCmd[i].Kd = 8;
3: +      _lowCmd->motorCmd[i].tau = 0;
3: @@ -20,9 +20,8 @@
3: -    else if(_ctrlComp->ctrlPlatform == CtrlPlatform::REALROBOT){
3: -        for(int i=0; i<12; i++){
3: -            _lowCmd->motorCmd[i].mode = 10;
3: -            _lowCmd->motorCmd[i].q = 0;
3: -            _lowCmd->motorCmd[i].dq = 0;
3: -            _lowCmd->motorCmd[i].Kp = 0;
3: -            _lowCmd->motorCmd[i].Kd = 3;
3: -            _lowCmd->motorCmd[i].tau = 0;
3: -        }
3: +  } else if (_ctrlComp->ctrlPlatform == CtrlPlatform::REALROBOT) {
3: +    for (int i = 0; i < 12; i++) {
3: +      _lowCmd->motorCmd[i].mode = 10;
3: +      _lowCmd->motorCmd[i].q = 0;
3: +      _lowCmd->motorCmd[i].dq = 0;
3: +      _lowCmd->motorCmd[i].Kp = 0;
3: +      _lowCmd->motorCmd[i].Kd = 3;
3: +      _lowCmd->motorCmd[i].tau = 0;
3: @@ -29,0 +29 @@
3: +  }
3: @@ -31 +31 @@
3: -    _ctrlComp->setAllSwing();
3: +  _ctrlComp->setAllSwing();
3: @@ -34,5 +34,2 @@
3: -void State_Passive::run(){
3: -    
3: -}
3: -
3: -void State_Passive::exit(){
3: +void State_Passive::run()
3: +{
3: @@ -42,8 +39,13 @@
3: -FSMStateName State_Passive::checkChange(){
3: -    if(_lowState->userCmd == UserCommand::L2_A){
3: -        return FSMStateName::FIXEDSTAND;
3: -    }
3: -    else{
3: -        return FSMStateName::PASSIVE;
3: -    }
3: -}
3: +void State_Passive::exit()
3: +{
3: +
3: +}
3: +
3: +FSMStateName State_Passive::checkChange()
3: +{
3: +  if (_lowState->userCmd == UserCommand::L2_A) {
3: +    return FSMStateName::FIXEDSTAND;
3: +  } else {
3: +    return FSMStateName::PASSIVE;
3: +  }
3: +}
3: 
3: Code style divergence in file 'src/FSM/State_StepTest.cpp':
3: 
3: --- src/FSM/State_StepTest.cpp
3: +++ src/FSM/State_StepTest.cpp.uncrustify
3: @@ -6,5 +6,6 @@
3: -State_StepTest::State_StepTest(CtrlComponents *ctrlComp)
3: -                  :FSMState(ctrlComp, FSMStateName::STEPTEST, "stepTest"),
3: -                  _est(ctrlComp->estimator), _robModel(ctrlComp->robotModel), 
3: -                  _balCtrl(ctrlComp->balCtrl), _contact(ctrlComp->contact),
3: -                  _phase(ctrlComp->phase){
3: +State_StepTest::State_StepTest(CtrlComponents * ctrlComp)
3: +: FSMState(ctrlComp, FSMStateName::STEPTEST, "stepTest"),
3: +  _est(ctrlComp->estimator), _robModel(ctrlComp->robotModel),
3: +  _balCtrl(ctrlComp->balCtrl), _contact(ctrlComp->contact),
3: +  _phase(ctrlComp->phase)
3: +{
3: @@ -12 +13 @@
3: -    _gaitHeight = 0.05;
3: +  _gaitHeight = 0.05;
3: @@ -14,2 +15,2 @@
3: -    _KpSwing = Vec3(600, 600, 200).asDiagonal();
3: -    _KdSwing = Vec3(20, 20, 5).asDiagonal();
3: +  _KpSwing = Vec3(600, 600, 200).asDiagonal();
3: +  _KdSwing = Vec3(20, 20, 5).asDiagonal();
3: @@ -17,4 +18,4 @@
3: -    _Kpp = Vec3(50, 50, 300).asDiagonal();
3: -    _Kpw = Vec3(600, 600, 600).asDiagonal();
3: -    _Kdp = Vec3(5, 5, 20).asDiagonal();
3: -    _Kdw = Vec3(10, 10, 10).asDiagonal();
3: +  _Kpp = Vec3(50, 50, 300).asDiagonal();
3: +  _Kpw = Vec3(600, 600, 600).asDiagonal();
3: +  _Kdp = Vec3(5, 5, 20).asDiagonal();
3: +  _Kdw = Vec3(10, 10, 10).asDiagonal();
3: @@ -23,7 +24,8 @@
3: -void State_StepTest::enter(){
3: -    _pcd = _est->getPosition();
3: -    _Rd  = _lowState->getRotMat();
3: -    _posFeetGlobalInit = _est->getFeetPos();
3: -    _posFeetGlobalGoal = _posFeetGlobalInit;
3: -    _ctrlComp->setStartWave();
3: -    _ctrlComp->ioInter->zeroCmdPanel();
3: +void State_StepTest::enter()
3: +{
3: +  _pcd = _est->getPosition();
3: +  _Rd = _lowState->getRotMat();
3: +  _posFeetGlobalInit = _est->getFeetPos();
3: +  _posFeetGlobalGoal = _posFeetGlobalInit;
3: +  _ctrlComp->setStartWave();
3: +  _ctrlComp->ioInter->zeroCmdPanel();
3: @@ -32,3 +34,4 @@
3: -void State_StepTest::run(){
3: -    _posBody = _est->getPosition();
3: -    _velBody = _est->getVelocity();
3: +void State_StepTest::run()
3: +{
3: +  _posBody = _est->getPosition();
3: +  _velBody = _est->getVelocity();
3: @@ -36,2 +39,2 @@
3: -    _B2G_RotMat = _lowState->getRotMat();
3: -    _G2B_RotMat = _B2G_RotMat.transpose();
3: +  _B2G_RotMat = _lowState->getRotMat();
3: +  _G2B_RotMat = _B2G_RotMat.transpose();
3: @@ -40,5 +43,6 @@
3: -    for(int i(0); i<4; ++i){
3: -        if((*_contact)(i) == 0){
3: -            _posFeetGlobalGoal(2, i) = _posFeetGlobalInit(2, i) + (1-cos((*_phase)(i)*2*M_PI))*_gaitHeight;
3: -            _velFeetGlobalGoal(2, i) = sin((*_phase)(i)*2*M_PI)*2*M_PI*_gaitHeight;
3: -        }
3: +  for (int i(0); i < 4; ++i) {
3: +    if ((*_contact)(i) == 0) {
3: +      _posFeetGlobalGoal(
3: +        2,
3: +        i) = _posFeetGlobalInit(2, i) + (1 - cos((*_phase)(i) * 2 * M_PI)) * _gaitHeight;
3: +      _velFeetGlobalGoal(2, i) = sin((*_phase)(i) * 2 * M_PI) * 2 * M_PI * _gaitHeight;
3: @@ -45,0 +50 @@
3: +  }
3: @@ -47 +52 @@
3: -    calcTau();
3: +  calcTau();
3: @@ -49,2 +54,2 @@
3: -    _lowCmd->setZeroGain();
3: -    _lowCmd->setTau(_tau);
3: +  _lowCmd->setZeroGain();
3: +  _lowCmd->setTau(_tau);
3: @@ -53,3 +58,4 @@
3: -void State_StepTest::exit(){
3: -    _ctrlComp->ioInter->zeroCmdPanel();
3: -    _ctrlComp->setAllSwing();
3: +void State_StepTest::exit()
3: +{
3: +  _ctrlComp->ioInter->zeroCmdPanel();
3: +  _ctrlComp->setAllSwing();
3: @@ -58,10 +64,9 @@
3: -FSMStateName State_StepTest::checkChange(){
3: -    if(_lowState->userCmd == UserCommand::L2_B){
3: -        return FSMStateName::PASSIVE;
3: -    }
3: -    else if(_lowState->userCmd == UserCommand::L2_A){
3: -        return FSMStateName::FIXEDSTAND;
3: -    }
3: -    else{
3: -        return FSMStateName::STEPTEST;
3: -    }
3: +FSMStateName State_StepTest::checkChange()
3: +{
3: +  if (_lowState->userCmd == UserCommand::L2_B) {
3: +    return FSMStateName::PASSIVE;
3: +  } else if (_lowState->userCmd == UserCommand::L2_A) {
3: +    return FSMStateName::FIXEDSTAND;
3: +  } else {
3: +    return FSMStateName::STEPTEST;
3: +  }
3: @@ -70,3 +75,5 @@
3: -void State_StepTest::calcTau(){
3: -    _ddPcd = _Kpp*(_pcd - _posBody) + _Kdp * (Vec3(0, 0, 0) - _velBody);
3: -    _dWbd  = _Kpw*rotMatToExp(_Rd*_G2B_RotMat) + _Kdw * (Vec3(0, 0, 0) - _lowState->getGyroGlobal());
3: +void State_StepTest::calcTau()
3: +{
3: +  _ddPcd = _Kpp * (_pcd - _posBody) + _Kdp * (Vec3(0, 0, 0) - _velBody);
3: +  _dWbd = _Kpw * rotMatToExp(_Rd * _G2B_RotMat) + _Kdw *
3: +    (Vec3(0, 0, 0) - _lowState->getGyroGlobal());
3: @@ -74,9 +81,9 @@
3: -    _posFeet2BGlobal = _est->getPosFeet2BGlobal();
3: -    _forceFeetGlobal = - _balCtrl->calF(_ddPcd, _dWbd, _B2G_RotMat, _posFeet2BGlobal, *_contact);
3: -    
3: -    _posFeetGlobal = _est->getFeetPos();
3: -    _velFeetGlobal = _est->getFeetVel();
3: -    for(int i(0); i<4; ++i){
3: -        if((*_contact)(i) == 0){
3: -            _forceFeetGlobal.col(i) = _KpSwing*(_posFeetGlobalGoal.col(i) - _posFeetGlobal.col(i)) + _KdSwing*(_velFeetGlobalGoal.col(i)-_velFeetGlobal.col(i));
3: -        }
3: +  _posFeet2BGlobal = _est->getPosFeet2BGlobal();
3: +  _forceFeetGlobal = -_balCtrl->calF(_ddPcd, _dWbd, _B2G_RotMat, _posFeet2BGlobal, *_contact);
3: +
3: +  _posFeetGlobal = _est->getFeetPos();
3: +  _velFeetGlobal = _est->getFeetVel();
3: +  for (int i(0); i < 4; ++i) {
3: +    if ((*_contact)(i) == 0) {
3: +      _forceFeetGlobal.col(i) = _KpSwing * (_posFeetGlobalGoal.col(i) - _posFeetGlobal.col(i)) +
3: +        _KdSwing * (_velFeetGlobalGoal.col(i) - _velFeetGlobal.col(i));
3: @@ -84,2 +91 @@
3: -    
3: -    _forceFeetBody = _G2B_RotMat * _forceFeetGlobal;
3: +  }
3: @@ -87,3 +93,5 @@
3: -    _q = vec34ToVec12(_lowState->getQ());
3: -    _tau = _robModel->getTau(_q, _forceFeetBody);
3: -}
3: +  _forceFeetBody = _G2B_RotMat * _forceFeetGlobal;
3: +
3: +  _q = vec34ToVec12(_lowState->getQ());
3: +  _tau = _robModel->getTau(_q, _forceFeetBody);
3: +}
3: 
3: Code style divergence in file 'src/FSM/State_SwingTest.cpp':
3: 
3: --- src/FSM/State_SwingTest.cpp
3: +++ src/FSM/State_SwingTest.cpp.uncrustify
3: @@ -6,8 +6,9 @@
3: -State_SwingTest::State_SwingTest(CtrlComponents *ctrlComp)
3: -                :FSMState(ctrlComp, FSMStateName::SWINGTEST, "swingTest"){
3: -    _xMin = -0.15;
3: -    _xMax =  0.10;
3: -    _yMin = -0.15;
3: -    _yMax =  0.15;
3: -    _zMin = -0.05;
3: -    _zMax =  0.20;
3: +State_SwingTest::State_SwingTest(CtrlComponents * ctrlComp)
3: +: FSMState(ctrlComp, FSMStateName::SWINGTEST, "swingTest")
3: +{
3: +  _xMin = -0.15;
3: +  _xMax = 0.10;
3: +  _yMin = -0.15;
3: +  _yMax = 0.15;
3: +  _zMin = -0.05;
3: +  _zMax = 0.20;
3: @@ -16,10 +17,7 @@
3: -void State_SwingTest::enter(){
3: -    for(int i=0; i<4; i++){
3: -        if(_ctrlComp->ctrlPlatform == CtrlPlatform::GAZEBO){
3: -            _lowCmd->setSimStanceGain(i);
3: -        }
3: -        else if(_ctrlComp->ctrlPlatform == CtrlPlatform::REALROBOT){
3: -            _lowCmd->setRealStanceGain(i);
3: -        }
3: -        _lowCmd->setZeroDq(i);
3: -        _lowCmd->setZeroTau(i);
3: +void State_SwingTest::enter()
3: +{
3: +  for (int i = 0; i < 4; i++) {
3: +    if (_ctrlComp->ctrlPlatform == CtrlPlatform::GAZEBO) {
3: +      _lowCmd->setSimStanceGain(i);
3: +    } else if (_ctrlComp->ctrlPlatform == CtrlPlatform::REALROBOT) {
3: +      _lowCmd->setRealStanceGain(i);
3: @@ -27 +25,4 @@
3: -    _lowCmd->setSwingGain(0);
3: +    _lowCmd->setZeroDq(i);
3: +    _lowCmd->setZeroTau(i);
3: +  }
3: +  _lowCmd->setSwingGain(0);
3: @@ -29,2 +30,2 @@
3: -    _Kp = Vec3(20, 20, 50).asDiagonal();
3: -    _Kd = Vec3( 5,  5, 20).asDiagonal();
3: +  _Kp = Vec3(20, 20, 50).asDiagonal();
3: +  _Kd = Vec3(5, 5, 20).asDiagonal();
3: @@ -32,3 +33,3 @@
3: -    for(int i=0; i<12; i++){
3: -        _lowCmd->motorCmd[i].q = _lowState->motorState[i].q;
3: -    }
3: +  for (int i = 0; i < 12; i++) {
3: +    _lowCmd->motorCmd[i].q = _lowState->motorState[i].q;
3: +  }
3: @@ -36,3 +37,3 @@
3: -    _initFeetPos = _ctrlComp->robotModel->getFeet2BPositions(*_lowState, FrameType::HIP);
3: -    _feetPos = _initFeetPos;
3: -    _initPos = _initFeetPos.col(0);
3: +  _initFeetPos = _ctrlComp->robotModel->getFeet2BPositions(*_lowState, FrameType::HIP);
3: +  _feetPos = _initFeetPos;
3: +  _initPos = _initFeetPos.col(0);
3: @@ -40 +41 @@
3: -    _ctrlComp->setAllSwing();
3: +  _ctrlComp->setAllSwing();
3: @@ -43,2 +44,3 @@
3: -void State_SwingTest::run(){
3: -    _userValue = _lowState->userValue;
3: +void State_SwingTest::run()
3: +{
3: +  _userValue = _lowState->userValue;
3: @@ -46,11 +48,5 @@
3: -    if(_userValue.ly > 0){
3: -        _posGoal(0) = invNormalize(_userValue.ly, _initPos(0), _initPos(0)+_xMax, 0, 1);
3: -    }else{
3: -        _posGoal(0) = invNormalize(_userValue.ly, _initPos(0)+_xMin, _initPos(0), -1, 0);
3: -    }
3: -    
3: -    if(_userValue.lx > 0){
3: -        _posGoal(1) = invNormalize(_userValue.lx, _initPos(1, 0), _initPos(1)+_yMax, 0, 1);
3: -    }else{
3: -        _posGoal(1) = invNormalize(_userValue.lx, _initPos(1)+_yMin, _initPos(1), -1, 0);
3: -    }
3: +  if (_userValue.ly > 0) {
3: +    _posGoal(0) = invNormalize(_userValue.ly, _initPos(0), _initPos(0) + _xMax, 0, 1);
3: +  } else {
3: +    _posGoal(0) = invNormalize(_userValue.ly, _initPos(0) + _xMin, _initPos(0), -1, 0);
3: +  }
3: @@ -58,5 +54,5 @@
3: -    if(_userValue.ry > 0){
3: -        _posGoal(2) = invNormalize(_userValue.ry, _initPos(2), _initPos(2)+_zMax, 0, 1);
3: -    }else{
3: -        _posGoal(2) = invNormalize(_userValue.ry, _initPos(2)+_zMin, _initPos(2), -1, 0);
3: -    }
3: +  if (_userValue.lx > 0) {
3: +    _posGoal(1) = invNormalize(_userValue.lx, _initPos(1, 0), _initPos(1) + _yMax, 0, 1);
3: +  } else {
3: +    _posGoal(1) = invNormalize(_userValue.lx, _initPos(1) + _yMin, _initPos(1), -1, 0);
3: +  }
3: @@ -64,2 +60,8 @@
3: -    _positionCtrl();
3: -    _torqueCtrl();
3: +  if (_userValue.ry > 0) {
3: +    _posGoal(2) = invNormalize(_userValue.ry, _initPos(2), _initPos(2) + _zMax, 0, 1);
3: +  } else {
3: +    _posGoal(2) = invNormalize(_userValue.ry, _initPos(2) + _zMin, _initPos(2), -1, 0);
3: +  }
3: +
3: +  _positionCtrl();
3: +  _torqueCtrl();
3: @@ -68,2 +70,3 @@
3: -void State_SwingTest::exit(){
3: -    _ctrlComp->ioInter->zeroCmdPanel();
3: +void State_SwingTest::exit()
3: +{
3: +  _ctrlComp->ioInter->zeroCmdPanel();
3: @@ -72,10 +75,9 @@
3: -FSMStateName State_SwingTest::checkChange(){
3: -    if(_lowState->userCmd == UserCommand::L2_B){
3: -        return FSMStateName::PASSIVE;
3: -    }
3: -    else if(_lowState->userCmd == UserCommand::L2_A){
3: -        return FSMStateName::FIXEDSTAND;
3: -    }
3: -    else{
3: -        return FSMStateName::SWINGTEST;
3: -    }
3: +FSMStateName State_SwingTest::checkChange()
3: +{
3: +  if (_lowState->userCmd == UserCommand::L2_B) {
3: +    return FSMStateName::PASSIVE;
3: +  } else if (_lowState->userCmd == UserCommand::L2_A) {
3: +    return FSMStateName::FIXEDSTAND;
3: +  } else {
3: +    return FSMStateName::SWINGTEST;
3: +  }
3: @@ -84,4 +86,5 @@
3: -void State_SwingTest::_positionCtrl(){
3: -    _feetPos.col(0) = _posGoal;
3: -    _targetPos = _ctrlComp->robotModel->getQ(_feetPos, FrameType::HIP);
3: -    _lowCmd->setQ(_targetPos);
3: +void State_SwingTest::_positionCtrl()
3: +{
3: +  _feetPos.col(0) = _posGoal;
3: +  _targetPos = _ctrlComp->robotModel->getQ(_feetPos, FrameType::HIP);
3: +  _lowCmd->setQ(_targetPos);
3: @@ -90,3 +93,4 @@
3: -void State_SwingTest::_torqueCtrl(){
3: -    Vec3 pos0 = _ctrlComp->robotModel->getFootPosition(*_lowState, 0, FrameType::HIP);
3: -    Vec3 vel0 = _ctrlComp->robotModel->getFootVelocity(*_lowState, 0);
3: +void State_SwingTest::_torqueCtrl()
3: +{
3: +  Vec3 pos0 = _ctrlComp->robotModel->getFootPosition(*_lowState, 0, FrameType::HIP);
3: +  Vec3 vel0 = _ctrlComp->robotModel->getFootVelocity(*_lowState, 0);
3: @@ -94 +98 @@
3: -    Vec3 force0 = _Kp*(_posGoal - pos0) + _Kd*(-vel0);
3: +  Vec3 force0 = _Kp * (_posGoal - pos0) + _Kd * (-vel0);
3: @@ -96,2 +100,2 @@
3: -    Vec12 torque;
3: -    Mat3 jaco0 = _ctrlComp->robotModel->getJaco(*_lowState, 0);
3: +  Vec12 torque;
3: +  Mat3 jaco0 = _ctrlComp->robotModel->getJaco(*_lowState, 0);
3: @@ -99 +103 @@
3: -    torque.segment(0, 3) = jaco0.transpose() * force0;
3: +  torque.segment(0, 3) = jaco0.transpose() * force0;
3: @@ -101,2 +105,2 @@
3: -    _lowCmd->setTau(torque);
3: -}
3: +  _lowCmd->setTau(torque);
3: +}
3: 
3: Code style divergence in file 'src/FSM/State_Trotting.cpp':
3: 
3: --- src/FSM/State_Trotting.cpp
3: +++ src/FSM/State_Trotting.cpp.uncrustify
3: @@ -7,8 +7,9 @@
3: -State_Trotting::State_Trotting(CtrlComponents *ctrlComp)
3: -             :FSMState(ctrlComp, FSMStateName::TROTTING, "trotting"), 
3: -              _est(ctrlComp->estimator), _phase(ctrlComp->phase), 
3: -              _contact(ctrlComp->contact), _robModel(ctrlComp->robotModel), 
3: -              _balCtrl(ctrlComp->balCtrl){
3: -    _gait = new GaitGenerator(ctrlComp);
3: -
3: -    _gaitHeight = 0.08;
3: +State_Trotting::State_Trotting(CtrlComponents * ctrlComp)
3: +: FSMState(ctrlComp, FSMStateName::TROTTING, "trotting"),
3: +  _est(ctrlComp->estimator), _phase(ctrlComp->phase),
3: +  _contact(ctrlComp->contact), _robModel(ctrlComp->robotModel),
3: +  _balCtrl(ctrlComp->balCtrl)
3: +{
3: +  _gait = new GaitGenerator(ctrlComp);
3: +
3: +  _gaitHeight = 0.08;
3: @@ -17,6 +18,6 @@
3: -    _Kpp = Vec3(70, 70, 70).asDiagonal();
3: -    _Kdp = Vec3(10, 10, 10).asDiagonal();
3: -    _kpw = 780; 
3: -    _Kdw = Vec3(70, 70, 70).asDiagonal();
3: -    _KpSwing = Vec3(400, 400, 400).asDiagonal();
3: -    _KdSwing = Vec3(10, 10, 10).asDiagonal();
3: +  _Kpp = Vec3(70, 70, 70).asDiagonal();
3: +  _Kdp = Vec3(10, 10, 10).asDiagonal();
3: +  _kpw = 780;
3: +  _Kdw = Vec3(70, 70, 70).asDiagonal();
3: +  _KpSwing = Vec3(400, 400, 400).asDiagonal();
3: +  _KdSwing = Vec3(10, 10, 10).asDiagonal();
3: @@ -26,6 +27,6 @@
3: -    _Kpp = Vec3(20, 20, 100).asDiagonal();
3: -    _Kdp = Vec3(20, 20, 20).asDiagonal();
3: -    _kpw = 400;
3: -    _Kdw = Vec3(50, 50, 50).asDiagonal();
3: -    _KpSwing = Vec3(400, 400, 400).asDiagonal();
3: -    _KdSwing = Vec3(10, 10, 10).asDiagonal();
3: +  _Kpp = Vec3(20, 20, 100).asDiagonal();
3: +  _Kdp = Vec3(20, 20, 20).asDiagonal();
3: +  _kpw = 400;
3: +  _Kdw = Vec3(50, 50, 50).asDiagonal();
3: +  _KpSwing = Vec3(400, 400, 400).asDiagonal();
3: +  _KdSwing = Vec3(10, 10, 10).asDiagonal();
3: @@ -34,30 +35,79 @@
3: -    _vxLim = _robModel->getRobVelLimitX();
3: -    _vyLim = _robModel->getRobVelLimitY();
3: -    _wyawLim = _robModel->getRobVelLimitYaw();
3: -
3: -}
3: -
3: -State_Trotting::~State_Trotting(){
3: -    delete _gait;
3: -}
3: -
3: -void State_Trotting::enter(){
3: -    _pcd = _est->getPosition();
3: -    _pcd(2) = -_robModel->getFeetPosIdeal()(2, 0);
3: -    _vCmdBody.setZero();
3: -    _yawCmd = _lowState->getYaw();
3: -    _Rd = rotz(_yawCmd);
3: -    _wCmdGlobal.setZero();
3: -
3: -    _ctrlComp->ioInter->zeroCmdPanel();
3: -    _gait->restart();
3: -}
3: -
3: -void State_Trotting::exit(){
3: -    _ctrlComp->ioInter->zeroCmdPanel();
3: -    _ctrlComp->setAllSwing();
3: -}
3: -
3: -FSMStateName State_Trotting::checkChange(){
3: -    if(_lowState->userCmd == UserCommand::L2_B){
3: -        return FSMStateName::PASSIVE;
3: +  _vxLim = _robModel->getRobVelLimitX();
3: +  _vyLim = _robModel->getRobVelLimitY();
3: +  _wyawLim = _robModel->getRobVelLimitYaw();
3: +
3: +}
3: +
3: +State_Trotting::~State_Trotting()
3: +{
3: +  delete _gait;
3: +}
3: +
3: +void State_Trotting::enter()
3: +{
3: +  _pcd = _est->getPosition();
3: +  _pcd(2) = -_robModel->getFeetPosIdeal()(2, 0);
3: +  _vCmdBody.setZero();
3: +  _yawCmd = _lowState->getYaw();
3: +  _Rd = rotz(_yawCmd);
3: +  _wCmdGlobal.setZero();
3: +
3: +  _ctrlComp->ioInter->zeroCmdPanel();
3: +  _gait->restart();
3: +}
3: +
3: +void State_Trotting::exit()
3: +{
3: +  _ctrlComp->ioInter->zeroCmdPanel();
3: +  _ctrlComp->setAllSwing();
3: +}
3: +
3: +FSMStateName State_Trotting::checkChange()
3: +{
3: +  if (_lowState->userCmd == UserCommand::L2_B) {
3: +    return FSMStateName::PASSIVE;
3: +  } else if (_lowState->userCmd == UserCommand::L2_A) {
3: +    return FSMStateName::FIXEDSTAND;
3: +  } else {
3: +    return FSMStateName::TROTTING;
3: +  }
3: +}
3: +
3: +void State_Trotting::run()
3: +{
3: +  _posBody = _est->getPosition();
3: +  _velBody = _est->getVelocity();
3: +  _posFeet2BGlobal = _est->getPosFeet2BGlobal();
3: +  _posFeetGlobal = _est->getFeetPos();
3: +  _velFeetGlobal = _est->getFeetVel();
3: +  _B2G_RotMat = _lowState->getRotMat();
3: +  _G2B_RotMat = _B2G_RotMat.transpose();
3: +  _yaw = _lowState->getYaw();
3: +  _dYaw = _lowState->getDYaw();
3: +
3: +  _userValue = _lowState->userValue;
3: +
3: +  getUserCmd();
3: +  calcCmd();
3: +
3: +  _gait->setGait(_vCmdGlobal.segment(0, 2), _wCmdGlobal(2), _gaitHeight);
3: +  _gait->run(_posFeetGlobalGoal, _velFeetGlobalGoal);
3: +
3: +  calcTau();
3: +  calcQQd();
3: +
3: +  if (checkStepOrNot()) {
3: +    _ctrlComp->setStartWave();
3: +  } else {
3: +    _ctrlComp->setAllStance();
3: +  }
3: +
3: +  _lowCmd->setTau(_tau);
3: +  _lowCmd->setQ(vec34ToVec12(_qGoal));
3: +  _lowCmd->setQd(vec34ToVec12(_qdGoal));
3: +
3: +  for (int i(0); i < 4; ++i) {
3: +    if ((*_contact)(i) == 0) {
3: +      _lowCmd->setSwingGain(i);
3: +    } else {
3: +      _lowCmd->setStableGain(i);
3: @@ -65,2 +115,91 @@
3: -    else if(_lowState->userCmd == UserCommand::L2_A){
3: -        return FSMStateName::FIXEDSTAND;
3: +  }
3: +
3: +}
3: +
3: +bool State_Trotting::checkStepOrNot()
3: +{
3: +  if ( (fabs(_vCmdBody(0)) > 0.03) ||
3: +    (fabs(_vCmdBody(1)) > 0.03) ||
3: +    (fabs(_posError(0)) > 0.08) ||
3: +    (fabs(_posError(1)) > 0.08) ||
3: +    (fabs(_velError(0)) > 0.05) ||
3: +    (fabs(_velError(1)) > 0.05) ||
3: +    (fabs(_dYawCmd) > 0.20) )
3: +  {
3: +    return true;
3: +  } else {
3: +    return false;
3: +  }
3: +}
3: +
3: +void State_Trotting::setHighCmd(double vx, double vy, double wz)
3: +{
3: +  _vCmdBody(0) = vx;
3: +  _vCmdBody(1) = vy;
3: +  _vCmdBody(2) = 0;
3: +  _dYawCmd = wz;
3: +}
3: +
3: +void State_Trotting::getUserCmd()
3: +{
3: +  /* Movement */
3: +  _vCmdBody(0) = invNormalize(_userValue.ly, _vxLim(0), _vxLim(1));
3: +  _vCmdBody(1) = -invNormalize(_userValue.lx, _vyLim(0), _vyLim(1));
3: +  _vCmdBody(2) = 0;
3: +
3: +  /* Turning */
3: +  _dYawCmd = -invNormalize(_userValue.rx, _wyawLim(0), _wyawLim(1));
3: +  _dYawCmd = 0.9 * _dYawCmdPast + (1 - 0.9) * _dYawCmd;
3: +  _dYawCmdPast = _dYawCmd;
3: +}
3: +
3: +void State_Trotting::calcCmd()
3: +{
3: +  /* Movement */
3: +  _vCmdGlobal = _B2G_RotMat * _vCmdBody;
3: +
3: +  _vCmdGlobal(0) = saturation(_vCmdGlobal(0), Vec2(_velBody(0) - 0.2, _velBody(0) + 0.2));
3: +  _vCmdGlobal(1) = saturation(_vCmdGlobal(1), Vec2(_velBody(1) - 0.2, _velBody(1) + 0.2));
3: +
3: +  _pcd(0) =
3: +    saturation(
3: +    _pcd(0) + _vCmdGlobal(0) * _ctrlComp->dt, Vec2(
3: +      _posBody(0) - 0.05, _posBody(
3: +        0) + 0.05));
3: +  _pcd(1) =
3: +    saturation(
3: +    _pcd(1) + _vCmdGlobal(1) * _ctrlComp->dt, Vec2(
3: +      _posBody(1) - 0.05, _posBody(
3: +        1) + 0.05));
3: +
3: +  _vCmdGlobal(2) = 0;
3: +
3: +  /* Turning */
3: +  _yawCmd = _yawCmd + _dYawCmd * _ctrlComp->dt;
3: +
3: +  _Rd = rotz(_yawCmd);
3: +  _wCmdGlobal(2) = _dYawCmd;
3: +}
3: +
3: +void State_Trotting::calcTau()
3: +{
3: +  _posError = _pcd - _posBody;
3: +  _velError = _vCmdGlobal - _velBody;
3: +
3: +  _ddPcd = _Kpp * _posError + _Kdp * _velError;
3: +  _dWbd = _kpw * rotMatToExp(_Rd * _G2B_RotMat) + _Kdw * (_wCmdGlobal - _lowState->getGyroGlobal());
3: +
3: +  _ddPcd(0) = saturation(_ddPcd(0), Vec2(-3, 3));
3: +  _ddPcd(1) = saturation(_ddPcd(1), Vec2(-3, 3));
3: +  _ddPcd(2) = saturation(_ddPcd(2), Vec2(-5, 5));
3: +
3: +  _dWbd(0) = saturation(_dWbd(0), Vec2(-40, 40));
3: +  _dWbd(1) = saturation(_dWbd(1), Vec2(-40, 40));
3: +  _dWbd(2) = saturation(_dWbd(2), Vec2(-10, 10));
3: +
3: +  _forceFeetGlobal = -_balCtrl->calF(_ddPcd, _dWbd, _B2G_RotMat, _posFeet2BGlobal, *_contact);
3: +
3: +  for (int i(0); i < 4; ++i) {
3: +    if ((*_contact)(i) == 0) {
3: +      _forceFeetGlobal.col(i) = _KpSwing * (_posFeetGlobalGoal.col(i) - _posFeetGlobal.col(i)) +
3: +        _KdSwing * (_velFeetGlobalGoal.col(i) - _velFeetGlobal.col(i));
3: @@ -68,142 +207,22 @@
3: -    else{
3: -        return FSMStateName::TROTTING;
3: -    }
3: -}
3: -
3: -void State_Trotting::run(){
3: -    _posBody = _est->getPosition();
3: -    _velBody = _est->getVelocity();
3: -    _posFeet2BGlobal = _est->getPosFeet2BGlobal();
3: -    _posFeetGlobal = _est->getFeetPos();
3: -    _velFeetGlobal = _est->getFeetVel();
3: -    _B2G_RotMat = _lowState->getRotMat();
3: -    _G2B_RotMat = _B2G_RotMat.transpose();
3: -    _yaw = _lowState->getYaw();
3: -    _dYaw = _lowState->getDYaw();
3: -
3: -    _userValue = _lowState->userValue;
3: -
3: -    getUserCmd();
3: -    calcCmd();
3: -
3: -    _gait->setGait(_vCmdGlobal.segment(0,2), _wCmdGlobal(2), _gaitHeight);
3: -    _gait->run(_posFeetGlobalGoal, _velFeetGlobalGoal);
3: -
3: -    calcTau();
3: -    calcQQd();
3: -
3: -    if(checkStepOrNot()){
3: -        _ctrlComp->setStartWave();
3: -    }else{
3: -        _ctrlComp->setAllStance();
3: -    }
3: -
3: -    _lowCmd->setTau(_tau);
3: -    _lowCmd->setQ(vec34ToVec12(_qGoal));
3: -    _lowCmd->setQd(vec34ToVec12(_qdGoal));
3: -
3: -    for(int i(0); i<4; ++i){
3: -        if((*_contact)(i) == 0){
3: -            _lowCmd->setSwingGain(i);
3: -        }else{
3: -            _lowCmd->setStableGain(i);
3: -        }
3: -    }
3: -
3: -}
3: -
3: -bool State_Trotting::checkStepOrNot(){
3: -    if( (fabs(_vCmdBody(0)) > 0.03) ||
3: -        (fabs(_vCmdBody(1)) > 0.03) ||
3: -        (fabs(_posError(0)) > 0.08) ||
3: -        (fabs(_posError(1)) > 0.08) ||
3: -        (fabs(_velError(0)) > 0.05) ||
3: -        (fabs(_velError(1)) > 0.05) ||
3: -        (fabs(_dYawCmd) > 0.20) ){
3: -        return true;
3: -    }else{
3: -        return false;
3: -    }
3: -}
3: -
3: -void State_Trotting::setHighCmd(double vx, double vy, double wz){
3: -    _vCmdBody(0) = vx;
3: -    _vCmdBody(1) = vy;
3: -    _vCmdBody(2) = 0; 
3: -    _dYawCmd = wz;
3: -}
3: -
3: -void State_Trotting::getUserCmd(){
3: -    /* Movement */
3: -    _vCmdBody(0) =  invNormalize(_userValue.ly, _vxLim(0), _vxLim(1));
3: -    _vCmdBody(1) = -invNormalize(_userValue.lx, _vyLim(0), _vyLim(1));
3: -    _vCmdBody(2) = 0;
3: -
3: -    /* Turning */
3: -    _dYawCmd = -invNormalize(_userValue.rx, _wyawLim(0), _wyawLim(1));
3: -    _dYawCmd = 0.9*_dYawCmdPast + (1-0.9) * _dYawCmd;
3: -    _dYawCmdPast = _dYawCmd;
3: -}
3: -
3: -void State_Trotting::calcCmd(){
3: -    /* Movement */
3: -    _vCmdGlobal = _B2G_RotMat * _vCmdBody;
3: -
3: -    _vCmdGlobal(0) = saturation(_vCmdGlobal(0), Vec2(_velBody(0)-0.2, _velBody(0)+0.2));
3: -    _vCmdGlobal(1) = saturation(_vCmdGlobal(1), Vec2(_velBody(1)-0.2, _velBody(1)+0.2));
3: -
3: -    _pcd(0) = saturation(_pcd(0) + _vCmdGlobal(0) * _ctrlComp->dt, Vec2(_posBody(0) - 0.05, _posBody(0) + 0.05));
3: -    _pcd(1) = saturation(_pcd(1) + _vCmdGlobal(1) * _ctrlComp->dt, Vec2(_posBody(1) - 0.05, _posBody(1) + 0.05));
3: -
3: -    _vCmdGlobal(2) = 0;
3: -
3: -    /* Turning */
3: -    _yawCmd = _yawCmd + _dYawCmd * _ctrlComp->dt;
3: -
3: -    _Rd = rotz(_yawCmd);
3: -    _wCmdGlobal(2) = _dYawCmd;
3: -}
3: -
3: -void State_Trotting::calcTau(){
3: -    _posError = _pcd - _posBody;
3: -    _velError = _vCmdGlobal - _velBody;
3: -
3: -    _ddPcd = _Kpp * _posError + _Kdp * _velError;
3: -    _dWbd  = _kpw*rotMatToExp(_Rd*_G2B_RotMat) + _Kdw * (_wCmdGlobal - _lowState->getGyroGlobal());
3: -
3: -    _ddPcd(0) = saturation(_ddPcd(0), Vec2(-3, 3));
3: -    _ddPcd(1) = saturation(_ddPcd(1), Vec2(-3, 3));
3: -    _ddPcd(2) = saturation(_ddPcd(2), Vec2(-5, 5));
3: -
3: -    _dWbd(0) = saturation(_dWbd(0), Vec2(-40, 40));
3: -    _dWbd(1) = saturation(_dWbd(1), Vec2(-40, 40));
3: -    _dWbd(2) = saturation(_dWbd(2), Vec2(-10, 10));
3: -
3: -    _forceFeetGlobal = - _balCtrl->calF(_ddPcd, _dWbd, _B2G_RotMat, _posFeet2BGlobal, *_contact);
3: -
3: -    for(int i(0); i<4; ++i){
3: -        if((*_contact)(i) == 0){
3: -            _forceFeetGlobal.col(i) = _KpSwing*(_posFeetGlobalGoal.col(i) - _posFeetGlobal.col(i)) + _KdSwing*(_velFeetGlobalGoal.col(i)-_velFeetGlobal.col(i));
3: -        }
3: -    }
3: -
3: -    _forceFeetBody = _G2B_RotMat * _forceFeetGlobal;
3: -    _q = vec34ToVec12(_lowState->getQ());
3: -    _tau = _robModel->getTau(_q, _forceFeetBody);
3: -}
3: -
3: -void State_Trotting::calcQQd(){
3: -
3: -    Vec34 _posFeet2B;
3: -    _posFeet2B = _robModel->getFeet2BPositions(*_lowState,FrameType::BODY);
3: -    
3: -    for(int i(0); i<4; ++i){
3: -        _posFeet2BGoal.col(i) = _G2B_RotMat * (_posFeetGlobalGoal.col(i) - _posBody);
3: -        _velFeet2BGoal.col(i) = _G2B_RotMat * (_velFeetGlobalGoal.col(i) - _velBody); 
3: -        // _velFeet2BGoal.col(i) = _G2B_RotMat * (_velFeetGlobalGoal.col(i) - _velBody - _B2G_RotMat * (skew(_lowState->getGyro()) * _posFeet2B.col(i)) );  //  c.f formula (6.12) 
3: -    }
3: -    
3: -    _qGoal = vec12ToVec34(_robModel->getQ(_posFeet2BGoal, FrameType::BODY));
3: -    _qdGoal = vec12ToVec34(_robModel->getQd(_posFeet2B, _velFeet2BGoal, FrameType::BODY));
3: -}
3: -
3: +  }
3: +
3: +  _forceFeetBody = _G2B_RotMat * _forceFeetGlobal;
3: +  _q = vec34ToVec12(_lowState->getQ());
3: +  _tau = _robModel->getTau(_q, _forceFeetBody);
3: +}
3: +
3: +void State_Trotting::calcQQd()
3: +{
3: +
3: +  Vec34 _posFeet2B;
3: +  _posFeet2B = _robModel->getFeet2BPositions(*_lowState, FrameType::BODY);
3: +
3: +  for (int i(0); i < 4; ++i) {
3: +    _posFeet2BGoal.col(i) = _G2B_RotMat * (_posFeetGlobalGoal.col(i) - _posBody);
3: +    _velFeet2BGoal.col(i) = _G2B_RotMat * (_velFeetGlobalGoal.col(i) - _velBody);
3: +    // _velFeet2BGoal.col(i) = _G2B_RotMat * (_velFeetGlobalGoal.col(i) - _velBody - _B2G_RotMat * (skew(_lowState->getGyro()) * _posFeet2B.col(i)) );  //  c.f formula (6.12)
3: +  }
3: +
3: +  _qGoal = vec12ToVec34(_robModel->getQ(_posFeet2BGoal, FrameType::BODY));
3: +  _qdGoal = vec12ToVec34(_robModel->getQd(_posFeet2B, _velFeet2BGoal, FrameType::BODY));
3: +}
3: 
3: Code style divergence in file 'src/FSM/State_move_base.cpp':
3: 
3: --- src/FSM/State_move_base.cpp
3: +++ src/FSM/State_move_base.cpp.uncrustify
3: @@ -8,6 +8,7 @@
3: -State_move_base::State_move_base(CtrlComponents *ctrlComp)
3: -    :State_Trotting(ctrlComp){
3: -    _stateName = FSMStateName::MOVE_BASE;
3: -    _stateNameString = "move_base";
3: -    initRecv();
3: -    
3: +State_move_base::State_move_base(CtrlComponents * ctrlComp)
3: +: State_Trotting(ctrlComp)
3: +{
3: +  _stateName = FSMStateName::MOVE_BASE;
3: +  _stateNameString = "move_base";
3: +  initRecv();
3: +
3: @@ -16,10 +17,9 @@
3: -FSMStateName State_move_base::checkChange(){
3: -    if(_lowState->userCmd == UserCommand::L2_B){
3: -        return FSMStateName::PASSIVE;
3: -    }
3: -    else if(_lowState->userCmd == UserCommand::L2_A){
3: -        return FSMStateName::FIXEDSTAND;
3: -    }
3: -    else{
3: -        return FSMStateName::MOVE_BASE;
3: -    }
3: +FSMStateName State_move_base::checkChange()
3: +{
3: +  if (_lowState->userCmd == UserCommand::L2_B) {
3: +    return FSMStateName::PASSIVE;
3: +  } else if (_lowState->userCmd == UserCommand::L2_A) {
3: +    return FSMStateName::FIXEDSTAND;
3: +  } else {
3: +    return FSMStateName::MOVE_BASE;
3: +  }
3: @@ -28,3 +28,4 @@
3: -void State_move_base::getUserCmd(){
3: -    setHighCmd(_vx, _vy, _wz);
3: -    ros::spinOnce();
3: +void State_move_base::getUserCmd()
3: +{
3: +  setHighCmd(_vx, _vy, _wz);
3: +  ros::spinOnce();
3: @@ -33,4 +34,5 @@
3: -void State_move_base::twistCallback(const geometry_msgs::Twist& msg){
3: -    _vx = msg.linear.x;
3: -    _vy = msg.linear.y;
3: -    _wz = msg.angular.z;
3: +void State_move_base::twistCallback(const geometry_msgs::Twist & msg)
3: +{
3: +  _vx = msg.linear.x;
3: +  _vy = msg.linear.y;
3: +  _wz = msg.angular.z;
3: @@ -39,2 +41,3 @@
3: -void State_move_base::initRecv(){
3: -    _cmdSub = _nm.subscribe("/cmd_vel", 1, &State_move_base::twistCallback, this);
3: +void State_move_base::initRecv()
3: +{
3: +  _cmdSub = _nm.subscribe("/cmd_vel", 1, &State_move_base::twistCallback, this);
3: @@ -49,11 +52,13 @@
3: -State_move_base::State_move_base(CtrlComponents *ctrlComp)
3: -    :State_Trotting(ctrlComp){
3: -    _stateName = FSMStateName::MOVE_BASE;
3: -    _stateNameString = "move_base";
3: -    _nm = rclcpp::Node::make_shared("state_mb");
3: -    auto executor = std::make_shared<rclcpp::executors::MultiThreadedExecutor>(
3: -        rclcpp::ExecutorOptions(), 1
3: -    );
3: -    executor->add_node(_nm);
3: -    executor_thread = std::thread([executor] (){
3: -        executor->spin();
3: +State_move_base::State_move_base(CtrlComponents * ctrlComp)
3: +: State_Trotting(ctrlComp)
3: +{
3: +  _stateName = FSMStateName::MOVE_BASE;
3: +  _stateNameString = "move_base";
3: +  _nm = rclcpp::Node::make_shared("state_mb");
3: +  auto executor = std::make_shared<rclcpp::executors::MultiThreadedExecutor>(
3: +    rclcpp::ExecutorOptions(), 1
3: +  );
3: +  executor->add_node(_nm);
3: +  executor_thread = std::thread(
3: +    [executor]() {
3: +      executor->spin();
3: @@ -61,2 +66,2 @@
3: -    executor_thread.detach();
3: -    initRecv();
3: +  executor_thread.detach();
3: +  initRecv();
3: @@ -65,10 +70,9 @@
3: -FSMStateName State_move_base::checkChange(){
3: -    if(_lowState->userCmd == UserCommand::L2_B){
3: -        return FSMStateName::PASSIVE;
3: -    }
3: -    else if(_lowState->userCmd == UserCommand::L2_A){
3: -        return FSMStateName::FIXEDSTAND;
3: -    }
3: -    else{
3: -        return FSMStateName::MOVE_BASE;
3: -    }
3: +FSMStateName State_move_base::checkChange()
3: +{
3: +  if (_lowState->userCmd == UserCommand::L2_B) {
3: +    return FSMStateName::PASSIVE;
3: +  } else if (_lowState->userCmd == UserCommand::L2_A) {
3: +    return FSMStateName::FIXEDSTAND;
3: +  } else {
3: +    return FSMStateName::MOVE_BASE;
3: +  }
3: @@ -77,2 +81,3 @@
3: -void State_move_base::getUserCmd(){
3: -    setHighCmd(_vx, _vy, _wz);
3: +void State_move_base::getUserCmd()
3: +{
3: +  setHighCmd(_vx, _vy, _wz);
3: @@ -81,4 +86,5 @@
3: -void State_move_base::twistCallback(const geometry_msgs::msg::Twist::SharedPtr msg){
3: -    _vx = msg->linear.x;
3: -    _vy = msg->linear.y;
3: -    _wz = msg->angular.z;
3: +void State_move_base::twistCallback(const geometry_msgs::msg::Twist::SharedPtr msg)
3: +{
3: +  _vx = msg->linear.x;
3: +  _vy = msg->linear.y;
3: +  _wz = msg->angular.z;
3: @@ -87,3 +93,7 @@
3: -void State_move_base::initRecv(){
3: -    std::cout << "Initialized cmd vel sub" << std::endl;
3: -    _cmdSub = _nm->create_subscription<geometry_msgs::msg::Twist>("/cmd_vel", 1, std::bind(&State_move_base::twistCallback, this, std::placeholders::_1));
3: +void State_move_base::initRecv()
3: +{
3: +  std::cout << "Initialized cmd vel sub" << std::endl;
3: +  _cmdSub =
3: +    _nm->create_subscription<geometry_msgs::msg::Twist>(
3: +    "/cmd_vel", 1,
3: +    std::bind(&State_move_base::twistCallback, this, std::placeholders::_1));
3: @@ -92 +102 @@
3: -#endif  // COMPILE_WITH_ROS2_MB
3: +#endif  // COMPILE_WITH_ROS2_MB
3: 
3: Code style divergence in file 'src/Gait/FeetEndCal.cpp':
3: 
3: --- src/Gait/FeetEndCal.cpp
3: +++ src/Gait/FeetEndCal.cpp.uncrustify
3: @@ -6,5 +6,6 @@
3: -FeetEndCal::FeetEndCal(CtrlComponents *ctrlComp)
3: -           : _est(ctrlComp->estimator), _lowState(ctrlComp->lowState),
3: -             _robModel(ctrlComp->robotModel){
3: -    _Tstance  = ctrlComp->waveGen->getTstance();
3: -    _Tswing   = ctrlComp->waveGen->getTswing();
3: +FeetEndCal::FeetEndCal(CtrlComponents * ctrlComp)
3: +: _est(ctrlComp->estimator), _lowState(ctrlComp->lowState),
3: +  _robModel(ctrlComp->robotModel)
3: +{
3: +  _Tstance = ctrlComp->waveGen->getTstance();
3: +  _Tswing = ctrlComp->waveGen->getTswing();
3: @@ -12,3 +13,3 @@
3: -    _kx = 0.005;
3: -    _ky = 0.005;
3: -    _kyaw = 0.005;
3: +  _kx = 0.005;
3: +  _ky = 0.005;
3: +  _kyaw = 0.005;
3: @@ -16,5 +17,5 @@
3: -    Vec34 feetPosBody = _robModel->getFeetPosIdeal();
3: -    for(int i(0); i<4; ++i){
3: -        _feetRadius(i)    = sqrt( pow(feetPosBody(0, i), 2) + pow(feetPosBody(1, i), 2) );
3: -        _feetInitAngle(i) = atan2(feetPosBody(1, i), feetPosBody(0, i));
3: -    }
3: +  Vec34 feetPosBody = _robModel->getFeetPosIdeal();
3: +  for (int i(0); i < 4; ++i) {
3: +    _feetRadius(i) = sqrt(pow(feetPosBody(0, i), 2) + pow(feetPosBody(1, i), 2) );
3: +    _feetInitAngle(i) = atan2(feetPosBody(1, i), feetPosBody(0, i));
3: +  }
3: @@ -23 +24,2 @@
3: -FeetEndCal::~FeetEndCal(){
3: +FeetEndCal::~FeetEndCal()
3: +{
3: @@ -27,3 +29,4 @@
3: -Vec3 FeetEndCal::calFootPos(int legID, Vec2 vxyGoalGlobal, float dYawGoal, float phase){
3: -    _bodyVelGlobal = _est->getVelocity();
3: -    _bodyWGlobal = _lowState->getGyroGlobal();
3: +Vec3 FeetEndCal::calFootPos(int legID, Vec2 vxyGoalGlobal, float dYawGoal, float phase)
3: +{
3: +  _bodyVelGlobal = _est->getVelocity();
3: +  _bodyWGlobal = _lowState->getGyroGlobal();
3: @@ -31,3 +34,5 @@
3: -    _nextStep(0) = _bodyVelGlobal(0)*(1-phase)*_Tswing + _bodyVelGlobal(0)*_Tstance/2 + _kx*(_bodyVelGlobal(0) - vxyGoalGlobal(0));
3: -    _nextStep(1) = _bodyVelGlobal(1)*(1-phase)*_Tswing + _bodyVelGlobal(1)*_Tstance/2 + _ky*(_bodyVelGlobal(1) - vxyGoalGlobal(1));
3: -    _nextStep(2) = 0;
3: +  _nextStep(0) = _bodyVelGlobal(0) * (1 - phase) * _Tswing + _bodyVelGlobal(0) * _Tstance / 2 +
3: +    _kx * (_bodyVelGlobal(0) - vxyGoalGlobal(0));
3: +  _nextStep(1) = _bodyVelGlobal(1) * (1 - phase) * _Tswing + _bodyVelGlobal(1) * _Tstance / 2 +
3: +    _ky * (_bodyVelGlobal(1) - vxyGoalGlobal(1));
3: +  _nextStep(2) = 0;
3: @@ -35,3 +40,3 @@
3: -    _yaw = _lowState->getYaw();
3: -    _dYaw = _lowState->getDYaw();
3: -    _nextYaw = _dYaw*(1-phase)*_Tswing + _dYaw*_Tstance/2 + _kyaw*(dYawGoal - _dYaw);
3: +  _yaw = _lowState->getYaw();
3: +  _dYaw = _lowState->getDYaw();
3: +  _nextYaw = _dYaw * (1 - phase) * _Tswing + _dYaw * _Tstance / 2 + _kyaw * (dYawGoal - _dYaw);
3: @@ -39,2 +44,2 @@
3: -    _nextStep(0) += _feetRadius(legID) * cos(_yaw + _feetInitAngle(legID) + _nextYaw);
3: -    _nextStep(1) += _feetRadius(legID) * sin(_yaw + _feetInitAngle(legID) + _nextYaw);
3: +  _nextStep(0) += _feetRadius(legID) * cos(_yaw + _feetInitAngle(legID) + _nextYaw);
3: +  _nextStep(1) += _feetRadius(legID) * sin(_yaw + _feetInitAngle(legID) + _nextYaw);
3: @@ -42,2 +47,2 @@
3: -    _footPos = _est->getPosition() + _nextStep;
3: -    _footPos(2) = 0.0;
3: +  _footPos = _est->getPosition() + _nextStep;
3: +  _footPos(2) = 0.0;
3: @@ -45,2 +50,2 @@
3: -    return _footPos;
3: -}
3: +  return _footPos;
3: +}
3: 
3: Code style divergence in file 'src/Gait/GaitGenerator.cpp':
3: 
3: --- src/Gait/GaitGenerator.cpp
3: +++ src/Gait/GaitGenerator.cpp.uncrustify
3: @@ -6,6 +6,7 @@
3: -GaitGenerator::GaitGenerator(CtrlComponents *ctrlComp)
3: -              : _waveG(ctrlComp->waveGen), _est(ctrlComp->estimator), 
3: -                _phase(ctrlComp->phase), _contact(ctrlComp->contact), 
3: -                _robModel(ctrlComp->robotModel), _state(ctrlComp->lowState){
3: -    _feetCal = new FeetEndCal(ctrlComp);
3: -    _firstRun = true;
3: +GaitGenerator::GaitGenerator(CtrlComponents * ctrlComp)
3: +: _waveG(ctrlComp->waveGen), _est(ctrlComp->estimator),
3: +  _phase(ctrlComp->phase), _contact(ctrlComp->contact),
3: +  _robModel(ctrlComp->robotModel), _state(ctrlComp->lowState)
3: +{
3: +  _feetCal = new FeetEndCal(ctrlComp);
3: +  _firstRun = true;
3: @@ -14 +15,2 @@
3: -GaitGenerator::~GaitGenerator(){
3: +GaitGenerator::~GaitGenerator()
3: +{
3: @@ -17,4 +19,5 @@
3: -void GaitGenerator::setGait(Vec2 vxyGoalGlobal, float dYawGoal, float gaitHeight){
3: -    _vxyGoal = vxyGoalGlobal;
3: -    _dYawGoal = dYawGoal;
3: -    _gaitHeight = gaitHeight;
3: +void GaitGenerator::setGait(Vec2 vxyGoalGlobal, float dYawGoal, float gaitHeight)
3: +{
3: +  _vxyGoal = vxyGoalGlobal;
3: +  _dYawGoal = dYawGoal;
3: +  _gaitHeight = gaitHeight;
3: @@ -23,3 +26,4 @@
3: -void GaitGenerator::restart(){
3: -    _firstRun = true;
3: -    _vxyGoal.setZero();
3: +void GaitGenerator::restart()
3: +{
3: +  _firstRun = true;
3: +  _vxyGoal.setZero();
3: @@ -28,4 +32,19 @@
3: -void GaitGenerator::run(Vec34 &feetPos, Vec34 &feetVel){
3: -    if(_firstRun){
3: -        _startP = _est->getFeetPos();
3: -        _firstRun = false;
3: +void GaitGenerator::run(Vec34 & feetPos, Vec34 & feetVel)
3: +{
3: +  if (_firstRun) {
3: +    _startP = _est->getFeetPos();
3: +    _firstRun = false;
3: +  }
3: +
3: +  for (int i(0); i < 4; ++i) {
3: +    if ((*_contact)(i) == 1) {
3: +      if ((*_phase)(i) < 0.5) {
3: +        _startP.col(i) = _est->getFootPos(i);
3: +      }
3: +      feetPos.col(i) = _startP.col(i);
3: +      feetVel.col(i).setZero();
3: +    } else {
3: +      _endP.col(i) = _feetCal->calFootPos(i, _vxyGoal, _dYawGoal, (*_phase)(i));
3: +
3: +      feetPos.col(i) = getFootPos(i);
3: +      feetVel.col(i) = getFootVel(i);
3: @@ -33,18 +52,3 @@
3: -
3: -    for(int i(0); i<4; ++i){
3: -        if((*_contact)(i) == 1){
3: -            if((*_phase)(i) < 0.5){
3: -                _startP.col(i) = _est->getFootPos(i);
3: -            }
3: -            feetPos.col(i) = _startP.col(i);
3: -            feetVel.col(i).setZero();
3: -        }
3: -        else{
3: -            _endP.col(i) = _feetCal->calFootPos(i, _vxyGoal, _dYawGoal, (*_phase)(i));
3: -
3: -            feetPos.col(i) = getFootPos(i);
3: -            feetVel.col(i) = getFootVel(i);
3: -        }
3: -    }
3: -    _pastP = feetPos;
3: -    _phasePast = *_phase;
3: +  }
3: +  _pastP = feetPos;
3: +  _phasePast = *_phase;
3: @@ -53,2 +57,3 @@
3: -Vec3 GaitGenerator::getFootPos(int i){
3: -    Vec3 footPos;
3: +Vec3 GaitGenerator::getFootPos(int i)
3: +{
3: +  Vec3 footPos;
3: @@ -56,5 +61,5 @@
3: -    footPos(0) = cycloidXYPosition(_startP.col(i)(0), _endP.col(i)(0), (*_phase)(i));
3: -    footPos(1) = cycloidXYPosition(_startP.col(i)(1), _endP.col(i)(1), (*_phase)(i));
3: -    footPos(2) =  cycloidZPosition(_startP.col(i)(2), _gaitHeight, (*_phase)(i));
3: -    
3: -    return footPos;
3: +  footPos(0) = cycloidXYPosition(_startP.col(i)(0), _endP.col(i)(0), (*_phase)(i));
3: +  footPos(1) = cycloidXYPosition(_startP.col(i)(1), _endP.col(i)(1), (*_phase)(i));
3: +  footPos(2) = cycloidZPosition(_startP.col(i)(2), _gaitHeight, (*_phase)(i));
3: +
3: +  return footPos;
3: @@ -63,2 +68,3 @@
3: -Vec3 GaitGenerator::getFootVel(int i){
3: -    Vec3 footVel;
3: +Vec3 GaitGenerator::getFootVel(int i)
3: +{
3: +  Vec3 footVel;
3: @@ -66,3 +72,3 @@
3: -    footVel(0) = cycloidXYVelocity(_startP.col(i)(0), _endP.col(i)(0), (*_phase)(i));
3: -    footVel(1) = cycloidXYVelocity(_startP.col(i)(1), _endP.col(i)(1), (*_phase)(i));
3: -    footVel(2) =  cycloidZVelocity(_gaitHeight, (*_phase)(i));
3: +  footVel(0) = cycloidXYVelocity(_startP.col(i)(0), _endP.col(i)(0), (*_phase)(i));
3: +  footVel(1) = cycloidXYVelocity(_startP.col(i)(1), _endP.col(i)(1), (*_phase)(i));
3: +  footVel(2) = cycloidZVelocity(_gaitHeight, (*_phase)(i));
3: @@ -70 +76 @@
3: -    return footVel;
3: +  return footVel;
3: @@ -73,3 +79,4 @@
3: -float GaitGenerator::cycloidXYPosition(float start, float end, float phase){
3: -    float phasePI = 2 * M_PI * phase;
3: -    return (end - start)*(phasePI - sin(phasePI))/(2*M_PI) + start;
3: +float GaitGenerator::cycloidXYPosition(float start, float end, float phase)
3: +{
3: +  float phasePI = 2 * M_PI * phase;
3: +  return (end - start) * (phasePI - sin(phasePI)) / (2 * M_PI) + start;
3: @@ -78,3 +85,4 @@
3: -float GaitGenerator::cycloidXYVelocity(float start, float end, float phase){
3: -    float phasePI = 2 * M_PI * phase;
3: -    return (end - start)*(1 - cos(phasePI)) / _waveG->getTswing();
3: +float GaitGenerator::cycloidXYVelocity(float start, float end, float phase)
3: +{
3: +  float phasePI = 2 * M_PI * phase;
3: +  return (end - start) * (1 - cos(phasePI)) / _waveG->getTswing();
3: @@ -83,3 +91,4 @@
3: -float GaitGenerator::cycloidZPosition(float start, float h, float phase){
3: -    float phasePI = 2 * M_PI * phase;
3: -    return h*(1 - cos(phasePI))/2 + start;
3: +float GaitGenerator::cycloidZPosition(float start, float h, float phase)
3: +{
3: +  float phasePI = 2 * M_PI * phase;
3: +  return h * (1 - cos(phasePI)) / 2 + start;
3: @@ -88,4 +97,5 @@
3: -float GaitGenerator::cycloidZVelocity(float h, float phase){
3: -    float phasePI = 2 * M_PI * phase;
3: -    return h*M_PI * sin(phasePI) / _waveG->getTswing();
3: -}
3: +float GaitGenerator::cycloidZVelocity(float h, float phase)
3: +{
3: +  float phasePI = 2 * M_PI * phase;
3: +  return h * M_PI * sin(phasePI) / _waveG->getTswing();
3: +}
3: 
3: Code style divergence in file 'src/Gait/WaveGenerator.cpp':
3: 
3: --- src/Gait/WaveGenerator.cpp
3: +++ src/Gait/WaveGenerator.cpp.uncrustify
3: @@ -10 +10 @@
3: -    : _period(period), _stRatio(stancePhaseRatio), _bias(bias)
3: +: _period(period), _stRatio(stancePhaseRatio), _bias(bias)
3: @@ -13,4 +13,9 @@
3: -    if ((_stRatio >= 1) || (_stRatio <= 0))
3: -    {
3: -        std::cout << "[ERROR] The stancePhaseRatio of WaveGenerator should between (0, 1)" << std::endl;
3: -        exit(-1);
3: +  if ((_stRatio >= 1) || (_stRatio <= 0)) {
3: +    std::cout << "[ERROR] The stancePhaseRatio of WaveGenerator should between (0, 1)" << std::endl;
3: +    exit(-1);
3: +  }
3: +
3: +  for (int i(0); i < bias.rows(); ++i) {
3: +    if ((bias(i) > 1) || (bias(i) < 0)) {
3: +      std::cout << "[ERROR] The bias of WaveGenerator should between [0, 1]" << std::endl;
3: +      exit(-1);
3: @@ -17,0 +23 @@
3: +  }
3: @@ -19,13 +25,4 @@
3: -    for (int i(0); i < bias.rows(); ++i)
3: -    {
3: -        if ((bias(i) > 1) || (bias(i) < 0))
3: -        {
3: -            std::cout << "[ERROR] The bias of WaveGenerator should between [0, 1]" << std::endl;
3: -            exit(-1);
3: -        }
3: -    }
3: -
3: -    _startT = getSystemTime();
3: -    _contactPast.setZero();
3: -    _phasePast << 0.5, 0.5, 0.5, 0.5;
3: -    _statusPast = WaveStatus::SWING_ALL;
3: +  _startT = getSystemTime();
3: +  _contactPast.setZero();
3: +  _phasePast << 0.5, 0.5, 0.5, 0.5;
3: +  _statusPast = WaveStatus::SWING_ALL;
3: @@ -38 +35 @@
3: -void WaveGenerator::calcContactPhase(Vec4 &phaseResult, VecInt4 &contactResult, WaveStatus status)
3: +void WaveGenerator::calcContactPhase(Vec4 & phaseResult, VecInt4 & contactResult, WaveStatus status)
3: @@ -41 +38 @@
3: -    calcWave(_phase, _contact, status);
3: +  calcWave(_phase, _contact, status);
3: @@ -43,16 +40,3 @@
3: -    if (status != _statusPast)
3: -    {
3: -        if (_switchStatus.sum() == 0)
3: -        {
3: -            _switchStatus.setOnes();
3: -        }
3: -        calcWave(_phasePast, _contactPast, _statusPast);
3: -        // two special case
3: -        if ((status == WaveStatus::STANCE_ALL) && (_statusPast == WaveStatus::SWING_ALL))
3: -        {
3: -            _contactPast.setOnes();
3: -        }
3: -        else if ((status == WaveStatus::SWING_ALL) && (_statusPast == WaveStatus::STANCE_ALL))
3: -        {
3: -            _contactPast.setZero();
3: -        }
3: +  if (status != _statusPast) {
3: +    if (_switchStatus.sum() == 0) {
3: +      _switchStatus.setOnes();
3: @@ -59,0 +44,8 @@
3: +    calcWave(_phasePast, _contactPast, _statusPast);
3: +    // two special case
3: +    if ((status == WaveStatus::STANCE_ALL) && (_statusPast == WaveStatus::SWING_ALL)) {
3: +      _contactPast.setOnes();
3: +    } else if ((status == WaveStatus::SWING_ALL) && (_statusPast == WaveStatus::STANCE_ALL)) {
3: +      _contactPast.setZero();
3: +    }
3: +  }
3: @@ -61,18 +53,8 @@
3: -    if (_switchStatus.sum() != 0)
3: -    {
3: -        for (int i(0); i < 4; ++i)
3: -        {
3: -            if (_contact(i) == _contactPast(i))
3: -            {
3: -                _switchStatus(i) = 0;
3: -            }
3: -            else
3: -            {
3: -                _contact(i) = _contactPast(i);
3: -                _phase(i) = _phasePast(i);
3: -            }
3: -        }
3: -        if (_switchStatus.sum() == 0)
3: -        {
3: -            _statusPast = status;
3: -        }
3: +  if (_switchStatus.sum() != 0) {
3: +    for (int i(0); i < 4; ++i) {
3: +      if (_contact(i) == _contactPast(i)) {
3: +        _switchStatus(i) = 0;
3: +      } else {
3: +        _contact(i) = _contactPast(i);
3: +        _phase(i) = _phasePast(i);
3: +      }
3: @@ -79,0 +62,4 @@
3: +    if (_switchStatus.sum() == 0) {
3: +      _statusPast = status;
3: +    }
3: +  }
3: @@ -81,2 +67,2 @@
3: -    phaseResult = _phase;
3: -    contactResult = _contact;
3: +  phaseResult = _phase;
3: +  contactResult = _contact;
3: @@ -87 +73 @@
3: -    return _period * _stRatio;
3: +  return _period * _stRatio;
3: @@ -92 +78 @@
3: -    return _period * (1 - _stRatio);
3: +  return _period * (1 - _stRatio);
3: @@ -97 +83 @@
3: -    return _period;
3: +  return _period;
3: @@ -100 +86 @@
3: -void WaveGenerator::calcWave(Vec4 &phase, VecInt4 &contact, WaveStatus status)
3: +void WaveGenerator::calcWave(Vec4 & phase, VecInt4 & contact, WaveStatus status)
3: @@ -102,17 +88,11 @@
3: -    if (status == WaveStatus::WAVE_ALL)
3: -    {
3: -        _passT = (double)(getSystemTime() - _startT) * 1e-6;
3: -        for (int i(0); i < 4; ++i)
3: -        {
3: -            _normalT(i) = fmod(_passT + _period - _period * _bias(i), _period) / _period;
3: -            if (_normalT(i) < _stRatio)
3: -            {
3: -                contact(i) = 1;
3: -                phase(i) = _normalT(i) / _stRatio;
3: -            }
3: -            else
3: -            {
3: -                contact(i) = 0;
3: -                phase(i) = (_normalT(i) - _stRatio) / (1 - _stRatio);
3: -            }
3: -        }
3: +  if (status == WaveStatus::WAVE_ALL) {
3: +    _passT = (double)(getSystemTime() - _startT) * 1e-6;
3: +    for (int i(0); i < 4; ++i) {
3: +      _normalT(i) = fmod(_passT + _period - _period * _bias(i), _period) / _period;
3: +      if (_normalT(i) < _stRatio) {
3: +        contact(i) = 1;
3: +        phase(i) = _normalT(i) / _stRatio;
3: +      } else {
3: +        contact(i) = 0;
3: +        phase(i) = (_normalT(i) - _stRatio) / (1 - _stRatio);
3: +      }
3: @@ -120,11 +100,8 @@
3: -    else if (status == WaveStatus::SWING_ALL)
3: -    {
3: -        contact.setZero();
3: -        phase << 0.5, 0.5, 0.5, 0.5;
3: -    }
3: -    else if (status == WaveStatus::STANCE_ALL)
3: -    {
3: -        contact.setOnes();
3: -        phase << 0.5, 0.5, 0.5, 0.5;
3: -    }
3: -}
3: +  } else if (status == WaveStatus::SWING_ALL) {
3: +    contact.setZero();
3: +    phase << 0.5, 0.5, 0.5, 0.5;
3: +  } else if (status == WaveStatus::STANCE_ALL) {
3: +    contact.setOnes();
3: +    phase << 0.5, 0.5, 0.5, 0.5;
3: +  }
3: +}
3: 
3: Code style divergence in file 'src/common/LowPassFilter.cpp':
3: 
3: --- src/common/LowPassFilter.cpp
3: +++ src/common/LowPassFilter.cpp.uncrustify
3: @@ -7,3 +7,4 @@
3: -LPFilter::LPFilter(double samplePeriod, double cutFrequency){
3: -    _weight = 1.0 / ( 1.0 + 1.0/(2.0*M_PI * samplePeriod * cutFrequency) );
3: -    _start  = false;
3: +LPFilter::LPFilter(double samplePeriod, double cutFrequency)
3: +{
3: +  _weight = 1.0 / ( 1.0 + 1.0 / (2.0 * M_PI * samplePeriod * cutFrequency) );
3: +  _start = false;
3: @@ -12,6 +13,7 @@
3: -void LPFilter::addValue(double newValue){
3: -    if(!_start){
3: -        _start = true;
3: -        _pastValue = newValue;
3: -    }
3: -    _pastValue = _weight*newValue + (1-_weight)*_pastValue;
3: +void LPFilter::addValue(double newValue)
3: +{
3: +  if (!_start) {
3: +    _start = true;
3: +    _pastValue = newValue;
3: +  }
3: +  _pastValue = _weight * newValue + (1 - _weight) * _pastValue;
3: @@ -20,2 +22,3 @@
3: -double LPFilter::getValue(){
3: -    return _pastValue;
3: +double LPFilter::getValue()
3: +{
3: +  return _pastValue;
3: @@ -24,3 +27,4 @@
3: -void LPFilter::clear(){
3: -    _start = false;
3: -}
3: +void LPFilter::clear()
3: +{
3: +  _start = false;
3: +}
3: 
3: Code style divergence in file 'src/common/unitreeLeg.cpp':
3: 
3: --- src/common/unitreeLeg.cpp
3: +++ src/common/unitreeLeg.cpp.uncrustify
3: @@ -11,14 +11,16 @@
3: -QuadrupedLeg::QuadrupedLeg(int legID, float abadLinkLength, float hipLinkLength, 
3: -                           float kneeLinkLength, Vec3 pHip2B)
3: -            :_abadLinkLength(abadLinkLength), 
3: -             _hipLinkLength(hipLinkLength), 
3: -             _kneeLinkLength(kneeLinkLength), 
3: -             _pHip2B(pHip2B){
3: -    if (legID == 0 || legID == 2)
3: -        _sideSign = -1;
3: -    else if (legID == 1 || legID == 3)
3: -        _sideSign = 1;
3: -    else{
3: -        std::cout << "Leg ID incorrect!" << std::endl;
3: -        exit(-1);
3: -    }
3: +QuadrupedLeg::QuadrupedLeg(
3: +  int legID, float abadLinkLength, float hipLinkLength,
3: +  float kneeLinkLength, Vec3 pHip2B)
3: +: _abadLinkLength(abadLinkLength),
3: +  _hipLinkLength(hipLinkLength),
3: +  _kneeLinkLength(kneeLinkLength),
3: +  _pHip2B(pHip2B)
3: +{
3: +  if (legID == 0 || legID == 2) {
3: +    _sideSign = -1;
3: +  } else if (legID == 1 || legID == 3) {
3: +    _sideSign = 1;
3: +  } else {
3: +    std::cout << "Leg ID incorrect!" << std::endl;
3: +    exit(-1);
3: +  }
3: @@ -28,4 +30,5 @@
3: -Vec3 QuadrupedLeg::calcPEe2H(Vec3 q){
3: -    float l1 = _sideSign * _abadLinkLength;
3: -    float l2 = -_hipLinkLength;
3: -    float l3 = -_kneeLinkLength;
3: +Vec3 QuadrupedLeg::calcPEe2H(Vec3 q)
3: +{
3: +  float l1 = _sideSign * _abadLinkLength;
3: +  float l2 = -_hipLinkLength;
3: +  float l3 = -_kneeLinkLength;
3: @@ -33,3 +36,3 @@
3: -    float s1 = std::sin(q(0));
3: -    float s2 = std::sin(q(1));
3: -    float s3 = std::sin(q(2));
3: +  float s1 = std::sin(q(0));
3: +  float s2 = std::sin(q(1));
3: +  float s3 = std::sin(q(2));
3: @@ -37,3 +40,3 @@
3: -    float c1 = std::cos(q(0));
3: -    float c2 = std::cos(q(1));
3: -    float c3 = std::cos(q(2));
3: +  float c1 = std::cos(q(0));
3: +  float c2 = std::cos(q(1));
3: +  float c3 = std::cos(q(2));
3: @@ -41,2 +44,2 @@
3: -    float c23 = c2 * c3 - s2 * s3;
3: -    float s23 = s2 * c3 + c2 * s3;
3: +  float c23 = c2 * c3 - s2 * s3;
3: +  float s23 = s2 * c3 + c2 * s3;
3: @@ -44 +47 @@
3: -    Vec3 pEe2H;
3: +  Vec3 pEe2H;
3: @@ -46,3 +49,3 @@
3: -    pEe2H(0) = l3 * s23 + l2 * s2;
3: -    pEe2H(1) = -l3 * s1 * c23 + l1 * c1 - l2 * c2 * s1;
3: -    pEe2H(2) =  l3 * c1 * c23 + l1 * s1 + l2 * c1 * c2;
3: +  pEe2H(0) = l3 * s23 + l2 * s2;
3: +  pEe2H(1) = -l3 * s1 * c23 + l1 * c1 - l2 * c2 * s1;
3: +  pEe2H(2) = l3 * c1 * c23 + l1 * s1 + l2 * c1 * c2;
3: @@ -50 +53 @@
3: -    return pEe2H;
3: +  return pEe2H;
3: @@ -54,2 +57,3 @@
3: -Vec3 QuadrupedLeg::calcPEe2B(Vec3 q){
3: -    return _pHip2B + calcPEe2H(q);
3: +Vec3 QuadrupedLeg::calcPEe2B(Vec3 q)
3: +{
3: +  return _pHip2B + calcPEe2H(q);
3: @@ -59,2 +63,3 @@
3: -Vec3 QuadrupedLeg::calcVEe(Vec3 q, Vec3 qd){
3: -    return calcJaco(q) * qd;
3: +Vec3 QuadrupedLeg::calcVEe(Vec3 q, Vec3 qd)
3: +{
3: +  return calcJaco(q) * qd;
3: @@ -64,10 +69,11 @@
3: -Vec3 QuadrupedLeg::calcQ(Vec3 pEe, FrameType frame){
3: -    Vec3 pEe2H;
3: -    if(frame == FrameType::HIP)
3: -        pEe2H = pEe;
3: -    else if(frame == FrameType::BODY)
3: -        pEe2H = pEe - _pHip2B;
3: -    else{
3: -        std::cout << "[ERROR] The frame of QuadrupedLeg::calcQ can only be HIP or BODY!" << std::endl;
3: -        exit(-1);
3: -    }
3: +Vec3 QuadrupedLeg::calcQ(Vec3 pEe, FrameType frame)
3: +{
3: +  Vec3 pEe2H;
3: +  if (frame == FrameType::HIP) {
3: +    pEe2H = pEe;
3: +  } else if (frame == FrameType::BODY) {
3: +    pEe2H = pEe - _pHip2B;
3: +  } else {
3: +    std::cout << "[ERROR] The frame of QuadrupedLeg::calcQ can only be HIP or BODY!" << std::endl;
3: +    exit(-1);
3: +  }
3: @@ -75,4 +81,4 @@
3: -    float q1, q2, q3;
3: -    Vec3 qResult;
3: -    float px, py, pz;
3: -    float b2y, b3z, b4z, a, b, c;
3: +  float q1, q2, q3;
3: +  Vec3 qResult;
3: +  float px, py, pz;
3: +  float b2y, b3z, b4z, a, b, c;
3: @@ -80,3 +86,3 @@
3: -    px = pEe2H(0);
3: -    py = pEe2H(1);
3: -    pz = pEe2H(2);
3: +  px = pEe2H(0);
3: +  py = pEe2H(1);
3: +  pz = pEe2H(2);
3: @@ -84,6 +90,6 @@
3: -    b2y = _abadLinkLength * _sideSign;
3: -    b3z = -_hipLinkLength;
3: -    b4z = -_kneeLinkLength;
3: -    a = _abadLinkLength;
3: -    c = sqrt(pow(px, 2) + pow(py, 2) + pow(pz, 2)); // whole length
3: -    b = sqrt(pow(c, 2) - pow(a, 2)); // distance between shoulder and footpoint
3: +  b2y = _abadLinkLength * _sideSign;
3: +  b3z = -_hipLinkLength;
3: +  b4z = -_kneeLinkLength;
3: +  a = _abadLinkLength;
3: +  c = sqrt(pow(px, 2) + pow(py, 2) + pow(pz, 2));   // whole length
3: +  b = sqrt(pow(c, 2) - pow(a, 2));   // distance between shoulder and footpoint
3: @@ -91,3 +97,3 @@
3: -    q1 = q1_ik(py, pz, b2y);
3: -    q3 = q3_ik(b3z, b4z, b);
3: -    q2 = q2_ik(q1, q3, px, py, pz, b3z, b4z);
3: +  q1 = q1_ik(py, pz, b2y);
3: +  q3 = q3_ik(b3z, b4z, b);
3: +  q2 = q2_ik(q1, q3, px, py, pz, b3z, b4z);
3: @@ -95,3 +101,3 @@
3: -    qResult(0) = q1;
3: -    qResult(1) = q2;
3: -    qResult(2) = q3;
3: +  qResult(0) = q1;
3: +  qResult(1) = q2;
3: +  qResult(2) = q3;
3: @@ -99 +105 @@
3: -    return qResult;
3: +  return qResult;
3: @@ -103,2 +109,3 @@
3: -Vec3 QuadrupedLeg::calcQd(Vec3 q, Vec3 vEe){
3: -    return calcJaco(q).inverse() * vEe;
3: +Vec3 QuadrupedLeg::calcQd(Vec3 q, Vec3 vEe)
3: +{
3: +  return calcJaco(q).inverse() * vEe;
3: @@ -108,3 +115,4 @@
3: -Vec3 QuadrupedLeg::calcQd(Vec3 pEe, Vec3 vEe, FrameType frame){
3: -    Vec3 q = calcQ(pEe, frame);
3: -    return calcJaco(q).inverse() * vEe;
3: +Vec3 QuadrupedLeg::calcQd(Vec3 pEe, Vec3 vEe, FrameType frame)
3: +{
3: +  Vec3 q = calcQ(pEe, frame);
3: +  return calcJaco(q).inverse() * vEe;
3: @@ -114,2 +122,3 @@
3: -Vec3 QuadrupedLeg::calcTau(Vec3 q, Vec3 force){
3: -    return calcJaco(q).transpose() * force;
3: +Vec3 QuadrupedLeg::calcTau(Vec3 q, Vec3 force)
3: +{
3: +  return calcJaco(q).transpose() * force;
3: @@ -119,2 +128,3 @@
3: -Mat3 QuadrupedLeg::calcJaco(Vec3 q){
3: -    Mat3 jaco;
3: +Mat3 QuadrupedLeg::calcJaco(Vec3 q)
3: +{
3: +  Mat3 jaco;
3: @@ -122,3 +132,3 @@
3: -    float l1 = _abadLinkLength * _sideSign;
3: -    float l2 = -_hipLinkLength;
3: -    float l3 = -_kneeLinkLength;
3: +  float l1 = _abadLinkLength * _sideSign;
3: +  float l2 = -_hipLinkLength;
3: +  float l3 = -_kneeLinkLength;
3: @@ -126,3 +136,3 @@
3: -    float s1 = std::sin(q(0));
3: -    float s2 = std::sin(q(1));
3: -    float s3 = std::sin(q(2));
3: +  float s1 = std::sin(q(0));
3: +  float s2 = std::sin(q(1));
3: +  float s3 = std::sin(q(2));
3: @@ -130,3 +140,3 @@
3: -    float c1 = std::cos(q(0));
3: -    float c2 = std::cos(q(1));
3: -    float c3 = std::cos(q(2));
3: +  float c1 = std::cos(q(0));
3: +  float c2 = std::cos(q(1));
3: +  float c3 = std::cos(q(2));
3: @@ -134,11 +144,11 @@
3: -    float c23 = c2 * c3 - s2 * s3;
3: -    float s23 = s2 * c3 + c2 * s3;
3: -    jaco(0, 0) = 0;
3: -    jaco(1, 0) = -l3 * c1 * c23 - l2 * c1 * c2 - l1 * s1;
3: -    jaco(2, 0) = -l3 * s1 * c23 - l2 * c2 * s1 + l1 * c1;
3: -    jaco(0, 1) = l3 * c23 + l2 * c2;
3: -    jaco(1, 1) = l3 * s1 * s23 + l2 * s1 * s2;
3: -    jaco(2, 1) = -l3 * c1 * s23 - l2 * c1 * s2;
3: -    jaco(0, 2) = l3 * c23;
3: -    jaco(1, 2) = l3 * s1 * s23;
3: -    jaco(2, 2) = -l3 * c1 * s23;
3: +  float c23 = c2 * c3 - s2 * s3;
3: +  float s23 = s2 * c3 + c2 * s3;
3: +  jaco(0, 0) = 0;
3: +  jaco(1, 0) = -l3 * c1 * c23 - l2 * c1 * c2 - l1 * s1;
3: +  jaco(2, 0) = -l3 * s1 * c23 - l2 * c2 * s1 + l1 * c1;
3: +  jaco(0, 1) = l3 * c23 + l2 * c2;
3: +  jaco(1, 1) = l3 * s1 * s23 + l2 * s1 * s2;
3: +  jaco(2, 1) = -l3 * c1 * s23 - l2 * c1 * s2;
3: +  jaco(0, 2) = l3 * c23;
3: +  jaco(1, 2) = l3 * s1 * s23;
3: +  jaco(2, 2) = -l3 * c1 * s23;
3: @@ -146 +156 @@
3: -    return jaco;
3: +  return jaco;
3: @@ -149,5 +159,6 @@
3: -float QuadrupedLeg::q1_ik(float py, float pz, float l1){
3: -    float q1;
3: -    float L = sqrt(pow(py,2)+pow(pz,2)-pow(l1,2));
3: -    q1 = atan2(pz*l1+py*L, py*l1-pz*L);
3: -    return q1;
3: +float QuadrupedLeg::q1_ik(float py, float pz, float l1)
3: +{
3: +  float q1;
3: +  float L = sqrt(pow(py, 2) + pow(pz, 2) - pow(l1, 2));
3: +  q1 = atan2(pz * l1 + py * L, py * l1 - pz * L);
3: +  return q1;
3: @@ -156,8 +167,9 @@
3: -float QuadrupedLeg::q3_ik(float b3z, float b4z, float b){
3: -    float q3, temp;
3: -    temp = (pow(b3z, 2) + pow(b4z, 2) - pow(b, 2))/(2*fabs(b3z*b4z));
3: -    if(temp>1) temp = 1;
3: -    if(temp<-1) temp = -1;
3: -    q3 = acos(temp);
3: -    q3 = -(M_PI - q3); //0~180
3: -    return q3;
3: +float QuadrupedLeg::q3_ik(float b3z, float b4z, float b)
3: +{
3: +  float q3, temp;
3: +  temp = (pow(b3z, 2) + pow(b4z, 2) - pow(b, 2)) / (2 * fabs(b3z * b4z));
3: +  if (temp > 1) {temp = 1;}
3: +  if (temp < -1) {temp = -1;}
3: +  q3 = acos(temp);
3: +  q3 = -(M_PI - q3);   //0~180
3: +  return q3;
3: @@ -166,9 +178,10 @@
3: -float QuadrupedLeg::q2_ik(float q1, float q3, float px, float py, float pz, float b3z, float b4z){
3: -    float q2, a1, a2, m1, m2;
3: -    
3: -    a1 = py*sin(q1) - pz*cos(q1);
3: -    a2 = px;
3: -    m1 = b4z*sin(q3);
3: -    m2 = b3z + b4z*cos(q3);
3: -    q2 = atan2(m1*a1+m2*a2, m1*a2-m2*a1);
3: -    return q2;
3: +float QuadrupedLeg::q2_ik(float q1, float q3, float px, float py, float pz, float b3z, float b4z)
3: +{
3: +  float q2, a1, a2, m1, m2;
3: +
3: +  a1 = py * sin(q1) - pz * cos(q1);
3: +  a2 = px;
3: +  m1 = b4z * sin(q3);
3: +  m2 = b3z + b4z * cos(q3);
3: +  q2 = atan2(m1 * a1 + m2 * a2, m1 * a2 - m2 * a1);
3: +  return q2;
3: 
3: Code style divergence in file 'src/common/unitreeRobot.cpp':
3: 
3: --- src/common/unitreeRobot.cpp
3: +++ src/common/unitreeRobot.cpp.uncrustify
3: @@ -7,2 +7,3 @@
3: -Vec3 QuadrupedRobot::getX(LowlevelState &state){
3: -    return getFootPosition(state, 0, FrameType::BODY);
3: +Vec3 QuadrupedRobot::getX(LowlevelState & state)
3: +{
3: +  return getFootPosition(state, 0, FrameType::BODY);
3: @@ -11,4 +12,5 @@
3: -Vec34 QuadrupedRobot::getVecXP(LowlevelState &state){
3: -    Vec3 x = getX(state);
3: -    Vec34 vecXP, qLegs;
3: -    qLegs = state.getQ();
3: +Vec34 QuadrupedRobot::getVecXP(LowlevelState & state)
3: +{
3: +  Vec3 x = getX(state);
3: +  Vec34 vecXP, qLegs;
3: +  qLegs = state.getQ();
3: @@ -16,4 +18,4 @@
3: -    for(int i(0); i < 4; ++i){
3: -        vecXP.col(i) = _Legs[i]->calcPEe2B(qLegs.col(i)) - x;
3: -    }
3: -    return vecXP;
3: +  for (int i(0); i < 4; ++i) {
3: +    vecXP.col(i) = _Legs[i]->calcPEe2B(qLegs.col(i)) - x;
3: +  }
3: +  return vecXP;
3: @@ -22,6 +24,7 @@
3: -Vec12 QuadrupedRobot::getQ(const Vec34 &vecP, FrameType frame){
3: -    Vec12 q;
3: -    for(int i(0); i < 4; ++i){
3: -        q.segment(3*i, 3) = _Legs[i]->calcQ(vecP.col(i), frame);
3: -    }
3: -    return q;
3: +Vec12 QuadrupedRobot::getQ(const Vec34 & vecP, FrameType frame)
3: +{
3: +  Vec12 q;
3: +  for (int i(0); i < 4; ++i) {
3: +    q.segment(3 * i, 3) = _Legs[i]->calcQ(vecP.col(i), frame);
3: +  }
3: +  return q;
3: @@ -30,6 +33,7 @@
3: -Vec12 QuadrupedRobot::getQd(const Vec34 &pos, const Vec34 &vel, FrameType frame){
3: -    Vec12 qd;
3: -    for(int i(0); i < 4; ++i){
3: -        qd.segment(3*i, 3) = _Legs[i]->calcQd(pos.col(i), vel.col(i), frame);
3: -    }
3: -    return qd;
3: +Vec12 QuadrupedRobot::getQd(const Vec34 & pos, const Vec34 & vel, FrameType frame)
3: +{
3: +  Vec12 qd;
3: +  for (int i(0); i < 4; ++i) {
3: +    qd.segment(3 * i, 3) = _Legs[i]->calcQd(pos.col(i), vel.col(i), frame);
3: +  }
3: +  return qd;
3: @@ -38,6 +42,7 @@
3: -Vec12 QuadrupedRobot::getTau(const Vec12 &q, const Vec34 feetForce){
3: -    Vec12 tau;
3: -    for(int i(0); i < 4; ++i){
3: -        tau.segment(3*i, 3) = _Legs[i]->calcTau(q.segment(3*i, 3), feetForce.col(i));
3: -    }
3: -    return tau;
3: +Vec12 QuadrupedRobot::getTau(const Vec12 & q, const Vec34 feetForce)
3: +{
3: +  Vec12 tau;
3: +  for (int i(0); i < 4; ++i) {
3: +    tau.segment(3 * i, 3) = _Legs[i]->calcTau(q.segment(3 * i, 3), feetForce.col(i));
3: +  }
3: +  return tau;
3: @@ -47,2 +52,3 @@
3: -Vec3 QuadrupedRobot::getFootPosition(LowlevelState &state, int id, FrameType frame){
3: -    Vec34 qLegs= state.getQ();
3: +Vec3 QuadrupedRobot::getFootPosition(LowlevelState & state, int id, FrameType frame)
3: +{
3: +  Vec34 qLegs = state.getQ();
3: @@ -50,8 +56,9 @@
3: -    if(frame == FrameType::BODY){
3: -        return _Legs[id]->calcPEe2B(qLegs.col(id));
3: -    }else if(frame == FrameType::HIP){
3: -        return _Legs[id]->calcPEe2H(qLegs.col(id));
3: -    }else{
3: -        std::cout << "[ERROR] The frame of function: getFootPosition can only be BODY or HIP." << std::endl;
3: -        exit(-1);
3: -    }
3: +  if (frame == FrameType::BODY) {
3: +    return _Legs[id]->calcPEe2B(qLegs.col(id));
3: +  } else if (frame == FrameType::HIP) {
3: +    return _Legs[id]->calcPEe2H(qLegs.col(id));
3: +  } else {
3: +    std::cout << "[ERROR] The frame of function: getFootPosition can only be BODY or HIP." <<
3: +      std::endl;
3: +    exit(-1);
3: +  }
3: @@ -61,4 +68,5 @@
3: -Vec3 QuadrupedRobot::getFootVelocity(LowlevelState &state, int id){
3: -    Vec34 qLegs = state.getQ();
3: -    Vec34 qdLegs= state.getQd();
3: -    return _Legs[id]->calcVEe(qLegs.col(id), qdLegs.col(id));
3: +Vec3 QuadrupedRobot::getFootVelocity(LowlevelState & state, int id)
3: +{
3: +  Vec34 qLegs = state.getQ();
3: +  Vec34 qdLegs = state.getQd();
3: +  return _Legs[id]->calcVEe(qLegs.col(id), qdLegs.col(id));
3: @@ -68,7 +76,6 @@
3: -Vec34 QuadrupedRobot::getFeet2BPositions(LowlevelState &state, FrameType frame){
3: -    Vec34 feetPos;
3: -    if(frame == FrameType::GLOBAL){
3: -        for(int i(0); i<4; ++i){
3: -            feetPos.col(i) = getFootPosition(state, i, FrameType::BODY);
3: -        }
3: -        feetPos = state.getRotMat() * feetPos;
3: +Vec34 QuadrupedRobot::getFeet2BPositions(LowlevelState & state, FrameType frame)
3: +{
3: +  Vec34 feetPos;
3: +  if (frame == FrameType::GLOBAL) {
3: +    for (int i(0); i < 4; ++i) {
3: +      feetPos.col(i) = getFootPosition(state, i, FrameType::BODY);
3: @@ -76,4 +83,4 @@
3: -    else if((frame == FrameType::BODY) || (frame == FrameType::HIP)){
3: -        for(int i(0); i<4; ++i){
3: -            feetPos.col(i) = getFootPosition(state, i, frame);
3: -        }
3: +    feetPos = state.getRotMat() * feetPos;
3: +  } else if ((frame == FrameType::BODY) || (frame == FrameType::HIP)) {
3: +    for (int i(0); i < 4; ++i) {
3: +      feetPos.col(i) = getFootPosition(state, i, frame);
3: @@ -81,5 +88,5 @@
3: -    else{
3: -        std::cout << "[ERROR] Frame error of function getFeet2BPositions" << std::endl;
3: -        exit(-1);
3: -    }
3: -    return feetPos;
3: +  } else {
3: +    std::cout << "[ERROR] Frame error of function getFeet2BPositions" << std::endl;
3: +    exit(-1);
3: +  }
3: +  return feetPos;
3: @@ -88,5 +95,6 @@
3: -Vec34 QuadrupedRobot::getFeet2BVelocities(LowlevelState &state, FrameType frame){
3: -    Vec34 feetVel;
3: -    for(int i(0); i<4; ++i){
3: -        feetVel.col(i) = getFootVelocity(state, i);
3: -    }
3: +Vec34 QuadrupedRobot::getFeet2BVelocities(LowlevelState & state, FrameType frame)
3: +{
3: +  Vec34 feetVel;
3: +  for (int i(0); i < 4; ++i) {
3: +    feetVel.col(i) = getFootVelocity(state, i);
3: +  }
3: @@ -94,12 +102,10 @@
3: -    if(frame == FrameType::GLOBAL){
3: -        Vec34 feetPos = getFeet2BPositions(state, FrameType::BODY);
3: -        feetVel += skew(state.getGyro()) * feetPos;
3: -        return state.getRotMat() * feetVel;
3: -    }
3: -    else if((frame == FrameType::BODY) || (frame == FrameType::HIP)){
3: -        return feetVel;
3: -    }
3: -    else{
3: -        std::cout << "[ERROR] Frame error of function getFeet2BVelocities" << std::endl;
3: -        exit(-1);
3: -    }   
3: +  if (frame == FrameType::GLOBAL) {
3: +    Vec34 feetPos = getFeet2BPositions(state, FrameType::BODY);
3: +    feetVel += skew(state.getGyro()) * feetPos;
3: +    return state.getRotMat() * feetVel;
3: +  } else if ((frame == FrameType::BODY) || (frame == FrameType::HIP)) {
3: +    return feetVel;
3: +  } else {
3: +    std::cout << "[ERROR] Frame error of function getFeet2BVelocities" << std::endl;
3: +    exit(-1);
3: +  }
3: @@ -108,2 +114,3 @@
3: -Mat3 QuadrupedRobot::getJaco(LowlevelState &state, int legID){
3: -    return _Legs[legID]->calcJaco(state.getQ().col(legID));
3: +Mat3 QuadrupedRobot::getJaco(LowlevelState & state, int legID)
3: +{
3: +  return _Legs[legID]->calcJaco(state.getQ().col(legID));
3: @@ -112,5 +119,6 @@
3: -A1Robot::A1Robot(){
3: -    _Legs[0] = new A1Leg(0, Vec3( 0.1805, -0.047, 0));
3: -    _Legs[1] = new A1Leg(1, Vec3( 0.1805,  0.047, 0));
3: -    _Legs[2] = new A1Leg(2, Vec3(-0.1805, -0.047, 0));
3: -    _Legs[3] = new A1Leg(3, Vec3(-0.1805,  0.047, 0));
3: +A1Robot::A1Robot()
3: +{
3: +  _Legs[0] = new A1Leg(0, Vec3(0.1805, -0.047, 0));
3: +  _Legs[1] = new A1Leg(1, Vec3(0.1805, 0.047, 0));
3: +  _Legs[2] = new A1Leg(2, Vec3(-0.1805, -0.047, 0));
3: +  _Legs[3] = new A1Leg(3, Vec3(-0.1805, 0.047, 0));
3: @@ -118,3 +126,3 @@
3: -    _feetPosNormalStand <<  0.1805,  0.1805, -0.1805, -0.1805, 
3: -                           -0.1308,  0.1308, -0.1308,  0.1308,
3: -                           -0.3180, -0.3180, -0.3180, -0.3180;
3: +  _feetPosNormalStand << 0.1805, 0.1805, -0.1805, -0.1805,
3: +    -0.1308, 0.1308, -0.1308, 0.1308,
3: +    -0.3180, -0.3180, -0.3180, -0.3180;
3: @@ -122,3 +130,3 @@
3: -    _robVelLimitX << -0.4, 0.4;
3: -    _robVelLimitY << -0.3, 0.3;
3: -    _robVelLimitYaw << -0.5, 0.5;
3: +  _robVelLimitX << -0.4, 0.4;
3: +  _robVelLimitY << -0.3, 0.3;
3: +  _robVelLimitYaw << -0.5, 0.5;
3: @@ -127,3 +135,3 @@
3: -    _mass = 12.5;
3: -    _pcb << 0.01, 0.0, 0.0;
3: -    _Ib = Vec3(0.132, 0.3475, 0.3775).asDiagonal();
3: +  _mass = 12.5;
3: +  _pcb << 0.01, 0.0, 0.0;
3: +  _Ib = Vec3(0.132, 0.3475, 0.3775).asDiagonal();
3: @@ -133,3 +141,3 @@
3: -    _mass = 13.4;
3: -    _pcb << 0.0, 0.0, 0.0;
3: -    _Ib = Vec3(0.132, 0.3475, 0.3775).asDiagonal();
3: +  _mass = 13.4;
3: +  _pcb << 0.0, 0.0, 0.0;
3: +  _Ib = Vec3(0.132, 0.3475, 0.3775).asDiagonal();
3: @@ -139,5 +147,6 @@
3: -Go1Robot::Go1Robot(){
3: -    _Legs[0] = new Go1Leg(0, Vec3( 0.1881, -0.04675, 0));
3: -    _Legs[1] = new Go1Leg(1, Vec3( 0.1881,  0.04675, 0));
3: -    _Legs[2] = new Go1Leg(2, Vec3(-0.1881, -0.04675, 0));
3: -    _Legs[3] = new Go1Leg(3, Vec3(-0.1881,  0.04675, 0));
3: +Go1Robot::Go1Robot()
3: +{
3: +  _Legs[0] = new Go1Leg(0, Vec3(0.1881, -0.04675, 0));
3: +  _Legs[1] = new Go1Leg(1, Vec3(0.1881, 0.04675, 0));
3: +  _Legs[2] = new Go1Leg(2, Vec3(-0.1881, -0.04675, 0));
3: +  _Legs[3] = new Go1Leg(3, Vec3(-0.1881, 0.04675, 0));
3: @@ -145,3 +154,3 @@
3: -    _feetPosNormalStand <<  0.1881,  0.1881, -0.1881, -0.1881,
3: -                           -0.1300,  0.1300, -0.1300,  0.1300,
3: -                           -0.3200, -0.3200, -0.3200, -0.3200;
3: +  _feetPosNormalStand << 0.1881, 0.1881, -0.1881, -0.1881,
3: +    -0.1300, 0.1300, -0.1300, 0.1300,
3: +    -0.3200, -0.3200, -0.3200, -0.3200;
3: @@ -149,3 +158,3 @@
3: -    _robVelLimitX << -0.4, 0.4;
3: -    _robVelLimitY << -0.3, 0.3;
3: -    _robVelLimitYaw << -0.5, 0.5;
3: +  _robVelLimitX << -0.4, 0.4;
3: +  _robVelLimitY << -0.3, 0.3;
3: +  _robVelLimitYaw << -0.5, 0.5;
3: @@ -155,3 +164,3 @@
3: -    _mass = 10.5;
3: -    _pcb << 0.04, 0.0, 0.0;
3: -    _Ib = Vec3(0.0792, 0.2085, 0.2265).asDiagonal();
3: +  _mass = 10.5;
3: +  _pcb << 0.04, 0.0, 0.0;
3: +  _Ib = Vec3(0.0792, 0.2085, 0.2265).asDiagonal();
3: @@ -161,3 +170,3 @@
3: -    _mass = 12.0;
3: -    _pcb << 0.0, 0.0, 0.0;
3: -    _Ib = Vec3(0.0792, 0.2085, 0.2265).asDiagonal();
3: +  _mass = 12.0;
3: +  _pcb << 0.0, 0.0, 0.0;
3: +  _Ib = Vec3(0.0792, 0.2085, 0.2265).asDiagonal();
3: @@ -165 +174 @@
3: -}
3: +}
3: 
3: Code style divergence in file 'src/control/BalanceCtrl.cpp':
3: 
3: --- src/control/BalanceCtrl.cpp
3: +++ src/control/BalanceCtrl.cpp.uncrustify
3: @@ -9,9 +9,10 @@
3: -            : _mass(mass), _Ib(Ib), _S(S), _alpha(alpha), _beta(beta){
3: -    _Fprev.setZero();
3: -    _g << 0, 0, -9.81;
3: -    _fricRatio = 0.3;
3: -    _fricMat <<  1,  0, _fricRatio,
3: -                -1,  0, _fricRatio,
3: -                 0,  1, _fricRatio,
3: -                 0, -1, _fricRatio,
3: -                 0,  0, 1;
3: +: _mass(mass), _Ib(Ib), _S(S), _alpha(alpha), _beta(beta)
3: +{
3: +  _Fprev.setZero();
3: +  _g << 0, 0, -9.81;
3: +  _fricRatio = 0.3;
3: +  _fricMat << 1, 0, _fricRatio,
3: +    -1, 0, _fricRatio,
3: +    0, 1, _fricRatio,
3: +    0, -1, _fricRatio,
3: +    0, 0, 1;
3: @@ -20,3 +21,4 @@
3: -BalanceCtrl::BalanceCtrl(QuadrupedRobot *robModel){
3: -    Vec6 s;
3: -    Vec12 w, u;
3: +BalanceCtrl::BalanceCtrl(QuadrupedRobot * robModel)
3: +{
3: +  Vec6 s;
3: +  Vec12 w, u;
3: @@ -24,4 +26,4 @@
3: -    _mass = robModel->getRobMass();
3: -    _pcb = robModel->getPcb();
3: -    _Ib = robModel->getRobInertial();
3: -    _g << 0, 0, -9.81;
3: +  _mass = robModel->getRobMass();
3: +  _pcb = robModel->getPcb();
3: +  _Ib = robModel->getRobInertial();
3: +  _g << 0, 0, -9.81;
3: @@ -29,5 +31,5 @@
3: -    w << 10, 10, 4, 10, 10, 4, 10, 10, 4, 10, 10, 4;
3: -    u << 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3;
3: -    _alpha = 0.001;
3: -    _beta  = 0.1;
3: -    _fricRatio = 0.4;
3: +  w << 10, 10, 4, 10, 10, 4, 10, 10, 4, 10, 10, 4;
3: +  u << 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3;
3: +  _alpha = 0.001;
3: +  _beta = 0.1;
3: +  _fricRatio = 0.4;
3: @@ -35 +37 @@
3: -    s << 20, 20, 50, 450, 450, 450; 
3: +  s << 20, 20, 50, 450, 450, 450;
3: @@ -37,10 +39,10 @@
3: -    _S = s.asDiagonal();
3: -    _W = w.asDiagonal();
3: -    _U = u.asDiagonal();
3: -    
3: -    _Fprev.setZero();
3: -    _fricMat <<  1,  0, _fricRatio,
3: -                -1,  0, _fricRatio,
3: -                 0,  1, _fricRatio,
3: -                 0, -1, _fricRatio,
3: -                 0,  0, 1;
3: +  _S = s.asDiagonal();
3: +  _W = w.asDiagonal();
3: +  _U = u.asDiagonal();
3: +
3: +  _Fprev.setZero();
3: +  _fricMat << 1, 0, _fricRatio,
3: +    -1, 0, _fricRatio,
3: +    0, 1, _fricRatio,
3: +    0, -1, _fricRatio,
3: +    0, 0, 1;
3: @@ -49,4 +51,5 @@
3: -Vec34 BalanceCtrl::calF(Vec3 ddPcd, Vec3 dWbd, RotMat rotM, Vec34 feetPos2B, VecInt4 contact){
3: -    calMatrixA(feetPos2B, rotM, contact);
3: -    calVectorBd(ddPcd, dWbd, rotM);
3: -    calConstraints(contact);
3: +Vec34 BalanceCtrl::calF(Vec3 ddPcd, Vec3 dWbd, RotMat rotM, Vec34 feetPos2B, VecInt4 contact)
3: +{
3: +  calMatrixA(feetPos2B, rotM, contact);
3: +  calVectorBd(ddPcd, dWbd, rotM);
3: +  calConstraints(contact);
3: @@ -54,2 +57,2 @@
3: -    _G = _A.transpose()*_S*_A + _alpha*_W + _beta*_U;
3: -    _g0T = -_bd.transpose()*_S*_A - _beta*_Fprev.transpose()*_U;
3: +  _G = _A.transpose() * _S * _A + _alpha * _W + _beta * _U;
3: +  _g0T = -_bd.transpose() * _S * _A - _beta * _Fprev.transpose() * _U;
3: @@ -57 +60 @@
3: -    solveQP();
3: +  solveQP();
3: @@ -59,2 +62,2 @@
3: -    _Fprev = _F;
3: -    return vec12ToVec34(_F);
3: +  _Fprev = _F;
3: +  return vec12ToVec34(_F);
3: @@ -63,5 +66,6 @@
3: -void BalanceCtrl::calMatrixA(Vec34 feetPos2B, RotMat rotM, VecInt4 contact){
3: -    for(int i(0); i < 4; ++i){
3: -        _A.block(0, 3*i, 3, 3) = I3;
3: -        _A.block(3, 3*i, 3, 3) = skew(feetPos2B.col(i) - rotM*_pcb);
3: -    }
3: +void BalanceCtrl::calMatrixA(Vec34 feetPos2B, RotMat rotM, VecInt4 contact)
3: +{
3: +  for (int i(0); i < 4; ++i) {
3: +    _A.block(0, 3 * i, 3, 3) = I3;
3: +    _A.block(3, 3 * i, 3, 3) = skew(feetPos2B.col(i) - rotM * _pcb);
3: +  }
3: @@ -70,3 +74,4 @@
3: -void BalanceCtrl::calVectorBd(Vec3 ddPcd, Vec3 dWbd, RotMat rotM){
3: -    _bd.head(3) = _mass * (ddPcd - _g);
3: -    _bd.tail(3) = (rotM * _Ib * rotM.transpose()) * dWbd;
3: +void BalanceCtrl::calVectorBd(Vec3 ddPcd, Vec3 dWbd, RotMat rotM)
3: +{
3: +  _bd.head(3) = _mass * (ddPcd - _g);
3: +  _bd.tail(3) = (rotM * _Ib * rotM.transpose()) * dWbd;
3: @@ -75,6 +80,6 @@
3: -void BalanceCtrl::calConstraints(VecInt4 contact){
3: -    int contactLegNum = 0;
3: -    for(int i(0); i<4; ++i){
3: -        if(contact(i) == 1){
3: -            contactLegNum += 1;
3: -        }
3: +void BalanceCtrl::calConstraints(VecInt4 contact)
3: +{
3: +  int contactLegNum = 0;
3: +  for (int i(0); i < 4; ++i) {
3: +    if (contact(i) == 1) {
3: +      contactLegNum += 1;
3: @@ -81,0 +87 @@
3: +  }
3: @@ -83,4 +89,4 @@
3: -    _CI.resize(5*contactLegNum, 12);
3: -    _ci0.resize(5*contactLegNum);
3: -    _CE.resize(3*(4 - contactLegNum), 12);
3: -    _ce0.resize(3*(4 - contactLegNum));
3: +  _CI.resize(5 * contactLegNum, 12);
3: +  _ci0.resize(5 * contactLegNum);
3: +  _CE.resize(3 * (4 - contactLegNum), 12);
3: +  _ce0.resize(3 * (4 - contactLegNum));
3: @@ -88,4 +94,4 @@
3: -    _CI.setZero();
3: -    _ci0.setZero();
3: -    _CE.setZero();
3: -    _ce0.setZero();
3: +  _CI.setZero();
3: +  _ci0.setZero();
3: +  _CE.setZero();
3: +  _ce0.setZero();
3: @@ -93,10 +99,9 @@
3: -    int ceID = 0;
3: -    int ciID = 0;
3: -    for(int i(0); i<4; ++i){
3: -        if(contact(i) == 1){
3: -            _CI.block(5*ciID, 3*i, 5, 3) = _fricMat;
3: -            ++ciID;
3: -        }else{
3: -            _CE.block(3*ceID, 3*i, 3, 3) = I3;
3: -            ++ceID;
3: -        }
3: +  int ceID = 0;
3: +  int ciID = 0;
3: +  for (int i(0); i < 4; ++i) {
3: +    if (contact(i) == 1) {
3: +      _CI.block(5 * ciID, 3 * i, 5, 3) = _fricMat;
3: +      ++ciID;
3: +    } else {
3: +      _CE.block(3 * ceID, 3 * i, 3, 3) = I3;
3: +      ++ceID;
3: @@ -103,0 +109 @@
3: +  }
3: @@ -106,4 +112,5 @@
3: -void BalanceCtrl::solveQP(){
3: -    int n = _F.size();
3: -    int m = _ce0.size();
3: -    int p = _ci0.size();
3: +void BalanceCtrl::solveQP()
3: +{
3: +  int n = _F.size();
3: +  int m = _ce0.size();
3: +  int p = _ci0.size();
3: @@ -111,7 +118,7 @@
3: -    G.resize(n, n);
3: -    CE.resize(n, m);
3: -    CI.resize(n, p);
3: -    g0.resize(n);
3: -    ce0.resize(m);
3: -    ci0.resize(p);
3: -    x.resize(n);
3: +  G.resize(n, n);
3: +  CE.resize(n, m);
3: +  CI.resize(n, p);
3: +  g0.resize(n);
3: +  ce0.resize(m);
3: +  ci0.resize(p);
3: +  x.resize(n);
3: @@ -119,4 +126,3 @@
3: -    for (int i = 0; i < n; ++i) {
3: -        for (int j = 0; j < n; ++j) {
3: -            G[i][j] = _G(i, j);
3: -        }
3: +  for (int i = 0; i < n; ++i) {
3: +    for (int j = 0; j < n; ++j) {
3: +      G[i][j] = _G(i, j);
3: @@ -123,0 +130 @@
3: +  }
3: @@ -125,4 +132,3 @@
3: -    for (int i = 0; i < n; ++i) {
3: -        for (int j = 0; j < m; ++j) {
3: -            CE[i][j] = (_CE.transpose())(i, j);
3: -        }
3: +  for (int i = 0; i < n; ++i) {
3: +    for (int j = 0; j < m; ++j) {
3: +      CE[i][j] = (_CE.transpose())(i, j);
3: @@ -129,0 +136 @@
3: +  }
3: @@ -131,4 +138,3 @@
3: -    for (int i = 0; i < n; ++i) {
3: -        for (int j = 0; j < p; ++j) {
3: -            CI[i][j] = (_CI.transpose())(i, j);
3: -        }
3: +  for (int i = 0; i < n; ++i) {
3: +    for (int j = 0; j < p; ++j) {
3: +      CI[i][j] = (_CI.transpose())(i, j);
3: @@ -135,0 +142 @@
3: +  }
3: @@ -137,3 +144,3 @@
3: -    for (int i = 0; i < n; ++i) {
3: -        g0[i] = _g0T[i];
3: -    }
3: +  for (int i = 0; i < n; ++i) {
3: +    g0[i] = _g0T[i];
3: +  }
3: @@ -141,3 +148,3 @@
3: -    for (int i = 0; i < m; ++i) {
3: -        ce0[i] = _ce0[i];
3: -    }
3: +  for (int i = 0; i < m; ++i) {
3: +    ce0[i] = _ce0[i];
3: +  }
3: @@ -145,3 +152,3 @@
3: -    for (int i = 0; i < p; ++i) {
3: -        ci0[i] = _ci0[i];
3: -    }
3: +  for (int i = 0; i < p; ++i) {
3: +    ci0[i] = _ci0[i];
3: +  }
3: @@ -149 +156 @@
3: -    double value = solve_quadprog(G, g0, CE, ce0, CI, ci0, x);
3: +  double value = solve_quadprog(G, g0, CE, ce0, CI, ci0, x);
3: @@ -151,4 +158,4 @@
3: -    for (int i = 0; i < n; ++i) {
3: -        _F[i] = x[i];
3: -    }
3: -}
3: +  for (int i = 0; i < n; ++i) {
3: +    _F[i] = x[i];
3: +  }
3: +}
3: 
3: Code style divergence in file 'src/control/ControlFrame.cpp':
3: 
3: --- src/control/ControlFrame.cpp
3: +++ src/control/ControlFrame.cpp.uncrustify
3: @@ -6,2 +6,4 @@
3: -ControlFrame::ControlFrame(CtrlComponents *ctrlComp):_ctrlComp(ctrlComp){
3: -    _FSMController = new FSM(_ctrlComp);
3: +ControlFrame::ControlFrame(CtrlComponents * ctrlComp)
3: +: _ctrlComp(ctrlComp)
3: +{
3: +  _FSMController = new FSM(_ctrlComp);
3: @@ -10,3 +12,4 @@
3: -void ControlFrame::run(){
3: -    _FSMController->run();
3: -}
3: +void ControlFrame::run()
3: +{
3: +  _FSMController->run();
3: +}
3: 
3: Code style divergence in file 'src/control/Estimator.cpp':
3: 
3: --- src/control/Estimator.cpp
3: +++ src/control/Estimator.cpp.uncrustify
3: @@ -8,24 +8,25 @@
3: -Estimator::Estimator(QuadrupedRobot *robotModel, LowlevelState* lowState, 
3: -                     VecInt4 *contact, Vec4 *phase, double dt, Vec18 Qdig,
3: -                     std::string testName)
3: -          :_robModel(robotModel), _lowState(lowState), _contact(contact),
3: -           _phase(phase), _dt(dt), _Qdig(Qdig), _estName(testName){
3: -
3: -    _initSystem();
3: -}
3: -
3: -Estimator::Estimator(QuadrupedRobot *robotModel, LowlevelState* lowState, 
3: -                     VecInt4 *contact, Vec4 *phase, double dt)
3: -          :_robModel(robotModel), _lowState(lowState), _contact(contact), 
3: -           _phase(phase), _dt(dt){
3: -
3: -    for(int i(0); i<_Qdig.rows(); ++i){
3: -        if(i < 3){
3: -            _Qdig(i) = 0.0003;
3: -        }
3: -        else if(i < 6){
3: -            _Qdig(i) = 0.0003;
3: -        }
3: -        else{
3: -            _Qdig(i) = 0.01;
3: -        }
3: +Estimator::Estimator(
3: +  QuadrupedRobot * robotModel, LowlevelState * lowState,
3: +  VecInt4 * contact, Vec4 * phase, double dt, Vec18 Qdig,
3: +  std::string testName)
3: +: _robModel(robotModel), _lowState(lowState), _contact(contact),
3: +  _phase(phase), _dt(dt), _Qdig(Qdig), _estName(testName)
3: +{
3: +
3: +  _initSystem();
3: +}
3: +
3: +Estimator::Estimator(
3: +  QuadrupedRobot * robotModel, LowlevelState * lowState,
3: +  VecInt4 * contact, Vec4 * phase, double dt)
3: +: _robModel(robotModel), _lowState(lowState), _contact(contact),
3: +  _phase(phase), _dt(dt)
3: +{
3: +
3: +  for (int i(0); i < _Qdig.rows(); ++i) {
3: +    if (i < 3) {
3: +      _Qdig(i) = 0.0003;
3: +    } else if (i < 6) {
3: +      _Qdig(i) = 0.0003;
3: +    } else {
3: +      _Qdig(i) = 0.01;
3: @@ -33,86 +34,145 @@
3: -
3: -    _estName = "current";
3: -
3: -    _initSystem();
3: -
3: -}
3: -
3: -Estimator::~Estimator(){
3: -}
3: -
3: -void Estimator::_initSystem(){
3: -    _g << 0, 0, -9.81;
3: -    _largeVariance = 100;
3: -
3: -    _xhat.setZero();
3: -    _u.setZero();
3: -    _A.setZero();
3: -    _A.block(0, 0, 3, 3) = I3;
3: -    _A.block(0, 3, 3, 3) = I3 * _dt;
3: -    _A.block(3, 3, 3, 3) = I3;
3: -    _A.block(6, 6, 12, 12) = I12;
3: -    _B.setZero();
3: -    _B.block(3, 0, 3, 3) = I3 * _dt;
3: -    _C.setZero();
3: -    _C.block(0, 0, 3, 3) = -I3;
3: -    _C.block(3, 0, 3, 3) = -I3;
3: -    _C.block(6, 0, 3, 3) = -I3;
3: -    _C.block(9, 0, 3, 3) = -I3;
3: -    _C.block(12, 3, 3, 3) = -I3;
3: -    _C.block(15, 3, 3, 3) = -I3;
3: -    _C.block(18, 3, 3, 3) = -I3;
3: -    _C.block(21, 3, 3, 3) = -I3;
3: -    _C.block(0, 6, 12, 12) = I12;
3: -    _C(24, 8) = 1;
3: -    _C(25, 11) = 1;
3: -    _C(26, 14) = 1;
3: -    _C(27, 17) = 1;
3: -    _P.setIdentity();
3: -    _P = _largeVariance * _P;
3: -
3: -    _RInit <<  0.008 , 0.012 ,-0.000 ,-0.009 , 0.012 , 0.000 , 0.009 ,-0.009 ,-0.000 ,-0.009 ,-0.009 , 0.000 ,-0.000 , 0.000 ,-0.000 , 0.000 ,-0.000 ,-0.001 ,-0.002 , 0.000 ,-0.000 ,-0.003 ,-0.000 ,-0.001 , 0.000 , 0.000 , 0.000 , 0.000,
3: -               0.012 , 0.019 ,-0.001 ,-0.014 , 0.018 ,-0.000 , 0.014 ,-0.013 ,-0.000 ,-0.014 ,-0.014 , 0.001 ,-0.001 , 0.001 ,-0.001 , 0.000 , 0.000 ,-0.001 ,-0.003 , 0.000 ,-0.001 ,-0.004 ,-0.000 ,-0.001 , 0.000 , 0.000 , 0.000 , 0.000,
3: -               -0.000, -0.001,  0.001,  0.001, -0.001,  0.000, -0.000,  0.000, -0.000,  0.001,  0.000, -0.000,  0.000, -0.000,  0.000,  0.000, -0.000, -0.000,  0.000, -0.000, -0.000, -0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,
3: -               -0.009, -0.014,  0.001,  0.010, -0.013,  0.000, -0.010,  0.010,  0.000,  0.010,  0.010, -0.000,  0.001,  0.000,  0.000,  0.001, -0.000,  0.001,  0.002, -0.000,  0.000,  0.003,  0.000,  0.001,  0.000,  0.000,  0.000,  0.000,
3: -               0.012 , 0.018 ,-0.001 ,-0.013 , 0.018 ,-0.000 , 0.013 ,-0.013 ,-0.000 ,-0.013 ,-0.013 , 0.001 ,-0.001 , 0.000 ,-0.001 , 0.000 , 0.001 ,-0.001 ,-0.003 , 0.000 ,-0.001 ,-0.004 ,-0.000 ,-0.001 , 0.000 , 0.000 , 0.000 , 0.000,
3: -               0.000 ,-0.000 , 0.000 , 0.000 ,-0.000 , 0.001 , 0.000 , 0.000 ,-0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 , 0.000 ,-0.000 , 0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 ,-0.000 ,-0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000,
3: -               0.009 , 0.014 ,-0.000 ,-0.010 , 0.013 , 0.000 , 0.010 ,-0.010 ,-0.000 ,-0.010 ,-0.010 , 0.000 ,-0.001 , 0.000 ,-0.001 , 0.000 ,-0.000 ,-0.001 ,-0.001 , 0.000 ,-0.000 ,-0.003 ,-0.000 ,-0.001 , 0.000 , 0.000 , 0.000 , 0.000,
3: -               -0.009, -0.013,  0.000,  0.010, -0.013,  0.000, -0.010,  0.009,  0.000,  0.010,  0.010, -0.000,  0.001, -0.000,  0.000, -0.000,  0.000,  0.001,  0.002,  0.000,  0.000,  0.003,  0.000,  0.001,  0.000,  0.000,  0.000,  0.000,
3: -               -0.000, -0.000, -0.000,  0.000, -0.000, -0.000, -0.000,  0.000,  0.001,  0.000,  0.000,  0.000,  0.000, -0.000,  0.000, -0.000,  0.000, -0.000,  0.000, -0.000,  0.000,  0.000, -0.000, -0.000,  0.000,  0.000,  0.000,  0.000,
3: -               -0.009, -0.014,  0.001,  0.010, -0.013,  0.000, -0.010,  0.010,  0.000,  0.010,  0.010, -0.000,  0.001,  0.000,  0.000, -0.000, -0.000,  0.001,  0.002, -0.000,  0.000,  0.003,  0.000,  0.001,  0.000,  0.000,  0.000,  0.000,
3: -               -0.009, -0.014,  0.000,  0.010, -0.013,  0.000, -0.010,  0.010,  0.000,  0.010,  0.010, -0.000,  0.001, -0.000,  0.000, -0.000,  0.000,  0.001,  0.002, -0.000,  0.000,  0.003,  0.001,  0.001,  0.000,  0.000,  0.000,  0.000,
3: -               0.000 , 0.001 ,-0.000 ,-0.000 , 0.001 ,-0.000 , 0.000 ,-0.000 , 0.000 ,-0.000 ,-0.000 , 0.001 , 0.000 ,-0.000 ,-0.000 ,-0.000 , 0.000 , 0.000 ,-0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000,
3: -               -0.000, -0.001,  0.000,  0.001, -0.001, -0.000, -0.001,  0.001,  0.000,  0.001,  0.001,  0.000,  1.708,  0.048,  0.784,  0.062,  0.042,  0.053,  0.077,  0.001, -0.061,  0.046, -0.019, -0.029,  0.000,  0.000,  0.000,  0.000,
3: -               0.000 , 0.001 ,-0.000 , 0.000 , 0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 , 0.000 ,-0.000 ,-0.000 , 0.048 , 5.001 ,-1.631 ,-0.036 , 0.144 , 0.040 , 0.036 , 0.016 ,-0.051 ,-0.067 ,-0.024 ,-0.005 , 0.000 , 0.000 , 0.000 , 0.000,
3: -               -0.000, -0.001,  0.000,  0.000, -0.001, -0.000, -0.001,  0.000,  0.000,  0.000,  0.000, -0.000,  0.784, -1.631,  1.242,  0.057, -0.037,  0.018,  0.034, -0.017, -0.015,  0.058, -0.021, -0.029,  0.000,  0.000,  0.000,  0.000,
3: -               0.000 , 0.000 , 0.000 , 0.001 , 0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 ,-0.000 ,-0.000 ,-0.000 , 0.062 ,-0.036 , 0.057 , 6.228 ,-0.014 , 0.932 , 0.059 , 0.053 ,-0.069 , 0.148 , 0.015 ,-0.031 , 0.000 , 0.000 , 0.000 , 0.000,
3: -               -0.000,  0.000, -0.000, -0.000,  0.001,  0.000, -0.000,  0.000,  0.000, -0.000,  0.000,  0.000,  0.042,  0.144, -0.037, -0.014,  3.011,  0.986,  0.076,  0.030, -0.052, -0.027,  0.057,  0.051,  0.000,  0.000,  0.000,  0.000,
3: -               -0.001, -0.001, -0.000,  0.001, -0.001,  0.000, -0.001,  0.001, -0.000,  0.001,  0.001,  0.000,  0.053,  0.040,  0.018,  0.932,  0.986,  0.885,  0.090,  0.044, -0.055,  0.057,  0.051, -0.003,  0.000,  0.000,  0.000,  0.000,
3: -               -0.002, -0.003,  0.000,  0.002, -0.003, -0.000, -0.001,  0.002,  0.000,  0.002,  0.002, -0.000,  0.077,  0.036,  0.034,  0.059,  0.076,  0.090,  6.230,  0.139,  0.763,  0.013, -0.019, -0.024,  0.000,  0.000,  0.000,  0.000,
3: -               0.000 , 0.000 ,-0.000 ,-0.000 , 0.000 ,-0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 ,-0.000 , 0.000 , 0.001 , 0.016 ,-0.017 , 0.053 , 0.030 , 0.044 , 0.139 , 3.130 ,-1.128 ,-0.010 , 0.131 , 0.018 , 0.000 , 0.000 , 0.000 , 0.000,
3: -               -0.000, -0.001, -0.000,  0.000, -0.001, -0.000, -0.000,  0.000,  0.000,  0.000,  0.000,  0.000, -0.061, -0.051, -0.015, -0.069, -0.052, -0.055,  0.763, -1.128,  0.866, -0.022, -0.053,  0.007,  0.000,  0.000,  0.000,  0.000,
3: -               -0.003, -0.004, -0.000,  0.003, -0.004, -0.000, -0.003,  0.003,  0.000,  0.003,  0.003,  0.000,  0.046, -0.067,  0.058,  0.148, -0.027,  0.057,  0.013, -0.010, -0.022,  2.437, -0.102,  0.938,  0.000,  0.000,  0.000,  0.000,
3: -               -0.000, -0.000,  0.000,  0.000, -0.000,  0.000, -0.000,  0.000, -0.000,  0.000,  0.001,  0.000, -0.019, -0.024, -0.021,  0.015,  0.057,  0.051, -0.019,  0.131, -0.053, -0.102,  4.944,  1.724,  0.000,  0.000,  0.000,  0.000,
3: -               -0.001, -0.001,  0.000,  0.001, -0.001,  0.000, -0.001,  0.001, -0.000,  0.001,  0.001,  0.000, -0.029, -0.005, -0.029, -0.031,  0.051, -0.003, -0.024,  0.018,  0.007,  0.938,  1.724,  1.569,  0.000,  0.000,  0.000,  0.000,
3: -               0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 1.0 , 0.000 , 0.000 , 0.000,
3: -               0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 1.0 , 0.000 , 0.000,
3: -               0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 1.0 , 0.000,
3: -               0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 1.0;
3: -
3: -    /* A1 Worked */
3: -    _Cu <<   268.573,  -43.819, -147.211,
3: -            -43.819 ,  92.949 ,  58.082,
3: -            -147.211,   58.082,  302.120;
3: -
3: -    _QInit = _Qdig.asDiagonal();
3: -    _QInit +=  _B * _Cu * _B.transpose();
3: -
3: -    _RCheck  = new AvgCov(28, _estName + " R");
3: -    _uCheck  = new AvgCov(3,  _estName + " u");
3: -
3: -    _vxFilter = new LPFilter(_dt, 3.0);
3: -    _vyFilter = new LPFilter(_dt, 3.0);
3: -    _vzFilter = new LPFilter(_dt, 3.0);
3: -
3: -
3: -    /* ROS odometry publisher */
3: +  }
3: +
3: +  _estName = "current";
3: +
3: +  _initSystem();
3: +
3: +}
3: +
3: +Estimator::~Estimator()
3: +{
3: +}
3: +
3: +void Estimator::_initSystem()
3: +{
3: +  _g << 0, 0, -9.81;
3: +  _largeVariance = 100;
3: +
3: +  _xhat.setZero();
3: +  _u.setZero();
3: +  _A.setZero();
3: +  _A.block(0, 0, 3, 3) = I3;
3: +  _A.block(0, 3, 3, 3) = I3 * _dt;
3: +  _A.block(3, 3, 3, 3) = I3;
3: +  _A.block(6, 6, 12, 12) = I12;
3: +  _B.setZero();
3: +  _B.block(3, 0, 3, 3) = I3 * _dt;
3: +  _C.setZero();
3: +  _C.block(0, 0, 3, 3) = -I3;
3: +  _C.block(3, 0, 3, 3) = -I3;
3: +  _C.block(6, 0, 3, 3) = -I3;
3: +  _C.block(9, 0, 3, 3) = -I3;
3: +  _C.block(12, 3, 3, 3) = -I3;
3: +  _C.block(15, 3, 3, 3) = -I3;
3: +  _C.block(18, 3, 3, 3) = -I3;
3: +  _C.block(21, 3, 3, 3) = -I3;
3: +  _C.block(0, 6, 12, 12) = I12;
3: +  _C(24, 8) = 1;
3: +  _C(25, 11) = 1;
3: +  _C(26, 14) = 1;
3: +  _C(27, 17) = 1;
3: +  _P.setIdentity();
3: +  _P = _largeVariance * _P;
3: +
3: +  _RInit << 0.008, 0.012, -0.000, -0.009, 0.012, 0.000, 0.009, -0.009, -0.000, -0.009, -0.009,
3: +    0.000, -0.000, 0.000, -0.000, 0.000, -0.000, -0.001, -0.002, 0.000, -0.000, -0.003, -0.000,
3: +    -0.001, 0.000, 0.000, 0.000, 0.000,
3: +    0.012, 0.019, -0.001, -0.014, 0.018, -0.000, 0.014, -0.013, -0.000, -0.014, -0.014, 0.001,
3: +    -0.001, 0.001, -0.001, 0.000, 0.000, -0.001, -0.003, 0.000, -0.001, -0.004, -0.000, -0.001,
3: +    0.000, 0.000, 0.000, 0.000,
3: +    -0.000, -0.001, 0.001, 0.001, -0.001, 0.000, -0.000, 0.000, -0.000, 0.001, 0.000, -0.000, 0.000,
3: +    -0.000, 0.000, 0.000, -0.000, -0.000, 0.000, -0.000, -0.000, -0.000, 0.000, 0.000, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    -0.009, -0.014, 0.001, 0.010, -0.013, 0.000, -0.010, 0.010, 0.000, 0.010, 0.010, -0.000, 0.001,
3: +    0.000, 0.000, 0.001, -0.000, 0.001, 0.002, -0.000, 0.000, 0.003, 0.000, 0.001, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    0.012, 0.018, -0.001, -0.013, 0.018, -0.000, 0.013, -0.013, -0.000, -0.013, -0.013, 0.001,
3: +    -0.001, 0.000, -0.001, 0.000, 0.001, -0.001, -0.003, 0.000, -0.001, -0.004, -0.000, -0.001,
3: +    0.000, 0.000, 0.000, 0.000,
3: +    0.000, -0.000, 0.000, 0.000, -0.000, 0.001, 0.000, 0.000, -0.000, 0.000, 0.000, -0.000, -0.000,
3: +    0.000, -0.000, 0.000, 0.000, 0.000, -0.000, -0.000, -0.000, -0.000, 0.000, 0.000, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    0.009, 0.014, -0.000, -0.010, 0.013, 0.000, 0.010, -0.010, -0.000, -0.010, -0.010, 0.000,
3: +    -0.001, 0.000, -0.001, 0.000, -0.000, -0.001, -0.001, 0.000, -0.000, -0.003, -0.000, -0.001,
3: +    0.000, 0.000, 0.000, 0.000,
3: +    -0.009, -0.013, 0.000, 0.010, -0.013, 0.000, -0.010, 0.009, 0.000, 0.010, 0.010, -0.000, 0.001,
3: +    -0.000, 0.000, -0.000, 0.000, 0.001, 0.002, 0.000, 0.000, 0.003, 0.000, 0.001, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    -0.000, -0.000, -0.000, 0.000, -0.000, -0.000, -0.000, 0.000, 0.001, 0.000, 0.000, 0.000, 0.000,
3: +    -0.000, 0.000, -0.000, 0.000, -0.000, 0.000, -0.000, 0.000, 0.000, -0.000, -0.000, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    -0.009, -0.014, 0.001, 0.010, -0.013, 0.000, -0.010, 0.010, 0.000, 0.010, 0.010, -0.000, 0.001,
3: +    0.000, 0.000, -0.000, -0.000, 0.001, 0.002, -0.000, 0.000, 0.003, 0.000, 0.001, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    -0.009, -0.014, 0.000, 0.010, -0.013, 0.000, -0.010, 0.010, 0.000, 0.010, 0.010, -0.000, 0.001,
3: +    -0.000, 0.000, -0.000, 0.000, 0.001, 0.002, -0.000, 0.000, 0.003, 0.001, 0.001, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    0.000, 0.001, -0.000, -0.000, 0.001, -0.000, 0.000, -0.000, 0.000, -0.000, -0.000, 0.001, 0.000,
3: +    -0.000, -0.000, -0.000, 0.000, 0.000, -0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    -0.000, -0.001, 0.000, 0.001, -0.001, -0.000, -0.001, 0.001, 0.000, 0.001, 0.001, 0.000, 1.708,
3: +    0.048, 0.784, 0.062, 0.042, 0.053, 0.077, 0.001, -0.061, 0.046, -0.019, -0.029, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    0.000, 0.001, -0.000, 0.000, 0.000, 0.000, 0.000, -0.000, -0.000, 0.000, -0.000, -0.000, 0.048,
3: +    5.001, -1.631, -0.036, 0.144, 0.040, 0.036, 0.016, -0.051, -0.067, -0.024, -0.005, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    -0.000, -0.001, 0.000, 0.000, -0.001, -0.000, -0.001, 0.000, 0.000, 0.000, 0.000, -0.000, 0.784,
3: +    -1.631, 1.242, 0.057, -0.037, 0.018, 0.034, -0.017, -0.015, 0.058, -0.021, -0.029, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    0.000, 0.000, 0.000, 0.001, 0.000, 0.000, 0.000, -0.000, -0.000, -0.000, -0.000, -0.000, 0.062,
3: +    -0.036, 0.057, 6.228, -0.014, 0.932, 0.059, 0.053, -0.069, 0.148, 0.015, -0.031, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    -0.000, 0.000, -0.000, -0.000, 0.001, 0.000, -0.000, 0.000, 0.000, -0.000, 0.000, 0.000, 0.042,
3: +    0.144, -0.037, -0.014, 3.011, 0.986, 0.076, 0.030, -0.052, -0.027, 0.057, 0.051, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    -0.001, -0.001, -0.000, 0.001, -0.001, 0.000, -0.001, 0.001, -0.000, 0.001, 0.001, 0.000, 0.053,
3: +    0.040, 0.018, 0.932, 0.986, 0.885, 0.090, 0.044, -0.055, 0.057, 0.051, -0.003, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    -0.002, -0.003, 0.000, 0.002, -0.003, -0.000, -0.001, 0.002, 0.000, 0.002, 0.002, -0.000, 0.077,
3: +    0.036, 0.034, 0.059, 0.076, 0.090, 6.230, 0.139, 0.763, 0.013, -0.019, -0.024, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    0.000, 0.000, -0.000, -0.000, 0.000, -0.000, 0.000, 0.000, -0.000, -0.000, -0.000, 0.000, 0.001,
3: +    0.016, -0.017, 0.053, 0.030, 0.044, 0.139, 3.130, -1.128, -0.010, 0.131, 0.018, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    -0.000, -0.001, -0.000, 0.000, -0.001, -0.000, -0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
3: +    -0.061, -0.051, -0.015, -0.069, -0.052, -0.055, 0.763, -1.128, 0.866, -0.022, -0.053, 0.007,
3: +    0.000, 0.000, 0.000, 0.000,
3: +    -0.003, -0.004, -0.000, 0.003, -0.004, -0.000, -0.003, 0.003, 0.000, 0.003, 0.003, 0.000, 0.046,
3: +    -0.067, 0.058, 0.148, -0.027, 0.057, 0.013, -0.010, -0.022, 2.437, -0.102, 0.938, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    -0.000, -0.000, 0.000, 0.000, -0.000, 0.000, -0.000, 0.000, -0.000, 0.000, 0.001, 0.000, -0.019,
3: +    -0.024, -0.021, 0.015, 0.057, 0.051, -0.019, 0.131, -0.053, -0.102, 4.944, 1.724, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    -0.001, -0.001, 0.000, 0.001, -0.001, 0.000, -0.001, 0.001, -0.000, 0.001, 0.001, 0.000, -0.029,
3: +    -0.005, -0.029, -0.031, 0.051, -0.003, -0.024, 0.018, 0.007, 0.938, 1.724, 1.569, 0.000, 0.000,
3: +    0.000, 0.000,
3: +    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
3: +    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 1.0, 0.000, 0.000,
3: +    0.000,
3: +    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
3: +    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 1.0, 0.000,
3: +    0.000,
3: +    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
3: +    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 1.0,
3: +    0.000,
3: +    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
3: +    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
3: +    0.000, 1.0;
3: +
3: +  /* A1 Worked */
3: +  _Cu << 268.573, -43.819, -147.211,
3: +    -43.819, 92.949, 58.082,
3: +    -147.211, 58.082, 302.120;
3: +
3: +  _QInit = _Qdig.asDiagonal();
3: +  _QInit += _B * _Cu * _B.transpose();
3: +
3: +  _RCheck = new AvgCov(28, _estName + " R");
3: +  _uCheck = new AvgCov(3, _estName + " u");
3: +
3: +  _vxFilter = new LPFilter(_dt, 3.0);
3: +  _vyFilter = new LPFilter(_dt, 3.0);
3: +  _vzFilter = new LPFilter(_dt, 3.0);
3: +
3: +
3: +  /* ROS odometry publisher */
3: @@ -120 +180 @@
3: -        _pub = _nh.advertise<nav_msgs::Odometry>("odom", 1);
3: +  _pub = _nh.advertise<nav_msgs::Odometry>("odom", 1);
3: @@ -124,3 +184,3 @@
3: -        _nh = rclcpp::Node::make_shared("estimator");
3: -        _pub = _nh->create_publisher<nav_msgs::msg::Odometry>("odom", 1);
3: -        _odomBroadcaster = std::make_shared<tf2_ros::TransformBroadcaster>(_nh); 
3: +  _nh = rclcpp::Node::make_shared("estimator");
3: +  _pub = _nh->create_publisher<nav_msgs::msg::Odometry>("odom", 1);
3: +  _odomBroadcaster = std::make_shared<tf2_ros::TransformBroadcaster>(_nh);
3: @@ -130,22 +190,21 @@
3: -void Estimator::run(){
3: -    _feetH.setZero();
3: -    _feetPosGlobalKine = _robModel->getFeet2BPositions(*_lowState, FrameType::GLOBAL);
3: -    _feetVelGlobalKine = _robModel->getFeet2BVelocities(*_lowState, FrameType::GLOBAL);
3: -
3: -    _Q = _QInit;
3: -    _R = _RInit;
3: -
3: -    for(int i(0); i < 4; ++i){
3: -        if((*_contact)(i) == 0){
3: -            _Q.block(6+3*i, 6+3*i, 3, 3) = _largeVariance * I3;
3: -            _R.block(12+3*i, 12+3*i, 3, 3) = _largeVariance * I3;
3: -            _R(24+i, 24+i) = _largeVariance;
3: -        }
3: -        else{
3: -            _trust = windowFunc((*_phase)(i), 0.2);
3: -            _Q.block(6+3*i, 6+3*i, 3, 3) = (1 + (1-_trust)*_largeVariance) * _QInit.block(6+3*i, 6+3*i, 3, 3);
3: -            _R.block(12+3*i, 12+3*i, 3, 3) = (1 + (1-_trust)*_largeVariance) * _RInit.block(12+3*i, 12+3*i, 3, 3);
3: -            _R(24+i, 24+i) = (1 + (1-_trust)*_largeVariance) * _RInit(24+i, 24+i);
3: -        }
3: -        _feetPos2Body.segment(3*i, 3) = _feetPosGlobalKine.col(i);
3: -        _feetVel2Body.segment(3*i, 3) = _feetVelGlobalKine.col(i);
3: +void Estimator::run()
3: +{
3: +  _feetH.setZero();
3: +  _feetPosGlobalKine = _robModel->getFeet2BPositions(*_lowState, FrameType::GLOBAL);
3: +  _feetVelGlobalKine = _robModel->getFeet2BVelocities(*_lowState, FrameType::GLOBAL);
3: +
3: +  _Q = _QInit;
3: +  _R = _RInit;
3: +
3: +  for (int i(0); i < 4; ++i) {
3: +    if ((*_contact)(i) == 0) {
3: +      _Q.block(6 + 3 * i, 6 + 3 * i, 3, 3) = _largeVariance * I3;
3: +      _R.block(12 + 3 * i, 12 + 3 * i, 3, 3) = _largeVariance * I3;
3: +      _R(24 + i, 24 + i) = _largeVariance;
3: +    } else {
3: +      _trust = windowFunc((*_phase)(i), 0.2);
3: +      _Q.block(6 + 3 * i, 6 + 3 * i, 3, 3) = (1 + (1 - _trust) * _largeVariance) * _QInit.block(
3: +        6 + 3 * i, 6 + 3 * i, 3, 3);
3: +      _R.block(12 + 3 * i, 12 + 3 * i, 3, 3) = (1 + (1 - _trust) * _largeVariance) * _RInit.block(
3: +        12 + 3 * i, 12 + 3 * i, 3, 3);
3: +      _R(24 + i, 24 + i) = (1 + (1 - _trust) * _largeVariance) * _RInit(24 + i, 24 + i);
3: @@ -153,23 +212,26 @@
3: -
3: -    _rotMatB2G = _lowState->getRotMat();
3: -    _u = _rotMatB2G * _lowState->getAcc() + _g;
3: -    _xhat = _A * _xhat + _B * _u;
3: -    _yhat = _C * _xhat;
3: -    _y << _feetPos2Body, _feetVel2Body, _feetH;
3: -
3: -    _Ppriori = _A * _P * _A.transpose() + _Q;
3: -    _S =  _R + _C * _Ppriori * _C.transpose();
3: -    _Slu = _S.lu();
3: -    _Sy = _Slu.solve(_y - _yhat);
3: -    _Sc = _Slu.solve(_C);
3: -    _SR = _Slu.solve(_R);
3: -    _STC = (_S.transpose()).lu().solve(_C);
3: -    _IKC = I18 - _Ppriori*_C.transpose()*_Sc;
3: -
3: -    _xhat += _Ppriori * _C.transpose() * _Sy;
3: -    _P =  _IKC * _Ppriori * _IKC.transpose()
3: -        + _Ppriori * _C.transpose() * _SR * _STC * _Ppriori.transpose();
3: -
3: -    _vxFilter->addValue(_xhat(3));
3: -    _vyFilter->addValue(_xhat(4));
3: -    _vzFilter->addValue(_xhat(5));
3: +    _feetPos2Body.segment(3 * i, 3) = _feetPosGlobalKine.col(i);
3: +    _feetVel2Body.segment(3 * i, 3) = _feetVelGlobalKine.col(i);
3: +  }
3: +
3: +  _rotMatB2G = _lowState->getRotMat();
3: +  _u = _rotMatB2G * _lowState->getAcc() + _g;
3: +  _xhat = _A * _xhat + _B * _u;
3: +  _yhat = _C * _xhat;
3: +  _y << _feetPos2Body, _feetVel2Body, _feetH;
3: +
3: +  _Ppriori = _A * _P * _A.transpose() + _Q;
3: +  _S = _R + _C * _Ppriori * _C.transpose();
3: +  _Slu = _S.lu();
3: +  _Sy = _Slu.solve(_y - _yhat);
3: +  _Sc = _Slu.solve(_C);
3: +  _SR = _Slu.solve(_R);
3: +  _STC = (_S.transpose()).lu().solve(_C);
3: +  _IKC = I18 - _Ppriori * _C.transpose() * _Sc;
3: +
3: +  _xhat += _Ppriori * _C.transpose() * _Sy;
3: +  _P = _IKC * _Ppriori * _IKC.transpose() +
3: +    _Ppriori * _C.transpose() * _SR * _STC * _Ppriori.transpose();
3: +
3: +  _vxFilter->addValue(_xhat(3));
3: +  _vyFilter->addValue(_xhat(4));
3: +  _vzFilter->addValue(_xhat(5));
3: @@ -178,46 +240,46 @@
3: -        if(_count % ((int)( 1.0/(_dt*_pubFreq))) == 0){
3: -            _currentTime = ros::Time::now();
3: -            /* tf */
3: -            _odomTF.header.stamp = _currentTime;
3: -            _odomTF.header.frame_id = "odom";
3: -            _odomTF.child_frame_id  = "base_link";
3: -
3: -            _odomTF.transform.translation.x = _xhat(0);
3: -            _odomTF.transform.translation.y = _xhat(1);
3: -            _odomTF.transform.translation.z = _xhat(2);
3: -            _odomTF.transform.rotation.w = _lowState->imu.quaternion[0];
3: -            _odomTF.transform.rotation.x = _lowState->imu.quaternion[1];
3: -            _odomTF.transform.rotation.y = _lowState->imu.quaternion[2];
3: -            _odomTF.transform.rotation.z = _lowState->imu.quaternion[3];
3: -
3: -            _odomBroadcaster.sendTransform(_odomTF);
3: -
3: -            /* odometry */
3: -            _odomMsg.header.stamp = _currentTime;
3: -            _odomMsg.header.frame_id = "odom";
3: -
3: -            _odomMsg.pose.pose.position.x = _xhat(0);
3: -            _odomMsg.pose.pose.position.y = _xhat(1);
3: -            _odomMsg.pose.pose.position.z = _xhat(2);
3: -
3: -            _odomMsg.pose.pose.orientation.w = _lowState->imu.quaternion[0];
3: -            _odomMsg.pose.pose.orientation.x = _lowState->imu.quaternion[1];
3: -            _odomMsg.pose.pose.orientation.y = _lowState->imu.quaternion[2];
3: -            _odomMsg.pose.pose.orientation.z = _lowState->imu.quaternion[3];
3: -            _odomMsg.pose.covariance = _odom_pose_covariance;
3: -
3: -            _odomMsg.child_frame_id = "base_link";
3: -            _velBody = _rotMatB2G.transpose() * _xhat.segment(3, 3);
3: -            _wBody   = _lowState->imu.getGyro();
3: -            _odomMsg.twist.twist.linear.x = _velBody(0);
3: -            _odomMsg.twist.twist.linear.y = _velBody(1);
3: -            _odomMsg.twist.twist.linear.z = _velBody(2);
3: -            _odomMsg.twist.twist.angular.x = _wBody(0);
3: -            _odomMsg.twist.twist.angular.y = _wBody(1);
3: -            _odomMsg.twist.twist.angular.z = _wBody(2);
3: -            _odomMsg.twist.covariance = _odom_twist_covariance;
3: -
3: -            _pub.publish(_odomMsg);
3: -            _count = 1;
3: -        }
3: -        ++_count;
3: +  if (_count % ((int)( 1.0 / (_dt * _pubFreq))) == 0) {
3: +    _currentTime = ros::Time::now();
3: +    /* tf */
3: +    _odomTF.header.stamp = _currentTime;
3: +    _odomTF.header.frame_id = "odom";
3: +    _odomTF.child_frame_id = "base_link";
3: +
3: +    _odomTF.transform.translation.x = _xhat(0);
3: +    _odomTF.transform.translation.y = _xhat(1);
3: +    _odomTF.transform.translation.z = _xhat(2);
3: +    _odomTF.transform.rotation.w = _lowState->imu.quaternion[0];
3: +    _odomTF.transform.rotation.x = _lowState->imu.quaternion[1];
3: +    _odomTF.transform.rotation.y = _lowState->imu.quaternion[2];
3: +    _odomTF.transform.rotation.z = _lowState->imu.quaternion[3];
3: +
3: +    _odomBroadcaster.sendTransform(_odomTF);
3: +
3: +    /* odometry */
3: +    _odomMsg.header.stamp = _currentTime;
3: +    _odomMsg.header.frame_id = "odom";
3: +
3: +    _odomMsg.pose.pose.position.x = _xhat(0);
3: +    _odomMsg.pose.pose.position.y = _xhat(1);
3: +    _odomMsg.pose.pose.position.z = _xhat(2);
3: +
3: +    _odomMsg.pose.pose.orientation.w = _lowState->imu.quaternion[0];
3: +    _odomMsg.pose.pose.orientation.x = _lowState->imu.quaternion[1];
3: +    _odomMsg.pose.pose.orientation.y = _lowState->imu.quaternion[2];
3: +    _odomMsg.pose.pose.orientation.z = _lowState->imu.quaternion[3];
3: +    _odomMsg.pose.covariance = _odom_pose_covariance;
3: +
3: +    _odomMsg.child_frame_id = "base_link";
3: +    _velBody = _rotMatB2G.transpose() * _xhat.segment(3, 3);
3: +    _wBody = _lowState->imu.getGyro();
3: +    _odomMsg.twist.twist.linear.x = _velBody(0);
3: +    _odomMsg.twist.twist.linear.y = _velBody(1);
3: +    _odomMsg.twist.twist.linear.z = _velBody(2);
3: +    _odomMsg.twist.twist.angular.x = _wBody(0);
3: +    _odomMsg.twist.twist.angular.y = _wBody(1);
3: +    _odomMsg.twist.twist.angular.z = _wBody(2);
3: +    _odomMsg.twist.covariance = _odom_twist_covariance;
3: +
3: +    _pub.publish(_odomMsg);
3: +    _count = 1;
3: +  }
3: +  ++_count;
3: @@ -227,46 +289,46 @@
3: -        if(_count % ((int)( 1.0/(_dt*_pubFreq))) == 0){
3: -            _currentTime = _nh->get_clock()->now();
3: -            /* tf */
3: -            _odomTF.header.stamp = _currentTime;
3: -            _odomTF.header.frame_id = "odom";
3: -            _odomTF.child_frame_id  = "base";
3: -
3: -            _odomTF.transform.translation.x = _xhat(0);
3: -            _odomTF.transform.translation.y = _xhat(1);
3: -            _odomTF.transform.translation.z = _xhat(2);
3: -            _odomTF.transform.rotation.w = _lowState->imu.quaternion[0];
3: -            _odomTF.transform.rotation.x = _lowState->imu.quaternion[1];
3: -            _odomTF.transform.rotation.y = _lowState->imu.quaternion[2];
3: -            _odomTF.transform.rotation.z = _lowState->imu.quaternion[3];
3: -
3: -            // _odomBroadcaster->sendTransform(_odomTF);
3: -
3: -            /* odometry */
3: -            _odomMsg.header.stamp = _currentTime;
3: -            _odomMsg.header.frame_id = "odom";
3: -
3: -            _odomMsg.pose.pose.position.x = _xhat(0);
3: -            _odomMsg.pose.pose.position.y = _xhat(1);
3: -            _odomMsg.pose.pose.position.z = _xhat(2);
3: -
3: -            _odomMsg.pose.pose.orientation.w = _lowState->imu.quaternion[0];
3: -            _odomMsg.pose.pose.orientation.x = _lowState->imu.quaternion[1];
3: -            _odomMsg.pose.pose.orientation.y = _lowState->imu.quaternion[2];
3: -            _odomMsg.pose.pose.orientation.z = _lowState->imu.quaternion[3];
3: -            _odomMsg.pose.covariance = _odom_pose_covariance;
3: -
3: -            _odomMsg.child_frame_id = "base";
3: -            _velBody = _rotMatB2G.transpose() * _xhat.segment(3, 3);
3: -            _wBody   = _lowState->imu.getGyro();
3: -            _odomMsg.twist.twist.linear.x = _velBody(0);
3: -            _odomMsg.twist.twist.linear.y = _velBody(1);
3: -            _odomMsg.twist.twist.linear.z = _velBody(2);
3: -            _odomMsg.twist.twist.angular.x = _wBody(0);
3: -            _odomMsg.twist.twist.angular.y = _wBody(1);
3: -            _odomMsg.twist.twist.angular.z = _wBody(2);
3: -            _odomMsg.twist.covariance = _odom_twist_covariance;
3: -
3: -            // _pub->publish(_odomMsg);
3: -            _count = 1;
3: -        }
3: -        ++_count;
3: +  if (_count % ((int)( 1.0 / (_dt * _pubFreq))) == 0) {
3: +    _currentTime = _nh->get_clock()->now();
3: +    /* tf */
3: +    _odomTF.header.stamp = _currentTime;
3: +    _odomTF.header.frame_id = "odom";
3: +    _odomTF.child_frame_id = "base";
3: +
3: +    _odomTF.transform.translation.x = _xhat(0);
3: +    _odomTF.transform.translation.y = _xhat(1);
3: +    _odomTF.transform.translation.z = _xhat(2);
3: +    _odomTF.transform.rotation.w = _lowState->imu.quaternion[0];
3: +    _odomTF.transform.rotation.x = _lowState->imu.quaternion[1];
3: +    _odomTF.transform.rotation.y = _lowState->imu.quaternion[2];
3: +    _odomTF.transform.rotation.z = _lowState->imu.quaternion[3];
3: +
3: +    // _odomBroadcaster->sendTransform(_odomTF);
3: +
3: +    /* odometry */
3: +    _odomMsg.header.stamp = _currentTime;
3: +    _odomMsg.header.frame_id = "odom";
3: +
3: +    _odomMsg.pose.pose.position.x = _xhat(0);
3: +    _odomMsg.pose.pose.position.y = _xhat(1);
3: +    _odomMsg.pose.pose.position.z = _xhat(2);
3: +
3: +    _odomMsg.pose.pose.orientation.w = _lowState->imu.quaternion[0];
3: +    _odomMsg.pose.pose.orientation.x = _lowState->imu.quaternion[1];
3: +    _odomMsg.pose.pose.orientation.y = _lowState->imu.quaternion[2];
3: +    _odomMsg.pose.pose.orientation.z = _lowState->imu.quaternion[3];
3: +    _odomMsg.pose.covariance = _odom_pose_covariance;
3: +
3: +    _odomMsg.child_frame_id = "base";
3: +    _velBody = _rotMatB2G.transpose() * _xhat.segment(3, 3);
3: +    _wBody = _lowState->imu.getGyro();
3: +    _odomMsg.twist.twist.linear.x = _velBody(0);
3: +    _odomMsg.twist.twist.linear.y = _velBody(1);
3: +    _odomMsg.twist.twist.linear.z = _velBody(2);
3: +    _odomMsg.twist.twist.angular.x = _wBody(0);
3: +    _odomMsg.twist.twist.angular.y = _wBody(1);
3: +    _odomMsg.twist.twist.angular.z = _wBody(2);
3: +    _odomMsg.twist.covariance = _odom_twist_covariance;
3: +
3: +    // _pub->publish(_odomMsg);
3: +    _count = 1;
3: +  }
3: +  ++_count;
3: @@ -276,36 +338,43 @@
3: -Vec3 Estimator::getPosition(){
3: -    return _xhat.segment(0, 3);
3: -}
3: -
3: -Vec3 Estimator::getVelocity(){
3: -    return _xhat.segment(3, 3);
3: -}
3: -
3: -Vec3 Estimator::getFootPos(int i){
3: -    return getPosition() + _lowState->getRotMat() * _robModel->getFootPosition(*_lowState, i, FrameType::BODY);
3: -}
3: -
3: -Vec34 Estimator::getFeetPos(){
3: -    Vec34 feetPos;
3: -    for(int i(0); i < 4; ++i){
3: -        feetPos.col(i) = getFootPos(i);
3: -    }
3: -    return feetPos;
3: -}
3: -
3: -Vec34 Estimator::getFeetVel(){
3: -    Vec34 feetVel = _robModel->getFeet2BVelocities(*_lowState, FrameType::GLOBAL);
3: -    for(int i(0); i < 4; ++i){
3: -        feetVel.col(i) += getVelocity();
3: -    }
3: -    return feetVel;
3: -}
3: -
3: -Vec34 Estimator::getPosFeet2BGlobal(){
3: -    Vec34 feet2BPos;
3: -    for(int i(0); i < 4; ++i){
3: -        feet2BPos.col(i) = getFootPos(i) - getPosition();
3: -    }
3: -    return feet2BPos;
3: -}
3: -
3: +Vec3 Estimator::getPosition()
3: +{
3: +  return _xhat.segment(0, 3);
3: +}
3: +
3: +Vec3 Estimator::getVelocity()
3: +{
3: +  return _xhat.segment(3, 3);
3: +}
3: +
3: +Vec3 Estimator::getFootPos(int i)
3: +{
3: +  return getPosition() + _lowState->getRotMat() * _robModel->getFootPosition(
3: +    *_lowState, i,
3: +    FrameType::BODY);
3: +}
3: +
3: +Vec34 Estimator::getFeetPos()
3: +{
3: +  Vec34 feetPos;
3: +  for (int i(0); i < 4; ++i) {
3: +    feetPos.col(i) = getFootPos(i);
3: +  }
3: +  return feetPos;
3: +}
3: +
3: +Vec34 Estimator::getFeetVel()
3: +{
3: +  Vec34 feetVel = _robModel->getFeet2BVelocities(*_lowState, FrameType::GLOBAL);
3: +  for (int i(0); i < 4; ++i) {
3: +    feetVel.col(i) += getVelocity();
3: +  }
3: +  return feetVel;
3: +}
3: +
3: +Vec34 Estimator::getPosFeet2BGlobal()
3: +{
3: +  Vec34 feet2BPos;
3: +  for (int i(0); i < 4; ++i) {
3: +    feet2BPos.col(i) = getFootPos(i) - getPosition();
3: +  }
3: +  return feet2BPos;
3: +}
3: 
3: Code style divergence in file 'src/interface/IOROS.cpp':
3: 
3: --- src/interface/IOROS.cpp
3: +++ src/interface/IOROS.cpp.uncrustify
3: @@ -12,95 +12,140 @@
3: -void RosShutDown(int sig){
3: -	ROS_INFO("ROS interface shutting down!");
3: -	ros::shutdown();
3: -}
3: -
3: -IOROS::IOROS():IOInterface(){
3: -    std::cout << "The control interface for ROS 2 Gazebo simulation" << std::endl;
3: -    ros::param::get("/robot_name", _robot_name);
3: -    std::cout << "robot_name: " << _robot_name << std::endl;
3: -
3: -    // start subscriber
3: -    initRecv();
3: -    ros::AsyncSpinner subSpinner(1); // one threads
3: -    subSpinner.start();
3: -    usleep(300000);     //wait for subscribers start
3: -    // initialize publisher
3: -    initSend();   
3: -
3: -    signal(SIGINT, RosShutDown);
3: -
3: -    cmdPanel = new KeyBoard();
3: -}
3: -
3: -IOROS::~IOROS(){
3: -    delete cmdPanel;
3: -    ros::shutdown();
3: -}
3: -
3: -void IOROS::sendRecv(const LowlevelCmd *cmd, LowlevelState *state){
3: -    sendCmd(cmd);
3: -    recvState(state);
3: -
3: -    state->userCmd = cmdPanel->getUserCmd();
3: -    state->userValue = cmdPanel->getUserValue();
3: -}
3: -
3: -void IOROS::sendCmd(const LowlevelCmd *lowCmd){
3: -    for(int i(0); i < 12; ++i){
3: -        _lowCmd.motorCmd[i].mode = lowCmd->motorCmd[i].mode;
3: -        _lowCmd.motorCmd[i].q = lowCmd->motorCmd[i].q;
3: -        _lowCmd.motorCmd[i].dq = lowCmd->motorCmd[i].dq;
3: -        _lowCmd.motorCmd[i].tau = lowCmd->motorCmd[i].tau;
3: -        _lowCmd.motorCmd[i].Kd = lowCmd->motorCmd[i].Kd;
3: -        _lowCmd.motorCmd[i].Kp = lowCmd->motorCmd[i].Kp;
3: -    }
3: -    for(int m(0); m < 12; ++m){
3: -        _servo_pub[m].publish(_lowCmd.motorCmd[m]);
3: -    }
3: -    ros::spinOnce();
3: -}
3: -
3: -void IOROS::recvState(LowlevelState *state){
3: -    for(int i(0); i < 12; ++i){
3: -        state->motorState[i].q = _lowState.motorState[i].q;
3: -        state->motorState[i].dq = _lowState.motorState[i].dq;
3: -        state->motorState[i].ddq = _lowState.motorState[i].ddq;
3: -        state->motorState[i].tauEst = _lowState.motorState[i].tauEst;
3: -    }
3: -    for(int i(0); i < 3; ++i){
3: -        state->imu.quaternion[i] = _lowState.imu.quaternion[i];
3: -        state->imu.accelerometer[i] = _lowState.imu.accelerometer[i];
3: -        state->imu.gyroscope[i] = _lowState.imu.gyroscope[i];
3: -    }
3: -    state->imu.quaternion[3] = _lowState.imu.quaternion[3];
3: -}
3: -
3: -void IOROS::initSend(){
3: -    _servo_pub[0] = _nm.advertise<unitree_legged_msgs::MotorCmd>("/" + _robot_name + "_gazebo/FR_hip_controller/command", 1);
3: -    _servo_pub[1] = _nm.advertise<unitree_legged_msgs::MotorCmd>("/" + _robot_name + "_gazebo/FR_thigh_controller/command", 1);
3: -    _servo_pub[2] = _nm.advertise<unitree_legged_msgs::MotorCmd>("/" + _robot_name + "_gazebo/FR_calf_controller/command", 1);
3: -    _servo_pub[3] = _nm.advertise<unitree_legged_msgs::MotorCmd>("/" + _robot_name + "_gazebo/FL_hip_controller/command", 1);
3: -    _servo_pub[4] = _nm.advertise<unitree_legged_msgs::MotorCmd>("/" + _robot_name + "_gazebo/FL_thigh_controller/command", 1);
3: -    _servo_pub[5] = _nm.advertise<unitree_legged_msgs::MotorCmd>("/" + _robot_name + "_gazebo/FL_calf_controller/command", 1);
3: -    _servo_pub[6] = _nm.advertise<unitree_legged_msgs::MotorCmd>("/" + _robot_name + "_gazebo/RR_hip_controller/command", 1);
3: -    _servo_pub[7] = _nm.advertise<unitree_legged_msgs::MotorCmd>("/" + _robot_name + "_gazebo/RR_thigh_controller/command", 1);
3: -    _servo_pub[8] = _nm.advertise<unitree_legged_msgs::MotorCmd>("/" + _robot_name + "_gazebo/RR_calf_controller/command", 1);
3: -    _servo_pub[9] = _nm.advertise<unitree_legged_msgs::MotorCmd>("/" + _robot_name + "_gazebo/RL_hip_controller/command", 1);
3: -    _servo_pub[10] = _nm.advertise<unitree_legged_msgs::MotorCmd>("/" + _robot_name + "_gazebo/RL_thigh_controller/command", 1);
3: -    _servo_pub[11] = _nm.advertise<unitree_legged_msgs::MotorCmd>("/" + _robot_name + "_gazebo/RL_calf_controller/command", 1);
3: -}
3: -
3: -void IOROS::initRecv(){
3: -    _imu_sub = _nm.subscribe("/trunk_imu", 1, &IOROS::imuCallback, this);
3: -    _servo_sub[0] = _nm.subscribe("/" + _robot_name + "_gazebo/FR_hip_controller/state", 1, &IOROS::FRhipCallback, this);
3: -    _servo_sub[1] = _nm.subscribe("/" + _robot_name + "_gazebo/FR_thigh_controller/state", 1, &IOROS::FRthighCallback, this);
3: -    _servo_sub[2] = _nm.subscribe("/" + _robot_name + "_gazebo/FR_calf_controller/state", 1, &IOROS::FRcalfCallback, this);
3: -    _servo_sub[3] = _nm.subscribe("/" + _robot_name + "_gazebo/FL_hip_controller/state", 1, &IOROS::FLhipCallback, this);
3: -    _servo_sub[4] = _nm.subscribe("/" + _robot_name + "_gazebo/FL_thigh_controller/state", 1, &IOROS::FLthighCallback, this);
3: -    _servo_sub[5] = _nm.subscribe("/" + _robot_name + "_gazebo/FL_calf_controller/state", 1, &IOROS::FLcalfCallback, this);
3: -    _servo_sub[6] = _nm.subscribe("/" + _robot_name + "_gazebo/RR_hip_controller/state", 1, &IOROS::RRhipCallback, this);
3: -    _servo_sub[7] = _nm.subscribe("/" + _robot_name + "_gazebo/RR_thigh_controller/state", 1, &IOROS::RRthighCallback, this);
3: -    _servo_sub[8] = _nm.subscribe("/" + _robot_name + "_gazebo/RR_calf_controller/state", 1, &IOROS::RRcalfCallback, this);
3: -    _servo_sub[9] = _nm.subscribe("/" + _robot_name + "_gazebo/RL_hip_controller/state", 1, &IOROS::RLhipCallback, this);
3: -    _servo_sub[10] = _nm.subscribe("/" + _robot_name + "_gazebo/RL_thigh_controller/state", 1, &IOROS::RLthighCallback, this);
3: -    _servo_sub[11] = _nm.subscribe("/" + _robot_name + "_gazebo/RL_calf_controller/state", 1, &IOROS::RLcalfCallback, this);
3: +void RosShutDown(int sig)
3: +{
3: +  ROS_INFO("ROS interface shutting down!");
3: +  ros::shutdown();
3: +}
3: +
3: +IOROS::IOROS()
3: +: IOInterface()
3: +{
3: +  std::cout << "The control interface for ROS 2 Gazebo simulation" << std::endl;
3: +  ros::param::get("/robot_name", _robot_name);
3: +  std::cout << "robot_name: " << _robot_name << std::endl;
3: +
3: +  // start subscriber
3: +  initRecv();
3: +  ros::AsyncSpinner subSpinner(1);   // one threads
3: +  subSpinner.start();
3: +  usleep(300000);       //wait for subscribers start
3: +  // initialize publisher
3: +  initSend();
3: +
3: +  signal(SIGINT, RosShutDown);
3: +
3: +  cmdPanel = new KeyBoard();
3: +}
3: +
3: +IOROS::~IOROS()
3: +{
3: +  delete cmdPanel;
3: +  ros::shutdown();
3: +}
3: +
3: +void IOROS::sendRecv(const LowlevelCmd * cmd, LowlevelState * state)
3: +{
3: +  sendCmd(cmd);
3: +  recvState(state);
3: +
3: +  state->userCmd = cmdPanel->getUserCmd();
3: +  state->userValue = cmdPanel->getUserValue();
3: +}
3: +
3: +void IOROS::sendCmd(const LowlevelCmd * lowCmd)
3: +{
3: +  for (int i(0); i < 12; ++i) {
3: +    _lowCmd.motorCmd[i].mode = lowCmd->motorCmd[i].mode;
3: +    _lowCmd.motorCmd[i].q = lowCmd->motorCmd[i].q;
3: +    _lowCmd.motorCmd[i].dq = lowCmd->motorCmd[i].dq;
3: +    _lowCmd.motorCmd[i].tau = lowCmd->motorCmd[i].tau;
3: +    _lowCmd.motorCmd[i].Kd = lowCmd->motorCmd[i].Kd;
3: +    _lowCmd.motorCmd[i].Kp = lowCmd->motorCmd[i].Kp;
3: +  }
3: +  for (int m(0); m < 12; ++m) {
3: +    _servo_pub[m].publish(_lowCmd.motorCmd[m]);
3: +  }
3: +  ros::spinOnce();
3: +}
3: +
3: +void IOROS::recvState(LowlevelState * state)
3: +{
3: +  for (int i(0); i < 12; ++i) {
3: +    state->motorState[i].q = _lowState.motorState[i].q;
3: +    state->motorState[i].dq = _lowState.motorState[i].dq;
3: +    state->motorState[i].ddq = _lowState.motorState[i].ddq;
3: +    state->motorState[i].tauEst = _lowState.motorState[i].tauEst;
3: +  }
3: +  for (int i(0); i < 3; ++i) {
3: +    state->imu.quaternion[i] = _lowState.imu.quaternion[i];
3: +    state->imu.accelerometer[i] = _lowState.imu.accelerometer[i];
3: +    state->imu.gyroscope[i] = _lowState.imu.gyroscope[i];
3: +  }
3: +  state->imu.quaternion[3] = _lowState.imu.quaternion[3];
3: +}
3: +
3: +void IOROS::initSend()
3: +{
3: +  _servo_pub[0] = _nm.advertise<unitree_legged_msgs::MotorCmd>(
3: +    "/" + _robot_name + "_gazebo/FR_hip_controller/command", 1);
3: +  _servo_pub[1] = _nm.advertise<unitree_legged_msgs::MotorCmd>(
3: +    "/" + _robot_name + "_gazebo/FR_thigh_controller/command", 1);
3: +  _servo_pub[2] = _nm.advertise<unitree_legged_msgs::MotorCmd>(
3: +    "/" + _robot_name + "_gazebo/FR_calf_controller/command", 1);
3: +  _servo_pub[3] = _nm.advertise<unitree_legged_msgs::MotorCmd>(
3: +    "/" + _robot_name + "_gazebo/FL_hip_controller/command", 1);
3: +  _servo_pub[4] = _nm.advertise<unitree_legged_msgs::MotorCmd>(
3: +    "/" + _robot_name + "_gazebo/FL_thigh_controller/command", 1);
3: +  _servo_pub[5] = _nm.advertise<unitree_legged_msgs::MotorCmd>(
3: +    "/" + _robot_name + "_gazebo/FL_calf_controller/command", 1);
3: +  _servo_pub[6] = _nm.advertise<unitree_legged_msgs::MotorCmd>(
3: +    "/" + _robot_name + "_gazebo/RR_hip_controller/command", 1);
3: +  _servo_pub[7] = _nm.advertise<unitree_legged_msgs::MotorCmd>(
3: +    "/" + _robot_name + "_gazebo/RR_thigh_controller/command", 1);
3: +  _servo_pub[8] = _nm.advertise<unitree_legged_msgs::MotorCmd>(
3: +    "/" + _robot_name + "_gazebo/RR_calf_controller/command", 1);
3: +  _servo_pub[9] = _nm.advertise<unitree_legged_msgs::MotorCmd>(
3: +    "/" + _robot_name + "_gazebo/RL_hip_controller/command", 1);
3: +  _servo_pub[10] = _nm.advertise<unitree_legged_msgs::MotorCmd>(
3: +    "/" + _robot_name + "_gazebo/RL_thigh_controller/command", 1);
3: +  _servo_pub[11] = _nm.advertise<unitree_legged_msgs::MotorCmd>(
3: +    "/" + _robot_name + "_gazebo/RL_calf_controller/command", 1);
3: +}
3: +
3: +void IOROS::initRecv()
3: +{
3: +  _imu_sub = _nm.subscribe("/trunk_imu", 1, &IOROS::imuCallback, this);
3: +  _servo_sub[0] = _nm.subscribe(
3: +    "/" + _robot_name + "_gazebo/FR_hip_controller/state", 1,
3: +    &IOROS::FRhipCallback, this);
3: +  _servo_sub[1] = _nm.subscribe(
3: +    "/" + _robot_name + "_gazebo/FR_thigh_controller/state", 1,
3: +    &IOROS::FRthighCallback, this);
3: +  _servo_sub[2] = _nm.subscribe(
3: +    "/" + _robot_name + "_gazebo/FR_calf_controller/state", 1,
3: +    &IOROS::FRcalfCallback, this);
3: +  _servo_sub[3] = _nm.subscribe(
3: +    "/" + _robot_name + "_gazebo/FL_hip_controller/state", 1,
3: +    &IOROS::FLhipCallback, this);
3: +  _servo_sub[4] = _nm.subscribe(
3: +    "/" + _robot_name + "_gazebo/FL_thigh_controller/state", 1,
3: +    &IOROS::FLthighCallback, this);
3: +  _servo_sub[5] = _nm.subscribe(
3: +    "/" + _robot_name + "_gazebo/FL_calf_controller/state", 1,
3: +    &IOROS::FLcalfCallback, this);
3: +  _servo_sub[6] = _nm.subscribe(
3: +    "/" + _robot_name + "_gazebo/RR_hip_controller/state", 1,
3: +    &IOROS::RRhipCallback, this);
3: +  _servo_sub[7] = _nm.subscribe(
3: +    "/" + _robot_name + "_gazebo/RR_thigh_controller/state", 1,
3: +    &IOROS::RRthighCallback, this);
3: +  _servo_sub[8] = _nm.subscribe(
3: +    "/" + _robot_name + "_gazebo/RR_calf_controller/state", 1,
3: +    &IOROS::RRcalfCallback, this);
3: +  _servo_sub[9] = _nm.subscribe(
3: +    "/" + _robot_name + "_gazebo/RL_hip_controller/state", 1,
3: +    &IOROS::RLhipCallback, this);
3: +  _servo_sub[10] = _nm.subscribe(
3: +    "/" + _robot_name + "_gazebo/RL_thigh_controller/state", 1,
3: +    &IOROS::RLthighCallback, this);
3: +  _servo_sub[11] = _nm.subscribe(
3: +    "/" + _robot_name + "_gazebo/RL_calf_controller/state", 1,
3: +    &IOROS::RLcalfCallback, this);
3: @@ -110,109 +155,109 @@
3: -{ 
3: -    _lowState.imu.quaternion[0] = msg.orientation.w;
3: -    _lowState.imu.quaternion[1] = msg.orientation.x;
3: -    _lowState.imu.quaternion[2] = msg.orientation.y;
3: -    _lowState.imu.quaternion[3] = msg.orientation.z;
3: -
3: -    _lowState.imu.gyroscope[0] = msg.angular_velocity.x;
3: -    _lowState.imu.gyroscope[1] = msg.angular_velocity.y;
3: -    _lowState.imu.gyroscope[2] = msg.angular_velocity.z;
3: -    
3: -    _lowState.imu.accelerometer[0] = msg.linear_acceleration.x;
3: -    _lowState.imu.accelerometer[1] = msg.linear_acceleration.y;
3: -    _lowState.imu.accelerometer[2] = msg.linear_acceleration.z;
3: -}
3: -
3: -void IOROS::FRhipCallback(const unitree_legged_msgs::MotorState& msg)
3: -{
3: -    _lowState.motorState[0].mode = msg.mode;
3: -    _lowState.motorState[0].q = msg.q;
3: -    _lowState.motorState[0].dq = msg.dq;
3: -    _lowState.motorState[0].tauEst = msg.tauEst;
3: -}
3: -
3: -void IOROS::FRthighCallback(const unitree_legged_msgs::MotorState& msg)
3: -{
3: -    _lowState.motorState[1].mode = msg.mode;
3: -    _lowState.motorState[1].q = msg.q;
3: -    _lowState.motorState[1].dq = msg.dq;
3: -    _lowState.motorState[1].tauEst = msg.tauEst;
3: -}
3: -
3: -void IOROS::FRcalfCallback(const unitree_legged_msgs::MotorState& msg)
3: -{
3: -    _lowState.motorState[2].mode = msg.mode;
3: -    _lowState.motorState[2].q = msg.q;
3: -    _lowState.motorState[2].dq = msg.dq;
3: -    _lowState.motorState[2].tauEst = msg.tauEst;
3: -}
3: -
3: -void IOROS::FLhipCallback(const unitree_legged_msgs::MotorState& msg)
3: -{
3: -    _lowState.motorState[3].mode = msg.mode;
3: -    _lowState.motorState[3].q = msg.q;
3: -    _lowState.motorState[3].dq = msg.dq;
3: -    _lowState.motorState[3].tauEst = msg.tauEst;
3: -}
3: -
3: -void IOROS::FLthighCallback(const unitree_legged_msgs::MotorState& msg)
3: -{
3: -    _lowState.motorState[4].mode = msg.mode;
3: -    _lowState.motorState[4].q = msg.q;
3: -    _lowState.motorState[4].dq = msg.dq;
3: -    _lowState.motorState[4].tauEst = msg.tauEst;
3: -}
3: -
3: -void IOROS::FLcalfCallback(const unitree_legged_msgs::MotorState& msg)
3: -{
3: -    _lowState.motorState[5].mode = msg.mode;
3: -    _lowState.motorState[5].q = msg.q;
3: -    _lowState.motorState[5].dq = msg.dq;
3: -    _lowState.motorState[5].tauEst = msg.tauEst;
3: -}
3: -
3: -void IOROS::RRhipCallback(const unitree_legged_msgs::MotorState& msg)
3: -{
3: -    _lowState.motorState[6].mode = msg.mode;
3: -    _lowState.motorState[6].q = msg.q;
3: -    _lowState.motorState[6].dq = msg.dq;
3: -    _lowState.motorState[6].tauEst = msg.tauEst;
3: -}
3: -
3: -void IOROS::RRthighCallback(const unitree_legged_msgs::MotorState& msg)
3: -{
3: -    _lowState.motorState[7].mode = msg.mode;
3: -    _lowState.motorState[7].q = msg.q;
3: -    _lowState.motorState[7].dq = msg.dq;
3: -    _lowState.motorState[7].tauEst = msg.tauEst;
3: -}
3: -
3: -void IOROS::RRcalfCallback(const unitree_legged_msgs::MotorState& msg)
3: -{
3: -    _lowState.motorState[8].mode = msg.mode;
3: -    _lowState.motorState[8].q = msg.q;
3: -    _lowState.motorState[8].dq = msg.dq;
3: -    _lowState.motorState[8].tauEst = msg.tauEst;
3: -}
3: -
3: -void IOROS::RLhipCallback(const unitree_legged_msgs::MotorState& msg)
3: -{
3: -    _lowState.motorState[9].mode = msg.mode;
3: -    _lowState.motorState[9].q = msg.q;
3: -    _lowState.motorState[9].dq = msg.dq;
3: -    _lowState.motorState[9].tauEst = msg.tauEst;
3: -}
3: -
3: -void IOROS::RLthighCallback(const unitree_legged_msgs::MotorState& msg)
3: -{
3: -    _lowState.motorState[10].mode = msg.mode;
3: -    _lowState.motorState[10].q = msg.q;
3: -    _lowState.motorState[10].dq = msg.dq;
3: -    _lowState.motorState[10].tauEst = msg.tauEst;
3: -}
3: -
3: -void IOROS::RLcalfCallback(const unitree_legged_msgs::MotorState& msg)
3: -{
3: -    _lowState.motorState[11].mode = msg.mode;
3: -    _lowState.motorState[11].q = msg.q;
3: -    _lowState.motorState[11].dq = msg.dq;
3: -    _lowState.motorState[11].tauEst = msg.tauEst;
3: +{
3: +  _lowState.imu.quaternion[0] = msg.orientation.w;
3: +  _lowState.imu.quaternion[1] = msg.orientation.x;
3: +  _lowState.imu.quaternion[2] = msg.orientation.y;
3: +  _lowState.imu.quaternion[3] = msg.orientation.z;
3: +
3: +  _lowState.imu.gyroscope[0] = msg.angular_velocity.x;
3: +  _lowState.imu.gyroscope[1] = msg.angular_velocity.y;
3: +  _lowState.imu.gyroscope[2] = msg.angular_velocity.z;
3: +
3: +  _lowState.imu.accelerometer[0] = msg.linear_acceleration.x;
3: +  _lowState.imu.accelerometer[1] = msg.linear_acceleration.y;
3: +  _lowState.imu.accelerometer[2] = msg.linear_acceleration.z;
3: +}
3: +
3: +void IOROS::FRhipCallback(const unitree_legged_msgs::MotorState & msg)
3: +{
3: +  _lowState.motorState[0].mode = msg.mode;
3: +  _lowState.motorState[0].q = msg.q;
3: +  _lowState.motorState[0].dq = msg.dq;
3: +  _lowState.motorState[0].tauEst = msg.tauEst;
3: +}
3: +
3: +void IOROS::FRthighCallback(const unitree_legged_msgs::MotorState & msg)
3: +{
3: +  _lowState.motorState[1].mode = msg.mode;
3: +  _lowState.motorState[1].q = msg.q;
3: +  _lowState.motorState[1].dq = msg.dq;
3: +  _lowState.motorState[1].tauEst = msg.tauEst;
3: +}
3: +
3: +void IOROS::FRcalfCallback(const unitree_legged_msgs::MotorState & msg)
3: +{
3: +  _lowState.motorState[2].mode = msg.mode;
3: +  _lowState.motorState[2].q = msg.q;
3: +  _lowState.motorState[2].dq = msg.dq;
3: +  _lowState.motorState[2].tauEst = msg.tauEst;
3: +}
3: +
3: +void IOROS::FLhipCallback(const unitree_legged_msgs::MotorState & msg)
3: +{
3: +  _lowState.motorState[3].mode = msg.mode;
3: +  _lowState.motorState[3].q = msg.q;
3: +  _lowState.motorState[3].dq = msg.dq;
3: +  _lowState.motorState[3].tauEst = msg.tauEst;
3: +}
3: +
3: +void IOROS::FLthighCallback(const unitree_legged_msgs::MotorState & msg)
3: +{
3: +  _lowState.motorState[4].mode = msg.mode;
3: +  _lowState.motorState[4].q = msg.q;
3: +  _lowState.motorState[4].dq = msg.dq;
3: +  _lowState.motorState[4].tauEst = msg.tauEst;
3: +}
3: +
3: +void IOROS::FLcalfCallback(const unitree_legged_msgs::MotorState & msg)
3: +{
3: +  _lowState.motorState[5].mode = msg.mode;
3: +  _lowState.motorState[5].q = msg.q;
3: +  _lowState.motorState[5].dq = msg.dq;
3: +  _lowState.motorState[5].tauEst = msg.tauEst;
3: +}
3: +
3: +void IOROS::RRhipCallback(const unitree_legged_msgs::MotorState & msg)
3: +{
3: +  _lowState.motorState[6].mode = msg.mode;
3: +  _lowState.motorState[6].q = msg.q;
3: +  _lowState.motorState[6].dq = msg.dq;
3: +  _lowState.motorState[6].tauEst = msg.tauEst;
3: +}
3: +
3: +void IOROS::RRthighCallback(const unitree_legged_msgs::MotorState & msg)
3: +{
3: +  _lowState.motorState[7].mode = msg.mode;
3: +  _lowState.motorState[7].q = msg.q;
3: +  _lowState.motorState[7].dq = msg.dq;
3: +  _lowState.motorState[7].tauEst = msg.tauEst;
3: +}
3: +
3: +void IOROS::RRcalfCallback(const unitree_legged_msgs::MotorState & msg)
3: +{
3: +  _lowState.motorState[8].mode = msg.mode;
3: +  _lowState.motorState[8].q = msg.q;
3: +  _lowState.motorState[8].dq = msg.dq;
3: +  _lowState.motorState[8].tauEst = msg.tauEst;
3: +}
3: +
3: +void IOROS::RLhipCallback(const unitree_legged_msgs::MotorState & msg)
3: +{
3: +  _lowState.motorState[9].mode = msg.mode;
3: +  _lowState.motorState[9].q = msg.q;
3: +  _lowState.motorState[9].dq = msg.dq;
3: +  _lowState.motorState[9].tauEst = msg.tauEst;
3: +}
3: +
3: +void IOROS::RLthighCallback(const unitree_legged_msgs::MotorState & msg)
3: +{
3: +  _lowState.motorState[10].mode = msg.mode;
3: +  _lowState.motorState[10].q = msg.q;
3: +  _lowState.motorState[10].dq = msg.dq;
3: +  _lowState.motorState[10].tauEst = msg.tauEst;
3: +}
3: +
3: +void IOROS::RLcalfCallback(const unitree_legged_msgs::MotorState & msg)
3: +{
3: +  _lowState.motorState[11].mode = msg.mode;
3: +  _lowState.motorState[11].q = msg.q;
3: +  _lowState.motorState[11].dq = msg.dq;
3: +  _lowState.motorState[11].tauEst = msg.tauEst;
3: @@ -236,6 +281,7 @@
3: -void IOROS::RosShutDown(int sig){
3: -
3: -	// RCLCPP_INFO_ONCE(_nm->get_logger(), "ROS 2 interface shutting down!");
3: -    std::cout << "ROS 2 interface shutting down!" << std::endl;
3: -    // executor_thread.join();
3: -	rclcpp::shutdown();
3: +void IOROS::RosShutDown(int sig)
3: +{
3: +
3: +  // RCLCPP_INFO_ONCE(_nm->get_logger(), "ROS 2 interface shutting down!");
3: +  std::cout << "ROS 2 interface shutting down!" << std::endl;
3: +  // executor_thread.join();
3: +  rclcpp::shutdown();
3: @@ -246 +292 @@
3: -//     joint_index_map["FL_thigh_joint"] = 1;         
3: +//     joint_index_map["FL_thigh_joint"] = 1;
3: @@ -250 +296 @@
3: -//     joint_index_map["FR_calf_joint"] = 5;         
3: +//     joint_index_map["FR_calf_joint"] = 5;
3: @@ -252 +298 @@
3: -//     joint_index_map["RL_thigh_joint"] = 7;         
3: +//     joint_index_map["RL_thigh_joint"] = 7;
3: @@ -254,2 +300,2 @@
3: -//     joint_index_map["RR_hip_joint"] = 9;          
3: -//     joint_index_map["RR_thigh_joint"] = 10;        
3: +//     joint_index_map["RR_hip_joint"] = 9;
3: +//     joint_index_map["RR_thigh_joint"] = 10;
3: @@ -259,31 +305,34 @@
3: -IOROS::IOROS(rclcpp::Node::SharedPtr node_ptr) : IOInterface(){
3: -    _nm = node_ptr;
3: -    
3: -    std::cout << "The control interface for ROS 2 Gazebo simulation" << std::endl;
3: -    _nm->declare_parameter("robot_name", "go2");
3: -    _nm->get_parameter("robot_name", _robot_name);
3: -    std::cout << "robot_name: " << _robot_name << std::endl;
3: -
3: -    // initialize map
3: -    // initializeJointIndexMap();
3: -
3: -    // _joint_cmd = std_msgs::msg::Float64MultiArray();
3: -    // for(int i = 0; i < 12; i++){
3: -    //     _joint_cmd.data.push_back(0.0);
3: -    // }
3: -    
3: -    // start subscriber
3: -    initRecv();
3: -    std::cout << "init recv" << std::endl;
3: -
3: -    // ros::AsyncSpinner subSpinner(1); // one threads
3: -    // subSpinner.start();
3: -
3: -    // ROS 2 equivalent
3: -    auto executor = std::make_shared<rclcpp::executors::MultiThreadedExecutor>(
3: -        rclcpp::ExecutorOptions(), 1
3: -    );
3: -    
3: -    executor->add_node(_nm);
3: -    executor_thread = std::thread([executor] (){
3: -        executor->spin();
3: +IOROS::IOROS(rclcpp::Node::SharedPtr node_ptr)
3: +: IOInterface()
3: +{
3: +  _nm = node_ptr;
3: +
3: +  std::cout << "The control interface for ROS 2 Gazebo simulation" << std::endl;
3: +  _nm->declare_parameter("robot_name", "go2");
3: +  _nm->get_parameter("robot_name", _robot_name);
3: +  std::cout << "robot_name: " << _robot_name << std::endl;
3: +
3: +  // initialize map
3: +  // initializeJointIndexMap();
3: +
3: +  // _joint_cmd = std_msgs::msg::Float64MultiArray();
3: +  // for(int i = 0; i < 12; i++){
3: +  //     _joint_cmd.data.push_back(0.0);
3: +  // }
3: +
3: +  // start subscriber
3: +  initRecv();
3: +  std::cout << "init recv" << std::endl;
3: +
3: +  // ros::AsyncSpinner subSpinner(1); // one threads
3: +  // subSpinner.start();
3: +
3: +  // ROS 2 equivalent
3: +  auto executor = std::make_shared<rclcpp::executors::MultiThreadedExecutor>(
3: +    rclcpp::ExecutorOptions(), 1
3: +  );
3: +
3: +  executor->add_node(_nm);
3: +  executor_thread = std::thread(
3: +    [executor]() {
3: +      executor->spin();
3: @@ -291,92 +340,165 @@
3: -    executor_thread.detach();
3: -    std::cout << "executor thread detached and running" << std::endl;
3: -
3: -    usleep(300000);     // wait for subscribers start
3: -
3: -    initSend();   
3: -
3: -    signal(SIGINT, IOROS::RosShutDown);
3: -
3: -    cmdPanel = new KeyBoard();
3: -    
3: -}
3: -
3: -IOROS::~IOROS(){
3: -    delete cmdPanel;
3: -    rclcpp::shutdown();
3: -}
3: -
3: -void IOROS::sendRecv(const LowlevelCmd *cmd, LowlevelState *state){
3: -    sendCmd(cmd);
3: -    recvState(state);
3: -
3: -    state->userCmd = cmdPanel->getUserCmd();
3: -    state->userValue = cmdPanel->getUserValue();
3: -}
3: -
3: -void IOROS::sendCmd(const LowlevelCmd *lowCmd){
3: -    
3: -    for(int i(0); i < 12; ++i){
3: -        _lowCmd.motor_cmd[i].mode = lowCmd->motorCmd[i].mode;
3: -        _lowCmd.motor_cmd[i].q = lowCmd->motorCmd[i].q;
3: -        _lowCmd.motor_cmd[i].dq = lowCmd->motorCmd[i].dq;
3: -        _lowCmd.motor_cmd[i].tau = lowCmd->motorCmd[i].tau;
3: -        _lowCmd.motor_cmd[i].kd = lowCmd->motorCmd[i].Kd;
3: -        _lowCmd.motor_cmd[i].kp = lowCmd->motorCmd[i].Kp;
3: -
3: -    }
3: -    for(int m(0); m < 12; ++m){
3: -        _servo_pub[m]->publish(_lowCmd.motor_cmd[m]);
3: -    }
3: -    // _joint_cmd_pub->publish(_joint_cmd);
3: -    // rclcpp::spin_once();
3: -
3: -
3: -}
3: -
3: -void IOROS::recvState(LowlevelState *state){
3: -    for(int i(0); i < 12; ++i){
3: -        state->motorState[i].q = _lowState.motor_state[i].q;
3: -        state->motorState[i].dq = _lowState.motor_state[i].dq;
3: -        state->motorState[i].ddq = _lowState.motor_state[i].ddq;
3: -        state->motorState[i].tauEst = _lowState.motor_state[i].tau_est;
3: -    }
3: -    for(int i(0); i < 3; ++i){
3: -        state->imu.quaternion[i] = _lowState.imu.quaternion[i];
3: -        state->imu.accelerometer[i] = _lowState.imu.accelerometer[i];
3: -        state->imu.gyroscope[i] = _lowState.imu.gyroscope[i];
3: -    }
3: -    state->imu.quaternion[3] = _lowState.imu.quaternion[3];
3: -}
3: -
3: -void IOROS::initSend(){
3: -    _servo_pub.push_back(_nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>("/FR_hip_controller/command", 1));
3: -    _servo_pub.push_back(_nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>("/FR_thigh_controller/command", 1));
3: -    _servo_pub.push_back(_nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>("/FR_calf_controller/command", 1));
3: -    _servo_pub.push_back(_nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>("/FL_hip_controller/command", 1));
3: -    _servo_pub.push_back(_nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>("/FL_thigh_controller/command", 1));
3: -    _servo_pub.push_back(_nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>("/FL_calf_controller/command", 1));
3: -    _servo_pub.push_back(_nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>("/RR_hip_controller/command", 1));
3: -    _servo_pub.push_back(_nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>("/RR_thigh_controller/command", 1));
3: -    _servo_pub.push_back(_nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>("/RR_calf_controller/command", 1));
3: -    _servo_pub.push_back(_nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>("/RL_hip_controller/command", 1));
3: -    _servo_pub.push_back(_nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>("/RL_thigh_controller/command", 1));
3: -    _servo_pub.push_back(_nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>("/RL_calf_controller/command", 1));
3: -    // _joint_cmd_pub = _nm->create_publisher<std_msgs::msg::Float64MultiArray>("/joint_group_position_controller/commands", 1);
3: -}
3: -
3: -void IOROS::initRecv(){
3: -    _imu_sub = _nm->create_subscription<sensor_msgs::msg::Imu>("/imu_plugin/out", 1, std::bind(&IOROS::imuCallback, this, std::placeholders::_1));
3: -    _servo_sub.push_back(_nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>("/FR_hip_controller/state", 1, std::bind(&IOROS::FRhipCallback, this, std::placeholders::_1)));
3: -    _servo_sub.push_back(_nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>("/FR_thigh_controller/state", 1, std::bind(&IOROS::FRthighCallback, this, std::placeholders::_1)));
3: -    _servo_sub.push_back(_nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>("/FR_calf_controller/state", 1, std::bind(&IOROS::FRcalfCallback, this, std::placeholders::_1)));
3: -    _servo_sub.push_back(_nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>("/FL_hip_controller/state", 1, std::bind(&IOROS::FLhipCallback, this, std::placeholders::_1)));
3: -    _servo_sub.push_back(_nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>("/FL_thigh_controller/state", 1, std::bind(&IOROS::FLthighCallback, this, std::placeholders::_1)));
3: -    _servo_sub.push_back(_nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>("/FL_calf_controller/state", 1, std::bind(&IOROS::FLcalfCallback, this, std::placeholders::_1)));
3: -    _servo_sub.push_back(_nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>("/RR_hip_controller/state", 1, std::bind(&IOROS::RRhipCallback, this, std::placeholders::_1)));
3: -    _servo_sub.push_back(_nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>("/RR_thigh_controller/state", 1, std::bind(&IOROS::RRthighCallback, this, std::placeholders::_1)));
3: -    _servo_sub.push_back(_nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>("/RR_calf_controller/state", 1, std::bind(&IOROS::RRcalfCallback, this, std::placeholders::_1)));
3: -    _servo_sub.push_back(_nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>("/RL_hip_controller/state", 1, std::bind(&IOROS::RLhipCallback, this, std::placeholders::_1)));
3: -    _servo_sub.push_back(_nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>("/RL_thigh_controller/state", 1, std::bind(&IOROS::RLthighCallback, this, std::placeholders::_1)));
3: -    _servo_sub.push_back(_nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>("/RL_calf_controller/state", 1, std::bind(&IOROS::RLcalfCallback, this, std::placeholders::_1)));
3: -    // _joint_state_sub = _nm->create_subscription<sensor_msgs::msg::JointState>("/joint_states", 1, std::bind(&IOROS::jointStateCallback, this, std::placeholders::_1));
3: +  executor_thread.detach();
3: +  std::cout << "executor thread detached and running" << std::endl;
3: +
3: +  usleep(300000);       // wait for subscribers start
3: +
3: +  initSend();
3: +
3: +  signal(SIGINT, IOROS::RosShutDown);
3: +
3: +  cmdPanel = new KeyBoard();
3: +
3: +}
3: +
3: +IOROS::~IOROS()
3: +{
3: +  delete cmdPanel;
3: +  rclcpp::shutdown();
3: +}
3: +
3: +void IOROS::sendRecv(const LowlevelCmd * cmd, LowlevelState * state)
3: +{
3: +  sendCmd(cmd);
3: +  recvState(state);
3: +
3: +  state->userCmd = cmdPanel->getUserCmd();
3: +  state->userValue = cmdPanel->getUserValue();
3: +}
3: +
3: +void IOROS::sendCmd(const LowlevelCmd * lowCmd)
3: +{
3: +
3: +  for (int i(0); i < 12; ++i) {
3: +    _lowCmd.motor_cmd[i].mode = lowCmd->motorCmd[i].mode;
3: +    _lowCmd.motor_cmd[i].q = lowCmd->motorCmd[i].q;
3: +    _lowCmd.motor_cmd[i].dq = lowCmd->motorCmd[i].dq;
3: +    _lowCmd.motor_cmd[i].tau = lowCmd->motorCmd[i].tau;
3: +    _lowCmd.motor_cmd[i].kd = lowCmd->motorCmd[i].Kd;
3: +    _lowCmd.motor_cmd[i].kp = lowCmd->motorCmd[i].Kp;
3: +
3: +  }
3: +  for (int m(0); m < 12; ++m) {
3: +    _servo_pub[m]->publish(_lowCmd.motor_cmd[m]);
3: +  }
3: +  // _joint_cmd_pub->publish(_joint_cmd);
3: +  // rclcpp::spin_once();
3: +
3: +
3: +}
3: +
3: +void IOROS::recvState(LowlevelState * state)
3: +{
3: +  for (int i(0); i < 12; ++i) {
3: +    state->motorState[i].q = _lowState.motor_state[i].q;
3: +    state->motorState[i].dq = _lowState.motor_state[i].dq;
3: +    state->motorState[i].ddq = _lowState.motor_state[i].ddq;
3: +    state->motorState[i].tauEst = _lowState.motor_state[i].tau_est;
3: +  }
3: +  for (int i(0); i < 3; ++i) {
3: +    state->imu.quaternion[i] = _lowState.imu.quaternion[i];
3: +    state->imu.accelerometer[i] = _lowState.imu.accelerometer[i];
3: +    state->imu.gyroscope[i] = _lowState.imu.gyroscope[i];
3: +  }
3: +  state->imu.quaternion[3] = _lowState.imu.quaternion[3];
3: +}
3: +
3: +void IOROS::initSend()
3: +{
3: +  _servo_pub.push_back(
3: +    _nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>(
3: +      "/FR_hip_controller/command", 1));
3: +  _servo_pub.push_back(
3: +    _nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>(
3: +      "/FR_thigh_controller/command", 1));
3: +  _servo_pub.push_back(
3: +    _nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>(
3: +      "/FR_calf_controller/command", 1));
3: +  _servo_pub.push_back(
3: +    _nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>(
3: +      "/FL_hip_controller/command", 1));
3: +  _servo_pub.push_back(
3: +    _nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>(
3: +      "/FL_thigh_controller/command", 1));
3: +  _servo_pub.push_back(
3: +    _nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>(
3: +      "/FL_calf_controller/command", 1));
3: +  _servo_pub.push_back(
3: +    _nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>(
3: +      "/RR_hip_controller/command", 1));
3: +  _servo_pub.push_back(
3: +    _nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>(
3: +      "/RR_thigh_controller/command", 1));
3: +  _servo_pub.push_back(
3: +    _nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>(
3: +      "/RR_calf_controller/command", 1));
3: +  _servo_pub.push_back(
3: +    _nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>(
3: +      "/RL_hip_controller/command", 1));
3: +  _servo_pub.push_back(
3: +    _nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>(
3: +      "/RL_thigh_controller/command", 1));
3: +  _servo_pub.push_back(
3: +    _nm->create_publisher<ros2_unitree_legged_msgs::msg::MotorCmd>(
3: +      "/RL_calf_controller/command", 1));
3: +  // _joint_cmd_pub = _nm->create_publisher<std_msgs::msg::Float64MultiArray>("/joint_group_position_controller/commands", 1);
3: +}
3: +
3: +void IOROS::initRecv()
3: +{
3: +  _imu_sub =
3: +    _nm->create_subscription<sensor_msgs::msg::Imu>(
3: +    "/imu_plugin/out", 1,
3: +    std::bind(&IOROS::imuCallback, this, std::placeholders::_1));
3: +  _servo_sub.push_back(
3: +    _nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>(
3: +      "/FR_hip_controller/state", 1,
3: +      std::bind(&IOROS::FRhipCallback, this, std::placeholders::_1)));
3: +  _servo_sub.push_back(
3: +    _nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>(
3: +      "/FR_thigh_controller/state", 1, std::bind(
3: +        &IOROS::FRthighCallback, this,
3: +        std::placeholders::_1)));
3: +  _servo_sub.push_back(
3: +    _nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>(
3: +      "/FR_calf_controller/state", 1,
3: +      std::bind(&IOROS::FRcalfCallback, this, std::placeholders::_1)));
3: +  _servo_sub.push_back(
3: +    _nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>(
3: +      "/FL_hip_controller/state", 1,
3: +      std::bind(&IOROS::FLhipCallback, this, std::placeholders::_1)));
3: +  _servo_sub.push_back(
3: +    _nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>(
3: +      "/FL_thigh_controller/state", 1, std::bind(
3: +        &IOROS::FLthighCallback, this,
3: +        std::placeholders::_1)));
3: +  _servo_sub.push_back(
3: +    _nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>(
3: +      "/FL_calf_controller/state", 1,
3: +      std::bind(&IOROS::FLcalfCallback, this, std::placeholders::_1)));
3: +  _servo_sub.push_back(
3: +    _nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>(
3: +      "/RR_hip_controller/state", 1,
3: +      std::bind(&IOROS::RRhipCallback, this, std::placeholders::_1)));
3: +  _servo_sub.push_back(
3: +    _nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>(
3: +      "/RR_thigh_controller/state", 1, std::bind(
3: +        &IOROS::RRthighCallback, this,
3: +        std::placeholders::_1)));
3: +  _servo_sub.push_back(
3: +    _nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>(
3: +      "/RR_calf_controller/state", 1,
3: +      std::bind(&IOROS::RRcalfCallback, this, std::placeholders::_1)));
3: +  _servo_sub.push_back(
3: +    _nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>(
3: +      "/RL_hip_controller/state", 1,
3: +      std::bind(&IOROS::RLhipCallback, this, std::placeholders::_1)));
3: +  _servo_sub.push_back(
3: +    _nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>(
3: +      "/RL_thigh_controller/state", 1, std::bind(
3: +        &IOROS::RLthighCallback, this,
3: +        std::placeholders::_1)));
3: +  _servo_sub.push_back(
3: +    _nm->create_subscription<ros2_unitree_legged_msgs::msg::MotorState>(
3: +      "/RL_calf_controller/state", 1,
3: +      std::bind(&IOROS::RLcalfCallback, this, std::placeholders::_1)));
3: +  // _joint_state_sub = _nm->create_subscription<sensor_msgs::msg::JointState>("/joint_states", 1, std::bind(&IOROS::jointStateCallback, this, std::placeholders::_1));
3: @@ -387,12 +509,12 @@
3: -    _lowState.imu.quaternion[0] = msg->orientation.w;
3: -    _lowState.imu.quaternion[1] = msg->orientation.x;
3: -    _lowState.imu.quaternion[2] = msg->orientation.y;
3: -    _lowState.imu.quaternion[3] = msg->orientation.z;
3: -
3: -    _lowState.imu.gyroscope[0] = msg->angular_velocity.x;
3: -    _lowState.imu.gyroscope[1] = msg->angular_velocity.y;
3: -    _lowState.imu.gyroscope[2] = msg->angular_velocity.z;
3: -    
3: -    _lowState.imu.accelerometer[0] = msg->linear_acceleration.x;
3: -    _lowState.imu.accelerometer[1] = msg->linear_acceleration.y;
3: -    _lowState.imu.accelerometer[2] = msg->linear_acceleration.z;
3: +  _lowState.imu.quaternion[0] = msg->orientation.w;
3: +  _lowState.imu.quaternion[1] = msg->orientation.x;
3: +  _lowState.imu.quaternion[2] = msg->orientation.y;
3: +  _lowState.imu.quaternion[3] = msg->orientation.z;
3: +
3: +  _lowState.imu.gyroscope[0] = msg->angular_velocity.x;
3: +  _lowState.imu.gyroscope[1] = msg->angular_velocity.y;
3: +  _lowState.imu.gyroscope[2] = msg->angular_velocity.z;
3: +
3: +  _lowState.imu.accelerometer[0] = msg->linear_acceleration.x;
3: +  _lowState.imu.accelerometer[1] = msg->linear_acceleration.y;
3: +  _lowState.imu.accelerometer[2] = msg->linear_acceleration.z;
3: @@ -404,4 +526,4 @@
3: -    _lowState.motor_state[0].mode = msg->mode;
3: -    _lowState.motor_state[0].q = msg->q;
3: -    _lowState.motor_state[0].dq = msg->dq;
3: -    _lowState.motor_state[0].tau_est = msg->tau_est;
3: +  _lowState.motor_state[0].mode = msg->mode;
3: +  _lowState.motor_state[0].q = msg->q;
3: +  _lowState.motor_state[0].dq = msg->dq;
3: +  _lowState.motor_state[0].tau_est = msg->tau_est;
3: @@ -412,4 +534,4 @@
3: -    _lowState.motor_state[1].mode = msg->mode;
3: -    _lowState.motor_state[1].q = msg->q;
3: -    _lowState.motor_state[1].dq = msg->dq;
3: -    _lowState.motor_state[1].tau_est = msg->tau_est;
3: +  _lowState.motor_state[1].mode = msg->mode;
3: +  _lowState.motor_state[1].q = msg->q;
3: +  _lowState.motor_state[1].dq = msg->dq;
3: +  _lowState.motor_state[1].tau_est = msg->tau_est;
3: @@ -420,4 +542,4 @@
3: -    _lowState.motor_state[2].mode = msg->mode;
3: -    _lowState.motor_state[2].q = msg->q;
3: -    _lowState.motor_state[2].dq = msg->dq;
3: -    _lowState.motor_state[2].tau_est = msg->tau_est;
3: +  _lowState.motor_state[2].mode = msg->mode;
3: +  _lowState.motor_state[2].q = msg->q;
3: +  _lowState.motor_state[2].dq = msg->dq;
3: +  _lowState.motor_state[2].tau_est = msg->tau_est;
3: @@ -428,4 +550,4 @@
3: -    _lowState.motor_state[3].mode = msg->mode;
3: -    _lowState.motor_state[3].q = msg->q;
3: -    _lowState.motor_state[3].dq = msg->dq;
3: -    _lowState.motor_state[3].tau_est = msg->tau_est;
3: +  _lowState.motor_state[3].mode = msg->mode;
3: +  _lowState.motor_state[3].q = msg->q;
3: +  _lowState.motor_state[3].dq = msg->dq;
3: +  _lowState.motor_state[3].tau_est = msg->tau_est;
3: @@ -436,4 +558,4 @@
3: -    _lowState.motor_state[4].mode = msg->mode;
3: -    _lowState.motor_state[4].q = msg->q;
3: -    _lowState.motor_state[4].dq = msg->dq;
3: -    _lowState.motor_state[4].tau_est = msg->tau_est;
3: +  _lowState.motor_state[4].mode = msg->mode;
3: +  _lowState.motor_state[4].q = msg->q;
3: +  _lowState.motor_state[4].dq = msg->dq;
3: +  _lowState.motor_state[4].tau_est = msg->tau_est;
3: @@ -444,4 +566,4 @@
3: -    _lowState.motor_state[5].mode = msg->mode;
3: -    _lowState.motor_state[5].q = msg->q;
3: -    _lowState.motor_state[5].dq = msg->dq;
3: -    _lowState.motor_state[5].tau_est = msg->tau_est;
3: +  _lowState.motor_state[5].mode = msg->mode;
3: +  _lowState.motor_state[5].q = msg->q;
3: +  _lowState.motor_state[5].dq = msg->dq;
3: +  _lowState.motor_state[5].tau_est = msg->tau_est;
3: @@ -452,4 +574,4 @@
3: -    _lowState.motor_state[6].mode = msg->mode;
3: -    _lowState.motor_state[6].q = msg->q;
3: -    _lowState.motor_state[6].dq = msg->dq;
3: -    _lowState.motor_state[6].tau_est = msg->tau_est;
3: +  _lowState.motor_state[6].mode = msg->mode;
3: +  _lowState.motor_state[6].q = msg->q;
3: +  _lowState.motor_state[6].dq = msg->dq;
3: +  _lowState.motor_state[6].tau_est = msg->tau_est;
3: @@ -460,4 +582,4 @@
3: -    _lowState.motor_state[7].mode = msg->mode;
3: -    _lowState.motor_state[7].q = msg->q;
3: -    _lowState.motor_state[7].dq = msg->dq;
3: -    _lowState.motor_state[7].tau_est = msg->tau_est;
3: +  _lowState.motor_state[7].mode = msg->mode;
3: +  _lowState.motor_state[7].q = msg->q;
3: +  _lowState.motor_state[7].dq = msg->dq;
3: +  _lowState.motor_state[7].tau_est = msg->tau_est;
3: @@ -468,4 +590,4 @@
3: -    _lowState.motor_state[8].mode = msg->mode;
3: -    _lowState.motor_state[8].q = msg->q;
3: -    _lowState.motor_state[8].dq = msg->dq;
3: -    _lowState.motor_state[8].tau_est = msg->tau_est;
3: +  _lowState.motor_state[8].mode = msg->mode;
3: +  _lowState.motor_state[8].q = msg->q;
3: +  _lowState.motor_state[8].dq = msg->dq;
3: +  _lowState.motor_state[8].tau_est = msg->tau_est;
3: @@ -476,4 +598,4 @@
3: -    _lowState.motor_state[9].mode = msg->mode;
3: -    _lowState.motor_state[9].q = msg->q;
3: -    _lowState.motor_state[9].dq = msg->dq;
3: -    _lowState.motor_state[9].tau_est = msg->tau_est;
3: +  _lowState.motor_state[9].mode = msg->mode;
3: +  _lowState.motor_state[9].q = msg->q;
3: +  _lowState.motor_state[9].dq = msg->dq;
3: +  _lowState.motor_state[9].tau_est = msg->tau_est;
3: @@ -484,4 +606,4 @@
3: -    _lowState.motor_state[10].mode = msg->mode;
3: -    _lowState.motor_state[10].q = msg->q;
3: -    _lowState.motor_state[10].dq = msg->dq;
3: -    _lowState.motor_state[10].tau_est = msg->tau_est;
3: +  _lowState.motor_state[10].mode = msg->mode;
3: +  _lowState.motor_state[10].q = msg->q;
3: +  _lowState.motor_state[10].dq = msg->dq;
3: +  _lowState.motor_state[10].tau_est = msg->tau_est;
3: @@ -492,8 +614,8 @@
3: -    _lowState.motor_state[11].mode = msg->mode;
3: -    _lowState.motor_state[11].q = msg->q;
3: -    _lowState.motor_state[11].dq = msg->dq;
3: -    _lowState.motor_state[11].tau_est = msg->tau_est;
3: -}
3: -
3: -
3: -#endif  // COMPILE_WITH_ROS2_MB
3: +  _lowState.motor_state[11].mode = msg->mode;
3: +  _lowState.motor_state[11].q = msg->q;
3: +  _lowState.motor_state[11].dq = msg->dq;
3: +  _lowState.motor_state[11].tau_est = msg->tau_est;
3: +}
3: +
3: +
3: +#endif  // COMPILE_WITH_ROS2_MB
3: 
3: Code style divergence in file 'src/interface/IOSDK.cpp':
3: 
3: --- src/interface/IOSDK.cpp
3: +++ src/interface/IOSDK.cpp.uncrustify
3: @@ -11,4 +11,7 @@
3: -IOSDK::IOSDK():_safe(UNITREE_LEGGED_SDK::LeggedType::Aliengo), _udp(UNITREE_LEGGED_SDK::LOWLEVEL, 8090, "192.168.123.10", 8007){
3: -    std::cout << "The control interface for real robot" << std::endl;
3: -    _udp.InitCmdData(_lowCmd);
3: -    cmdPanel = new WirelessHandle();
3: +IOSDK::IOSDK()
3: +: _safe(UNITREE_LEGGED_SDK::LeggedType::Aliengo), _udp(UNITREE_LEGGED_SDK::LOWLEVEL, 8090,
3: +    "192.168.123.10", 8007)
3: +{
3: +  std::cout << "The control interface for real robot" << std::endl;
3: +  _udp.InitCmdData(_lowCmd);
3: +  cmdPanel = new WirelessHandle();
3: @@ -17,5 +20,5 @@
3: -    _pub = _nh.advertise<sensor_msgs::JointState>("/realRobot/joint_states", 20);
3: -    _joint_state.name.resize(12);
3: -    _joint_state.position.resize(12);
3: -    _joint_state.velocity.resize(12);
3: -    _joint_state.effort.resize(12);
3: +  _pub = _nh.advertise<sensor_msgs::JointState>("/realRobot/joint_states", 20);
3: +  _joint_state.name.resize(12);
3: +  _joint_state.position.resize(12);
3: +  _joint_state.velocity.resize(12);
3: +  _joint_state.effort.resize(12);
3: @@ -27,4 +30,6 @@
3: -IOSDK::IOSDK():_safe(UNITREE_LEGGED_SDK::LeggedType::Aliengo), _udp(UNITREE_LEGGED_SDK::LOWLEVEL){
3: -    std::cout << "The control interface for real robot" << std::endl;
3: -    _udp.InitCmdData(_lowCmd);
3: -    cmdPanel = new WirelessHandle();
3: +IOSDK::IOSDK()
3: +: _safe(UNITREE_LEGGED_SDK::LeggedType::Aliengo), _udp(UNITREE_LEGGED_SDK::LOWLEVEL)
3: +{
3: +  std::cout << "The control interface for real robot" << std::endl;
3: +  _udp.InitCmdData(_lowCmd);
3: +  cmdPanel = new WirelessHandle();
3: @@ -33,5 +38,5 @@
3: -    _pub = _nh.advertise<sensor_msgs::JointState>("/realRobot/joint_states", 20);
3: -    _joint_state.name.resize(12);
3: -    _joint_state.position.resize(12);
3: -    _joint_state.velocity.resize(12);
3: -    _joint_state.effort.resize(12);
3: +  _pub = _nh.advertise<sensor_msgs::JointState>("/realRobot/joint_states", 20);
3: +  _joint_state.name.resize(12);
3: +  _joint_state.position.resize(12);
3: +  _joint_state.velocity.resize(12);
3: +  _joint_state.effort.resize(12);
3: @@ -43,12 +48,10 @@
3: -void IOSDK::sendRecv(const LowlevelCmd *cmd, LowlevelState *state){
3: -    for(int i(0); i < 12; ++i){
3: -        _lowCmd.motorCmd[i].mode = cmd->motorCmd[i].mode;
3: -        _lowCmd.motorCmd[i].q    = cmd->motorCmd[i].q;
3: -        _lowCmd.motorCmd[i].dq   = cmd->motorCmd[i].dq;
3: -        _lowCmd.motorCmd[i].Kp   = cmd->motorCmd[i].Kp;
3: -        _lowCmd.motorCmd[i].Kd   = cmd->motorCmd[i].Kd;
3: -        _lowCmd.motorCmd[i].tau  = cmd->motorCmd[i].tau;
3: -    }
3: -    
3: -    _udp.SetSend(_lowCmd);
3: -    _udp.Send();
3: +void IOSDK::sendRecv(const LowlevelCmd * cmd, LowlevelState * state)
3: +{
3: +  for (int i(0); i < 12; ++i) {
3: +    _lowCmd.motorCmd[i].mode = cmd->motorCmd[i].mode;
3: +    _lowCmd.motorCmd[i].q = cmd->motorCmd[i].q;
3: +    _lowCmd.motorCmd[i].dq = cmd->motorCmd[i].dq;
3: +    _lowCmd.motorCmd[i].Kp = cmd->motorCmd[i].Kp;
3: +    _lowCmd.motorCmd[i].Kd = cmd->motorCmd[i].Kd;
3: +    _lowCmd.motorCmd[i].tau = cmd->motorCmd[i].tau;
3: +  }
3: @@ -56,2 +59,2 @@
3: -    _udp.Recv();
3: -    _udp.GetRecv(_lowState);
3: +  _udp.SetSend(_lowCmd);
3: +  _udp.Send();
3: @@ -59,7 +62,2 @@
3: -    for(int i(0); i < 12; ++i){
3: -        state->motorState[i].q = _lowState.motorState[i].q;
3: -        state->motorState[i].dq = _lowState.motorState[i].dq;
3: -        state->motorState[i].ddq = _lowState.motorState[i].ddq;
3: -        state->motorState[i].tauEst = _lowState.motorState[i].tauEst;
3: -        state->motorState[i].mode = _lowState.motorState[i].mode;
3: -    }
3: +  _udp.Recv();
3: +  _udp.GetRecv(_lowState);
3: @@ -67,6 +65,7 @@
3: -    for(int i(0); i < 3; ++i){
3: -        state->imu.quaternion[i] = _lowState.imu.quaternion[i];
3: -        state->imu.gyroscope[i]  = _lowState.imu.gyroscope[i];
3: -        state->imu.accelerometer[i] = _lowState.imu.accelerometer[i];
3: -    }
3: -    state->imu.quaternion[3] = _lowState.imu.quaternion[3];
3: +  for (int i(0); i < 12; ++i) {
3: +    state->motorState[i].q = _lowState.motorState[i].q;
3: +    state->motorState[i].dq = _lowState.motorState[i].dq;
3: +    state->motorState[i].ddq = _lowState.motorState[i].ddq;
3: +    state->motorState[i].tauEst = _lowState.motorState[i].tauEst;
3: +    state->motorState[i].mode = _lowState.motorState[i].mode;
3: +  }
3: @@ -74,3 +73,10 @@
3: -    cmdPanel->receiveHandle(&_lowState);
3: -    state->userCmd = cmdPanel->getUserCmd();
3: -    state->userValue = cmdPanel->getUserValue();
3: +  for (int i(0); i < 3; ++i) {
3: +    state->imu.quaternion[i] = _lowState.imu.quaternion[i];
3: +    state->imu.gyroscope[i] = _lowState.imu.gyroscope[i];
3: +    state->imu.accelerometer[i] = _lowState.imu.accelerometer[i];
3: +  }
3: +  state->imu.quaternion[3] = _lowState.imu.quaternion[3];
3: +
3: +  cmdPanel->receiveHandle(&_lowState);
3: +  state->userCmd = cmdPanel->getUserCmd();
3: +  state->userValue = cmdPanel->getUserValue();
3: @@ -79,10 +85,10 @@
3: -    _joint_state.header.stamp = ros::Time::now();
3: -    _joint_state.name = {"FR_hip_joint", "FR_thigh_joint", "FR_calf_joint", 
3: -                         "FL_hip_joint", "FL_thigh_joint", "FL_calf_joint",  
3: -                         "RR_hip_joint", "RR_thigh_joint", "RR_calf_joint", 
3: -                         "RL_hip_joint", "RL_thigh_joint", "RL_calf_joint"};
3: -    for(int i(0); i<12; ++i){
3: -        _joint_state.position[i] = state->motorState[i].q;
3: -        _joint_state.velocity[i] = state->motorState[i].dq;
3: -        _joint_state.effort[i]   = state->motorState[i].tauEst;
3: -    }
3: +  _joint_state.header.stamp = ros::Time::now();
3: +  _joint_state.name = {"FR_hip_joint", "FR_thigh_joint", "FR_calf_joint",
3: +    "FL_hip_joint", "FL_thigh_joint", "FL_calf_joint",
3: +    "RR_hip_joint", "RR_thigh_joint", "RR_calf_joint",
3: +    "RL_hip_joint", "RL_thigh_joint", "RL_calf_joint"};
3: +  for (int i(0); i < 12; ++i) {
3: +    _joint_state.position[i] = state->motorState[i].q;
3: +    _joint_state.velocity[i] = state->motorState[i].dq;
3: +    _joint_state.effort[i] = state->motorState[i].tauEst;
3: +  }
3: @@ -90 +96 @@
3: -    _pub.publish(_joint_state);
3: +  _pub.publish(_joint_state);
3: @@ -94 +100 @@
3: -#endif  // COMPILE_WITH_REAL_ROBOT
3: +#endif  // COMPILE_WITH_REAL_ROBOT
3: 
3: Code style divergence in file 'src/interface/KeyBoard.cpp':
3: 
3: --- src/interface/KeyBoard.cpp
3: +++ src/interface/KeyBoard.cpp.uncrustify
3: @@ -7,3 +7,4 @@
3: -KeyBoard::KeyBoard(){
3: -    userCmd = UserCommand::NONE;
3: -    userValue.setZero();
3: +KeyBoard::KeyBoard()
3: +{
3: +  userCmd = UserCommand::NONE;
3: +  userValue.setZero();
3: @@ -11,4 +12,4 @@
3: -    tcgetattr( fileno( stdin ), &_oldSettings );
3: -    _newSettings = _oldSettings;
3: -    _newSettings.c_lflag &= (~ICANON & ~ECHO);
3: -    tcsetattr( fileno( stdin ), TCSANOW, &_newSettings );
3: +  tcgetattr(fileno(stdin), &_oldSettings);
3: +  _newSettings = _oldSettings;
3: +  _newSettings.c_lflag &= (~ICANON & ~ECHO);
3: +  tcsetattr(fileno(stdin), TCSANOW, &_newSettings);
3: @@ -16 +17 @@
3: -    pthread_create(&_tid, NULL, runKeyBoard, (void*)this);
3: +  pthread_create(&_tid, NULL, runKeyBoard, (void *)this);
3: @@ -19,4 +20,5 @@
3: -KeyBoard::~KeyBoard(){
3: -    pthread_cancel(_tid);
3: -    pthread_join(_tid, NULL);
3: -    tcsetattr( fileno( stdin ), TCSANOW, &_oldSettings );
3: +KeyBoard::~KeyBoard()
3: +{
3: +  pthread_cancel(_tid);
3: +  pthread_join(_tid, NULL);
3: +  tcsetattr(fileno(stdin), TCSANOW, &_oldSettings);
3: @@ -25,2 +27,3 @@
3: -UserCommand KeyBoard::checkCmd(){
3: -    switch (_c){
3: +UserCommand KeyBoard::checkCmd()
3: +{
3: +  switch (_c) {
3: @@ -28 +31 @@
3: -        return UserCommand::L2_B;
3: +      return UserCommand::L2_B;
3: @@ -30 +33 @@
3: -        return UserCommand::L2_A;
3: +      return UserCommand::L2_A;
3: @@ -32 +35 @@
3: -        return UserCommand::L2_X;
3: +      return UserCommand::L2_X;
3: @@ -34 +37 @@
3: -        return UserCommand::START;
3: +      return UserCommand::START;
3: @@ -37 +40 @@
3: -        return UserCommand::L2_Y;
3: +      return UserCommand::L2_Y;
3: @@ -41 +44 @@
3: -        return UserCommand::L2_Y;
3: +      return UserCommand::L2_Y;
3: @@ -44 +47 @@
3: -        return UserCommand::L1_X;
3: +      return UserCommand::L1_X;
3: @@ -46 +49 @@
3: -        return UserCommand::L1_A;
3: +      return UserCommand::L1_A;
3: @@ -48 +51 @@
3: -        return UserCommand::L1_Y;
3: +      return UserCommand::L1_Y;
3: @@ -50,2 +53,2 @@
3: -        userValue.setZero();
3: -        return UserCommand::NONE;
3: +      userValue.setZero();
3: +      return UserCommand::NONE;
3: @@ -53,2 +56,2 @@
3: -        return UserCommand::NONE;
3: -    }
3: +      return UserCommand::NONE;
3: +  }
3: @@ -57,14 +60,15 @@
3: -void KeyBoard::changeValue(){
3: -    switch (_c){
3: -    case 'w':case 'W':
3: -        userValue.ly = min<float>(userValue.ly+sensitivityLeft, 1.0);
3: -        break;
3: -    case 's':case 'S':
3: -        userValue.ly = max<float>(userValue.ly-sensitivityLeft, -1.0);
3: -        break;
3: -    case 'd':case 'D':
3: -        userValue.lx = min<float>(userValue.lx+sensitivityLeft, 1.0);
3: -        break;
3: -    case 'a':case 'A':
3: -        userValue.lx = max<float>(userValue.lx-sensitivityLeft, -1.0);
3: -        break;
3: +void KeyBoard::changeValue()
3: +{
3: +  switch (_c) {
3: +    case 'w': case 'W':
3: +      userValue.ly = min<float>(userValue.ly + sensitivityLeft, 1.0);
3: +      break;
3: +    case 's': case 'S':
3: +      userValue.ly = max<float>(userValue.ly - sensitivityLeft, -1.0);
3: +      break;
3: +    case 'd': case 'D':
3: +      userValue.lx = min<float>(userValue.lx + sensitivityLeft, 1.0);
3: +      break;
3: +    case 'a': case 'A':
3: +      userValue.lx = max<float>(userValue.lx - sensitivityLeft, -1.0);
3: +      break;
3: @@ -72,12 +76,12 @@
3: -    case 'i':case 'I':
3: -        userValue.ry = min<float>(userValue.ry+sensitivityRight, 1.0);
3: -        break;
3: -    case 'k':case 'K':
3: -        userValue.ry = max<float>(userValue.ry-sensitivityRight, -1.0);
3: -        break;
3: -    case 'l':case 'L':
3: -        userValue.rx = min<float>(userValue.rx+sensitivityRight, 1.0);
3: -        break;
3: -    case 'j':case 'J':
3: -        userValue.rx = max<float>(userValue.rx-sensitivityRight, -1.0);
3: -        break;
3: +    case 'i': case 'I':
3: +      userValue.ry = min<float>(userValue.ry + sensitivityRight, 1.0);
3: +      break;
3: +    case 'k': case 'K':
3: +      userValue.ry = max<float>(userValue.ry - sensitivityRight, -1.0);
3: +      break;
3: +    case 'l': case 'L':
3: +      userValue.rx = min<float>(userValue.rx + sensitivityRight, 1.0);
3: +      break;
3: +    case 'j': case 'J':
3: +      userValue.rx = max<float>(userValue.rx - sensitivityRight, -1.0);
3: +      break;
3: @@ -85,2 +89,2 @@
3: -        break;
3: -    }
3: +      break;
3: +  }
3: @@ -89,3 +93,4 @@
3: -void* KeyBoard::runKeyBoard(void *arg){
3: -    ((KeyBoard*)arg)->run(NULL);
3: -    return NULL;
3: +void * KeyBoard::runKeyBoard(void * arg)
3: +{
3: +  ((KeyBoard *)arg)->run(NULL);
3: +  return NULL;
3: @@ -94,4 +99,5 @@
3: -void* KeyBoard::run(void *arg){
3: -    while(1){
3: -        FD_ZERO(&set);
3: -        FD_SET( fileno( stdin ), &set );
3: +void * KeyBoard::run(void * arg)
3: +{
3: +  while (1) {
3: +    FD_ZERO(&set);
3: +    FD_SET(fileno(stdin), &set);
3: @@ -99 +105 @@
3: -        res = select( fileno( stdin )+1, &set, NULL, NULL, NULL);
3: +    res = select(fileno(stdin) + 1, &set, NULL, NULL, NULL);
3: @@ -101,8 +107,7 @@
3: -        if(res > 0){
3: -            ret = read( fileno( stdin ), &_c, 1 );
3: -            userCmd = checkCmd();
3: -            if(userCmd == UserCommand::NONE)
3: -                changeValue();
3: -            _c = '\0';
3: -        }
3: -        usleep(1000);
3: +    if (res > 0) {
3: +      ret = read(fileno(stdin), &_c, 1);
3: +      userCmd = checkCmd();
3: +      if (userCmd == UserCommand::NONE) {
3: +        changeValue();
3: +      }
3: +      _c = '\0';
3: @@ -110,2 +115,4 @@
3: -    return NULL;
3: -}
3: +    usleep(1000);
3: +  }
3: +  return NULL;
3: +}
3: 
3: Code style divergence in file 'src/interface/WirelessHandle.cpp':
3: 
3: --- src/interface/WirelessHandle.cpp
3: +++ src/interface/WirelessHandle.cpp.uncrustify
3: @@ -11 +11,2 @@
3: -WirelessHandle::WirelessHandle(){
3: +WirelessHandle::WirelessHandle()
3: +{
3: @@ -14 +15,2 @@
3: -void WirelessHandle::receiveHandle(UNITREE_LEGGED_SDK::LowState *lowState){
3: +void WirelessHandle::receiveHandle(UNITREE_LEGGED_SDK::LowState * lowState)
3: +{
3: @@ -16 +18 @@
3: -    memcpy(&_keyData, lowState->wirelessRemote, 40);  // note: available in the unitree_legged_sdk_3.2
3: +  memcpy(&_keyData, lowState->wirelessRemote, 40);    // note: available in the unitree_legged_sdk_3.2
3: @@ -19,14 +21,15 @@
3: -    memcpy(&_keyData, &lowState->wirelessRemote[0], 40);
3: -#endif  
3: -    if(((int)_keyData.btn.components.L2 == 1) && 
3: -       ((int)_keyData.btn.components.B  == 1)){
3: -        userCmd = UserCommand::L2_B;
3: -    }
3: -    else if(((int)_keyData.btn.components.L2 == 1) && 
3: -            ((int)_keyData.btn.components.A  == 1)){
3: -        userCmd = UserCommand::L2_A;
3: -    }
3: -    else if(((int)_keyData.btn.components.L2 == 1) && 
3: -            ((int)_keyData.btn.components.X  == 1)){
3: -        userCmd = UserCommand::L2_X;
3: -    }
3: +  memcpy(&_keyData, &lowState->wirelessRemote[0], 40);
3: +#endif
3: +  if (((int)_keyData.btn.components.L2 == 1) &&
3: +    ((int)_keyData.btn.components.B == 1))
3: +  {
3: +    userCmd = UserCommand::L2_B;
3: +  } else if (((int)_keyData.btn.components.L2 == 1) &&
3: +    ((int)_keyData.btn.components.A == 1))
3: +  {
3: +    userCmd = UserCommand::L2_A;
3: +  } else if (((int)_keyData.btn.components.L2 == 1) &&
3: +    ((int)_keyData.btn.components.X == 1))
3: +  {
3: +    userCmd = UserCommand::L2_X;
3: +  }
3: @@ -35,4 +38,5 @@
3: -    else if(((int)_keyData.btn.components.L2 == 1) && 
3: -            ((int)_keyData.btn.components.Y  == 1)){
3: -        userCmd = UserCommand::L2_Y;
3: -    }
3: +  else if (((int)_keyData.btn.components.L2 == 1) &&
3: +    ((int)_keyData.btn.components.Y == 1))
3: +  {
3: +    userCmd = UserCommand::L2_Y;
3: +  }
3: @@ -42,4 +46,5 @@
3: -    else if(((int)_keyData.btn.components.L2 == 1) && 
3: -            ((int)_keyData.btn.components.Y  == 1)){
3: -        userCmd = UserCommand::L2_Y;
3: -    }
3: +  else if (((int)_keyData.btn.components.L2 == 1) &&
3: +    ((int)_keyData.btn.components.Y == 1))
3: +  {
3: +    userCmd = UserCommand::L2_Y;
3: +  }
3: @@ -48,15 +53,15 @@
3: -    else if(((int)_keyData.btn.components.L1 == 1) && 
3: -            ((int)_keyData.btn.components.X  == 1)){
3: -        userCmd = UserCommand::L1_X;
3: -    }
3: -    else if(((int)_keyData.btn.components.L1 == 1) && 
3: -            ((int)_keyData.btn.components.A  == 1)){
3: -        userCmd = UserCommand::L1_A;
3: -    }
3: -    else if(((int)_keyData.btn.components.L1 == 1) && 
3: -            ((int)_keyData.btn.components.Y  == 1)){
3: -        userCmd = UserCommand::L1_Y;
3: -    }
3: -    else if((int)_keyData.btn.components.start == 1){
3: -        userCmd = UserCommand::START;
3: -    }
3: +  else if (((int)_keyData.btn.components.L1 == 1) &&
3: +    ((int)_keyData.btn.components.X == 1))
3: +  {
3: +    userCmd = UserCommand::L1_X;
3: +  } else if (((int)_keyData.btn.components.L1 == 1) &&
3: +    ((int)_keyData.btn.components.A == 1))
3: +  {
3: +    userCmd = UserCommand::L1_A;
3: +  } else if (((int)_keyData.btn.components.L1 == 1) &&
3: +    ((int)_keyData.btn.components.Y == 1))
3: +  {
3: +    userCmd = UserCommand::L1_Y;
3: +  } else if ((int)_keyData.btn.components.start == 1) {
3: +    userCmd = UserCommand::START;
3: +  }
3: @@ -64,5 +69,5 @@
3: -    userValue.L2 = killZeroOffset(_keyData.L2, 0.08);
3: -    userValue.lx = killZeroOffset(_keyData.lx, 0.08);
3: -    userValue.ly = killZeroOffset(_keyData.ly, 0.08);
3: -    userValue.rx = killZeroOffset(_keyData.rx, 0.08);
3: -    userValue.ry = killZeroOffset(_keyData.ry, 0.08);
3: +  userValue.L2 = killZeroOffset(_keyData.L2, 0.08);
3: +  userValue.lx = killZeroOffset(_keyData.lx, 0.08);
3: +  userValue.ly = killZeroOffset(_keyData.ly, 0.08);
3: +  userValue.rx = killZeroOffset(_keyData.rx, 0.08);
3: +  userValue.ry = killZeroOffset(_keyData.ry, 0.08);
3: 
3: Code style divergence in file 'src/main.cpp':
3: 
3: --- src/main.cpp
3: +++ src/main.cpp.uncrustify
3: @@ -33,2 +33,2 @@
3: -    std::cout << "stop the controller" << std::endl;
3: -    running = false;
3: +  std::cout << "stop the controller" << std::endl;
3: +  running = false;
3: @@ -39,7 +39,6 @@
3: -    pid_t pid = getpid();
3: -    sched_param param;
3: -    param.sched_priority = sched_get_priority_max(SCHED_FIFO);
3: -    if (sched_setscheduler(pid, SCHED_FIFO, &param) == -1)
3: -    {
3: -        std::cout << "[ERROR] Function setProcessScheduler failed." << std::endl;
3: -    }
3: +  pid_t pid = getpid();
3: +  sched_param param;
3: +  param.sched_priority = sched_get_priority_max(SCHED_FIFO);
3: +  if (sched_setscheduler(pid, SCHED_FIFO, &param) == -1) {
3: +    std::cout << "[ERROR] Function setProcessScheduler failed." << std::endl;
3: +  }
3: @@ -48 +47 @@
3: -int main(int argc, char **argv)
3: +int main(int argc, char ** argv)
3: @@ -50,4 +49,4 @@
3: -    /* set real-time process */
3: -    setProcessScheduler();
3: -    /* set the print format */
3: -    std::cout << std::fixed << std::setprecision(3);
3: +  /* set real-time process */
3: +  setProcessScheduler();
3: +  /* set the print format */
3: +  std::cout << std::fixed << std::setprecision(3);
3: @@ -56 +55 @@
3: -    // ros::init(argc, argv, "unitree_gazebo_servo");
3: +  // ros::init(argc, argv, "unitree_gazebo_servo");
3: @@ -58,4 +57,4 @@
3: -    // ROS 2
3: -    rclcpp::init(argc, argv);
3: -    auto node = std::make_shared<rclcpp::Node>("unitree_gazebo_server");
3: -    std::cout << "initialized node" << std::endl;
3: +  // ROS 2
3: +  rclcpp::init(argc, argv);
3: +  auto node = std::make_shared<rclcpp::Node>("unitree_gazebo_server");
3: +  std::cout << "initialized node" << std::endl;
3: @@ -65,2 +64,2 @@
3: -    IOInterface *ioInter;
3: -    CtrlPlatform ctrlPlat;
3: +  IOInterface * ioInter;
3: +  CtrlPlatform ctrlPlat;
3: @@ -69,2 +68,2 @@
3: -    ioInter = new IOROS(node);
3: -    ctrlPlat = CtrlPlatform::GAZEBO;
3: +  ioInter = new IOROS(node);
3: +  ctrlPlat = CtrlPlatform::GAZEBO;
3: @@ -74,2 +73,2 @@
3: -    ioInter = new IOSDK();
3: -    ctrlPlat = CtrlPlatform::REALROBOT;
3: +  ioInter = new IOSDK();
3: +  ctrlPlat = CtrlPlatform::REALROBOT;
3: @@ -78,5 +77,5 @@
3: -    CtrlComponents *ctrlComp = new CtrlComponents(ioInter);
3: -    ctrlComp->ctrlPlatform = ctrlPlat;
3: -    ctrlComp->dt = 0.002; // run at 500hz
3: -    ctrlComp->running = &running;
3: -    std::cout << "initialized ctrl components" << std::endl;
3: +  CtrlComponents * ctrlComp = new CtrlComponents(ioInter);
3: +  ctrlComp->ctrlPlatform = ctrlPlat;
3: +  ctrlComp->dt = 0.002;   // run at 500hz
3: +  ctrlComp->running = &running;
3: +  std::cout << "initialized ctrl components" << std::endl;
3: @@ -85 +84 @@
3: -    ctrlComp->robotModel = new A1Robot();
3: +  ctrlComp->robotModel = new A1Robot();
3: @@ -88 +87 @@
3: -    ctrlComp->robotModel = new Go1Robot();
3: +  ctrlComp->robotModel = new Go1Robot();
3: @@ -91,6 +90,6 @@
3: -    ctrlComp->waveGen = new WaveGenerator(0.45, 0.5, Vec4(0, 0.5, 0.5, 0)); // Trot
3: -    std::cout << "initialized wave generator" << std::endl;
3: -    // ctrlComp->waveGen = new WaveGenerator(1.1, 0.75, Vec4(0, 0.25, 0.5, 0.75));  //Crawl, only for sim
3: -    // ctrlComp->waveGen = new WaveGenerator(0.4, 0.6, Vec4(0, 0.5, 0.5, 0));  //Walking Trot, only for sim
3: -    // ctrlComp->waveGen = new WaveGenerator(0.4, 0.35, Vec4(0, 0.5, 0.5, 0));  //Running Trot, only for sim
3: -    // ctrlComp->waveGen = new WaveGenerator(0.4, 0.7, Vec4(0, 0, 0, 0));  //Pronk, only for sim
3: +  ctrlComp->waveGen = new WaveGenerator(0.45, 0.5, Vec4(0, 0.5, 0.5, 0));   // Trot
3: +  std::cout << "initialized wave generator" << std::endl;
3: +  // ctrlComp->waveGen = new WaveGenerator(1.1, 0.75, Vec4(0, 0.25, 0.5, 0.75));  //Crawl, only for sim
3: +  // ctrlComp->waveGen = new WaveGenerator(0.4, 0.6, Vec4(0, 0.5, 0.5, 0));  //Walking Trot, only for sim
3: +  // ctrlComp->waveGen = new WaveGenerator(0.4, 0.35, Vec4(0, 0.5, 0.5, 0));  //Running Trot, only for sim
3: +  // ctrlComp->waveGen = new WaveGenerator(0.4, 0.7, Vec4(0, 0, 0, 0));  //Pronk, only for sim
3: @@ -98 +97 @@
3: -    ctrlComp->geneObj();
3: +  ctrlComp->geneObj();
3: @@ -100,2 +99,2 @@
3: -    ControlFrame ctrlFrame(ctrlComp);
3: -    std::cout << "initialized ctrl frame" << std::endl;
3: +  ControlFrame ctrlFrame(ctrlComp);
3: +  std::cout << "initialized ctrl frame" << std::endl;
3: @@ -103,2 +102,2 @@
3: -    signal(SIGINT, ShutDown);
3: -    // std::cout << "initialized main sig shutdown" << std::endl;
3: +  signal(SIGINT, ShutDown);
3: +  // std::cout << "initialized main sig shutdown" << std::endl;
3: @@ -106,5 +105,4 @@
3: -    while (running)
3: -    {   
3: -        // std::cout << "running main loop" << std::endl;
3: -        ctrlFrame.run();
3: -    }
3: +  while (running) {
3: +    // std::cout << "running main loop" << std::endl;
3: +    ctrlFrame.run();
3: +  }
3: @@ -112,2 +110,2 @@
3: -    delete ctrlComp;
3: -    return 0;
3: +  delete ctrlComp;
3: +  return 0;
3: 
3: Code style divergence in file 'src/quadProgpp/Array.cc':
3: 
3: --- src/quadProgpp/Array.cc
3: +++ src/quadProgpp/Array.cc.uncrustify
3: @@ -2,2 +2,2 @@
3: -// This file is part of QuadProg++:  
3: -// Copyright (C) 2006--2009 Luca Di Gaspero. 
3: +// This file is part of QuadProg++:
3: +// Copyright (C) 2006--2009 Luca Di Gaspero.
3: @@ -16,8 +16,6 @@
3: -std::set<unsigned int> seq(unsigned int s, unsigned int e)
3: -{
3: -	std::set<unsigned int> tmp;
3: -	for (unsigned int i = s; i <= e; i++)
3: -		tmp.insert(i);
3: -	
3: -	return tmp;
3: -}
3: +  std::set < unsigned int > seq(unsigned int s, unsigned int e)
3: +  {
3: +    std::set < unsigned int > tmp;
3: +    for (unsigned int i = s; i <= e; i++) {
3: +      tmp.insert(i);
3: +    }
3: @@ -25,7 +23,10 @@
3: -std::set<unsigned int> singleton(unsigned int i)
3: -{
3: -	std::set<unsigned int> tmp;
3: -	tmp.insert(i);
3: -	
3: -	return tmp;
3: -}
3: +    return tmp;
3: +  }
3: +
3: +  std::set < unsigned int > singleton(unsigned int i)
3: +  {
3: +    std::set < unsigned int > tmp;
3: +    tmp.insert(i);
3: +
3: +    return tmp;
3: +  }
3: 
3: Code style divergence in file 'src/quadProgpp/QuadProg++.cc':
3: 
3: --- src/quadProgpp/QuadProg++.cc
3: +++ src/quadProgpp/QuadProg++.cc.uncrustify
3: @@ -1 +1 @@
3: -/* 
3: +/*
3: @@ -3 +3 @@
3: - 
3: +
3: @@ -8 +8 @@
3: - 
3: +
3: @@ -11 +11 @@
3: - 
3: +
3: @@ -25,6 +25,14 @@
3: -// Utility functions for updating some data needed by the solution method 
3: -void compute_d(Vector<double>& d, const Matrix<double>& J, const Vector<double>& np);
3: -void update_z(Vector<double>& z, const Matrix<double>& J, const Vector<double>& d, int iq);
3: -void update_r(const Matrix<double>& R, Vector<double>& r, const Vector<double>& d, int iq);
3: -bool add_constraint(Matrix<double>& R, Matrix<double>& J, Vector<double>& d, unsigned int& iq, double& rnorm);
3: -void delete_constraint(Matrix<double>& R, Matrix<double>& J, Vector<int>& A, Vector<double>& u, unsigned int n, int p, unsigned int& iq, int l);
3: +// Utility functions for updating some data needed by the solution method
3: +  void compute_d(Vector < double > & d, const Matrix < double > & J, const Vector < double > & np);
3: +  void update_z(
3: +    Vector < double > & z, const Matrix < double > & J, const Vector < double > & d,
3: +    int iq);
3: +  void update_r(
3: +    const Matrix < double > & R, Vector < double > & r, const Vector < double > & d,
3: +    int iq);
3: +  bool add_constraint(
3: +    Matrix < double > & R, Matrix < double > & J, Vector < double > & d,
3: +    unsigned int & iq, double & rnorm);
3: +  void delete_constraint(
3: +    Matrix < double > & R, Matrix < double > & J, Vector < int > & A,
3: +    Vector < double > & u, unsigned int n, int p, unsigned int & iq, int l);
3: @@ -34,6 +42,12 @@
3: -void cholesky_decomposition(Matrix<double>& A);
3: -void cholesky_solve(const Matrix<double>& L, Vector<double>& x, const Vector<double>& b);
3: -void forward_elimination(const Matrix<double>& L, Vector<double>& y, const Vector<double>& b);
3: -void backward_elimination(const Matrix<double>& U, Vector<double>& x, const Vector<double>& y);
3: -
3: -// Utility functions for computing the scalar product and the euclidean 
3: +  void cholesky_decomposition(Matrix < double > & A);
3: +  void cholesky_solve(
3: +    const Matrix < double > & L, Vector < double > & x,
3: +    const Vector < double > & b);
3: +  void forward_elimination(
3: +    const Matrix < double > & L, Vector < double > & y,
3: +    const Vector < double > & b);
3: +  void backward_elimination(
3: +    const Matrix < double > & U, Vector < double > & x,
3: +    const Vector < double > & y);
3: +
3: +// Utility functions for computing the scalar product and the euclidean
3: @@ -41,2 +55,2 @@
3: -double scalar_product(const Vector<double>& x, const Vector<double>& y);
3: -double distance(double a, double b);
3: +  double scalar_product(const Vector < double > & x, const Vector < double > & y);
3: +  double distance(double a, double b);
3: @@ -45,4 +59,4 @@
3: -void print_matrix(const char* name, const Matrix<double>& A, int n = -1, int m = -1);
3: -
3: -template<typename T>
3: -void print_vector(const char* name, const Vector<T>& v, int n = -1);
3: +  void print_matrix(const char * name, const Matrix < double > & A, int n = -1, int m = -1);
3: +
3: +  template < typename T >
3: +  void print_vector(const char * name, const Vector < T > & v, int n = -1);
3: @@ -51,44 +65,45 @@
3: -double solve_quadprog(Matrix<double>& G, Vector<double>& g0, 
3: -                      const Matrix<double>& CE, const Vector<double>& ce0,  
3: -                      const Matrix<double>& CI, const Vector<double>& ci0, 
3: -                      Vector<double>& x)
3: -{
3: -  std::ostringstream msg;
3: -  unsigned int n = G.ncols(), p = CE.ncols(), m = CI.ncols();
3: -  if (G.nrows() != n)
3: -  {
3: -    msg << "The matrix G is not a squared matrix (" << G.nrows() << " x " << G.ncols() << ")";
3: -    throw std::logic_error(msg.str());
3: -  }
3: -  if (CE.nrows() != n)
3: -  {
3: -    msg << "The matrix CE is incompatible (incorrect number of rows " << CE.nrows() << " , expecting " << n << ")";
3: -    throw std::logic_error(msg.str());
3: -  }
3: -  if (ce0.size() != p)
3: -  {
3: -    msg << "The vector ce0 is incompatible (incorrect dimension " << ce0.size() << ", expecting " << p << ")";
3: -    throw std::logic_error(msg.str());
3: -  }
3: -  if (CI.nrows() != n)
3: -  {
3: -    msg << "The matrix CI is incompatible (incorrect number of rows " << CI.nrows() << " , expecting " << n << ")";
3: -    throw std::logic_error(msg.str());
3: -  }
3: -  if (ci0.size() != m)
3: -  {
3: -    msg << "The vector ci0 is incompatible (incorrect dimension " << ci0.size() << ", expecting " << m << ")";
3: -    throw std::logic_error(msg.str());
3: -  }
3: -  x.resize(n);
3: -  register unsigned int i, j, k, l; /* indices */
3: -  int ip; // this is the index of the constraint to be added to the active set
3: -  Matrix<double> R(n, n), J(n, n);
3: -  Vector<double> s(m + p), z(n), r(m + p), d(n), np(n), u(m + p), x_old(n), u_old(m + p);
3: -  double f_value, psi, c1, c2, sum, ss, R_norm;
3: -  double inf;
3: -  if (std::numeric_limits<double>::has_infinity)
3: -    inf = std::numeric_limits<double>::infinity();
3: -  else
3: -    inf = 1.0E300;
3: -  double t, t1, t2; /* t is the step lenght, which is the minimum of the partial step length t1 
3: +  double solve_quadprog(
3: +    Matrix < double > & G, Vector < double > & g0,
3: +    const Matrix < double > & CE, const Vector < double > & ce0,
3: +    const Matrix < double > & CI, const Vector < double > & ci0,
3: +    Vector < double > & x)
3: +  {
3: +    std::ostringstream msg;
3: +    unsigned int n = G.ncols(), p = CE.ncols(), m = CI.ncols();
3: +    if (G.nrows() != n) {
3: +      msg << "The matrix G is not a squared matrix (" << G.nrows() << " x " << G.ncols() << ")";
3: +      throw std::logic_error(msg.str());
3: +    }
3: +    if (CE.nrows() != n) {
3: +      msg << "The matrix CE is incompatible (incorrect number of rows " << CE.nrows() <<
3: +        " , expecting " << n << ")";
3: +      throw std::logic_error(msg.str());
3: +    }
3: +    if (ce0.size() != p) {
3: +      msg << "The vector ce0 is incompatible (incorrect dimension " << ce0.size() <<
3: +        ", expecting " << p << ")";
3: +      throw std::logic_error(msg.str());
3: +    }
3: +    if (CI.nrows() != n) {
3: +      msg << "The matrix CI is incompatible (incorrect number of rows " << CI.nrows() <<
3: +        " , expecting " << n << ")";
3: +      throw std::logic_error(msg.str());
3: +    }
3: +    if (ci0.size() != m) {
3: +      msg << "The vector ci0 is incompatible (incorrect dimension " << ci0.size() <<
3: +        ", expecting " << m << ")";
3: +      throw std::logic_error(msg.str());
3: +    }
3: +    x.resize(n);
3: +    register unsigned int i, j, k, l; /* indices */
3: +    int ip; // this is the index of the constraint to be added to the active set
3: +    Matrix < double > R(n, n), J(n, n);
3: +    Vector < double > s(m + p), z(n), r(m + p), d(n), np(n), u(m + p), x_old(n), u_old(m + p);
3: +    double f_value, psi, c1, c2, sum, ss, R_norm;
3: +    double inf;
3: +    if (std::numeric_limits < double > ::has_infinity) {
3: +      inf = std::numeric_limits < double > ::infinity();
3: +    } else {
3: +      inf = 1.0E300;
3: +    }
3: +    double t, t1, t2; /* t is the step lenght, which is the minimum of the partial step length t1
3: @@ -96,111 +111,153 @@
3: -  Vector<int> A(m + p), A_old(m + p), iai(m + p);
3: -  unsigned int iq, iter = 0;
3: -  Vector<bool> iaexcl(m + p);
3: -	
3: -  /* p is the number of equality constraints */
3: -  /* m is the number of inequality constraints */
3: -#ifdef TRACE_SOLVER
3: -  std::cout << std::endl << "Starting solve_quadprog" << std::endl;
3: -  print_matrix("G", G);
3: -  print_vector("g0", g0);
3: -  print_matrix("CE", CE);
3: -  print_vector("ce0", ce0);
3: -  print_matrix("CI", CI);
3: -  print_vector("ci0", ci0);
3: -#endif  
3: -  
3: -  /*
3: -   * Preprocessing phase
3: -   */
3: -	
3: -  /* compute the trace of the original matrix G */
3: -  c1 = 0.0;
3: -  for (i = 0; i < n; i++)
3: -  {
3: -    c1 += G[i][i];
3: -  }
3: -  /* decompose the matrix G in the form L^T L */
3: -  cholesky_decomposition(G);
3: -#ifdef TRACE_SOLVER
3: -  print_matrix("G", G);
3: -#endif
3: -  /* initialize the matrix R */
3: -  for (i = 0; i < n; i++)
3: -  {
3: -    d[i] = 0.0;
3: -    for (j = 0; j < n; j++)
3: -      R[i][j] = 0.0;
3: -  }
3: -  R_norm = 1.0; /* this variable will hold the norm of the matrix R */
3: -  
3: -  /* compute the inverse of the factorized matrix G^-1, this is the initial value for H */
3: -  c2 = 0.0;
3: -  for (i = 0; i < n; i++) 
3: -  {
3: -    d[i] = 1.0;
3: -    forward_elimination(G, z, d);
3: -    for (j = 0; j < n; j++)
3: -      J[i][j] = z[j];
3: -    c2 += z[i];
3: -    d[i] = 0.0;
3: -  }
3: -#ifdef TRACE_SOLVER
3: -  print_matrix("J", J);
3: -#endif
3: -  
3: -  /* c1 * c2 is an estimate for cond(G) */
3: -  
3: -  /* 
3: -    * Find the unconstrained minimizer of the quadratic form 0.5 * x G x + g0 x 
3: -   * this is a feasible point in the dual space
3: -   * x = G^-1 * g0
3: -   */
3: -  cholesky_solve(G, x, g0);
3: -  for (i = 0; i < n; i++)
3: -    x[i] = -x[i];
3: -  /* and compute the current solution value */ 
3: -  f_value = 0.5 * scalar_product(g0, x);
3: -#ifdef TRACE_SOLVER
3: -  std::cout << "Unconstrained solution: " << f_value << std::endl;
3: -  print_vector("x", x);
3: -#endif
3: -  
3: -  /* Add equality constraints to the working set A */
3: -  iq = 0;
3: -  for (i = 0; i < p; i++)
3: -  {
3: -    for (j = 0; j < n; j++)
3: -      np[j] = CE[j][i];
3: -    compute_d(d, J, np);
3: -    update_z(z, J, d, iq);
3: -    update_r(R, r, d, iq);
3: -#ifdef TRACE_SOLVER
3: -    print_matrix("R", R, n, iq);
3: -    print_vector("z", z);
3: -    print_vector("r", r, iq);
3: -    print_vector("d", d);
3: -#endif
3: -    
3: -    /* compute full step length t2: i.e., the minimum step in primal space s.t. the contraint 
3: -      becomes feasible */
3: -    t2 = 0.0;
3: -    if (fabs(scalar_product(z, z)) > std::numeric_limits<double>::epsilon()) // i.e. z != 0
3: -      t2 = (-scalar_product(np, x) - ce0[i]) / scalar_product(z, np);
3: -    
3: -    /* set x = x + t2 * z */
3: -    for (k = 0; k < n; k++)
3: -      x[k] += t2 * z[k];
3: -    
3: -    /* set u = u+ */
3: -    u[iq] = t2;
3: -    for (k = 0; k < iq; k++)
3: -      u[k] -= t2 * r[k];
3: -    
3: -    /* compute the new solution value */
3: -    f_value += 0.5 * (t2 * t2) * scalar_product(z, np);
3: -    A[i] = -i - 1;
3: -    
3: -    if (!add_constraint(R, J, d, iq, R_norm))
3: -    {	  
3: -      // Equality constraints are linearly dependent
3: -      throw std::runtime_error("Constraints are linearly dependent");
3: +    Vector < int > A(m + p), A_old(m + p), iai(m + p);
3: +    unsigned int iq, iter = 0;
3: +    Vector < bool > iaexcl(m + p);
3: +
3: +    /* p is the number of equality constraints */
3: +    /* m is the number of inequality constraints */
3: +#ifdef TRACE_SOLVER
3: +    std::cout << std::endl << "Starting solve_quadprog" << std::endl;
3: +    print_matrix("G", G);
3: +    print_vector("g0", g0);
3: +    print_matrix("CE", CE);
3: +    print_vector("ce0", ce0);
3: +    print_matrix("CI", CI);
3: +    print_vector("ci0", ci0);
3: +#endif
3: +
3: +    /*
3: +     * Preprocessing phase
3: +     */
3: +
3: +    /* compute the trace of the original matrix G */
3: +    c1 = 0.0;
3: +    for (i = 0; i < n; i++) {
3: +      c1 += G[i][i];
3: +    }
3: +    /* decompose the matrix G in the form L^T L */
3: +    cholesky_decomposition(G);
3: +#ifdef TRACE_SOLVER
3: +    print_matrix("G", G);
3: +#endif
3: +    /* initialize the matrix R */
3: +    for (i = 0; i < n; i++) {
3: +      d[i] = 0.0;
3: +      for (j = 0; j < n; j++) {
3: +        R[i][j] = 0.0;
3: +      }
3: +    }
3: +    R_norm = 1.0; /* this variable will hold the norm of the matrix R */
3: +
3: +    /* compute the inverse of the factorized matrix G^-1, this is the initial value for H */
3: +    c2 = 0.0;
3: +    for (i = 0; i < n; i++) {
3: +      d[i] = 1.0;
3: +      forward_elimination(G, z, d);
3: +      for (j = 0; j < n; j++) {
3: +        J[i][j] = z[j];
3: +      }
3: +      c2 += z[i];
3: +      d[i] = 0.0;
3: +    }
3: +#ifdef TRACE_SOLVER
3: +    print_matrix("J", J);
3: +#endif
3: +
3: +    /* c1 * c2 is an estimate for cond(G) */
3: +
3: +    /*
3: +      * Find the unconstrained minimizer of the quadratic form 0.5 * x G x + g0 x
3: +     * this is a feasible point in the dual space
3: +     * x = G^-1 * g0
3: +     */
3: +    cholesky_solve(G, x, g0);
3: +    for (i = 0; i < n; i++) {
3: +      x[i] = -x[i];
3: +    }
3: +    /* and compute the current solution value */
3: +    f_value = 0.5 * scalar_product(g0, x);
3: +#ifdef TRACE_SOLVER
3: +    std::cout << "Unconstrained solution: " << f_value << std::endl;
3: +    print_vector("x", x);
3: +#endif
3: +
3: +    /* Add equality constraints to the working set A */
3: +    iq = 0;
3: +    for (i = 0; i < p; i++) {
3: +      for (j = 0; j < n; j++) {
3: +        np[j] = CE[j][i];
3: +      }
3: +      compute_d(d, J, np);
3: +      update_z(z, J, d, iq);
3: +      update_r(R, r, d, iq);
3: +#ifdef TRACE_SOLVER
3: +      print_matrix("R", R, n, iq);
3: +      print_vector("z", z);
3: +      print_vector("r", r, iq);
3: +      print_vector("d", d);
3: +#endif
3: +
3: +      /* compute full step length t2: i.e., the minimum step in primal space s.t. the contraint
3: +        becomes feasible */
3: +      t2 = 0.0;
3: +      if (fabs(scalar_product(z, z)) > std::numeric_limits < double > ::epsilon()) { // i.e. z != 0
3: +        t2 = (-scalar_product(np, x) - ce0[i]) / scalar_product(z, np);
3: +      }
3: +
3: +      /* set x = x + t2 * z */
3: +      for (k = 0; k < n; k++) {
3: +        x[k] += t2 * z[k];
3: +      }
3: +
3: +      /* set u = u+ */
3: +      u[iq] = t2;
3: +      for (k = 0; k < iq; k++) {
3: +        u[k] -= t2 * r[k];
3: +      }
3: +
3: +      /* compute the new solution value */
3: +      f_value += 0.5 * (t2 * t2) * scalar_product(z, np);
3: +      A[i] = -i - 1;
3: +
3: +      if (!add_constraint(R, J, d, iq, R_norm)) {
3: +        // Equality constraints are linearly dependent
3: +        throw std::runtime_error("Constraints are linearly dependent");
3: +        return f_value;
3: +      }
3: +    }
3: +
3: +    /* set iai = K \ A */
3: +    for (i = 0; i < m; i++) {
3: +      iai[i] = i;
3: +    }
3: +
3: +l1: iter++;
3: +#ifdef TRACE_SOLVER
3: +    print_vector("x", x);
3: +#endif
3: +    /* step 1: choose a violated constraint */
3: +    for (i = p; i < iq; i++) {
3: +      ip = A[i];
3: +      iai[ip] = -1;
3: +    }
3: +
3: +    /* compute s[x] = ci^T * x + ci0 for all elements of K \ A */
3: +    ss = 0.0;
3: +    psi = 0.0; /* this value will contain the sum of all infeasibilities */
3: +    ip = 0; /* ip will be the index of the chosen violated constraint */
3: +    for (i = 0; i < m; i++) {
3: +      iaexcl[i] = true;
3: +      sum = 0.0;
3: +      for (j = 0; j < n; j++) {
3: +        sum += CI[j][i] * x[j];
3: +      }
3: +      sum += ci0[i];
3: +      s[i] = sum;
3: +      psi += std::min(0.0, sum);
3: +    }
3: +#ifdef TRACE_SOLVER
3: +    print_vector("s", s, m);
3: +#endif
3: +
3: +
3: +    if (fabs(psi) <= m * std::numeric_limits < double > ::epsilon() * c1 * c2 * 100.0) {
3: +      /* numerically there are not infeasibilities anymore */
3: @@ -209,52 +266,11 @@
3: -  }
3: -  
3: -  /* set iai = K \ A */
3: -  for (i = 0; i < m; i++)
3: -    iai[i] = i;
3: -  
3: -l1:	iter++;
3: -#ifdef TRACE_SOLVER
3: -  print_vector("x", x);
3: -#endif
3: -  /* step 1: choose a violated constraint */
3: -  for (i = p; i < iq; i++)
3: -  {
3: -    ip = A[i];
3: -    iai[ip] = -1;
3: -  }
3: -	
3: -  /* compute s[x] = ci^T * x + ci0 for all elements of K \ A */
3: -  ss = 0.0;
3: -  psi = 0.0; /* this value will contain the sum of all infeasibilities */
3: -  ip = 0; /* ip will be the index of the chosen violated constraint */
3: -  for (i = 0; i < m; i++)
3: -  {
3: -    iaexcl[i] = true;
3: -    sum = 0.0;
3: -    for (j = 0; j < n; j++)
3: -      sum += CI[j][i] * x[j];
3: -    sum += ci0[i];
3: -    s[i] = sum;
3: -    psi += std::min(0.0, sum);
3: -  }
3: -#ifdef TRACE_SOLVER
3: -  print_vector("s", s, m);
3: -#endif
3: -  
3: -  
3: -  if (fabs(psi) <= m * std::numeric_limits<double>::epsilon() * c1 * c2* 100.0)
3: -  {
3: -    /* numerically there are not infeasibilities anymore */
3: -    return f_value;
3: -  }
3: -  
3: -  /* save old values for u and A */
3: -  for (i = 0; i < iq; i++)
3: -  {
3: -    u_old[i] = u[i];
3: -    A_old[i] = A[i];
3: -  }
3: -  /* and for x */
3: -  for (i = 0; i < n; i++)
3: -    x_old[i] = x[i];
3: -  
3: +
3: +    /* save old values for u and A */
3: +    for (i = 0; i < iq; i++) {
3: +      u_old[i] = u[i];
3: +      A_old[i] = A[i];
3: +    }
3: +    /* and for x */
3: +    for (i = 0; i < n; i++) {
3: +      x_old[i] = x[i];
3: +    }
3: +
3: @@ -262,4 +278,2 @@
3: -    for (i = 0; i < m; i++)
3: -    {
3: -      if (s[i] < ss && iai[i] != -1 && iaexcl[i])
3: -      {
3: +    for (i = 0; i < m; i++) {
3: +      if (s[i] < ss && iai[i] != -1 && iaexcl[i]) {
3: @@ -270,18 +284,18 @@
3: -  if (ss >= 0.0)
3: -  {
3: -    return f_value;
3: -  }
3: -  
3: -  /* set np = n[ip] */
3: -  for (i = 0; i < n; i++)
3: -    np[i] = CI[i][ip];
3: -  /* set u = [u 0]^T */
3: -  u[iq] = 0.0;
3: -  /* add ip to the active set A */
3: -  A[iq] = ip;
3: -  
3: -#ifdef TRACE_SOLVER
3: -  std::cout << "Trying with constraint " << ip << std::endl;
3: -  print_vector("np", np);
3: -#endif
3: -  
3: +    if (ss >= 0.0) {
3: +      return f_value;
3: +    }
3: +
3: +    /* set np = n[ip] */
3: +    for (i = 0; i < n; i++) {
3: +      np[i] = CI[i][ip];
3: +    }
3: +    /* set u = [u 0]^T */
3: +    u[iq] = 0.0;
3: +    /* add ip to the active set A */
3: +    A[iq] = ip;
3: +
3: +#ifdef TRACE_SOLVER
3: +    std::cout << "Trying with constraint " << ip << std::endl;
3: +    print_vector("np", np);
3: +#endif
3: +
3: @@ -291,58 +305,78 @@
3: -  update_z(z, J, d, iq);
3: -  /* compute N* np (if q > 0): the negative of the step direction in the dual space */
3: -  update_r(R, r, d, iq);
3: -#ifdef TRACE_SOLVER
3: -  std::cout << "Step direction z" << std::endl;
3: -  print_vector("z", z);
3: -  print_vector("r", r, iq + 1);
3: -  print_vector("u", u, iq + 1);
3: -  print_vector("d", d);
3: -  print_vector("A", A, iq + 1);
3: -#endif
3: -  
3: -  /* Step 2b: compute step length */
3: -  l = 0;
3: -  /* Compute t1: partial step length (maximum step in dual space without violating dual feasibility */
3: -  t1 = inf; /* +inf */
3: -  /* find the index l s.t. it reaches the minimum of u+[x] / r */
3: -  for (k = p; k < iq; k++)
3: -  {
3: -    if (r[k] > 0.0)
3: -    {
3: -      if (u[k] / r[k] < t1)
3: -	    {
3: -	      t1 = u[k] / r[k];
3: -	      l = A[k];
3: -	    }
3: -    }
3: -  }
3: -  /* Compute t2: full step length (minimum step in primal space such that the constraint ip becomes feasible */
3: -  if (fabs(scalar_product(z, z))  > std::numeric_limits<double>::epsilon()) // i.e. z != 0
3: -  {
3: -    t2 = -s[ip] / scalar_product(z, np);
3: -    if (t2 < 0) // patch suggested by Takano Akio for handling numerical inconsistencies
3: -      t2 = inf;
3: -  }
3: -  else
3: -    t2 = inf; /* +inf */
3: -  
3: -  /* the step is chosen as the minimum of t1 and t2 */
3: -  t = std::min(t1, t2);
3: -#ifdef TRACE_SOLVER
3: -  std::cout << "Step sizes: " << t << " (t1 = " << t1 << ", t2 = " << t2 << ") ";
3: -#endif
3: -  
3: -  /* Step 2c: determine new S-pair and take step: */
3: -  
3: -  /* case (i): no step in primal or dual space */
3: -  if (t >= inf)
3: -  {
3: -    /* QPP is infeasible */
3: -    // FIXME: unbounded to raise
3: -    return inf;
3: -  }
3: -  /* case (ii): step in dual space */
3: -  if (t2 >= inf)
3: -  {
3: -    /* set u = u +  t * [-r 1] and drop constraint l from the active set A */
3: -    for (k = 0; k < iq; k++)
3: +    update_z(z, J, d, iq);
3: +    /* compute N* np (if q > 0): the negative of the step direction in the dual space */
3: +    update_r(R, r, d, iq);
3: +#ifdef TRACE_SOLVER
3: +    std::cout << "Step direction z" << std::endl;
3: +    print_vector("z", z);
3: +    print_vector("r", r, iq + 1);
3: +    print_vector("u", u, iq + 1);
3: +    print_vector("d", d);
3: +    print_vector("A", A, iq + 1);
3: +#endif
3: +
3: +    /* Step 2b: compute step length */
3: +    l = 0;
3: +    /* Compute t1: partial step length (maximum step in dual space without violating dual feasibility */
3: +    t1 = inf; /* +inf */
3: +    /* find the index l s.t. it reaches the minimum of u+[x] / r */
3: +    for (k = p; k < iq; k++) {
3: +      if (r[k] > 0.0) {
3: +        if (u[k] / r[k] < t1) {
3: +          t1 = u[k] / r[k];
3: +          l = A[k];
3: +        }
3: +      }
3: +    }
3: +    /* Compute t2: full step length (minimum step in primal space such that the constraint ip becomes feasible */
3: +    if (fabs(scalar_product(z, z)) > std::numeric_limits < double > ::epsilon()) { // i.e. z != 0
3: +      t2 = -s[ip] / scalar_product(z, np);
3: +      if (t2 < 0) { // patch suggested by Takano Akio for handling numerical inconsistencies
3: +        t2 = inf;
3: +      }
3: +    } else {
3: +      t2 = inf; /* +inf */
3: +
3: +    }
3: +    /* the step is chosen as the minimum of t1 and t2 */
3: +    t = std::min(t1, t2);
3: +#ifdef TRACE_SOLVER
3: +    std::cout << "Step sizes: " << t << " (t1 = " << t1 << ", t2 = " << t2 << ") ";
3: +#endif
3: +
3: +    /* Step 2c: determine new S-pair and take step: */
3: +
3: +    /* case (i): no step in primal or dual space */
3: +    if (t >= inf) {
3: +      /* QPP is infeasible */
3: +      // FIXME: unbounded to raise
3: +      return inf;
3: +    }
3: +    /* case (ii): step in dual space */
3: +    if (t2 >= inf) {
3: +      /* set u = u +  t * [-r 1] and drop constraint l from the active set A */
3: +      for (k = 0; k < iq; k++) {
3: +        u[k] -= t * r[k];
3: +      }
3: +      u[iq] += t;
3: +      iai[l] = l;
3: +      delete_constraint(R, J, A, u, n, p, iq, l);
3: +#ifdef TRACE_SOLVER
3: +      std::cout << " in dual space: "
3: +                << f_value << std::endl;
3: +      print_vector("x", x);
3: +      print_vector("z", z);
3: +      print_vector("A", A, iq + 1);
3: +#endif
3: +      goto l2a;
3: +    }
3: +
3: +    /* case (iii): step in primal and dual space */
3: +
3: +    /* set x = x + t * z */
3: +    for (k = 0; k < n; k++) {
3: +      x[k] += t * z[k];
3: +    }
3: +    /* update the solution value */
3: +    f_value += t * scalar_product(z, np) * (0.5 * t + u[iq]);
3: +    /* u = u + t * [-r 1] */
3: +    for (k = 0; k < iq; k++) {
3: @@ -349,0 +384 @@
3: +    }
3: @@ -350,0 +386,53 @@
3: +#ifdef TRACE_SOLVER
3: +    std::cout << " in both spaces: "
3: +              << f_value << std::endl;
3: +    print_vector("x", x);
3: +    print_vector("u", u, iq + 1);
3: +    print_vector("r", r, iq + 1);
3: +    print_vector("A", A, iq + 1);
3: +#endif
3: +
3: +    if (fabs(t - t2) < std::numeric_limits < double > ::epsilon()) {
3: +#ifdef TRACE_SOLVER
3: +      std::cout << "Full step has taken " << t << std::endl;
3: +      print_vector("x", x);
3: +#endif
3: +      /* full step has taken */
3: +      /* add constraint ip to the active set*/
3: +      if (!add_constraint(R, J, d, iq, R_norm)) {
3: +        iaexcl[ip] = false;
3: +        delete_constraint(R, J, A, u, n, p, iq, ip);
3: +#ifdef TRACE_SOLVER
3: +        print_matrix("R", R);
3: +        print_vector("A", A, iq);
3: +        print_vector("iai", iai);
3: +#endif
3: +        for (i = 0; i < m; i++) {
3: +          iai[i] = i;
3: +        }
3: +        for (i = p; i < iq; i++) {
3: +          A[i] = A_old[i];
3: +          u[i] = u_old[i];
3: +          iai[A[i]] = -1;
3: +        }
3: +        for (i = 0; i < n; i++) {
3: +          x[i] = x_old[i];
3: +        }
3: +        goto l2; /* go to step 2 */
3: +      } else {
3: +        iai[ip] = -1;
3: +      }
3: +#ifdef TRACE_SOLVER
3: +      print_matrix("R", R);
3: +      print_vector("A", A, iq);
3: +      print_vector("iai", iai);
3: +#endif
3: +      goto l1;
3: +    }
3: +
3: +    /* a patial step has taken */
3: +#ifdef TRACE_SOLVER
3: +    std::cout << "Partial step has taken " << t << std::endl;
3: +    print_vector("x", x);
3: +#endif
3: +    /* drop constraint l */
3: @@ -354,61 +441,0 @@
3: -    std::cout << " in dual space: " 
3: -      << f_value << std::endl;
3: -    print_vector("x", x);
3: -    print_vector("z", z);
3: -    print_vector("A", A, iq + 1);
3: -#endif
3: -    goto l2a;
3: -  }
3: -  
3: -  /* case (iii): step in primal and dual space */
3: -  
3: -  /* set x = x + t * z */
3: -  for (k = 0; k < n; k++)
3: -    x[k] += t * z[k];
3: -  /* update the solution value */
3: -  f_value += t * scalar_product(z, np) * (0.5 * t + u[iq]);
3: -  /* u = u + t * [-r 1] */
3: -  for (k = 0; k < iq; k++)
3: -    u[k] -= t * r[k];
3: -  u[iq] += t;
3: -#ifdef TRACE_SOLVER
3: -  std::cout << " in both spaces: " 
3: -    << f_value << std::endl;
3: -  print_vector("x", x);
3: -  print_vector("u", u, iq + 1);
3: -  print_vector("r", r, iq + 1);
3: -  print_vector("A", A, iq + 1);
3: -#endif
3: -  
3: -  if (fabs(t - t2) < std::numeric_limits<double>::epsilon())
3: -  {
3: -#ifdef TRACE_SOLVER
3: -    std::cout << "Full step has taken " << t << std::endl;
3: -    print_vector("x", x);
3: -#endif
3: -    /* full step has taken */
3: -    /* add constraint ip to the active set*/
3: -    if (!add_constraint(R, J, d, iq, R_norm))
3: -    {
3: -      iaexcl[ip] = false;
3: -      delete_constraint(R, J, A, u, n, p, iq, ip);
3: -#ifdef TRACE_SOLVER
3: -      print_matrix("R", R);
3: -      print_vector("A", A, iq);
3: -			print_vector("iai", iai);
3: -#endif
3: -      for (i = 0; i < m; i++)
3: -        iai[i] = i;
3: -      for (i = p; i < iq; i++)
3: -	    {
3: -	      A[i] = A_old[i];
3: -	      u[i] = u_old[i];
3: -				iai[A[i]] = -1;
3: -	    }
3: -      for (i = 0; i < n; i++)
3: -        x[i] = x_old[i];
3: -      goto l2; /* go to step 2 */
3: -    }    
3: -    else
3: -      iai[ip] = -1;
3: -#ifdef TRACE_SOLVER
3: @@ -417,38 +444,3 @@
3: -		print_vector("iai", iai);
3: -#endif
3: -    goto l1;
3: -  }
3: -  
3: -  /* a patial step has taken */
3: -#ifdef TRACE_SOLVER
3: -  std::cout << "Partial step has taken " << t << std::endl;
3: -  print_vector("x", x);
3: -#endif
3: -  /* drop constraint l */
3: -  iai[l] = l;
3: -  delete_constraint(R, J, A, u, n, p, iq, l);
3: -#ifdef TRACE_SOLVER
3: -  print_matrix("R", R);
3: -  print_vector("A", A, iq);
3: -#endif
3: -  
3: -  /* update s[ip] = CI * x + ci0 */
3: -  sum = 0.0;
3: -  for (k = 0; k < n; k++)
3: -    sum += CI[k][ip] * x[k];
3: -  s[ip] = sum + ci0[ip];
3: -  
3: -#ifdef TRACE_SOLVER
3: -  print_vector("s", s, m);
3: -#endif
3: -  goto l2a;
3: -}
3: -
3: -inline void compute_d(Vector<double>& d, const Matrix<double>& J, const Vector<double>& np)
3: -{
3: -  register int i, j, n = d.size();
3: -  register double sum;
3: -  
3: -  /* compute d = H^T * np */
3: -  for (i = 0; i < n; i++)
3: -  {
3: +#endif
3: +
3: +    /* update s[ip] = CI * x + ci0 */
3: @@ -456,132 +448,158 @@
3: -    for (j = 0; j < n; j++)
3: -      sum += J[j][i] * np[j];
3: -    d[i] = sum;
3: -  }
3: -}
3: -
3: -inline void update_z(Vector<double>& z, const Matrix<double>& J, const Vector<double>& d, int iq)
3: -{
3: -  register int i, j, n = z.size();
3: -	
3: -  /* setting of z = H * d */
3: -  for (i = 0; i < n; i++)
3: -  {
3: -    z[i] = 0.0;
3: -    for (j = iq; j < n; j++)
3: -      z[i] += J[i][j] * d[j];
3: -  }
3: -}
3: -
3: -inline void update_r(const Matrix<double>& R, Vector<double>& r, const Vector<double>& d, int iq)
3: -{
3: -  register int i, j;
3: -  register double sum;
3: -  
3: -  /* setting of r = R^-1 d */
3: -  for (i = iq - 1; i >= 0; i--)
3: -  {
3: -    sum = 0.0;
3: -    for (j = i + 1; j < iq; j++)
3: -      sum += R[i][j] * r[j];
3: -    r[i] = (d[i] - sum) / R[i][i];
3: -  }
3: -}
3: -
3: -bool add_constraint(Matrix<double>& R, Matrix<double>& J, Vector<double>& d, unsigned int& iq, double& R_norm)
3: -{
3: -  unsigned int n = d.size();
3: -#ifdef TRACE_SOLVER
3: -  std::cout << "Add constraint " << iq << '/';
3: -#endif
3: -  register unsigned int i, j, k;
3: -  double cc, ss, h, t1, t2, xny;
3: -	
3: -  /* we have to find the Givens rotation which will reduce the element
3: -    d[j] to zero.
3: -    if it is already zero we don't have to do anything, except of
3: -    decreasing j */  
3: -  for (j = n - 1; j >= iq + 1; j--)
3: -  {
3: -    /* The Givens rotation is done with the matrix (cc cs, cs -cc).
3: -    If cc is one, then element (j) of d is zero compared with element
3: -    (j - 1). Hence we don't have to do anything. 
3: -    If cc is zero, then we just have to switch column (j) and column (j - 1) 
3: -    of J. Since we only switch columns in J, we have to be careful how we
3: -    update d depending on the sign of gs.
3: -    Otherwise we have to apply the Givens rotation to these columns.
3: -    The i - 1 element of d has to be updated to h. */
3: -    cc = d[j - 1];
3: -    ss = d[j];
3: -    h = distance(cc, ss);
3: -    if (fabs(h) < std::numeric_limits<double>::epsilon()) // h == 0
3: -      continue;
3: -    d[j] = 0.0;
3: -    ss = ss / h;
3: -    cc = cc / h;
3: -    if (cc < 0.0)
3: -    {
3: -      cc = -cc;
3: -      ss = -ss;
3: -      d[j - 1] = -h;
3: -    }
3: -    else
3: -      d[j - 1] = h;
3: -    xny = ss / (1.0 + cc);
3: -    for (k = 0; k < n; k++)
3: -    {
3: -      t1 = J[k][j - 1];
3: -      t2 = J[k][j];
3: -      J[k][j - 1] = t1 * cc + t2 * ss;
3: -      J[k][j] = xny * (t1 + J[k][j - 1]) - t2;
3: -    }
3: -  }
3: -  /* update the number of constraints added*/
3: -  iq++;
3: -  /* To update R we have to put the iq components of the d vector
3: -    into column iq - 1 of R
3: -    */
3: -  for (i = 0; i < iq; i++)
3: -    R[i][iq - 1] = d[i];
3: -#ifdef TRACE_SOLVER
3: -  std::cout << iq << std::endl;
3: -  print_matrix("R", R, iq, iq);
3: -  print_matrix("J", J);
3: -  print_vector("d", d, iq);
3: -#endif
3: -  
3: -  if (fabs(d[iq - 1]) <= std::numeric_limits<double>::epsilon() * R_norm) 
3: -  {
3: -    // problem degenerate
3: -    return false;
3: -  }
3: -  R_norm = std::max<double>(R_norm, fabs(d[iq - 1]));
3: -  return true;
3: -}
3: -
3: -void delete_constraint(Matrix<double>& R, Matrix<double>& J, Vector<int>& A, Vector<double>& u, unsigned int n, int p, unsigned int& iq, int l)
3: -{
3: -#ifdef TRACE_SOLVER
3: -  std::cout << "Delete constraint " << l << ' ' << iq;
3: -#endif
3: -  register unsigned int i, j, k, qq = 0; // just to prevent warnings from smart compilers
3: -  double cc, ss, h, xny, t1, t2;
3: -
3: -  bool found = false;
3: -  /* Find the index qq for active constraint l to be removed */
3: -  for (i = p; i < iq; i++)
3: -    if (A[i] == l)
3: -    {
3: -      qq = i;
3: -      found = true;
3: -      break;
3: -    }
3: -
3: -  if(!found)
3: -  {
3: -    std::ostringstream os;
3: -    os << "Attempt to delete non existing constraint, constraint: " << l;
3: -    throw std::invalid_argument(os.str());
3: -  }
3: -  /* remove the constraint from the active set and the duals */
3: -  for (i = qq; i < iq - 1; i++)
3: -    {
3: +    for (k = 0; k < n; k++) {
3: +      sum += CI[k][ip] * x[k];
3: +    }
3: +    s[ip] = sum + ci0[ip];
3: +
3: +#ifdef TRACE_SOLVER
3: +    print_vector("s", s, m);
3: +#endif
3: +    goto l2a;
3: +  }
3: +
3: +  inline void compute_d(
3: +    Vector < double > & d, const Matrix < double > & J,
3: +    const Vector < double > & np)
3: +  {
3: +    register int i, j, n = d.size();
3: +    register double sum;
3: +
3: +    /* compute d = H^T * np */
3: +    for (i = 0; i < n; i++) {
3: +      sum = 0.0;
3: +      for (j = 0; j < n; j++) {
3: +        sum += J[j][i] * np[j];
3: +      }
3: +      d[i] = sum;
3: +    }
3: +  }
3: +
3: +  inline void update_z(
3: +    Vector < double > & z, const Matrix < double > & J,
3: +    const Vector < double > & d, int iq)
3: +  {
3: +    register int i, j, n = z.size();
3: +
3: +    /* setting of z = H * d */
3: +    for (i = 0; i < n; i++) {
3: +      z[i] = 0.0;
3: +      for (j = iq; j < n; j++) {
3: +        z[i] += J[i][j] * d[j];
3: +      }
3: +    }
3: +  }
3: +
3: +  inline void update_r(
3: +    const Matrix < double > & R, Vector < double > & r,
3: +    const Vector < double > & d, int iq)
3: +  {
3: +    register int i, j;
3: +    register double sum;
3: +
3: +    /* setting of r = R^-1 d */
3: +    for (i = iq - 1; i >= 0; i--) {
3: +      sum = 0.0;
3: +      for (j = i + 1; j < iq; j++) {
3: +        sum += R[i][j] * r[j];
3: +      }
3: +      r[i] = (d[i] - sum) / R[i][i];
3: +    }
3: +  }
3: +
3: +  bool add_constraint(
3: +    Matrix < double > & R, Matrix < double > & J, Vector < double > & d,
3: +    unsigned int & iq, double & R_norm)
3: +  {
3: +    unsigned int n = d.size();
3: +#ifdef TRACE_SOLVER
3: +    std::cout << "Add constraint " << iq << '/';
3: +#endif
3: +    register unsigned int i, j, k;
3: +    double cc, ss, h, t1, t2, xny;
3: +
3: +    /* we have to find the Givens rotation which will reduce the element
3: +      d[j] to zero.
3: +      if it is already zero we don't have to do anything, except of
3: +      decreasing j */
3: +    for (j = n - 1; j >= iq + 1; j--) {
3: +      /* The Givens rotation is done with the matrix (cc cs, cs -cc).
3: +      If cc is one, then element (j) of d is zero compared with element
3: +      (j - 1). Hence we don't have to do anything.
3: +      If cc is zero, then we just have to switch column (j) and column (j - 1)
3: +      of J. Since we only switch columns in J, we have to be careful how we
3: +      update d depending on the sign of gs.
3: +      Otherwise we have to apply the Givens rotation to these columns.
3: +      The i - 1 element of d has to be updated to h. */
3: +      cc = d[j - 1];
3: +      ss = d[j];
3: +      h = distance(cc, ss);
3: +      if (fabs(h) < std::numeric_limits < double > ::epsilon()) { // h == 0
3: +        continue;
3: +      }
3: +      d[j] = 0.0;
3: +      ss = ss / h;
3: +      cc = cc / h;
3: +      if (cc < 0.0) {
3: +        cc = -cc;
3: +        ss = -ss;
3: +        d[j - 1] = -h;
3: +      } else {
3: +        d[j - 1] = h;
3: +      }
3: +      xny = ss / (1.0 + cc);
3: +      for (k = 0; k < n; k++) {
3: +        t1 = J[k][j - 1];
3: +        t2 = J[k][j];
3: +        J[k][j - 1] = t1 * cc + t2 * ss;
3: +        J[k][j] = xny * (t1 + J[k][j - 1]) - t2;
3: +      }
3: +    }
3: +    /* update the number of constraints added*/
3: +    iq++;
3: +    /* To update R we have to put the iq components of the d vector
3: +      into column iq - 1 of R
3: +      */
3: +    for (i = 0; i < iq; i++) {
3: +      R[i][iq - 1] = d[i];
3: +    }
3: +#ifdef TRACE_SOLVER
3: +    std::cout << iq << std::endl;
3: +    print_matrix("R", R, iq, iq);
3: +    print_matrix("J", J);
3: +    print_vector("d", d, iq);
3: +#endif
3: +
3: +    if (fabs(d[iq - 1]) <= std::numeric_limits < double > ::epsilon() * R_norm) {
3: +      // problem degenerate
3: +      return false;
3: +    }
3: +    R_norm = std::max < double > (R_norm, fabs(d[iq - 1]));
3: +    return true;
3: +  }
3: +
3: +  void delete_constraint(
3: +    Matrix < double > & R, Matrix < double > & J, Vector < int > & A,
3: +    Vector < double > & u, unsigned int n, int p, unsigned int & iq, int l)
3: +  {
3: +#ifdef TRACE_SOLVER
3: +    std::cout << "Delete constraint " << l << ' ' << iq;
3: +#endif
3: +    register unsigned int i, j, k, qq = 0; // just to prevent warnings from smart compilers
3: +    double cc, ss, h, xny, t1, t2;
3: +
3: +    bool found = false;
3: +    /* Find the index qq for active constraint l to be removed */
3: +    for (i = p; i < iq; i++) {
3: +      if (A[i] == l) {
3: +        qq = i;
3: +        found = true;
3: +        break;
3: +      }
3: +    }
3: +
3: +    if (!found) {
3: +      std::ostringstream os;
3: +      os << "Attempt to delete non existing constraint, constraint: " << l;
3: +      throw std::invalid_argument(os.str());
3: +    }
3: +    /* remove the constraint from the active set and the duals */
3: +    for (i = qq; i < iq - 1; i++) {
3: @@ -590 +608 @@
3: -      for (j = 0; j < n; j++)
3: +      for (j = 0; j < n; j++) {
3: @@ -592,67 +610,63 @@
3: -    }
3: -      
3: -  A[iq - 1] = A[iq];
3: -  u[iq - 1] = u[iq];
3: -  A[iq] = 0; 
3: -  u[iq] = 0.0;
3: -  for (j = 0; j < iq; j++)
3: -    R[j][iq - 1] = 0.0;
3: -  /* constraint has been fully removed */
3: -  iq--;
3: -#ifdef TRACE_SOLVER
3: -  std::cout << '/' << iq << std::endl;
3: -#endif 
3: -  
3: -  if (iq == 0)
3: -    return;
3: -  
3: -  for (j = qq; j < iq; j++)
3: -  {
3: -    cc = R[j][j];
3: -    ss = R[j + 1][j];
3: -    h = distance(cc, ss);
3: -    if (fabs(h) < std::numeric_limits<double>::epsilon()) // h == 0
3: -      continue;
3: -    cc = cc / h;
3: -    ss = ss / h;
3: -    R[j + 1][j] = 0.0;
3: -    if (cc < 0.0)
3: -    {
3: -      R[j][j] = -h;
3: -      cc = -cc;
3: -      ss = -ss;
3: -    }
3: -    else
3: -      R[j][j] = h;
3: -    
3: -    xny = ss / (1.0 + cc);
3: -    for (k = j + 1; k < iq; k++)
3: -    {
3: -      t1 = R[j][k];
3: -      t2 = R[j + 1][k];
3: -      R[j][k] = t1 * cc + t2 * ss;
3: -      R[j + 1][k] = xny * (t1 + R[j][k]) - t2;
3: -    }
3: -    for (k = 0; k < n; k++)
3: -    {
3: -      t1 = J[k][j];
3: -      t2 = J[k][j + 1];
3: -      J[k][j] = t1 * cc + t2 * ss;
3: -      J[k][j + 1] = xny * (J[k][j] + t1) - t2;
3: -    }
3: -  }
3: -}
3: -
3: -inline double distance(double a, double b)
3: -{
3: -  register double a1, b1, t;
3: -  a1 = fabs(a);
3: -  b1 = fabs(b);
3: -  if (a1 > b1) 
3: -  {
3: -    t = (b1 / a1);
3: -    return a1 * sqrt(1.0 + t * t);
3: -  }
3: -  else
3: -    if (b1 > a1)
3: -    {
3: +      }
3: +    }
3: +
3: +    A[iq - 1] = A[iq];
3: +    u[iq - 1] = u[iq];
3: +    A[iq] = 0;
3: +    u[iq] = 0.0;
3: +    for (j = 0; j < iq; j++) {
3: +      R[j][iq - 1] = 0.0;
3: +    }
3: +    /* constraint has been fully removed */
3: +    iq--;
3: +#ifdef TRACE_SOLVER
3: +    std::cout << '/' << iq << std::endl;
3: +#endif
3: +
3: +    if (iq == 0) {
3: +      return;
3: +    }
3: +
3: +    for (j = qq; j < iq; j++) {
3: +      cc = R[j][j];
3: +      ss = R[j + 1][j];
3: +      h = distance(cc, ss);
3: +      if (fabs(h) < std::numeric_limits < double > ::epsilon()) { // h == 0
3: +        continue;
3: +      }
3: +      cc = cc / h;
3: +      ss = ss / h;
3: +      R[j + 1][j] = 0.0;
3: +      if (cc < 0.0) {
3: +        R[j][j] = -h;
3: +        cc = -cc;
3: +        ss = -ss;
3: +      } else {
3: +        R[j][j] = h;
3: +      }
3: +
3: +      xny = ss / (1.0 + cc);
3: +      for (k = j + 1; k < iq; k++) {
3: +        t1 = R[j][k];
3: +        t2 = R[j + 1][k];
3: +        R[j][k] = t1 * cc + t2 * ss;
3: +        R[j + 1][k] = xny * (t1 + R[j][k]) - t2;
3: +      }
3: +      for (k = 0; k < n; k++) {
3: +        t1 = J[k][j];
3: +        t2 = J[k][j + 1];
3: +        J[k][j] = t1 * cc + t2 * ss;
3: +        J[k][j + 1] = xny * (J[k][j] + t1) - t2;
3: +      }
3: +    }
3: +  }
3: +
3: +  inline double distance(double a, double b)
3: +  {
3: +    register double a1, b1, t;
3: +    a1 = fabs(a);
3: +    b1 = fabs(b);
3: +    if (a1 > b1) {
3: +      t = (b1 / a1);
3: +      return a1 * sqrt(1.0 + t * t);
3: +    } else if (b1 > a1) {
3: @@ -662,37 +676,26 @@
3: -  return a1 * sqrt(2.0);
3: -}
3: -
3: -
3: -inline double scalar_product(const Vector<double>& x, const Vector<double>& y)
3: -{
3: -  register int i, n = x.size();
3: -  register double sum;
3: -	
3: -  sum = 0.0;
3: -  for (i = 0; i < n; i++)
3: -    sum += x[i] * y[i];
3: -  return sum;			
3: -}
3: -
3: -void cholesky_decomposition(Matrix<double>& A) 
3: -{
3: -  register int i, j, k, n = A.nrows();
3: -  register double sum;
3: -	
3: -  for (i = 0; i < n; i++)
3: -  {
3: -    for (j = i; j < n; j++)
3: -    {
3: -      sum = A[i][j];
3: -      for (k = i - 1; k >= 0; k--)
3: -        sum -= A[i][k]*A[j][k];
3: -      if (i == j) 
3: -	    {
3: -	      if (sum <= 0.0)
3: -        {
3: -          std::ostringstream os;
3: -          // raise error
3: -          print_matrix("A", A);
3: -          os << "Error in cholesky decomposition, sum: " << sum;
3: -          throw std::logic_error(os.str());
3: -          exit(-1);
3: +    return a1 * sqrt(2.0);
3: +  }
3: +
3: +
3: +  inline double scalar_product(const Vector < double > & x, const Vector < double > & y)
3: +  {
3: +    register int i, n = x.size();
3: +    register double sum;
3: +
3: +    sum = 0.0;
3: +    for (i = 0; i < n; i++) {
3: +      sum += x[i] * y[i];
3: +    }
3: +    return sum;
3: +  }
3: +
3: +  void cholesky_decomposition(Matrix < double > & A)
3: +  {
3: +    register int i, j, k, n = A.nrows();
3: +    register double sum;
3: +
3: +    for (i = 0; i < n; i++) {
3: +      for (j = i; j < n; j++) {
3: +        sum = A[i][j];
3: +        for (k = i - 1; k >= 0; k--) {
3: +          sum -= A[i][k] * A[j][k];
3: @@ -700,90 +703,108 @@
3: -	      A[i][i] = sqrt(sum);
3: -	    }
3: -      else
3: -        A[j][i] = sum / A[i][i];
3: -    }
3: -    for (k = i + 1; k < n; k++)
3: -      A[i][k] = A[k][i];
3: -  } 
3: -}
3: -
3: -void cholesky_solve(const Matrix<double>& L, Vector<double>& x, const Vector<double>& b)
3: -{
3: -  int n = L.nrows();
3: -  Vector<double> y(n);
3: -	
3: -  /* Solve L * y = b */
3: -  forward_elimination(L, y, b);
3: -  /* Solve L^T * x = y */
3: -  backward_elimination(L, x, y);
3: -}
3: -
3: -inline void forward_elimination(const Matrix<double>& L, Vector<double>& y, const Vector<double>& b)
3: -{
3: -  register int i, j, n = L.nrows();
3: -	
3: -  y[0] = b[0] / L[0][0];
3: -  for (i = 1; i < n; i++)
3: -  {
3: -    y[i] = b[i];
3: -    for (j = 0; j < i; j++)
3: -      y[i] -= L[i][j] * y[j];
3: -    y[i] = y[i] / L[i][i];
3: -  }
3: -}
3: -
3: -inline void backward_elimination(const Matrix<double>& U, Vector<double>& x, const Vector<double>& y)
3: -{
3: -  register int i, j, n = U.nrows();
3: -	
3: -  x[n - 1] = y[n - 1] / U[n - 1][n - 1];
3: -  for (i = n - 2; i >= 0; i--)
3: -  {
3: -    x[i] = y[i];
3: -    for (j = i + 1; j < n; j++)
3: -      x[i] -= U[i][j] * x[j];
3: -    x[i] = x[i] / U[i][i];
3: -  }
3: -}
3: -
3: -void print_matrix(const char* name, const Matrix<double>& A, int n, int m)
3: -{
3: -  std::ostringstream s;
3: -  std::string t;
3: -  if (n == -1)
3: -    n = A.nrows();
3: -  if (m == -1)
3: -    m = A.ncols();
3: -	
3: -  s << name << ": " << std::endl;
3: -  for (int i = 0; i < n; i++)
3: -  {
3: -    s << " ";
3: -    for (int j = 0; j < m; j++)
3: -      s << A[i][j] << ", ";
3: -    s << std::endl;
3: -  }
3: -  t = s.str();
3: -  t = t.substr(0, t.size() - 3); // To remove the trailing space, comma and newline
3: -	
3: -  std::cout << t << std::endl;
3: -}
3: -
3: -template<typename T>
3: -void print_vector(const char* name, const Vector<T>& v, int n)
3: -{
3: -  std::ostringstream s;
3: -  std::string t;
3: -  if (n == -1)
3: -    n = v.size();
3: -	
3: -  s << name << ": " << std::endl << " ";
3: -  for (int i = 0; i < n; i++)
3: -  {
3: -    s << v[i] << ", ";
3: -  }
3: -  t = s.str();
3: -  t = t.substr(0, t.size() - 2); // To remove the trailing space and comma
3: -	
3: -  std::cout << t << std::endl;
3: -}
3: +        if (i == j) {
3: +          if (sum <= 0.0) {
3: +            std::ostringstream os;
3: +            // raise error
3: +            print_matrix("A", A);
3: +            os << "Error in cholesky decomposition, sum: " << sum;
3: +            throw std::logic_error(os.str());
3: +            exit(-1);
3: +          }
3: +          A[i][i] = sqrt(sum);
3: +        } else {
3: +          A[j][i] = sum / A[i][i];
3: +        }
3: +      }
3: +      for (k = i + 1; k < n; k++) {
3: +        A[i][k] = A[k][i];
3: +      }
3: +    }
3: +  }
3: +
3: +  void cholesky_solve(
3: +    const Matrix < double > & L, Vector < double > & x,
3: +    const Vector < double > & b)
3: +  {
3: +    int n = L.nrows();
3: +    Vector < double > y(n);
3: +
3: +    /* Solve L * y = b */
3: +    forward_elimination(L, y, b);
3: +    /* Solve L^T * x = y */
3: +    backward_elimination(L, x, y);
3: +  }
3: +
3: +  inline void forward_elimination(
3: +    const Matrix < double > & L, Vector < double > & y,
3: +    const Vector < double > & b)
3: +  {
3: +    register int i, j, n = L.nrows();
3: +
3: +    y[0] = b[0] / L[0][0];
3: +    for (i = 1; i < n; i++) {
3: +      y[i] = b[i];
3: +      for (j = 0; j < i; j++) {
3: +        y[i] -= L[i][j] * y[j];
3: +      }
3: +      y[i] = y[i] / L[i][i];
3: +    }
3: +  }
3: +
3: +  inline void backward_elimination(
3: +    const Matrix < double > & U, Vector < double > & x,
3: +    const Vector < double > & y)
3: +  {
3: +    register int i, j, n = U.nrows();
3: +
3: +    x[n - 1] = y[n - 1] / U[n - 1][n - 1];
3: +    for (i = n - 2; i >= 0; i--) {
3: +      x[i] = y[i];
3: +      for (j = i + 1; j < n; j++) {
3: +        x[i] -= U[i][j] * x[j];
3: +      }
3: +      x[i] = x[i] / U[i][i];
3: +    }
3: +  }
3: +
3: +  void print_matrix(const char * name, const Matrix < double > & A, int n, int m)
3: +  {
3: +    std::ostringstream s;
3: +    std::string t;
3: +    if (n == -1) {
3: +      n = A.nrows();
3: +    }
3: +    if (m == -1) {
3: +      m = A.ncols();
3: +    }
3: +
3: +    s << name << ": " << std::endl;
3: +    for (int i = 0; i < n; i++) {
3: +      s << " ";
3: +      for (int j = 0; j < m; j++) {
3: +        s << A[i][j] << ", ";
3: +      }
3: +      s << std::endl;
3: +    }
3: +    t = s.str();
3: +    t = t.substr(0, t.size() - 3); // To remove the trailing space, comma and newline
3: +
3: +    std::cout << t << std::endl;
3: +  }
3: +
3: +  template < typename T >
3: +  void print_vector(const char * name, const Vector < T > & v, int n)
3: +  {
3: +    std::ostringstream s;
3: +    std::string t;
3: +    if (n == -1) {
3: +      n = v.size();
3: +    }
3: +
3: +    s << name << ": " << std::endl << " ";
3: +    for (int i = 0; i < n; i++) {
3: +      s << v[i] << ", ";
3: +    }
3: +    t = s.str();
3: +    t = t.substr(0, t.size() - 2); // To remove the trailing space and comma
3: +
3: +    std::cout << t << std::endl;
3: +  }
3: 
3: 63 files with code style divergence
3: -- run_test.py: return code 1
3: -- run_test.py: verify result file '/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/uncrustify.xunit.xml'
3/4 Test #3: uncrustify .......................***Failed    3.03 sec
test 4
    Start 4: xmllint

4: Test command: /usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/xmllint.xunit.xml" "--package-name" "unitree_guide2" "--output-file" "/home/yk/rosros/build/unitree_guide2/ament_xmllint/xmllint.txt" "--command" "/opt/ros/humble/bin/ament_xmllint" "--xunit-file" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/xmllint.xunit.xml"
4: Test timeout computed to be: 60
4: -- run_test.py: invoking following command in '/home/yk/rosros/src/unitree_ros2_sim/unitree_guide2':
4:  - /opt/ros/humble/bin/ament_xmllint --xunit-file /home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/xmllint.xunit.xml
4: File 'package.xml' is valid
4: 
4: File 'config/plotjuggler_layout.xml' is valid
4: 
4: No problems found
4: -- run_test.py: return code 0
4: -- run_test.py: verify result file '/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/xmllint.xunit.xml'
4/4 Test #4: xmllint ..........................   Passed    2.45 sec

75% tests passed[0;0m, [0;31m1 tests failed[0;0m out of 4

Label Time Summary:
cppcheck      =   0.25 sec*proc (1 test)
lint_cmake    =   0.17 sec*proc (1 test)
linter        =   5.91 sec*proc (4 tests)
uncrustify    =   3.03 sec*proc (1 test)
xmllint       =   2.45 sec*proc (1 test)

Total Test time (real) =   5.92 sec

The following tests FAILED:
	[0;31m  3 - uncrustify (Failed)[0;0m
