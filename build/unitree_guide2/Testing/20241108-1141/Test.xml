<?xml version="1.0" encoding="UTF-8"?>
<Site BuildName="(empty)"
	BuildStamp="20241108-1141-Experimental"
	Name="yk-VirtualBox"
	Generator="ctest-3.22.1"
	CompilerName="/usr/bin/c++"
	CompilerVersion="11.4.0"
	OSName="Linux"
	Hostname="yk-VirtualBox"
	OSRelease="6.8.0-45-generic"
	OSVersion="#45~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Wed Sep 11 15:25:05 UTC 2"
	OSPlatform="x86_64"
	Is64Bits="1"
	VendorString="GenuineIntel"
	VendorID="Intel Corporation"
	FamilyID="6"
	ModelID="142"
	ProcessorCacheSize="6144"
	NumberOfLogicalCPU="2"
	NumberOfPhysicalCPU="2"
	TotalVirtualMemory="2679"
	TotalPhysicalMemory="3916"
	LogicalProcessorsPerPhysical="1"
	ProcessorClockFrequency="2112"
	>
	<Testing>
		<StartDateTime>Nov 08 20:41 KST</StartDateTime>
		<StartTestTime>1731066088</StartTestTime>
		<TestList>
			<Test>./cppcheck</Test>
			<Test>./lint_cmake</Test>
			<Test>./uncrustify</Test>
			<Test>./xmllint</Test>
		</TestList>
		<Test Status="passed">
			<Name>cppcheck</Name>
			<Path>.</Path>
			<FullName>./cppcheck</FullName>
			<FullCommandLine>/usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/cppcheck.xunit.xml" "--package-name" "unitree_guide2" "--output-file" "/home/yk/rosros/build/unitree_guide2/ament_cppcheck/cppcheck.txt" "--command" "/opt/ros/humble/bin/ament_cppcheck" "--xunit-file" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/cppcheck.xunit.xml" "--include_dirs" "/home/yk/rosros/src/unitree_ros2_sim/unitree_guide2/include"</FullCommandLine>
			<Results>
				<NamedMeasurement type="numeric/double" name="Execution Time">
					<Value>0.248904</Value>
				</NamedMeasurement>
				<NamedMeasurement type="numeric/double" name="Processors">
					<Value>1</Value>
				</NamedMeasurement>
				<NamedMeasurement type="text/string" name="Completion Status">
					<Value>Completed</Value>
				</NamedMeasurement>
				<NamedMeasurement type="text/string" name="Command Line">
					<Value>/usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/cppcheck.xunit.xml" "--package-name" "unitree_guide2" "--output-file" "/home/yk/rosros/build/unitree_guide2/ament_cppcheck/cppcheck.txt" "--command" "/opt/ros/humble/bin/ament_cppcheck" "--xunit-file" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/cppcheck.xunit.xml" "--include_dirs" "/home/yk/rosros/src/unitree_ros2_sim/unitree_guide2/include"</Value>
				</NamedMeasurement>
				<NamedMeasurement type="text/string" name="Environment">
					<Value>#CTEST_RESOURCE_GROUP_COUNT=</Value>
				</NamedMeasurement>
				<Measurement>
					<Value>-- run_test.py: invoking following command in '/home/yk/rosros/src/unitree_ros2_sim/unitree_guide2':
 - /opt/ros/humble/bin/ament_cppcheck --xunit-file /home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/cppcheck.xunit.xml --include_dirs /home/yk/rosros/src/unitree_ros2_sim/unitree_guide2/include
cppcheck 2.7 has known performance issues and therefore will not be used, set the AMENT_CPPCHECK_ALLOW_SLOW_VERSIONS environment variable to override this.
-- run_test.py: return code 0
-- run_test.py: verify result file '/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/cppcheck.xunit.xml'
</Value>
				</Measurement>
			</Results>
			<Labels>
				<Label>cppcheck</Label>
				<Label>linter</Label>
			</Labels>
		</Test>
		<Test Status="passed">
			<Name>lint_cmake</Name>
			<Path>.</Path>
			<FullName>./lint_cmake</FullName>
			<FullCommandLine>/usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/lint_cmake.xunit.xml" "--package-name" "unitree_guide2" "--output-file" "/home/yk/rosros/build/unitree_guide2/ament_lint_cmake/lint_cmake.txt" "--command" "/opt/ros/humble/bin/ament_lint_cmake" "--xunit-file" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/lint_cmake.xunit.xml"</FullCommandLine>
			<Results>
				<NamedMeasurement type="numeric/double" name="Execution Time">
					<Value>0.174469</Value>
				</NamedMeasurement>
				<NamedMeasurement type="numeric/double" name="Processors">
					<Value>1</Value>
				</NamedMeasurement>
				<NamedMeasurement type="text/string" name="Completion Status">
					<Value>Completed</Value>
				</NamedMeasurement>
				<NamedMeasurement type="text/string" name="Command Line">
					<Value>/usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/lint_cmake.xunit.xml" "--package-name" "unitree_guide2" "--output-file" "/home/yk/rosros/build/unitree_guide2/ament_lint_cmake/lint_cmake.txt" "--command" "/opt/ros/humble/bin/ament_lint_cmake" "--xunit-file" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/lint_cmake.xunit.xml"</Value>
				</NamedMeasurement>
				<NamedMeasurement type="text/string" name="Environment">
					<Value>#CTEST_RESOURCE_GROUP_COUNT=</Value>
				</NamedMeasurement>
				<Measurement>
					<Value>-- run_test.py: invoking following command in '/home/yk/rosros/src/unitree_ros2_sim/unitree_guide2':
 - /opt/ros/humble/bin/ament_lint_cmake --xunit-file /home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/lint_cmake.xunit.xml

No problems found
-- run_test.py: return code 0
-- run_test.py: verify result file '/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/lint_cmake.xunit.xml'
</Value>
				</Measurement>
			</Results>
			<Labels>
				<Label>lint_cmake</Label>
				<Label>linter</Label>
			</Labels>
		</Test>
		<Test Status="failed">
			<Name>uncrustify</Name>
			<Path>.</Path>
			<FullName>./uncrustify</FullName>
			<FullCommandLine>/usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/uncrustify.xunit.xml" "--package-name" "unitree_guide2" "--output-file" "/home/yk/rosros/build/unitree_guide2/ament_uncrustify/uncrustify.txt" "--command" "/opt/ros/humble/bin/ament_uncrustify" "--xunit-file" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/uncrustify.xunit.xml"</FullCommandLine>
			<Results>
				<NamedMeasurement type="text/string" name="Exit Code">
					<Value>Failed</Value>
				</NamedMeasurement>
				<NamedMeasurement type="text/string" name="Exit Value">
					<Value>1</Value>
				</NamedMeasurement>
				<NamedMeasurement type="numeric/double" name="Execution Time">
					<Value>3.03422</Value>
				</NamedMeasurement>
				<NamedMeasurement type="numeric/double" name="Processors">
					<Value>1</Value>
				</NamedMeasurement>
				<NamedMeasurement type="text/string" name="Completion Status">
					<Value>Completed</Value>
				</NamedMeasurement>
				<NamedMeasurement type="text/string" name="Command Line">
					<Value>/usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/uncrustify.xunit.xml" "--package-name" "unitree_guide2" "--output-file" "/home/yk/rosros/build/unitree_guide2/ament_uncrustify/uncrustify.txt" "--command" "/opt/ros/humble/bin/ament_uncrustify" "--xunit-file" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/uncrustify.xunit.xml"</Value>
				</NamedMeasurement>
				<NamedMeasurement type="text/string" name="Environment">
					<Value>#CTEST_RESOURCE_GROUP_COUNT=</Value>
				</NamedMeasurement>
				<Measurement>
					<Value>-- run_test.py: invoking following command in '/home/yk/rosros/src/unitree_ros2_sim/unitree_guide2':
 - /opt/ros/humble/bin/ament_uncrustify --xunit-file /home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/uncrustify.xunit.xml
Code style divergence in file 'include/FSM/FSM.h':

--- include/FSM/FSM.h
+++ include/FSM/FSM.h.uncrustify
@@ -26,9 +26,10 @@
-struct FSMStateList{
-    FSMState *invalid;
-    State_Passive *passive;
-    State_FixedStand *fixedStand;
-    State_FreeStand *freeStand;
-    State_Trotting *trotting;
-    State_BalanceTest *balanceTest;
-    State_SwingTest *swingTest;
-    State_StepTest *stepTest;
+struct FSMStateList
+{
+  FSMState * invalid;
+  State_Passive * passive;
+  State_FixedStand * fixedStand;
+  State_FreeStand * freeStand;
+  State_Trotting * trotting;
+  State_BalanceTest * balanceTest;
+  State_SwingTest * swingTest;
+  State_StepTest * stepTest;
@@ -36 +37 @@
-    State_move_base *moveBase;
+  State_move_base * moveBase;
@@ -40 +41 @@
-    State_move_base *moveBase;
+  State_move_base * moveBase;
@@ -43,9 +44,10 @@
-    void deletePtr(){
-        delete invalid;
-        delete passive;
-        delete fixedStand;
-        delete freeStand;
-        delete trotting;
-        delete balanceTest;
-        delete swingTest;
-        delete stepTest;
+  void deletePtr()
+  {
+    delete invalid;
+    delete passive;
+    delete fixedStand;
+    delete freeStand;
+    delete trotting;
+    delete balanceTest;
+    delete swingTest;
+    delete stepTest;
@@ -53 +55 @@
-        delete moveBase;
+    delete moveBase;
@@ -56 +58 @@
-        delete moveBase;
+    delete moveBase;
@@ -58 +60 @@
-    }
+  }
@@ -61 +63 @@
-class FSM{
+class FSM {
@@ -63,4 +65,5 @@
-    FSM(CtrlComponents *ctrlComp);
-    ~FSM();
-    void initialize();
-    void run();
+  FSM(CtrlComponents * ctrlComp);
+  ~FSM();
+  void initialize();
+  void run();
+
@@ -68,10 +71,10 @@
-    FSMState* getNextState(FSMStateName stateName);
-    bool checkSafty();
-    CtrlComponents *_ctrlComp;
-    FSMState *_currentState;
-    FSMState *_nextState;
-    FSMStateName _nextStateName;
-    FSMStateList _stateList;
-    FSMMode _mode;
-    long long _startTime;
-    int count;
+  FSMState * getNextState(FSMStateName stateName);
+  bool checkSafty();
+  CtrlComponents * _ctrlComp;
+  FSMState * _currentState;
+  FSMState * _nextState;
+  FSMStateName _nextStateName;
+  FSMStateList _stateList;
+  FSMMode _mode;
+  long long _startTime;
+  int count;
@@ -81 +84 @@
-#endif  // FSM_H
+#endif  // FSM_H

Code style divergence in file 'include/FSM/FSMState.h':

--- include/FSM/FSMState.h
+++ include/FSM/FSMState.h.uncrustify
@@ -19 +19 @@
-class FSMState{
+class FSMState {
@@ -21 +21 @@
-    FSMState(CtrlComponents *ctrlComp, FSMStateName stateName, std::string stateNameString);
+  FSMState(CtrlComponents * ctrlComp, FSMStateName stateName, std::string stateNameString);
@@ -23,4 +23,4 @@
-    virtual void enter() = 0;
-    virtual void run() = 0;
-    virtual void exit() = 0;
-    virtual FSMStateName checkChange() {return FSMStateName::INVALID;}
+  virtual void enter() = 0;
+  virtual void run() = 0;
+  virtual void exit() = 0;
+  virtual FSMStateName checkChange() {return FSMStateName::INVALID;}
@@ -28,2 +28,3 @@
-    FSMStateName _stateName;
-    std::string _stateNameString;
+  FSMStateName _stateName;
+  std::string _stateNameString;
+
@@ -31,2 +32,2 @@
-    CtrlComponents *_ctrlComp;
-    FSMStateName _nextStateName;
+  CtrlComponents * _ctrlComp;
+  FSMStateName _nextStateName;
@@ -34,3 +35,3 @@
-    LowlevelCmd *_lowCmd;
-    LowlevelState *_lowState;
-    UserValue _userValue;
+  LowlevelCmd * _lowCmd;
+  LowlevelState * _lowState;
+  UserValue _userValue;
@@ -39 +40 @@
-#endif  // FSMSTATE_H
+#endif  // FSMSTATE_H

Code style divergence in file 'include/FSM/State_BalanceTest.h':

--- include/FSM/State_BalanceTest.h
+++ include/FSM/State_BalanceTest.h.uncrustify
@@ -9 +9 @@
-class State_BalanceTest : public FSMState{
+class State_BalanceTest: public FSMState {
@@ -11,6 +11,8 @@
-    State_BalanceTest(CtrlComponents *ctrlComp);
-    ~State_BalanceTest(){}
-    void enter();
-    void run();
-    void exit();
-    FSMStateName checkChange();
+  State_BalanceTest(CtrlComponents * ctrlComp);
+  ~State_BalanceTest() {
+  }
+  void enter();
+  void run();
+  void exit();
+  FSMStateName checkChange();
+
@@ -18 +20 @@
-    void calcTau();
+  void calcTau();
@@ -20,3 +22,3 @@
-    Estimator *_est;
-    QuadrupedRobot *_robModel;
-    BalanceCtrl *_balCtrl;
+  Estimator * _est;
+  QuadrupedRobot * _robModel;
+  BalanceCtrl * _balCtrl;
@@ -24 +26 @@
-    VecInt4 *_contact;
+  VecInt4 * _contact;
@@ -26,5 +28,5 @@
-    RotMat _Rd, _RdInit;
-    Vec3 _pcd, _pcdInit;
-    double _kpw;
-    Mat3 _Kpp, _Kdp, _Kdw;
-    Vec3 _ddPcd, _dWbd;
+  RotMat _Rd, _RdInit;
+  Vec3 _pcd, _pcdInit;
+  double _kpw;
+  Mat3 _Kpp, _Kdp, _Kdw;
+  Vec3 _ddPcd, _dWbd;
@@ -32,5 +34,5 @@
-    Vec12 _q, _tau;
-    Vec3 _posBody, _velBody;
-    RotMat _B2G_RotMat, _G2B_RotMat;
-    Vec34 _posFeet2BGlobal;
-    Vec34 _forceFeetGlobal, _forceFeetBody;
+  Vec12 _q, _tau;
+  Vec3 _posBody, _velBody;
+  RotMat _B2G_RotMat, _G2B_RotMat;
+  Vec34 _posFeet2BGlobal;
+  Vec34 _forceFeetGlobal, _forceFeetBody;
@@ -38,4 +40,4 @@
-    float _xMax, _xMin;
-    float _yMax, _yMin;
-    float _zMax, _zMin;
-    float _yawMax, _yawMin;
+  float _xMax, _xMin;
+  float _yMax, _yMin;
+  float _zMax, _zMin;
+  float _yawMax, _yawMin;
@@ -44 +46 @@
-#endif  // BALANCETEST_H
+#endif  // BALANCETEST_H

Code style divergence in file 'include/FSM/State_FixedStand.h':

--- include/FSM/State_FixedStand.h
+++ include/FSM/State_FixedStand.h.uncrustify
@@ -9 +9 @@
-class State_FixedStand : public FSMState{
+class State_FixedStand: public FSMState {
@@ -11,6 +11,7 @@
-    State_FixedStand(CtrlComponents *ctrlComp);
-    ~State_FixedStand(){}
-    void enter();
-    void run();
-    void exit();
-    FSMStateName checkChange();
+  State_FixedStand(CtrlComponents * ctrlComp);
+  ~State_FixedStand() {
+  }
+  void enter();
+  void run();
+  void exit();
+  FSMStateName checkChange();
@@ -19,5 +20,5 @@
-    float _targetPos[12] = {0.0, 0.67, -1.3, 0.0, 0.67, -1.3, 
-                            0.0, 0.67, -1.3, 0.0, 0.67, -1.3};
-    float _startPos[12];
-    float _duration = 1000;   //steps
-    float _percent = 0;       //%
+  float _targetPos[12] = {0.0, 0.67, -1.3, 0.0, 0.67, -1.3,
+    0.0, 0.67, -1.3, 0.0, 0.67, -1.3};
+  float _startPos[12];
+  float _duration = 1000;     //steps
+  float _percent = 0;         //%
@@ -26 +27 @@
-#endif  // FIXEDSTAND_H
+#endif  // FIXEDSTAND_H

Code style divergence in file 'include/FSM/State_FreeStand.h':

--- include/FSM/State_FreeStand.h
+++ include/FSM/State_FreeStand.h.uncrustify
@@ -9 +9 @@
-class State_FreeStand : public FSMState{
+class State_FreeStand: public FSMState {
@@ -11,6 +11,8 @@
-    State_FreeStand(CtrlComponents *ctrlComp);
-    ~State_FreeStand(){}
-    void enter();
-    void run();
-    void exit();
-    FSMStateName checkChange();
+  State_FreeStand(CtrlComponents * ctrlComp);
+  ~State_FreeStand() {
+  }
+  void enter();
+  void run();
+  void exit();
+  FSMStateName checkChange();
+
@@ -18,6 +20,6 @@
-    Vec3 _initVecOX;
-    Vec34 _initVecXP;
-    float _rowMax, _rowMin;
-    float _pitchMax, _pitchMin;
-    float _yawMax, _yawMin;
-    float _heightMax, _heightMin;
+  Vec3 _initVecOX;
+  Vec34 _initVecXP;
+  float _rowMax, _rowMin;
+  float _pitchMax, _pitchMin;
+  float _yawMax, _yawMin;
+  float _heightMax, _heightMin;
@@ -25,2 +27,2 @@
-    Vec34 _calcOP(float row, float pitch, float yaw, float height);
-    void _calcCmd(Vec34 vecOP);
+  Vec34 _calcOP(float row, float pitch, float yaw, float height);
+  void _calcCmd(Vec34 vecOP);
@@ -29 +31 @@
-#endif  // FREESTAND_H
+#endif  // FREESTAND_H

Code style divergence in file 'include/FSM/State_Passive.h':

--- include/FSM/State_Passive.h
+++ include/FSM/State_Passive.h.uncrustify
@@ -9 +9 @@
-class State_Passive : public FSMState{
+class State_Passive: public FSMState {
@@ -11,5 +11,5 @@
-    State_Passive(CtrlComponents *ctrlComp);
-    void enter();
-    void run();
-    void exit();
-    FSMStateName checkChange();
+  State_Passive(CtrlComponents * ctrlComp);
+  void enter();
+  void run();
+  void exit();
+  FSMStateName checkChange();
@@ -18 +18 @@
-#endif  // PASSIVE_H
+#endif  // PASSIVE_H

Code style divergence in file 'include/FSM/State_StepTest.h':

--- include/FSM/State_StepTest.h
+++ include/FSM/State_StepTest.h.uncrustify
@@ -9 +9 @@
-class State_StepTest : public FSMState{
+class State_StepTest: public FSMState {
@@ -11,6 +11,8 @@
-    State_StepTest(CtrlComponents *ctrlComp);
-    ~State_StepTest(){}
-    void enter();
-    void run();
-    void exit();
-    FSMStateName checkChange();
+  State_StepTest(CtrlComponents * ctrlComp);
+  ~State_StepTest() {
+  }
+  void enter();
+  void run();
+  void exit();
+  FSMStateName checkChange();
+
@@ -18 +20 @@
-    void calcTau();
+  void calcTau();
@@ -20 +22 @@
-    float _gaitHeight;
+  float _gaitHeight;
@@ -22,3 +24,3 @@
-    Estimator *_est;
-    QuadrupedRobot *_robModel;
-    BalanceCtrl *_balCtrl;
+  Estimator * _est;
+  QuadrupedRobot * _robModel;
+  BalanceCtrl * _balCtrl;
@@ -26,2 +28,2 @@
-    VecInt4 *_contact;
-    Vec4 *_phase;
+  VecInt4 * _contact;
+  Vec4 * _phase;
@@ -29,5 +31,5 @@
-    RotMat _Rd;
-    Vec3 _pcd;
-    Mat3 _Kpp, _Kpw, _Kdp, _Kdw;
-    Mat3 _KpSwing, _KdSwing;
-    Vec3 _ddPcd, _dWbd;
+  RotMat _Rd;
+  Vec3 _pcd;
+  Mat3 _Kpp, _Kpw, _Kdp, _Kdw;
+  Mat3 _KpSwing, _KdSwing;
+  Vec3 _ddPcd, _dWbd;
@@ -35,7 +37,7 @@
-    Vec12 _q, _tau;
-    Vec3 _posBody, _velBody;
-    RotMat _B2G_RotMat, _G2B_RotMat;
-    Vec34 _posFeet2BGlobal;
-    Vec34 _posFeetGlobalInit, _posFeetGlobalGoal, _velFeetGlobalGoal;
-    Vec34 _posFeetGlobal, _velFeetGlobal;
-    Vec34 _forceFeetGlobal, _forceFeetBody;
+  Vec12 _q, _tau;
+  Vec3 _posBody, _velBody;
+  RotMat _B2G_RotMat, _G2B_RotMat;
+  Vec34 _posFeet2BGlobal;
+  Vec34 _posFeetGlobalInit, _posFeetGlobalGoal, _velFeetGlobalGoal;
+  Vec34 _posFeetGlobal, _velFeetGlobal;
+  Vec34 _forceFeetGlobal, _forceFeetBody;
@@ -44 +46 @@
-#endif  // STEPTEST_H
+#endif  // STEPTEST_H

Code style divergence in file 'include/FSM/State_SwingTest.h':

--- include/FSM/State_SwingTest.h
+++ include/FSM/State_SwingTest.h.uncrustify
@@ -10 +10 @@
-class State_SwingTest : public FSMState{
+class State_SwingTest: public FSMState {
@@ -12,6 +12,8 @@
-    State_SwingTest(CtrlComponents *ctrlComp);
-    ~State_SwingTest(){};
-    void enter();
-    void run();
-    void exit();
-    FSMStateName checkChange();
+  State_SwingTest(CtrlComponents * ctrlComp);
+  ~State_SwingTest() {
+  };
+  void enter();
+  void run();
+  void exit();
+  FSMStateName checkChange();
+
@@ -19,2 +21,2 @@
-    void _positionCtrl();
-    void _torqueCtrl();
+  void _positionCtrl();
+  void _torqueCtrl();
@@ -22,7 +24,7 @@
-    Vec34 _initFeetPos, _feetPos;
-    Vec3  _initPos, _posGoal;
-    Vec12 _targetPos;
-    float _xMin, _xMax;
-    float _yMin, _yMax;
-    float _zMin, _zMax;
-    Mat3 _Kp, _Kd;
+  Vec34 _initFeetPos, _feetPos;
+  Vec3 _initPos, _posGoal;
+  Vec12 _targetPos;
+  float _xMin, _xMax;
+  float _yMin, _yMax;
+  float _zMin, _zMax;
+  Mat3 _Kp, _Kd;
@@ -31 +33 @@
-#endif  // STATE_SWINGTEST_H
+#endif  // STATE_SWINGTEST_H

Code style divergence in file 'include/FSM/State_Trotting.h':

--- include/FSM/State_Trotting.h
+++ include/FSM/State_Trotting.h.uncrustify
@@ -11 +11 @@
-class State_Trotting : public FSMState{
+class State_Trotting: public FSMState {
@@ -13,7 +13,8 @@
-    State_Trotting(CtrlComponents *ctrlComp);
-    ~State_Trotting();
-    void enter();
-    void run();
-    void exit();
-    virtual FSMStateName checkChange();
-    void setHighCmd(double vx, double vy, double wz);
+  State_Trotting(CtrlComponents * ctrlComp);
+  ~State_Trotting();
+  void enter();
+  void run();
+  void exit();
+  virtual FSMStateName checkChange();
+  void setHighCmd(double vx, double vy, double wz);
+
@@ -21,6 +22,6 @@
-    void calcTau();
-    void calcQQd();
-    void calcCmd();
-    virtual void getUserCmd();
-    void calcBalanceKp();
-    bool checkStepOrNot();
+  void calcTau();
+  void calcQQd();
+  void calcCmd();
+  virtual void getUserCmd();
+  void calcBalanceKp();
+  bool checkStepOrNot();
@@ -28,4 +29,4 @@
-    GaitGenerator *_gait;
-    Estimator *_est;
-    QuadrupedRobot *_robModel;
-    BalanceCtrl *_balCtrl;
+  GaitGenerator * _gait;
+  Estimator * _est;
+  QuadrupedRobot * _robModel;
+  BalanceCtrl * _balCtrl;
@@ -33,7 +34,7 @@
-    // Rob State
-    Vec3  _posBody, _velBody;
-    double _yaw, _dYaw;
-    Vec34 _posFeetGlobal, _velFeetGlobal;
-    Vec34 _posFeet2BGlobal;
-    RotMat _B2G_RotMat, _G2B_RotMat;
-    Vec12 _q;
+  // Rob State
+  Vec3 _posBody, _velBody;
+  double _yaw, _dYaw;
+  Vec34 _posFeetGlobal, _velFeetGlobal;
+  Vec34 _posFeet2BGlobal;
+  RotMat _B2G_RotMat, _G2B_RotMat;
+  Vec12 _q;
@@ -41,13 +42,13 @@
-    // Robot command
-    Vec3 _pcd;
-    Vec3 _vCmdGlobal, _vCmdBody;
-    double _yawCmd, _dYawCmd;
-    double _dYawCmdPast;
-    Vec3 _wCmdGlobal;
-    Vec34 _posFeetGlobalGoal, _velFeetGlobalGoal;
-    Vec34 _posFeet2BGoal, _velFeet2BGoal;
-    RotMat _Rd;
-    Vec3 _ddPcd, _dWbd;
-    Vec34 _forceFeetGlobal, _forceFeetBody;
-    Vec34 _qGoal, _qdGoal;
-    Vec12 _tau;
+  // Robot command
+  Vec3 _pcd;
+  Vec3 _vCmdGlobal, _vCmdBody;
+  double _yawCmd, _dYawCmd;
+  double _dYawCmdPast;
+  Vec3 _wCmdGlobal;
+  Vec34 _posFeetGlobalGoal, _velFeetGlobalGoal;
+  Vec34 _posFeet2BGoal, _velFeet2BGoal;
+  RotMat _Rd;
+  Vec3 _ddPcd, _dWbd;
+  Vec34 _forceFeetGlobal, _forceFeetBody;
+  Vec34 _qGoal, _qdGoal;
+  Vec12 _tau;
@@ -55,9 +56,9 @@
-    // Control Parameters
-    double _gaitHeight;
-    Vec3 _posError, _velError;
-    Mat3 _Kpp, _Kdp, _Kdw;
-    double _kpw;
-    Mat3 _KpSwing, _KdSwing;
-    Vec2 _vxLim, _vyLim, _wyawLim;
-    Vec4 *_phase;
-    VecInt4 *_contact;
+  // Control Parameters
+  double _gaitHeight;
+  Vec3 _posError, _velError;
+  Mat3 _Kpp, _Kdp, _Kdw;
+  double _kpw;
+  Mat3 _KpSwing, _KdSwing;
+  Vec2 _vxLim, _vyLim, _wyawLim;
+  Vec4 * _phase;
+  VecInt4 * _contact;
@@ -65,3 +66,3 @@
-    // Calculate average value
-    AvgCov *_avg_posError = new AvgCov(3, "_posError", true, 1000, 1000, 1);
-    AvgCov *_avg_angError = new AvgCov(3, "_angError", true, 1000, 1000, 1000);
+  // Calculate average value
+  AvgCov * _avg_posError = new AvgCov(3, "_posError", true, 1000, 1000, 1);
+  AvgCov * _avg_angError = new AvgCov(3, "_angError", true, 1000, 1000, 1000);
@@ -70 +71 @@
-#endif  // TROTTING_H
+#endif  // TROTTING_H

Code style divergence in file 'include/FSM/State_move_base.h':

--- include/FSM/State_move_base.h
+++ include/FSM/State_move_base.h.uncrustify
@@ -13 +13 @@
-class State_move_base : public State_Trotting{
+class State_move_base: public State_Trotting {
@@ -15,3 +15,5 @@
-    State_move_base(CtrlComponents *ctrlComp);
-    ~State_move_base(){}
-    FSMStateName checkChange();
+  State_move_base(CtrlComponents * ctrlComp);
+  ~State_move_base() {
+  }
+  FSMStateName checkChange();
+
@@ -19,7 +21,7 @@
-    void getUserCmd();
-    void initRecv();
-    void twistCallback(const geometry_msgs::Twist::msg::SharedPtr msg);
-    ros::NodeHandle _nm;
-    ros::Subscriber _cmdSub;
-    double _vx, _vy;
-    double _wz;
+  void getUserCmd();
+  void initRecv();
+  void twistCallback(const geometry_msgs::Twist::msg::SharedPtr msg);
+  ros::NodeHandle _nm;
+  ros::Subscriber _cmdSub;
+  double _vx, _vy;
+  double _wz;
@@ -41 +43 @@
-class State_move_base : public State_Trotting{
+class State_move_base: public State_Trotting {
@@ -43,3 +45,5 @@
-    State_move_base(CtrlComponents *ctrlComp);
-    ~State_move_base(){}
-    FSMStateName checkChange();
+  State_move_base(CtrlComponents * ctrlComp);
+  ~State_move_base() {
+  }
+  FSMStateName checkChange();
+
@@ -47,9 +51,9 @@
-    void getUserCmd();
-    void initRecv();
-    void twistCallback(const geometry_msgs::msg::Twist::SharedPtr msg);
-    rclcpp::Node::SharedPtr _nm;
-    rclcpp::Subscription&lt;geometry_msgs::msg::Twist&gt;::SharedPtr _cmdSub;
-    double _vx, _vy;
-    double _wz;
-    rclcpp::executors::MultiThreadedExecutor::SharedPtr executor;
-    std::thread executor_thread;
+  void getUserCmd();
+  void initRecv();
+  void twistCallback(const geometry_msgs::msg::Twist::SharedPtr msg);
+  rclcpp::Node::SharedPtr _nm;
+  rclcpp::Subscription &lt; geometry_msgs::msg::Twist &gt; ::SharedPtr _cmdSub;
+  double _vx, _vy;
+  double _wz;
+  rclcpp::executors::MultiThreadedExecutor::SharedPtr executor;
+  std::thread executor_thread;
@@ -60 +64 @@
-#endif  // COMPILE_WITH_ROS2_MB
+#endif  // COMPILE_WITH_ROS2_MB

Code style divergence in file 'include/Gait/FeetEndCal.h':

--- include/Gait/FeetEndCal.h
+++ include/Gait/FeetEndCal.h.uncrustify
@@ -10 +10 @@
-class FeetEndCal{
+class FeetEndCal {
@@ -12,3 +12,4 @@
-    FeetEndCal(CtrlComponents *ctrlComp);
-    ~FeetEndCal();
-    Vec3 calFootPos(int legID, Vec2 vxyGoalGlobal, float dYawGoal, float phase);
+  FeetEndCal(CtrlComponents * ctrlComp);
+  ~FeetEndCal();
+  Vec3 calFootPos(int legID, Vec2 vxyGoalGlobal, float dYawGoal, float phase);
+
@@ -16,3 +17,3 @@
-    LowlevelState *_lowState;
-    Estimator *_est;
-    QuadrupedRobot *_robModel;
+  LowlevelState * _lowState;
+  Estimator * _est;
+  QuadrupedRobot * _robModel;
@@ -20,4 +21,4 @@
-    Vec3 _nextStep, _footPos;
-    Vec3 _bodyVelGlobal;        // linear velocity
-    Vec3 _bodyAccGlobal;        // linear accelerator
-    Vec3 _bodyWGlobal;          // angular velocity
+  Vec3 _nextStep, _footPos;
+  Vec3 _bodyVelGlobal;          // linear velocity
+  Vec3 _bodyAccGlobal;          // linear accelerator
+  Vec3 _bodyWGlobal;            // angular velocity
@@ -25,2 +26,2 @@
-    Vec4 _feetRadius, _feetInitAngle;
-    float _yaw, _dYaw, _nextYaw;
+  Vec4 _feetRadius, _feetInitAngle;
+  float _yaw, _dYaw, _nextYaw;
@@ -28,2 +29,2 @@
-    float _Tstance, _Tswing;
-    float _kx, _ky, _kyaw;
+  float _Tstance, _Tswing;
+  float _kx, _ky, _kyaw;
@@ -32 +33 @@
-#endif  // FEETENDCAL_H
+#endif  // FEETENDCAL_H

Code style divergence in file 'include/Gait/GaitGenerator.h':

--- include/Gait/GaitGenerator.h
+++ include/Gait/GaitGenerator.h.uncrustify
@@ -15 +15 @@
-class GaitGenerator{
+class GaitGenerator {
@@ -17,7 +17,8 @@
-    GaitGenerator(CtrlComponents *ctrlComp);
-    ~GaitGenerator();
-    void setGait(Vec2 vxyGoalGlobal, float dYawGoal, float gaitHeight);
-    void run(Vec34 &amp;feetPos, Vec34 &amp;feetVel);
-    Vec3 getFootPos(int i);
-    Vec3 getFootVel(int i);
-    void restart();
+  GaitGenerator(CtrlComponents * ctrlComp);
+  ~GaitGenerator();
+  void setGait(Vec2 vxyGoalGlobal, float dYawGoal, float gaitHeight);
+  void run(Vec34 &amp; feetPos, Vec34 &amp; feetVel);
+  Vec3 getFootPos(int i);
+  Vec3 getFootVel(int i);
+  void restart();
+
@@ -25,4 +26,4 @@
-    float cycloidXYPosition(float startXY, float endXY, float phase);
-    float cycloidXYVelocity(float startXY, float endXY, float phase);
-    float cycloidZPosition(float startZ, float height, float phase);
-    float cycloidZVelocity(float height, float phase);
+  float cycloidXYPosition(float startXY, float endXY, float phase);
+  float cycloidXYVelocity(float startXY, float endXY, float phase);
+  float cycloidZPosition(float startZ, float height, float phase);
+  float cycloidZVelocity(float height, float phase);
@@ -30,12 +31,12 @@
-    WaveGenerator *_waveG;
-    Estimator *_est;
-    FeetEndCal *_feetCal;
-    QuadrupedRobot *_robModel;
-    LowlevelState *_state;
-    float _gaitHeight;
-    Vec2 _vxyGoal;
-    float _dYawGoal;
-    Vec4 *_phase, _phasePast;
-    VecInt4 *_contact;
-    Vec34 _startP, _endP, _idealP, _pastP;
-    bool _firstRun;
+  WaveGenerator * _waveG;
+  Estimator * _est;
+  FeetEndCal * _feetCal;
+  QuadrupedRobot * _robModel;
+  LowlevelState * _state;
+  float _gaitHeight;
+  Vec2 _vxyGoal;
+  float _dYawGoal;
+  Vec4 * _phase, _phasePast;
+  VecInt4 * _contact;
+  Vec34 _startP, _endP, _idealP, _pastP;
+  bool _firstRun;
@@ -44 +45 @@
-    PyPlot _testGaitPlot;
+  PyPlot _testGaitPlot;
@@ -49 +50 @@
-#endif  // GAITGENERATOR_H
+#endif  // GAITGENERATOR_H

Code style divergence in file 'include/Gait/WaveGenerator.h':

--- include/Gait/WaveGenerator.h
+++ include/Gait/WaveGenerator.h.uncrustify
@@ -17 +17 @@
-class WaveGenerator{
+class WaveGenerator {
@@ -19,6 +19,7 @@
-    WaveGenerator(double period, double stancePhaseRatio, Vec4 bias);
-    ~WaveGenerator();
-    void calcContactPhase(Vec4 &amp;phaseResult, VecInt4 &amp;contactResult, WaveStatus status);
-    float getTstance();
-    float getTswing();
-    float getT();
+  WaveGenerator(double period, double stancePhaseRatio, Vec4 bias);
+  ~WaveGenerator();
+  void calcContactPhase(Vec4 &amp; phaseResult, VecInt4 &amp; contactResult, WaveStatus status);
+  float getTstance();
+  float getTswing();
+  float getT();
+
@@ -26 +27 @@
-    void calcWave(Vec4 &amp;phase, VecInt4 &amp;contact, WaveStatus status);
+  void calcWave(Vec4 &amp; phase, VecInt4 &amp; contact, WaveStatus status);
@@ -28,3 +29,3 @@
-    double _period;
-    double _stRatio;
-    Vec4 _bias;
+  double _period;
+  double _stRatio;
+  Vec4 _bias;
@@ -32,5 +33,5 @@
-    Vec4 _normalT;                   // [0, 1)
-    Vec4 _phase, _phasePast;
-    VecInt4 _contact, _contactPast;
-    VecInt4 _switchStatus;          // 1: switching, 0: do not switch
-    WaveStatus _statusPast;
+  Vec4 _normalT;                     // [0, 1)
+  Vec4 _phase, _phasePast;
+  VecInt4 _contact, _contactPast;
+  VecInt4 _switchStatus;            // 1: switching, 0: do not switch
+  WaveStatus _statusPast;
@@ -38,2 +39,2 @@
-    double _passT;                   // unit: second
-    long long _startT;    // unit: us
+  double _passT;                     // unit: second
+  long long _startT;      // unit: us
@@ -41 +42 @@
-    PyPlot _testPlot;
+  PyPlot _testPlot;
@@ -46 +47 @@
-#endif  // WAVEGENERATOR_H
+#endif  // WAVEGENERATOR_H

Code style divergence in file 'include/common/LowPassFilter.h':

--- include/common/LowPassFilter.h
+++ include/common/LowPassFilter.h.uncrustify
@@ -7 +7 @@
-class LPFilter{
+class LPFilter {
@@ -9,5 +9,6 @@
-    LPFilter(double samplePeriod, double cutFrequency);
-    ~LPFilter();
-    void addValue(double newValue);
-    double getValue();
-    void clear();
+  LPFilter(double samplePeriod, double cutFrequency);
+  ~LPFilter();
+  void addValue(double newValue);
+  double getValue();
+  void clear();
+
@@ -15,3 +16,3 @@
-    double _weight;
-    double _pastValue;
-    bool _start;
+  double _weight;
+  double _pastValue;
+  bool _start;
@@ -20 +21 @@
-#endif  // LOWPASSFILTER
+#endif  // LOWPASSFILTER

Code style divergence in file 'include/common/PyPlot.h':

--- include/common/PyPlot.h
+++ include/common/PyPlot.h.uncrustify
@@ -18,12 +18,11 @@
-struct Curve{
-    std::vector&lt;double&gt; x;
-    std::vector&lt;double&gt; y;
-
-    void printXY(double xRough, int pointNum){
-        for(int i(0); i&lt;x.size(); ++i){
-            if(xRough &lt; x[i]){
-                for(int j(0); j &lt; pointNum; ++j){
-                    std::cout &lt;&lt; "  X: " &lt;&lt; x[i+j] &lt;&lt; ", Y: " &lt;&lt; y[i+j] &lt;&lt; std::endl;
-                }
-                break;
-            }
+struct Curve
+{
+  std::vector &lt; double &gt; x;
+  std::vector &lt; double &gt; y;
+
+  void printXY(double xRough, int pointNum)
+  {
+    for (int i(0); i &lt; x.size(); ++i) {
+      if (xRough &lt; x[i]) {
+        for (int j(0); j &lt; pointNum; ++j) {
+          std::cout &lt;&lt; "  X: " &lt;&lt; x[i + j] &lt;&lt; ", Y: " &lt;&lt; y[i + j] &lt;&lt; std::endl;
@@ -31 +30,4 @@
-    }
+        break;
+      }
+    }
+  }
@@ -34,30 +36,33 @@
-struct Plot{
-    std::vector&lt;Curve*&gt; curves;
-    std::vector&lt;std::string&gt; labels;
-    std::string plotName;
-    int curveCount;
-
-    std::map&lt;std::string, int&gt; curveName2ID;
-
-    Plot(std::string name, int count, std::vector&lt;std::string&gt; labelVec)
-        :plotName(name), curveCount(count), labels(labelVec){
-        for(int i(0); i &lt; count; ++i){
-            curveName2ID.insert(std::pair&lt;std::string, int&gt;(labels[i], i));
-            curves.push_back(new Curve());
-        }
-    }
-
-    ~Plot(){
-        for(int i(0); i &lt; curveCount; ++i){
-            delete curves[i];
-        }
-    }
-
-    double getX(long long startT){
-        return (double)(getSystemTime() - startT) * 1e-6;
-    }
-
-    void printXY(std::string curveName, double xRough, int pointNum){
-        std::cout &lt;&lt; "[DEBUG] Plot: " &lt;&lt; plotName &lt;&lt; ", Curve: " &lt;&lt; curveName &lt;&lt; std::endl;
-        curves[curveName2ID[curveName]]-&gt;printXY(xRough, pointNum);
-    }
+struct Plot
+{
+  std::vector &lt; Curve * &gt; curves;
+  std::vector &lt; std::string &gt; labels;
+  std::string plotName;
+  int curveCount;
+
+  std::map &lt; std::string, int &gt; curveName2ID;
+
+  Plot(std::string name, int count, std::vector &lt; std::string &gt; labelVec)
+    : plotName(name), curveCount(count), labels(labelVec) {
+    for (int i(0); i &lt; count; ++i) {
+      curveName2ID.insert(std::pair &lt; std::string, int &gt; (labels[i], i));
+      curves.push_back(new Curve());
+    }
+  }
+
+  ~Plot() {
+    for (int i(0); i &lt; curveCount; ++i) {
+      delete curves[i];
+    }
+  }
+
+  double getX(long long startT)
+  {
+    return (double)(getSystemTime() - startT) * 1e-6;
+  }
+
+  void printXY(std::string curveName, double xRough, int pointNum)
+  {
+    std::cout &lt;&lt; "[DEBUG] Plot: " &lt;&lt; plotName &lt;&lt; ", Curve: " &lt;&lt; curveName &lt;&lt; std::endl;
+    curves[curveName2ID[curveName]]-&gt;printXY(xRough, pointNum);
+  }
@@ -66 +71 @@
-class PyPlot{
+class PyPlot {
@@ -68,27 +73,27 @@
-    PyPlot();
-    ~PyPlot();
-    void addPlot(std::string plotName, int curveCount, std::vector&lt;std::string&gt; labelVec);
-    void addPlot(std::string plotName, int curveCount);
-    void showPlot(std::string plotName);
-    void showPlot(std::vector&lt;std::string&gt; plotNameVec);
-    void showPlotAll();
-
-    void printXY(std::string plotName, std::string curveName, double xRough, int pointNum = 1);
-
-    void addFrame(std::string plotName, double value);
-    void addFrame(std::string plotName, double x, double value);
-
-    template &lt;typename T&gt;
-    void addFrame(std::string plotName, T* valueArray);
-    template &lt;typename T&gt;
-    void addFrame(std::string plotName, double x, T* valueArray);
-
-    template &lt;typename T&gt;
-    void addFrame(std::string plotName, const Eigen::MatrixBase&lt;T&gt; &amp;vec);
-    template &lt;typename T&gt;
-    void addFrame(std::string plotName, double x, const Eigen::MatrixBase&lt;T&gt; &amp;vec);
-
-    template &lt;typename T&gt;
-    void addFrame(std::string plotName, const std::vector&lt;T&gt; &amp;vec);
-    template &lt;typename T&gt;
-    void addFrame(std::string plotName, double x, const std::vector&lt;T&gt; &amp;vec);
+  PyPlot();
+  ~PyPlot();
+  void addPlot(std::string plotName, int curveCount, std::vector &lt; std::string &gt; labelVec);
+  void addPlot(std::string plotName, int curveCount);
+  void showPlot(std::string plotName);
+  void showPlot(std::vector &lt; std::string &gt; plotNameVec);
+  void showPlotAll();
+
+  void printXY(std::string plotName, std::string curveName, double xRough, int pointNum = 1);
+
+  void addFrame(std::string plotName, double value);
+  void addFrame(std::string plotName, double x, double value);
+
+  template &lt; typename T &gt;
+  void addFrame(std::string plotName, T * valueArray);
+  template &lt; typename T &gt;
+  void addFrame(std::string plotName, double x, T * valueArray);
+
+  template &lt; typename T &gt;
+  void addFrame(std::string plotName, const Eigen::MatrixBase &lt; T &gt; &amp; vec);
+  template &lt; typename T &gt;
+  void addFrame(std::string plotName, double x, const Eigen::MatrixBase &lt; T &gt; &amp; vec);
+
+  template &lt; typename T &gt;
+  void addFrame(std::string plotName, const std::vector &lt; T &gt; &amp; vec);
+  template &lt; typename T &gt;
+  void addFrame(std::string plotName, double x, const std::vector &lt; T &gt; &amp; vec);
@@ -97,8 +102,8 @@
-    void _checkStart();
-    int _plotCount = 0;
-    std::map&lt;std::string, int&gt; _plotName2ID;
-    std::vector&lt; Plot* &gt; _plots;
-    long long _pointNum;
-    Plot* _getPlotPtr(std::string plotName);
-    bool start;
-    long long startT;
+  void _checkStart();
+  int _plotCount = 0;
+  std::map &lt; std::string, int &gt; _plotName2ID;
+  std::vector &lt; Plot * &gt; _plots;
+  long long _pointNum;
+  Plot * _getPlotPtr(std::string plotName);
+  bool start;
+  long long startT;
@@ -107,43 +112,68 @@
-inline PyPlot::PyPlot(){
-    start = false;
-}
-
-inline PyPlot::~PyPlot(){
-    for(int i(0); i &lt; _plotCount; ++i){
-        delete _plots[i];
-    }
-}
-
-inline void PyPlot::_checkStart(){
-    if(!start){
-        start = true;
-        startT = getSystemTime();
-    }
-}
-
-inline void PyPlot::printXY(std::string plotName, std::string curveName, double xRough, int pointNum){
-    _plots[_plotName2ID[plotName]]-&gt;printXY(curveName, xRough, pointNum);
-}
-
-inline void PyPlot::addPlot(std::string plotName, int curveCount, std::vector&lt;std::string&gt; labelVec){
-    if(_plotName2ID.count(plotName) == 0){
-        _plotName2ID.insert(std::pair&lt;std::string, int&gt;(plotName, _plotCount));
-        ++_plotCount;
-
-        _plots.push_back( new Plot(plotName, curveCount, labelVec) );
-    }else{
-        std::cout &lt;&lt; "[ERROR] Already has same Plot: " &lt;&lt; plotName &lt;&lt; std::endl;
-        exit(-1);
-    }
-}
-
-inline void PyPlot::addPlot(std::string plotName, int curveCount){
-    std::vector&lt;std::string&gt; label;
-    for(int i(0); i &lt; curveCount; ++i){
-        label.push_back(std::to_string(i+1));
-    }
-    addPlot(plotName, curveCount, label);
-}
-
-inline void PyPlot::showPlot(std::string plotName){
-    Plot* plot = _getPlotPtr(plotName);
+inline PyPlot::PyPlot()
+{
+  start = false;
+}
+
+inline PyPlot::~PyPlot()
+{
+  for (int i(0); i &lt; _plotCount; ++i) {
+    delete _plots[i];
+  }
+}
+
+inline void PyPlot::_checkStart()
+{
+  if (!start) {
+    start = true;
+    startT = getSystemTime();
+  }
+}
+
+inline void PyPlot::printXY(
+  std::string plotName, std::string curveName, double xRough,
+  int pointNum)
+{
+  _plots[_plotName2ID[plotName]]-&gt;printXY(curveName, xRough, pointNum);
+}
+
+inline void PyPlot::addPlot(
+  std::string plotName, int curveCount,
+  std::vector &lt; std::string &gt; labelVec)
+{
+  if (_plotName2ID.count(plotName) == 0) {
+    _plotName2ID.insert(std::pair &lt; std::string, int &gt; (plotName, _plotCount));
+    ++_plotCount;
+
+    _plots.push_back(new Plot(plotName, curveCount, labelVec) );
+  } else {
+    std::cout &lt;&lt; "[ERROR] Already has same Plot: " &lt;&lt; plotName &lt;&lt; std::endl;
+    exit(-1);
+  }
+}
+
+inline void PyPlot::addPlot(std::string plotName, int curveCount)
+{
+  std::vector &lt; std::string &gt; label;
+  for (int i(0); i &lt; curveCount; ++i) {
+    label.push_back(std::to_string(i + 1));
+  }
+  addPlot(plotName, curveCount, label);
+}
+
+inline void PyPlot::showPlot(std::string plotName)
+{
+  Plot * plot = _getPlotPtr(plotName);
+  plt::figure();
+  plt::title(plot-&gt;plotName);
+  for (int i(0); i &lt; plot-&gt;curveCount; ++i) {
+    plt::named_plot(plot-&gt;labels[i], plot-&gt;curves[i]-&gt;x, plot-&gt;curves[i]-&gt;y);
+  }
+  plt::legend();
+  plt::show();
+}
+
+inline void PyPlot::showPlot(std::vector &lt; std::string &gt; plotNameVec)
+{
+  for (std::vector &lt; std::string &gt; ::iterator itName = plotNameVec.begin();
+    itName != plotNameVec.end(); ++itName)
+  {
@@ -150,0 +181 @@
+    Plot * plot = _plots[_plotName2ID[*itName]];
@@ -152,2 +183,2 @@
-    for(int i(0); i &lt; plot-&gt;curveCount; ++i){
-        plt::named_plot(plot-&gt;labels[i], plot-&gt;curves[i]-&gt;x, plot-&gt;curves[i]-&gt;y);
+    for (int i(0); i &lt; plot-&gt;curveCount; ++i) {
+      plt::named_plot(plot-&gt;labels[i], plot-&gt;curves[i]-&gt;x, plot-&gt;curves[i]-&gt;y);
@@ -156,103 +187,101 @@
-    plt::show();
-}
-
-inline void PyPlot::showPlot(std::vector&lt;std::string&gt; plotNameVec){
-    for(std::vector&lt;std::string&gt;::iterator itName = plotNameVec.begin(); itName != plotNameVec.end(); ++itName){
-        plt::figure();
-        Plot* plot = _plots[_plotName2ID[*itName]];
-        plt::title(plot-&gt;plotName);
-        for(int i(0); i &lt; plot-&gt;curveCount; ++i){
-            plt::named_plot(plot-&gt;labels[i], plot-&gt;curves[i]-&gt;x, plot-&gt;curves[i]-&gt;y);
-        }
-        plt::legend();
-    }
-    plt::show();
-}
-
-inline void PyPlot::showPlotAll(){
-    for(int i(0); i &lt; _plotCount; ++i){
-        plt::figure();
-        Plot* plot = _plots[i];
-        plt::title(plot-&gt;plotName);
-        for(int j(0); j &lt; plot-&gt;curveCount; ++j){
-            plt::named_plot(plot-&gt;labels[j], plot-&gt;curves[j]-&gt;x, plot-&gt;curves[j]-&gt;y);
-        }
-        plt::legend();
-    }
-    plt::show();
-    exit(0);
-}
-
-inline Plot* PyPlot::_getPlotPtr(std::string plotName){
-    if(_plotName2ID.count(plotName) == 0){
-        std::cout &lt;&lt; "[ERROR] Plot " &lt;&lt; plotName &lt;&lt; " does not exist" &lt;&lt; std::endl;
-        exit(-1);
-    }else{
-        return _plots[_plotName2ID[plotName]];
-    }
-}
-
-inline void PyPlot::addFrame(std::string plotName, double value){
-    _checkStart();
-    Plot* plot = _getPlotPtr(plotName);
-    addFrame(plotName, plot-&gt;getX(startT), value);
-}
-
-inline void PyPlot::addFrame(std::string plotName, double x, double value){
-    Plot* plot = _getPlotPtr(plotName);
-    
-    plot-&gt;curves[0]-&gt;x.push_back(x);
-    plot-&gt;curves[0]-&gt;y.push_back(value);
-}
-
-template &lt;typename T&gt;
-inline void PyPlot::addFrame(std::string plotName, T* valueArray){
-    _checkStart();
-    Plot* plot = _getPlotPtr(plotName);
-    addFrame(plotName, plot-&gt;getX(startT), valueArray);
-}
-
-template &lt;typename T&gt;
-inline void PyPlot::addFrame(std::string plotName, double x, T* valueArray){
-    Plot* plot = _getPlotPtr(plotName);
-
-    for(int i(0); i &lt; plot-&gt;curveCount; ++i){
-        plot-&gt;curves[i]-&gt;x.push_back(x);
-        plot-&gt;curves[i]-&gt;y.push_back(valueArray[i]);
-    }
-}
-
-template &lt;typename T&gt;
-inline void PyPlot::addFrame(std::string plotName, const Eigen::MatrixBase&lt;T&gt; &amp;vec){
-    _checkStart();
-    Plot* plot = _getPlotPtr(plotName);
-    addFrame(plotName, plot-&gt;getX(startT), vec);
-}
-
-template &lt;typename T&gt;
-inline void PyPlot::addFrame(std::string plotName, double x, const Eigen::MatrixBase&lt;T&gt; &amp;vec){
-    Plot* plot = _getPlotPtr(plotName);
-
-    for(int i(0); i &lt; plot-&gt;curveCount; ++i){
-        plot-&gt;curves[i]-&gt;x.push_back(x);
-        plot-&gt;curves[i]-&gt;y.push_back(vec(i));
-    }
-}
-
-template &lt;typename T&gt;
-inline void PyPlot::addFrame(std::string plotName, const std::vector&lt;T&gt; &amp;vec){
-    _checkStart();
-    Plot* plot = _getPlotPtr(plotName);
-    addFrame(plotName, plot-&gt;getX(startT), vec);
-}
-
-template &lt;typename T&gt;
-inline void PyPlot::addFrame(std::string plotName, double x, const std::vector&lt;T&gt; &amp;vec){
-    Plot* plot = _getPlotPtr(plotName);
-
-    for(int i(0); i &lt; plot-&gt;curveCount; ++i){
-        plot-&gt;curves[i]-&gt;x.push_back(x);
-        plot-&gt;curves[i]-&gt;y.push_back(vec[i]);
-    }
-}
-#endif // PYPLOT_H
+  }
+  plt::show();
+}
+
+inline void PyPlot::showPlotAll()
+{
+  for (int i(0); i &lt; _plotCount; ++i) {
+    plt::figure();
+    Plot * plot = _plots[i];
+    plt::title(plot-&gt;plotName);
+    for (int j(0); j &lt; plot-&gt;curveCount; ++j) {
+      plt::named_plot(plot-&gt;labels[j], plot-&gt;curves[j]-&gt;x, plot-&gt;curves[j]-&gt;y);
+    }
+    plt::legend();
+  }
+  plt::show();
+  exit(0);
+}
+
+inline Plot * PyPlot::_getPlotPtr(std::string plotName)
+{
+  if (_plotName2ID.count(plotName) == 0) {
+    std::cout &lt;&lt; "[ERROR] Plot " &lt;&lt; plotName &lt;&lt; " does not exist" &lt;&lt; std::endl;
+    exit(-1);
+  } else {
+    return _plots[_plotName2ID[plotName]];
+  }
+}
+
+inline void PyPlot::addFrame(std::string plotName, double value)
+{
+  _checkStart();
+  Plot * plot = _getPlotPtr(plotName);
+  addFrame(plotName, plot-&gt;getX(startT), value);
+}
+
+inline void PyPlot::addFrame(std::string plotName, double x, double value)
+{
+  Plot * plot = _getPlotPtr(plotName);
+
+  plot-&gt;curves[0]-&gt;x.push_back(x);
+  plot-&gt;curves[0]-&gt;y.push_back(value);
+}
+
+template &lt; typename T &gt;
+inline void PyPlot::addFrame(std::string plotName, T * valueArray)
+{
+  _checkStart();
+  Plot * plot = _getPlotPtr(plotName);
+  addFrame(plotName, plot-&gt;getX(startT), valueArray);
+}
+
+template &lt; typename T &gt;
+inline void PyPlot::addFrame(std::string plotName, double x, T * valueArray)
+{
+  Plot * plot = _getPlotPtr(plotName);
+
+  for (int i(0); i &lt; plot-&gt;curveCount; ++i) {
+    plot-&gt;curves[i]-&gt;x.push_back(x);
+    plot-&gt;curves[i]-&gt;y.push_back(valueArray[i]);
+  }
+}
+
+template &lt; typename T &gt;
+inline void PyPlot::addFrame(std::string plotName, const Eigen::MatrixBase &lt; T &gt; &amp; vec)
+{
+  _checkStart();
+  Plot * plot = _getPlotPtr(plotName);
+  addFrame(plotName, plot-&gt;getX(startT), vec);
+}
+
+template &lt; typename T &gt;
+inline void PyPlot::addFrame(std::string plotName, double x, const Eigen::MatrixBase &lt; T &gt; &amp; vec)
+{
+  Plot * plot = _getPlotPtr(plotName);
+
+  for (int i(0); i &lt; plot-&gt;curveCount; ++i) {
+    plot-&gt;curves[i]-&gt;x.push_back(x);
+    plot-&gt;curves[i]-&gt;y.push_back(vec(i));
+  }
+}
+
+template &lt; typename T &gt;
+inline void PyPlot::addFrame(std::string plotName, const std::vector &lt; T &gt; &amp; vec)
+{
+  _checkStart();
+  Plot * plot = _getPlotPtr(plotName);
+  addFrame(plotName, plot-&gt;getX(startT), vec);
+}
+
+template &lt; typename T &gt;
+inline void PyPlot::addFrame(std::string plotName, double x, const std::vector &lt; T &gt; &amp; vec)
+{
+  Plot * plot = _getPlotPtr(plotName);
+
+  for (int i(0); i &lt; plot-&gt;curveCount; ++i) {
+    plot-&gt;curves[i]-&gt;x.push_back(x);
+    plot-&gt;curves[i]-&gt;y.push_back(vec[i]);
+  }
+}
+#endif // PYPLOT_H

Code style divergence in file 'include/common/enumClass.h':

--- include/common/enumClass.h
+++ include/common/enumClass.h.uncrustify
@@ -10,3 +10,4 @@
-enum class CtrlPlatform{
-    GAZEBO,
-    REALROBOT,
+enum class CtrlPlatform
+{
+  GAZEBO,
+  REALROBOT,
@@ -15,3 +16,4 @@
-enum class RobotType{
-    A1,
-    Go1
+enum class RobotType
+{
+  A1,
+  Go1
@@ -20,7 +22,8 @@
-enum class UserCommand{
-    // EXIT,
-    NONE,
-    START,      // trotting
-    L2_A,       // fixedStand
-    L2_B,       // passive
-    L2_X,       // freeStand
+enum class UserCommand
+{
+  // EXIT,
+  NONE,
+  START,        // trotting
+  L2_A,         // fixedStand
+  L2_B,         // passive
+  L2_X,         // freeStand
@@ -28 +31 @@
-    L2_Y,       // move_base
+  L2_Y,         // move_base
@@ -31 +34 @@
-    L2_Y,       // move_base
+  L2_Y,         // move_base
@@ -33,3 +36,3 @@
-    L1_X,       // balanceTest
-    L1_A,       // swingTest
-    L1_Y        // stepTest
+  L1_X,         // balanceTest
+  L1_A,         // swingTest
+  L1_Y          // stepTest
@@ -38,4 +41,5 @@
-enum class FrameType{
-    BODY,
-    HIP,
-    GLOBAL
+enum class FrameType
+{
+  BODY,
+  HIP,
+  GLOBAL
@@ -44,4 +48,5 @@
-enum class WaveStatus{
-    STANCE_ALL,
-    SWING_ALL,
-    WAVE_ALL
+enum class WaveStatus
+{
+  STANCE_ALL,
+  SWING_ALL,
+  WAVE_ALL
@@ -50,3 +55,4 @@
-enum class FSMMode{
-    NORMAL,
-    CHANGE
+enum class FSMMode
+{
+  NORMAL,
+  CHANGE
@@ -55,7 +61,8 @@
-enum class FSMStateName{
-    // EXIT,
-    INVALID,
-    PASSIVE,
-    FIXEDSTAND,
-    FREESTAND,
-    TROTTING,
+enum class FSMStateName
+{
+  // EXIT,
+  INVALID,
+  PASSIVE,
+  FIXEDSTAND,
+  FREESTAND,
+  TROTTING,
@@ -63 +70 @@
-    MOVE_BASE,       // move_base
+  MOVE_BASE,         // move_base
@@ -66 +73 @@
-    MOVE_BASE,       // move_base
+  MOVE_BASE,         // move_base
@@ -68,3 +75,3 @@
-    BALANCETEST,
-    SWINGTEST,
-    STEPTEST
+  BALANCETEST,
+  SWINGTEST,
+  STEPTEST
@@ -73 +80 @@
-#endif  // ENUMCLASS_H
+#endif  // ENUMCLASS_H

Code style divergence in file 'include/common/mathTools.h':

--- include/common/mathTools.h
+++ include/common/mathTools.h.uncrustify
@@ -11,19 +11,290 @@
-template&lt;typename T1, typename T2&gt;
-inline T1 max(const T1 a, const T2 b){
-	return (a &gt; b ? a : b);
-}
-
-template&lt;typename T1, typename T2&gt;
-inline T1 min(const T1 a, const T2 b){
-	return (a &lt; b ? a : b);
-}
-
-template&lt;typename T&gt;
-inline T saturation(const T a, Vec2 limits){
-    T lowLim, highLim;
-    if(limits(0) &gt; limits(1)){
-        lowLim = limits(1);
-        highLim= limits(0);
-    }else{
-        lowLim = limits(0);
-        highLim= limits(1);
+template &lt; typename T1, typename T2 &gt;
+inline T1 max(const T1 a, const T2 b)
+{
+  return a &gt; b ? a : b;
+}
+
+template &lt; typename T1, typename T2 &gt;
+inline T1 min(const T1 a, const T2 b)
+{
+  return a &lt; b ? a : b;
+}
+
+template &lt; typename T &gt;
+inline T saturation(const T a, Vec2 limits)
+{
+  T lowLim, highLim;
+  if (limits(0) &gt; limits(1)) {
+    lowLim = limits(1);
+    highLim = limits(0);
+  } else {
+    lowLim = limits(0);
+    highLim = limits(1);
+  }
+
+  if (a &lt; lowLim) {
+    return lowLim;
+  } else if (a &gt; highLim) {
+    return highLim;
+  } else {
+    return a;
+  }
+}
+
+template &lt; typename T0, typename T1 &gt;
+inline T0 killZeroOffset(T0 a, const T1 limit)
+{
+  if ((a &gt; -limit) &amp;&amp; (a &lt; limit)) {
+    a = 0;
+  }
+  return a;
+}
+
+template &lt; typename T0, typename T1, typename T2 &gt;
+inline T1 invNormalize(
+  const T0 value, const T1 min, const T2 max, const double minLim = -1,
+  const double maxLim = 1)
+{
+  return (value - minLim) * (max - min) / (maxLim - minLim) + min;
+}
+
+template &lt; typename T &gt;
+inline T windowFunc(const T x, const T windowRatio, const T xRange = 1.0, const T yRange = 1.0)
+{
+  if ((x &lt; 0) || (x &gt; xRange)) {
+    std::cout &lt;&lt; "[ERROR][windowFunc] The x=" &lt;&lt; x &lt;&lt; ", which should between [0, xRange]" &lt;&lt;
+      std::endl;
+  }
+  if ((windowRatio &lt;= 0) || (windowRatio &gt;= 0.5)) {
+    std::cout &lt;&lt; "[ERROR][windowFunc] The windowRatio=" &lt;&lt; windowRatio &lt;&lt;
+      ", which should between [0, 0.5]" &lt;&lt; std::endl;
+  }
+
+  if (x / xRange &lt; windowRatio) {
+    return x * yRange / (xRange * windowRatio);
+  } else if (x / xRange &gt; 1 - windowRatio) {
+    return yRange * (xRange - x) / (xRange * windowRatio);
+  } else {
+    return yRange;
+  }
+}
+
+template &lt; typename T1, typename T2 &gt;
+inline void updateAverage(T1 &amp; exp, T2 newValue, double n)
+{
+  if (exp.rows() != newValue.rows()) {
+    std::cout &lt;&lt; "The size of updateAverage is error" &lt;&lt; std::endl;
+    exit(-1);
+  }
+  if (fabs(n - 1) &lt; 0.001) {
+    exp = newValue;
+  } else {
+    exp = exp + (newValue - exp) / n;
+  }
+}
+
+template &lt; typename T1, typename T2, typename T3 &gt;
+inline void updateCovariance(T1 &amp; cov, T2 expPast, T3 newValue, double n)
+{
+  if ( (cov.rows() != cov.cols()) || (cov.rows() != expPast.rows()) ||
+    (expPast.rows() != newValue.rows()))
+  {
+    std::cout &lt;&lt; "The size of updateCovariance is error" &lt;&lt; std::endl;
+    exit(-1);
+  }
+  if (fabs(n - 1) &lt; 0.1) {
+    cov.setZero();
+  } else {
+    cov = cov * (n - 1) / n + (newValue - expPast) * (newValue - expPast).transpose() * (n - 1) /
+      (n * n);
+  }
+}
+
+template &lt; typename T1, typename T2, typename T3 &gt;
+inline void updateAvgCov(T1 &amp; cov, T2 &amp; exp, T3 newValue, double n)
+{
+  // The order matters!!! covariance first!!!
+  updateCovariance(cov, exp, newValue, n);
+  updateAverage(exp, newValue, n);
+}
+
+inline RotMat rotx(const double &amp; theta)
+{
+  double s = std::sin(theta);
+  double c = std::cos(theta);
+
+  RotMat R;
+  R &lt;&lt; 1, 0, 0, 0, c, -s, 0, s, c;
+  return R;
+}
+
+inline RotMat roty(const double &amp; theta)
+{
+  double s = std::sin(theta);
+  double c = std::cos(theta);
+
+  RotMat R;
+  R &lt;&lt; c, 0, s, 0, 1, 0, -s, 0, c;
+  return R;
+}
+
+inline RotMat rotz(const double &amp; theta)
+{
+  double s = std::sin(theta);
+  double c = std::cos(theta);
+
+  RotMat R;
+  R &lt;&lt; c, -s, 0, s, c, 0, 0, 0, 1;
+  return R;
+}
+
+inline Mat2 skew(const double &amp; w)
+{
+  Mat2 mat; mat.setZero();
+  mat(0, 1) = -w;
+  mat(1, 0) = w;
+  return mat;
+}
+
+inline Mat3 skew(const Vec3 &amp; v)
+{
+  Mat3 m;
+  m &lt;&lt; 0, -v(2), v(1),
+    v(2), 0, -v(0),
+    -v(1), v(0), 0;
+  return m;
+}
+
+inline RotMat rpyToRotMat(const double &amp; row, const double &amp; pitch, const double &amp; yaw)
+{
+  RotMat m = rotz(yaw) * roty(pitch) * rotx(row);
+  return m;
+}
+
+inline Vec3 rotMatToRPY(const Mat3 &amp; R)
+{
+  Vec3 rpy;
+  rpy(0) = atan2(R(2, 1), R(2, 2));
+  rpy(1) = asin(-R(2, 0));
+  rpy(2) = atan2(R(1, 0), R(0, 0));
+  return rpy;
+}
+
+inline RotMat quatToRotMat(const Quat &amp; q)
+{
+  double e0 = q(0);
+  double e1 = q(1);
+  double e2 = q(2);
+  double e3 = q(3);
+
+  RotMat R;
+  R &lt;&lt; 1 - 2 * (e2 * e2 + e3 * e3), 2 * (e1 * e2 - e0 * e3),
+    2 * (e1 * e3 + e0 * e2), 2 * (e1 * e2 + e0 * e3),
+    1 - 2 * (e1 * e1 + e3 * e3), 2 * (e2 * e3 - e0 * e1),
+    2 * (e1 * e3 - e0 * e2), 2 * (e2 * e3 + e0 * e1),
+    1 - 2 * (e1 * e1 + e2 * e2);
+  return R;
+}
+
+inline Vec3 rotMatToExp(const RotMat &amp; rm)
+{
+  double cosValue = rm.trace() / 2.0 - 1 / 2.0;
+  if (cosValue &gt; 1.0f) {
+    cosValue = 1.0f;
+  } else if (cosValue &lt; -1.0f) {
+    cosValue = -1.0f;
+  }
+
+  double angle = acos(cosValue);
+  Vec3 exp;
+  if (fabs(angle) &lt; 1e-5) {
+    exp = Vec3(0, 0, 0);
+  } else if (fabs(angle - M_PI) &lt; 1e-5) {
+    exp = angle * Vec3(rm(0, 0) + 1, rm(0, 1), rm(0, 2)) / sqrt(2 * (1 + rm(0, 0)));
+  } else {
+    exp = angle / (2.0f * sin(angle)) * Vec3(
+      rm(2, 1) - rm(1, 2), rm(0, 2) - rm(2, 0), rm(1, 0) - rm(
+        0, 1));
+  }
+  return exp;
+}
+
+inline HomoMat homoMatrix(Vec3 p, RotMat m)
+{
+  HomoMat homoM;
+  homoM.setZero();
+  homoM.topLeftCorner(3, 3) = m;
+  homoM.topRightCorner(3, 1) = p;
+  homoM(3, 3) = 1;
+  return homoM;
+}
+
+inline HomoMat homoMatrix(Vec3 p, Quat q)
+{
+  HomoMat homoM;
+  homoM.setZero();
+  homoM.topLeftCorner(3, 3) = quatToRotMat(q);
+  homoM.topRightCorner(3, 1) = p;
+  homoM(3, 3) = 1;
+  return homoM;
+}
+
+inline HomoMat homoMatrixInverse(HomoMat homoM)
+{
+  HomoMat homoInv;
+  homoInv.setZero();
+  homoInv.topLeftCorner(3, 3) = homoM.topLeftCorner(3, 3).transpose();
+  homoInv.topRightCorner(
+    3,
+    1) = -homoM.topLeftCorner(3, 3).transpose() * homoM.topRightCorner(3, 1);
+  homoInv(3, 3) = 1;
+  return homoInv;
+}
+
+//  add 1 at the end of Vec3
+inline Vec4 homoVec(Vec3 v3)
+{
+  Vec4 v4;
+  v4.block(0, 0, 3, 1) = v3;
+  v4(3) = 1;
+  return v4;
+}
+
+//  remove 1 at the end of Vec4
+inline Vec3 noHomoVec(Vec4 v4)
+{
+  Vec3 v3;
+  v3 = v4.block(0, 0, 3, 1);
+  return v3;
+}
+
+// Calculate average value and covariance
+class AvgCov {
+public:
+  AvgCov(
+    unsigned int size, std::string name, bool avgOnly = false, unsigned int showPeriod = 1000,
+    unsigned int waitCount = 5000, double zoomFactor = 10000)
+    : _size(size), _showPeriod(showPeriod), _waitCount(waitCount), _zoomFactor(zoomFactor),
+    _valueName(name), _avgOnly(avgOnly) {
+    _exp.resize(size);
+    _cov.resize(size, size);
+    _defaultWeight.resize(size, size);
+    _defaultWeight.setIdentity();
+    _measureCount = 0;
+  }
+  void measure(VecX newValue)
+  {
+    ++_measureCount;
+
+    if (_measureCount &gt; _waitCount) {
+      updateAvgCov(_cov, _exp, newValue, _measureCount - _waitCount);
+      if (_measureCount % _showPeriod == 0) {
+        std::cout &lt;&lt; "******" &lt;&lt; _valueName &lt;&lt; " measured count: " &lt;&lt; _measureCount - _waitCount &lt;&lt;
+          "******" &lt;&lt; std::endl;
+        std::cout &lt;&lt; _zoomFactor &lt;&lt; " Times Average of " &lt;&lt; _valueName &lt;&lt; std::endl &lt;&lt;
+          (_zoomFactor * _exp).transpose() &lt;&lt; std::endl;
+        if (!_avgOnly) {
+          std::cout &lt;&lt; _zoomFactor &lt;&lt; " Times Covariance of " &lt;&lt; _valueName &lt;&lt; std::endl &lt;&lt;
+            _zoomFactor * _cov &lt;&lt; std::endl;
+        }
+      }
@@ -31,237 +302,2 @@
-
-    if(a &lt; lowLim){
-        return lowLim;
-    }
-    else if(a &gt; highLim){
-        return highLim;
-    }
-    else{
-        return a;
-    }
-}
-
-template&lt;typename T0, typename T1&gt;
-inline T0 killZeroOffset(T0 a, const T1 limit){
-    if((a &gt; -limit) &amp;&amp; (a &lt; limit)){
-        a = 0;
-    }
-    return a;
-}
-
-template&lt;typename T0, typename T1, typename T2&gt;
-inline T1 invNormalize(const T0 value, const T1 min, const T2 max, const double minLim = -1, const double maxLim = 1){
-	return (value-minLim)*(max-min)/(maxLim-minLim) + min;
-}
-
-template&lt;typename T&gt;
-inline T windowFunc(const T x, const T windowRatio, const T xRange=1.0, const T yRange=1.0){
-    if((x &lt; 0)||(x &gt; xRange)){
-        std::cout &lt;&lt; "[ERROR][windowFunc] The x=" &lt;&lt; x &lt;&lt; ", which should between [0, xRange]" &lt;&lt; std::endl;
-    }
-    if((windowRatio &lt;= 0)||(windowRatio &gt;= 0.5)){
-        std::cout &lt;&lt; "[ERROR][windowFunc] The windowRatio=" &lt;&lt; windowRatio &lt;&lt; ", which should between [0, 0.5]" &lt;&lt; std::endl;
-    }
-
-    if(x/xRange &lt; windowRatio){
-        return x * yRange / (xRange * windowRatio);
-    }
-    else if(x/xRange &gt; 1 - windowRatio){
-        return yRange * (xRange - x)/(xRange * windowRatio);
-    }
-    else{
-        return yRange;
-    }
-}
-
-template&lt;typename T1, typename T2&gt;
-inline void updateAverage(T1 &amp;exp, T2 newValue, double n){
-    if(exp.rows()!=newValue.rows()){
-        std::cout &lt;&lt; "The size of updateAverage is error" &lt;&lt; std::endl;
-        exit(-1);
-    }
-    if(fabs(n - 1) &lt; 0.001){
-        exp = newValue;
-    }else{
-        exp = exp + (newValue - exp)/n;
-    }
-}
-
-template&lt;typename T1, typename T2, typename T3&gt;
-inline void updateCovariance(T1 &amp;cov, T2 expPast, T3 newValue, double n){
-    if( (cov.rows()!=cov.cols()) || (cov.rows() != expPast.rows()) || (expPast.rows()!=newValue.rows())){
-        std::cout &lt;&lt; "The size of updateCovariance is error" &lt;&lt; std::endl;
-        exit(-1);
-    }
-    if(fabs(n - 1) &lt; 0.1){
-        cov.setZero();
-    }else{
-        cov = cov*(n-1)/n + (newValue-expPast)*(newValue-expPast).transpose()*(n-1)/(n*n);
-    }
-}
-
-template&lt;typename T1, typename T2, typename T3&gt;
-inline void updateAvgCov(T1 &amp;cov, T2 &amp;exp, T3 newValue, double n){
-    // The order matters!!! covariance first!!!
-    updateCovariance(cov, exp, newValue, n);
-    updateAverage(exp, newValue, n);
-}
-
-inline RotMat rotx(const double &amp;theta) {
-    double s = std::sin(theta);
-    double c = std::cos(theta);
-
-    RotMat R;
-    R &lt;&lt; 1, 0, 0, 0, c, -s, 0, s, c;
-    return R;
-}
-
-inline RotMat roty(const double &amp;theta) {
-    double s = std::sin(theta);
-    double c = std::cos(theta);
-
-    RotMat R;
-    R &lt;&lt; c, 0, s, 0, 1, 0, -s, 0, c;
-    return R;
-}
-
-inline RotMat rotz(const double &amp;theta) {
-    double s = std::sin(theta);
-    double c = std::cos(theta);
-
-    RotMat R;
-    R &lt;&lt; c, -s, 0, s, c, 0, 0, 0, 1;
-    return R;
-}
-
-inline Mat2 skew(const double&amp; w){
-    Mat2 mat; mat.setZero();
-    mat(0, 1) = -w;
-    mat(1, 0) =  w;
-    return mat;
-}
-
-inline Mat3 skew(const Vec3&amp; v) {
-    Mat3 m;
-    m &lt;&lt; 0, -v(2), v(1),
-            v(2), 0, -v(0),
-            -v(1), v(0), 0;
-    return m;
-}
-
-inline RotMat rpyToRotMat(const double&amp; row, const double&amp; pitch, const double&amp; yaw) {
-    RotMat m = rotz(yaw) * roty(pitch) * rotx(row);
-    return m;
-}
-
-inline Vec3 rotMatToRPY(const Mat3&amp; R) {
-    Vec3 rpy;
-    rpy(0) = atan2(R(2,1),R(2,2));
-    rpy(1) = asin(-R(2,0));
-    rpy(2) = atan2(R(1,0),R(0,0));
-    return rpy;
-}
-
-inline RotMat quatToRotMat(const Quat&amp; q) {
-    double e0 = q(0);
-    double e1 = q(1);
-    double e2 = q(2);
-    double e3 = q(3);
-
-    RotMat R;
-    R &lt;&lt; 1 - 2 * (e2 * e2 + e3 * e3), 2 * (e1 * e2 - e0 * e3),
-            2 * (e1 * e3 + e0 * e2), 2 * (e1 * e2 + e0 * e3),
-            1 - 2 * (e1 * e1 + e3 * e3), 2 * (e2 * e3 - e0 * e1),
-            2 * (e1 * e3 - e0 * e2), 2 * (e2 * e3 + e0 * e1),
-            1 - 2 * (e1 * e1 + e2 * e2);
-    return R;
-}
-
-inline Vec3 rotMatToExp(const RotMat&amp; rm){
-    double cosValue = rm.trace()/2.0-1/2.0;
-    if(cosValue &gt; 1.0f){
-        cosValue = 1.0f;
-    }else if(cosValue &lt; -1.0f){
-        cosValue = -1.0f;
-    }
-
-    double angle = acos(cosValue);
-    Vec3 exp;
-    if (fabs(angle) &lt; 1e-5){
-        exp=Vec3(0,0,0);
-    }
-    else if (fabs(angle - M_PI) &lt; 1e-5){
-        exp = angle * Vec3(rm(0,0)+1, rm(0,1), rm(0,2)) / sqrt(2*(1+rm(0, 0)));
-    }
-    else{
-        exp=angle/(2.0f*sin(angle))*Vec3(rm(2,1)-rm(1,2),rm(0,2)-rm(2,0),rm(1,0)-rm(0,1));
-    }
-    return exp;
-}
-
-inline HomoMat homoMatrix(Vec3 p, RotMat m){
-    HomoMat homoM;
-    homoM.setZero();
-    homoM.topLeftCorner(3, 3) = m;
-    homoM.topRightCorner(3, 1) = p;
-    homoM(3, 3) = 1;
-    return homoM;
-}
-
-inline HomoMat homoMatrix(Vec3 p, Quat q){
-    HomoMat homoM;
-    homoM.setZero();
-    homoM.topLeftCorner(3, 3) = quatToRotMat(q);
-    homoM.topRightCorner(3, 1) = p;
-    homoM(3, 3) = 1;
-    return homoM;
-}
-
-inline HomoMat homoMatrixInverse(HomoMat homoM){
-    HomoMat homoInv;
-    homoInv.setZero();
-    homoInv.topLeftCorner(3, 3) = homoM.topLeftCorner(3, 3).transpose();
-    homoInv.topRightCorner(3, 1) = -homoM.topLeftCorner(3, 3).transpose() * homoM.topRightCorner(3, 1);
-    homoInv(3, 3) = 1;
-    return homoInv;
-}
-
-//  add 1 at the end of Vec3
-inline Vec4 homoVec(Vec3 v3){
-    Vec4 v4;
-    v4.block(0, 0, 3, 1) = v3;
-    v4(3) = 1;
-    return v4;
-}
-
-//  remove 1 at the end of Vec4
-inline Vec3 noHomoVec(Vec4 v4){
-    Vec3 v3;
-    v3 = v4.block(0, 0, 3, 1);
-    return v3;
-}
-
-// Calculate average value and covariance
-class AvgCov{
-public:
-    AvgCov(unsigned int size, std::string name, bool avgOnly=false, unsigned int showPeriod=1000, unsigned int waitCount=5000, double zoomFactor=10000)
-            :_size(size), _showPeriod(showPeriod), _waitCount(waitCount), _zoomFactor(zoomFactor), _valueName(name), _avgOnly(avgOnly) {
-        _exp.resize(size);
-        _cov.resize(size, size);
-        _defaultWeight.resize(size, size);
-        _defaultWeight.setIdentity();
-        _measureCount = 0;
-    }
-    void measure(VecX newValue){
-        ++_measureCount;
-
-        if(_measureCount &gt; _waitCount){
-            updateAvgCov(_cov, _exp, newValue, _measureCount-_waitCount);
-            if(_measureCount % _showPeriod == 0){
-                std::cout &lt;&lt; "******" &lt;&lt; _valueName &lt;&lt; " measured count: " &lt;&lt; _measureCount-_waitCount &lt;&lt; "******" &lt;&lt; std::endl;
-                std::cout &lt;&lt; _zoomFactor &lt;&lt; " Times Average of " &lt;&lt; _valueName &lt;&lt; std::endl &lt;&lt; (_zoomFactor*_exp).transpose() &lt;&lt; std::endl;
-                if(!_avgOnly){
-                    std::cout &lt;&lt; _zoomFactor &lt;&lt; " Times Covariance of " &lt;&lt; _valueName &lt;&lt; std::endl &lt;&lt; _zoomFactor*_cov &lt;&lt; std::endl;
-                }
-            }
-        }
-    }
+  }
+
@@ -269,10 +305,10 @@
-    VecX _exp;
-    MatX _cov;
-    MatX _defaultWeight;
-    bool _avgOnly;
-    unsigned int _size;
-    unsigned int _measureCount;
-    unsigned int _showPeriod;
-    unsigned int _waitCount;
-    double _zoomFactor;
-    std::string _valueName;
+  VecX _exp;
+  MatX _cov;
+  MatX _defaultWeight;
+  bool _avgOnly;
+  unsigned int _size;
+  unsigned int _measureCount;
+  unsigned int _showPeriod;
+  unsigned int _waitCount;
+  double _zoomFactor;
+  std::string _valueName;
@@ -281 +317 @@
-#endif  // MATHTOOLS_H
+#endif  // MATHTOOLS_H

Code style divergence in file 'include/common/mathTypes.h':

--- include/common/mathTypes.h
+++ include/common/mathTypes.h.uncrustify
@@ -13 +13 @@
-using Vec2 = typename Eigen::Matrix&lt;double, 2, 1&gt;;
+using Vec2 = typename Eigen::Matrix &lt; double, 2, 1 &gt;;
@@ -16 +16 @@
-using Vec3 = typename Eigen::Matrix&lt;double, 3, 1&gt;;
+using Vec3 = typename Eigen::Matrix &lt; double, 3, 1 &gt;;
@@ -19 +19 @@
-using Vec4 = typename Eigen::Matrix&lt;double, 4, 1&gt;;
+using Vec4 = typename Eigen::Matrix &lt; double, 4, 1 &gt;;
@@ -22 +22 @@
-using Vec6 = typename Eigen::Matrix&lt;double, 6, 1&gt;;
+using Vec6 = typename Eigen::Matrix &lt; double, 6, 1 &gt;;
@@ -25 +25 @@
-using Quat = typename Eigen::Matrix&lt;double, 4, 1&gt;;
+using Quat = typename Eigen::Matrix &lt; double, 4, 1 &gt;;
@@ -28 +28 @@
-using VecInt4 = typename Eigen::Matrix&lt;int, 4, 1&gt;;
+using VecInt4 = typename Eigen::Matrix &lt; int, 4, 1 &gt;;
@@ -31 +31 @@
-using Vec12 = typename Eigen::Matrix&lt;double, 12, 1&gt;;
+using Vec12 = typename Eigen::Matrix &lt; double, 12, 1 &gt;;
@@ -34 +34 @@
-using Vec18 = typename Eigen::Matrix&lt;double, 18, 1&gt;;
+using Vec18 = typename Eigen::Matrix &lt; double, 18, 1 &gt;;
@@ -37 +37 @@
-using VecX = typename Eigen::Matrix&lt;double, Eigen::Dynamic, 1&gt;;
+using VecX = typename Eigen::Matrix &lt; double, Eigen::Dynamic, 1 &gt;;
@@ -43 +43 @@
-using RotMat = typename Eigen::Matrix&lt;double, 3, 3&gt;;
+using RotMat = typename Eigen::Matrix &lt; double, 3, 3 &gt;;
@@ -46 +46 @@
-using HomoMat = typename Eigen::Matrix&lt;double, 4, 4&gt;;
+using HomoMat = typename Eigen::Matrix &lt; double, 4, 4 &gt;;
@@ -49 +49 @@
-using Mat2 = typename Eigen::Matrix&lt;double, 2, 2&gt;;
+using Mat2 = typename Eigen::Matrix &lt; double, 2, 2 &gt;;
@@ -52 +52 @@
-using Mat3 = typename Eigen::Matrix&lt;double, 3, 3&gt;;
+using Mat3 = typename Eigen::Matrix &lt; double, 3, 3 &gt;;
@@ -58 +58 @@
-using Vec34 = typename Eigen::Matrix&lt;double, 3, 4&gt;;
+using Vec34 = typename Eigen::Matrix &lt; double, 3, 4 &gt;;
@@ -61 +61 @@
-using Mat6 = typename Eigen::Matrix&lt;double, 6, 6&gt;;
+using Mat6 = typename Eigen::Matrix &lt; double, 6, 6 &gt;;
@@ -64 +64 @@
-using Mat12 = typename Eigen::Matrix&lt;double, 12, 12&gt;;
+using Mat12 = typename Eigen::Matrix &lt; double, 12, 12 &gt;;
@@ -73 +73 @@
-using MatX = typename Eigen::Matrix&lt;double, Eigen::Dynamic, Eigen::Dynamic&gt;;
+using MatX = typename Eigen::Matrix &lt; double, Eigen::Dynamic, Eigen::Dynamic &gt;;
@@ -78,6 +78,7 @@
-inline Vec34 vec12ToVec34(Vec12 vec12){
-    Vec34 vec34;
-    for(int i(0); i &lt; 4; ++i){
-        vec34.col(i) = vec12.segment(3*i, 3);
-    }
-    return vec34;
+inline Vec34 vec12ToVec34(Vec12 vec12)
+{
+  Vec34 vec34;
+  for (int i(0); i &lt; 4; ++i) {
+    vec34.col(i) = vec12.segment(3 * i, 3);
+  }
+  return vec34;
@@ -86,6 +87,7 @@
-inline Vec12 vec34ToVec12(Vec34 vec34){
-    Vec12 vec12;
-    for(int i(0); i &lt; 4; ++i){
-        vec12.segment(3*i, 3) = vec34.col(i);
-    }
-    return vec12;
+inline Vec12 vec34ToVec12(Vec34 vec34)
+{
+  Vec12 vec12;
+  for (int i(0); i &lt; 4; ++i) {
+    vec12.segment(3 * i, 3) = vec34.col(i);
+  }
+  return vec12;
@@ -94 +96 @@
-#endif  // MATHTYPES_H
+#endif  // MATHTYPES_H

Code style divergence in file 'include/common/timeMarker.h':

--- include/common/timeMarker.h
+++ include/common/timeMarker.h.uncrustify
@@ -11,5 +11,6 @@
-//   #include &lt;sys/time.h&gt; 
-inline long long getSystemTime(){
-    struct timeval t;  
-    gettimeofday(&amp;t, NULL);
-    return 1000000 * t.tv_sec + t.tv_usec;  
+//   #include &lt;sys/time.h&gt;
+inline long long getSystemTime()
+{
+  struct timeval t;
+  gettimeofday(&amp;t, NULL);
+  return 1000000 * t.tv_sec + t.tv_usec;
@@ -18,3 +19,4 @@
-inline double getTimeSecond(){
-    double time = getSystemTime() * 0.000001;
-    return time;
+inline double getTimeSecond()
+{
+  double time = getSystemTime() * 0.000001;
+  return time;
@@ -23,8 +25,11 @@
-inline void absoluteWait(long long startTime, long long waitTime){
-    if(getSystemTime() - startTime &gt; waitTime){
-        std::cout &lt;&lt; "[WARNING] The waitTime=" &lt;&lt; waitTime &lt;&lt; " of function absoluteWait is not enough!" &lt;&lt; std::endl
-        &lt;&lt; "The program has already cost " &lt;&lt; getSystemTime() - startTime &lt;&lt; "us." &lt;&lt; std::endl;
-    }
-    while(getSystemTime() - startTime &lt; waitTime){
-        usleep(50);
-    }
+inline void absoluteWait(long long startTime, long long waitTime)
+{
+  if (getSystemTime() - startTime &gt; waitTime) {
+    std::cout &lt;&lt; "[WARNING] The waitTime=" &lt;&lt; waitTime &lt;&lt;
+      " of function absoluteWait is not enough!" &lt;&lt; std::endl
+              &lt;&lt; "The program has already cost " &lt;&lt; getSystemTime() - startTime &lt;&lt; "us." &lt;&lt;
+      std::endl;
+  }
+  while (getSystemTime() - startTime &lt; waitTime) {
+    usleep(50);
+  }
@@ -33 +38 @@
-#endif //TIMEMARKER_H
+#endif //TIMEMARKER_H

Code style divergence in file 'include/common/unitreeLeg.h':

--- include/common/unitreeLeg.h
+++ include/common/unitreeLeg.h.uncrustify
@@ -10 +10 @@
-class QuadrupedLeg{
+class QuadrupedLeg {
@@ -12,12 +12,15 @@
-    QuadrupedLeg(int legID, float abadLinkLength, float hipLinkLength, 
-                 float kneeLinkLength, Vec3 pHip2B);
-    ~QuadrupedLeg(){}
-    Vec3 calcPEe2H(Vec3 q);
-    Vec3 calcPEe2B(Vec3 q);
-    Vec3 calcVEe(Vec3 q, Vec3 qd);
-    Vec3 calcQ(Vec3 pEe, FrameType frame);
-    Vec3 calcQd(Vec3 q, Vec3 vEe);
-    Vec3 calcQd(Vec3 pEe, Vec3 vEe, FrameType frame);
-    Vec3 calcTau(Vec3 q, Vec3 force);
-    Mat3 calcJaco(Vec3 q);
-    Vec3 getHip2B(){return _pHip2B;}
+  QuadrupedLeg(
+    int legID, float abadLinkLength, float hipLinkLength,
+    float kneeLinkLength, Vec3 pHip2B);
+  ~QuadrupedLeg() {
+  }
+  Vec3 calcPEe2H(Vec3 q);
+  Vec3 calcPEe2B(Vec3 q);
+  Vec3 calcVEe(Vec3 q, Vec3 qd);
+  Vec3 calcQ(Vec3 pEe, FrameType frame);
+  Vec3 calcQd(Vec3 q, Vec3 vEe);
+  Vec3 calcQd(Vec3 pEe, Vec3 vEe, FrameType frame);
+  Vec3 calcTau(Vec3 q, Vec3 force);
+  Mat3 calcJaco(Vec3 q);
+  Vec3 getHip2B() {return _pHip2B;}
+
@@ -25,7 +28,8 @@
-    float q1_ik(float py, float pz, float b2y);
-    float q3_ik(float b3z, float b4z, float b);
-    float q2_ik(float q1, float q3, float px, 
-                float py, float pz, float b3z, float b4z);
-    float _sideSign;
-    const float _abadLinkLength, _hipLinkLength, _kneeLinkLength;
-    const Vec3 _pHip2B;
+  float q1_ik(float py, float pz, float b2y);
+  float q3_ik(float b3z, float b4z, float b);
+  float q2_ik(
+    float q1, float q3, float px,
+    float py, float pz, float b3z, float b4z);
+  float _sideSign;
+  const float _abadLinkLength, _hipLinkLength, _kneeLinkLength;
+  const Vec3 _pHip2B;
@@ -34 +38 @@
-class A1Leg : public QuadrupedLeg{
+class A1Leg: public QuadrupedLeg {
@@ -36,3 +40,5 @@
-    A1Leg(const int legID, const Vec3 pHip2B):
-        QuadrupedLeg(legID, 0.0838, 0.2, 0.2, pHip2B){}
-    ~A1Leg(){}
+  A1Leg(const int legID, const Vec3 pHip2B)
+    : QuadrupedLeg(legID, 0.0838, 0.2, 0.2, pHip2B) {
+  }
+  ~A1Leg() {
+  }
@@ -41 +47 @@
-class Go1Leg : public QuadrupedLeg{
+class Go1Leg: public QuadrupedLeg {
@@ -43,3 +49,5 @@
-    Go1Leg(const int legID, const Vec3 pHip2B):
-        QuadrupedLeg(legID, 0.08, 0.213, 0.213, pHip2B){}
-    ~Go1Leg(){}
+  Go1Leg(const int legID, const Vec3 pHip2B)
+    : QuadrupedLeg(legID, 0.08, 0.213, 0.213, pHip2B) {
+  }
+  ~Go1Leg() {
+  }
@@ -48 +56 @@
-#endif  // UNITREELEG_H
+#endif  // UNITREELEG_H

Code style divergence in file 'include/common/unitreeRobot.h':

--- include/common/unitreeRobot.h
+++ include/common/unitreeRobot.h.uncrustify
@@ -10 +10 @@
-class QuadrupedRobot{
+class QuadrupedRobot {
@@ -12,2 +12,4 @@
-    QuadrupedRobot(){};
-    ~QuadrupedRobot(){}
+  QuadrupedRobot() {
+  };
+  ~QuadrupedRobot() {
+  }
@@ -15,2 +17,2 @@
-    Vec3 getX(LowlevelState &amp;state);
-    Vec34 getVecXP(LowlevelState &amp;state);
+  Vec3 getX(LowlevelState &amp; state);
+  Vec34 getVecXP(LowlevelState &amp; state);
@@ -18,4 +20,4 @@
-    // Inverse Kinematics(Body/Hip Frame)
-    Vec12 getQ(const Vec34 &amp;feetPosition, FrameType frame);
-    Vec12 getQd(const Vec34 &amp;feetPosition, const Vec34 &amp;feetVelocity, FrameType frame);
-    Vec12 getTau(const Vec12 &amp;q, const Vec34 feetForce);
+  // Inverse Kinematics(Body/Hip Frame)
+  Vec12 getQ(const Vec34 &amp; feetPosition, FrameType frame);
+  Vec12 getQd(const Vec34 &amp; feetPosition, const Vec34 &amp; feetVelocity, FrameType frame);
+  Vec12 getTau(const Vec12 &amp; q, const Vec34 feetForce);
@@ -23,5 +25,5 @@
-    // Forward Kinematics
-    Vec3 getFootPosition(LowlevelState &amp;state, int id, FrameType frame);
-    Vec3 getFootVelocity(LowlevelState &amp;state, int id);
-    Vec34 getFeet2BPositions(LowlevelState &amp;state, FrameType frame);
-    Vec34 getFeet2BVelocities(LowlevelState &amp;state, FrameType frame);
+  // Forward Kinematics
+  Vec3 getFootPosition(LowlevelState &amp; state, int id, FrameType frame);
+  Vec3 getFootVelocity(LowlevelState &amp; state, int id);
+  Vec34 getFeet2BPositions(LowlevelState &amp; state, FrameType frame);
+  Vec34 getFeet2BVelocities(LowlevelState &amp; state, FrameType frame);
@@ -29,8 +31,8 @@
-    Mat3 getJaco(LowlevelState &amp;state, int legID);
-    Vec2 getRobVelLimitX(){return _robVelLimitX;}
-    Vec2 getRobVelLimitY(){return _robVelLimitY;}
-    Vec2 getRobVelLimitYaw(){return _robVelLimitYaw;}
-    Vec34 getFeetPosIdeal(){return _feetPosNormalStand;}
-    double getRobMass(){return _mass;}
-    Vec3 getPcb(){return _pcb;}
-    Mat3 getRobInertial(){return _Ib;}
+  Mat3 getJaco(LowlevelState &amp; state, int legID);
+  Vec2 getRobVelLimitX() {return _robVelLimitX;}
+  Vec2 getRobVelLimitY() {return _robVelLimitY;}
+  Vec2 getRobVelLimitYaw() {return _robVelLimitYaw;}
+  Vec34 getFeetPosIdeal() {return _feetPosNormalStand;}
+  double getRobMass() {return _mass;}
+  Vec3 getPcb() {return _pcb;}
+  Mat3 getRobInertial() {return _Ib;}
@@ -39,8 +41,8 @@
-    QuadrupedLeg* _Legs[4];
-    Vec2 _robVelLimitX;
-    Vec2 _robVelLimitY;
-    Vec2 _robVelLimitYaw;
-    Vec34 _feetPosNormalStand;
-    double _mass;
-    Vec3 _pcb;
-    Mat3 _Ib;
+  QuadrupedLeg * _Legs[4];
+  Vec2 _robVelLimitX;
+  Vec2 _robVelLimitY;
+  Vec2 _robVelLimitYaw;
+  Vec34 _feetPosNormalStand;
+  double _mass;
+  Vec3 _pcb;
+  Mat3 _Ib;
@@ -49 +51 @@
-class A1Robot : public QuadrupedRobot{
+class A1Robot: public QuadrupedRobot {
@@ -51,2 +53,3 @@
-    A1Robot();
-    ~A1Robot(){}
+  A1Robot();
+  ~A1Robot() {
+  }
@@ -55 +58 @@
-class Go1Robot : public QuadrupedRobot{
+class Go1Robot: public QuadrupedRobot {
@@ -57,2 +60,3 @@
-    Go1Robot();
-    ~Go1Robot(){};
+  Go1Robot();
+  ~Go1Robot() {
+  };
@@ -61 +65 @@
-#endif  // UNITREEROBOT_H
+#endif  // UNITREEROBOT_H

Code style divergence in file 'include/control/BalanceCtrl.h':

--- include/control/BalanceCtrl.h
+++ include/control/BalanceCtrl.h.uncrustify
@@ -15 +15 @@
-class BalanceCtrl{
+class BalanceCtrl {
@@ -17,3 +17,3 @@
-    BalanceCtrl(double mass, Mat3 Ib, Mat6 S, double alpha, double beta);
-    BalanceCtrl(QuadrupedRobot *robModel);
-    Vec34 calF(Vec3 ddPcd, Vec3 dWbd, RotMat rotM, Vec34 feetPos2B, VecInt4 contact);
+  BalanceCtrl(double mass, Mat3 Ib, Mat6 S, double alpha, double beta);
+  BalanceCtrl(QuadrupedRobot * robModel);
+  Vec34 calF(Vec3 ddPcd, Vec3 dWbd, RotMat rotM, Vec34 feetPos2B, VecInt4 contact);
@@ -21 +21 @@
-    void setPyPlot(PyPlot *plot){_testPlot = plot;}
+  void setPyPlot(PyPlot * plot) {_testPlot = plot;}
@@ -22,0 +23 @@
+
@@ -24,4 +25,4 @@
-    void calMatrixA(Vec34 feetPos2B, RotMat rotM, VecInt4 contact);
-    void calVectorBd(Vec3 ddPcd, Vec3 dWbd, RotMat rotM);
-    void calConstraints(VecInt4 contact);
-    void solveQP();
+  void calMatrixA(Vec34 feetPos2B, RotMat rotM, VecInt4 contact);
+  void calVectorBd(Vec3 ddPcd, Vec3 dWbd, RotMat rotM);
+  void calConstraints(VecInt4 contact);
+  void solveQP();
@@ -29,12 +30,12 @@
-    Mat12 _G, _W, _U;
-    Mat6 _S;
-    Mat3 _Ib;
-    Vec6 _bd;
-    Vec3 _g;
-    Vec3 _pcb;
-    Vec12 _F, _Fprev, _g0T;
-    double _mass, _alpha, _beta, _fricRatio;
-    Eigen::MatrixXd _CE, _CI;
-    Eigen::VectorXd _ce0, _ci0;
-    Eigen::Matrix&lt;double, 6 , 12&gt; _A;
-    Eigen::Matrix&lt;double, 5 , 3 &gt; _fricMat;
+  Mat12 _G, _W, _U;
+  Mat6 _S;
+  Mat3 _Ib;
+  Vec6 _bd;
+  Vec3 _g;
+  Vec3 _pcb;
+  Vec12 _F, _Fprev, _g0T;
+  double _mass, _alpha, _beta, _fricRatio;
+  Eigen::MatrixXd _CE, _CI;
+  Eigen::VectorXd _ce0, _ci0;
+  Eigen::Matrix &lt; double, 6, 12 &gt; _A;
+  Eigen::Matrix &lt; double, 5, 3 &gt; _fricMat;
@@ -42,2 +43,2 @@
-    quadprogpp::Matrix&lt;double&gt; G, CE, CI;
-    quadprogpp::Vector&lt;double&gt; g0, ce0, ci0, x;
+  quadprogpp::Matrix &lt; double &gt; G, CE, CI;
+  quadprogpp::Vector &lt; double &gt; g0, ce0, ci0, x;
@@ -46 +47 @@
-    PyPlot *_testPlot;
+  PyPlot * _testPlot;
@@ -50 +51 @@
-#endif  // BALANCECTRL_H
+#endif  // BALANCECTRL_H

Code style divergence in file 'include/control/ControlFrame.h':

--- include/control/ControlFrame.h
+++ include/control/ControlFrame.h.uncrustify
@@ -10 +10 @@
-class ControlFrame{
+class ControlFrame {
@@ -12,5 +12,6 @@
-	ControlFrame(CtrlComponents *ctrlComp);
-	~ControlFrame(){
-		delete _FSMController;
-	}
-	void run();
+  ControlFrame(CtrlComponents * ctrlComp);
+  ~ControlFrame() {
+    delete _FSMController;
+  }
+  void run();
+
@@ -18,2 +19,2 @@
-	FSM* _FSMController;
-	CtrlComponents *_ctrlComp;
+  FSM * _FSMController;
+  CtrlComponents * _ctrlComp;
@@ -22 +23 @@
-#endif  //CONTROLFRAME_H
+#endif  //CONTROLFRAME_H

Code style divergence in file 'include/control/CtrlComponents.h':

--- include/control/CtrlComponents.h
+++ include/control/CtrlComponents.h.uncrustify
@@ -22 +22,2 @@
-struct CtrlComponents{
+struct CtrlComponents
+{
@@ -24,16 +25,16 @@
-    CtrlComponents(IOInterface *ioInter):ioInter(ioInter){
-        lowCmd = new LowlevelCmd();
-        lowState = new LowlevelState();
-        contact = new VecInt4;
-        phase = new Vec4;
-        *contact = VecInt4(0, 0, 0, 0);
-        *phase = Vec4(0.5, 0.5, 0.5, 0.5);
-    }
-    ~CtrlComponents(){
-        delete lowCmd;
-        delete lowState;
-        delete ioInter;
-        delete robotModel;
-        delete waveGen;
-        delete estimator;
-        delete balCtrl;
+  CtrlComponents(IOInterface * ioInter) : ioInter(ioInter) {
+    lowCmd = new LowlevelCmd();
+    lowState = new LowlevelState();
+    contact = new VecInt4;
+    phase = new Vec4;
+    *contact = VecInt4(0, 0, 0, 0);
+    *phase = Vec4(0.5, 0.5, 0.5, 0.5);
+  }
+  ~CtrlComponents() {
+    delete lowCmd;
+    delete lowState;
+    delete ioInter;
+    delete robotModel;
+    delete waveGen;
+    delete estimator;
+    delete balCtrl;
@@ -41 +42 @@
-        delete plot;
+    delete plot;
@@ -43,8 +44,8 @@
-    }
-    LowlevelCmd *lowCmd;
-    LowlevelState *lowState;
-    IOInterface *ioInter;
-    QuadrupedRobot *robotModel;
-    WaveGenerator *waveGen;
-    Estimator *estimator;
-    BalanceCtrl *balCtrl;
+  }
+  LowlevelCmd * lowCmd;
+  LowlevelState * lowState;
+  IOInterface * ioInter;
+  QuadrupedRobot * robotModel;
+  WaveGenerator * waveGen;
+  Estimator * estimator;
+  BalanceCtrl * balCtrl;
@@ -53 +54 @@
-    PyPlot *plot;
+  PyPlot * plot;
@@ -56,2 +57,2 @@
-    VecInt4 *contact;
-    Vec4 *phase;
+  VecInt4 * contact;
+  Vec4 * phase;
@@ -59,3 +60,3 @@
-    double dt;
-    bool *running;
-    CtrlPlatform ctrlPlatform;
+  double dt;
+  bool * running;
+  CtrlPlatform ctrlPlatform;
@@ -63,3 +64,4 @@
-    void sendRecv(){
-        ioInter-&gt;sendRecv(lowCmd, lowState);
-    }
+  void sendRecv()
+  {
+    ioInter-&gt;sendRecv(lowCmd, lowState);
+  }
@@ -67,3 +69,4 @@
-    void runWaveGen(){
-        waveGen-&gt;calcContactPhase(*phase, *contact, _waveStatus);
-    }
+  void runWaveGen()
+  {
+    waveGen-&gt;calcContactPhase(*phase, *contact, _waveStatus);
+  }
@@ -71,3 +74,4 @@
-    void setAllStance(){
-        _waveStatus = WaveStatus::STANCE_ALL;
-    }
+  void setAllStance()
+  {
+    _waveStatus = WaveStatus::STANCE_ALL;
+  }
@@ -75,3 +79,4 @@
-    void setAllSwing(){
-        _waveStatus = WaveStatus::SWING_ALL;
-    }
+  void setAllSwing()
+  {
+    _waveStatus = WaveStatus::SWING_ALL;
+  }
@@ -79,3 +84,4 @@
-    void setStartWave(){
-        _waveStatus = WaveStatus::WAVE_ALL;
-    }
+  void setStartWave()
+  {
+    _waveStatus = WaveStatus::WAVE_ALL;
+  }
@@ -83,3 +89,4 @@
-    void geneObj(){
-        estimator = new Estimator(robotModel, lowState, contact, phase, dt);
-        balCtrl = new BalanceCtrl(robotModel);
+  void geneObj()
+  {
+    estimator = new Estimator(robotModel, lowState, contact, phase, dt);
+    balCtrl = new BalanceCtrl(robotModel);
@@ -88,3 +95,3 @@
-        plot = new PyPlot();
-        balCtrl-&gt;setPyPlot(plot);
-        estimator-&gt;setPyPlot(plot);
+    plot = new PyPlot();
+    balCtrl-&gt;setPyPlot(plot);
+    estimator-&gt;setPyPlot(plot);
@@ -92 +99 @@
-    }
+  }
@@ -95 +102 @@
-    WaveStatus _waveStatus = WaveStatus::SWING_ALL;
+  WaveStatus _waveStatus = WaveStatus::SWING_ALL;
@@ -99 +106 @@
-#endif  // CTRLCOMPONENTS_H
+#endif  // CTRLCOMPONENTS_H

Code style divergence in file 'include/control/Estimator.h':

--- include/control/Estimator.h
+++ include/control/Estimator.h.uncrustify
@@ -37 +37 @@
-class Estimator{
+class Estimator {
@@ -39,10 +39,14 @@
-    Estimator(QuadrupedRobot *robotModel, LowlevelState* lowState, VecInt4 *contact, Vec4 *phase, double dt);
-    Estimator(QuadrupedRobot *robotModel, LowlevelState* lowState, VecInt4 *contact, Vec4 *phase, double dt, Vec18 Qdig, std::string testName);
-    ~Estimator();
-    Vec3  getPosition();
-    Vec3  getVelocity();
-    Vec3  getFootPos(int i);
-    Vec34 getFeetPos();
-    Vec34 getFeetVel();
-    Vec34 getPosFeet2BGlobal();
-    void run();
+  Estimator(
+    QuadrupedRobot * robotModel, LowlevelState * lowState, VecInt4 * contact, Vec4 * phase,
+    double dt);
+  Estimator(
+    QuadrupedRobot * robotModel, LowlevelState * lowState, VecInt4 * contact, Vec4 * phase,
+    double dt, Vec18 Qdig, std::string testName);
+  ~Estimator();
+  Vec3  getPosition();
+  Vec3  getVelocity();
+  Vec3  getFootPos(int i);
+  Vec34 getFeetPos();
+  Vec34 getFeetVel();
+  Vec34 getPosFeet2BGlobal();
+  void run();
@@ -51 +55 @@
-    void setPyPlot(PyPlot *plot){_testPlot = plot;}
+  void setPyPlot(PyPlot * plot) {_testPlot = plot;}
@@ -55,29 +59,29 @@
-    void _initSystem();
-    // Linear System
-    Eigen::Matrix&lt;double, 18, 1&gt;  _xhat;            // The state of estimator, position(3)+velocity(3)+feet position(3x4)
-    Vec3 _u;                                        // The input of estimator
-    Eigen::Matrix&lt;double, 28,  1&gt; _y;               // The measurement value of output y
-    Eigen::Matrix&lt;double, 28,  1&gt; _yhat;            // The prediction of output y
-    Eigen::Matrix&lt;double, 18, 18&gt; _A;               // The transtion matrix of estimator
-    Eigen::Matrix&lt;double, 18, 3&gt;  _B;               // The input matrix
-    Eigen::Matrix&lt;double, 28, 18&gt; _C;               // The output matrix
-    // Covariance Matrix
-    Eigen::Matrix&lt;double, 18, 18&gt; _P;               // Prediction covariance
-    Eigen::Matrix&lt;double, 18, 18&gt; _Ppriori;         // Priori prediction covariance
-    Eigen::Matrix&lt;double, 18, 18&gt; _Q;               // Dynamic simulation covariance
-    Eigen::Matrix&lt;double, 28, 28&gt; _R;               // Measurement covariance
-    Eigen::Matrix&lt;double, 18, 18&gt; _QInit;           // Initial value of Dynamic simulation covariance
-    Eigen::Matrix&lt;double, 28, 28&gt; _RInit;           // Initial value of Measurement covariance
-    Vec18 _Qdig;                                    // adjustable process noise covariance
-    Mat3 _Cu;                                       // The covariance of system input u
-    // Output Measurement
-    Eigen::Matrix&lt;double, 12, 1&gt;  _feetPos2Body;    // The feet positions to body, in the global coordinate
-    Eigen::Matrix&lt;double, 12, 1&gt;  _feetVel2Body;    // The feet velocity to body, in the global coordinate
-    Eigen::Matrix&lt;double,  4, 1&gt;  _feetH;           // The Height of each foot, in the global coordinate
-    Eigen::Matrix&lt;double, 28, 28&gt; _S;               // _S = C*P*C.T + R
-    Eigen::PartialPivLU&lt;Eigen::Matrix&lt;double, 28, 28&gt;&gt; _Slu;    // _S.lu()
-    Eigen::Matrix&lt;double, 28,  1&gt; _Sy;              // _Sy = _S.inv() * (y - yhat)
-    Eigen::Matrix&lt;double, 28, 18&gt; _Sc;              // _Sc = _S.inv() * C
-    Eigen::Matrix&lt;double, 28, 28&gt; _SR;              // _SR = _S.inv() * R
-    Eigen::Matrix&lt;double, 28, 18&gt; _STC;             // _STC = (_S.transpose()).inv() * C
-    Eigen::Matrix&lt;double, 18, 18&gt; _IKC;             // _IKC = I - KC
+  void _initSystem();
+  // Linear System
+  Eigen::Matrix &lt; double, 18, 1 &gt; _xhat;            // The state of estimator, position(3)+velocity(3)+feet position(3x4)
+  Vec3 _u;                                          // The input of estimator
+  Eigen::Matrix &lt; double, 28, 1 &gt; _y;               // The measurement value of output y
+  Eigen::Matrix &lt; double, 28, 1 &gt; _yhat;            // The prediction of output y
+  Eigen::Matrix &lt; double, 18, 18 &gt; _A;              // The transtion matrix of estimator
+  Eigen::Matrix &lt; double, 18, 3 &gt; _B;               // The input matrix
+  Eigen::Matrix &lt; double, 28, 18 &gt; _C;              // The output matrix
+  // Covariance Matrix
+  Eigen::Matrix &lt; double, 18, 18 &gt; _P;              // Prediction covariance
+  Eigen::Matrix &lt; double, 18, 18 &gt; _Ppriori;        // Priori prediction covariance
+  Eigen::Matrix &lt; double, 18, 18 &gt; _Q;              // Dynamic simulation covariance
+  Eigen::Matrix &lt; double, 28, 28 &gt; _R;              // Measurement covariance
+  Eigen::Matrix &lt; double, 18, 18 &gt; _QInit;          // Initial value of Dynamic simulation covariance
+  Eigen::Matrix &lt; double, 28, 28 &gt; _RInit;          // Initial value of Measurement covariance
+  Vec18 _Qdig;                                      // adjustable process noise covariance
+  Mat3 _Cu;                                         // The covariance of system input u
+  // Output Measurement
+  Eigen::Matrix &lt; double, 12, 1 &gt; _feetPos2Body;    // The feet positions to body, in the global coordinate
+  Eigen::Matrix &lt; double, 12, 1 &gt; _feetVel2Body;    // The feet velocity to body, in the global coordinate
+  Eigen::Matrix &lt; double, 4, 1 &gt; _feetH;            // The Height of each foot, in the global coordinate
+  Eigen::Matrix &lt; double, 28, 28 &gt; _S;              // _S = C*P*C.T + R
+  Eigen::PartialPivLU &lt; Eigen::Matrix &lt; double, 28, 28 &gt;&gt; _Slu; // _S.lu()
+  Eigen::Matrix &lt; double, 28, 1 &gt; _Sy;              // _Sy = _S.inv() * (y - yhat)
+  Eigen::Matrix &lt; double, 28, 18 &gt; _Sc;             // _Sc = _S.inv() * C
+  Eigen::Matrix &lt; double, 28, 28 &gt; _SR;             // _SR = _S.inv() * R
+  Eigen::Matrix &lt; double, 28, 18 &gt; _STC;            // _STC = (_S.transpose()).inv() * C
+  Eigen::Matrix &lt; double, 18, 18 &gt; _IKC;            // _IKC = I - KC
@@ -85,3 +89,3 @@
-    RotMat _rotMatB2G;                              // Rotate Matrix: from body to global
-    Vec3 _g;
-    Vec34 _feetPosGlobalKine, _feetVelGlobalKine;
+  RotMat _rotMatB2G;                                // Rotate Matrix: from body to global
+  Vec3 _g;
+  Vec34 _feetPosGlobalKine, _feetVelGlobalKine;
@@ -89,7 +93,7 @@
-    LowlevelState* _lowState;
-    QuadrupedRobot *_robModel;
-    Vec4 *_phase;
-    VecInt4 *_contact;
-    double _dt;
-    double _trust;
-    double _largeVariance;
+  LowlevelState * _lowState;
+  QuadrupedRobot * _robModel;
+  Vec4 * _phase;
+  VecInt4 * _contact;
+  double _dt;
+  double _trust;
+  double _largeVariance;
@@ -97,2 +101,2 @@
-    // Low pass filters
-    LPFilter *_vxFilter, *_vyFilter, *_vzFilter;
+  // Low pass filters
+  LPFilter * _vxFilter, * _vyFilter, * _vzFilter;
@@ -100,4 +104,4 @@
-    // Tuning
-    AvgCov *_RCheck;
-    AvgCov *_uCheck;
-    std::string _estName;
+  // Tuning
+  AvgCov * _RCheck;
+  AvgCov * _uCheck;
+  std::string _estName;
@@ -106 +110 @@
-    PyPlot *_testPlot;
+  PyPlot * _testPlot;
@@ -109,8 +113,8 @@
-    ros::NodeHandle _nh;
-    ros::Publisher _pub;
-    tf::TransformBroadcaster _odomBroadcaster;
-    ros::Time _currentTime;
-    geometry_msgs::TransformStamped _odomTF;
-    nav_msgs::Odometry _odomMsg;
-    int _count = 0;
-    double _pubFreq = 10;
+  ros::NodeHandle _nh;
+  ros::Publisher _pub;
+  tf::TransformBroadcaster _odomBroadcaster;
+  ros::Time _currentTime;
+  geometry_msgs::TransformStamped _odomTF;
+  nav_msgs::Odometry _odomMsg;
+  int _count = 0;
+  double _pubFreq = 10;
@@ -118,13 +122,13 @@
-    Vec3 _velBody, _wBody;
-    boost::array&lt;double, 36&gt; _odom_pose_covariance = {1e-9, 0, 0, 0, 0, 0, 
-                                        0, 1e-3, 1e-9, 0, 0, 0, 
-                                        0, 0, 1e6, 0, 0, 0,
-                                        0, 0, 0, 1e6, 0, 0, 
-                                        0, 0, 0, 0, 1e6, 0, 
-                                        0, 0, 0, 0, 0, 1e-9};
-    boost::array&lt;double, 36&gt; _odom_twist_covariance = {1e-9, 0, 0, 0, 0, 0, 
-                                        0, 1e-3, 1e-9, 0, 0, 0, 
-                                        0, 0, 1e6, 0, 0, 0, 
-                                        0, 0, 0, 1e6, 0, 0, 
-                                        0, 0, 0, 0, 1e6, 0, 
-                                        0, 0, 0, 0, 0, 1e-9};
+  Vec3 _velBody, _wBody;
+  boost::array &lt; double, 36 &gt; _odom_pose_covariance = {1e-9, 0, 0, 0, 0, 0,
+    0, 1e-3, 1e-9, 0, 0, 0,
+    0, 0, 1e6, 0, 0, 0,
+    0, 0, 0, 1e6, 0, 0,
+    0, 0, 0, 0, 1e6, 0,
+    0, 0, 0, 0, 0, 1e-9};
+  boost::array &lt; double, 36 &gt; _odom_twist_covariance = {1e-9, 0, 0, 0, 0, 0,
+    0, 1e-3, 1e-9, 0, 0, 0,
+    0, 0, 1e6, 0, 0, 0,
+    0, 0, 0, 1e6, 0, 0,
+    0, 0, 0, 0, 1e6, 0,
+    0, 0, 0, 0, 0, 1e-9};
@@ -134,6 +138,6 @@
-    rclcpp::Node::SharedPtr _nh;
-    rclcpp::Publisher&lt;nav_msgs::msg::Odometry&gt;::SharedPtr _pub;
-    std::shared_ptr&lt;tf2_ros::TransformBroadcaster&gt; _odomBroadcaster;
-    rclcpp::Time _currentTime;
-    geometry_msgs::msg::TransformStamped _odomTF;
-    nav_msgs::msg::Odometry _odomMsg;
+  rclcpp::Node::SharedPtr _nh;
+  rclcpp::Publisher &lt; nav_msgs::msg::Odometry &gt; ::SharedPtr _pub;
+  std::shared_ptr &lt; tf2_ros::TransformBroadcaster &gt; _odomBroadcaster;
+  rclcpp::Time _currentTime;
+  geometry_msgs::msg::TransformStamped _odomTF;
+  nav_msgs::msg::Odometry _odomMsg;
@@ -141,2 +145,2 @@
-    int _count = 0;
-    double _pubFreq = 10;
+  int _count = 0;
+  double _pubFreq = 10;
@@ -144,13 +148,13 @@
-    Vec3 _velBody, _wBody;
-    std::array&lt;double, 36&gt; _odom_pose_covariance = {1e-9, 0, 0, 0, 0, 0, 
-                                        0, 1e-3, 1e-9, 0, 0, 0, 
-                                        0, 0, 1e6, 0, 0, 0,
-                                        0, 0, 0, 1e6, 0, 0, 
-                                        0, 0, 0, 0, 1e6, 0, 
-                                        0, 0, 0, 0, 0, 1e-9};
-    std::array&lt;double, 36&gt; _odom_twist_covariance = {1e-9, 0, 0, 0, 0, 0, 
-                                        0, 1e-3, 1e-9, 0, 0, 0, 
-                                        0, 0, 1e6, 0, 0, 0, 
-                                        0, 0, 0, 1e6, 0, 0, 
-                                        0, 0, 0, 0, 1e6, 0, 
-                                        0, 0, 0, 0, 0, 1e-9};
+  Vec3 _velBody, _wBody;
+  std::array &lt; double, 36 &gt; _odom_pose_covariance = {1e-9, 0, 0, 0, 0, 0,
+    0, 1e-3, 1e-9, 0, 0, 0,
+    0, 0, 1e6, 0, 0, 0,
+    0, 0, 0, 1e6, 0, 0,
+    0, 0, 0, 0, 1e6, 0,
+    0, 0, 0, 0, 0, 1e-9};
+  std::array &lt; double, 36 &gt; _odom_twist_covariance = {1e-9, 0, 0, 0, 0, 0,
+    0, 1e-3, 1e-9, 0, 0, 0,
+    0, 0, 1e6, 0, 0, 0,
+    0, 0, 0, 1e6, 0, 0,
+    0, 0, 0, 0, 1e6, 0,
+    0, 0, 0, 0, 0, 1e-9};
@@ -161 +165 @@
-#endif  // ESTIMATOR_H
+#endif  // ESTIMATOR_H

Code style divergence in file 'include/interface/CmdPanel.h':

--- include/interface/CmdPanel.h
+++ include/interface/CmdPanel.h.uncrustify
@@ -20,16 +20,18 @@
-struct UserValue{
-    float lx;
-    float ly;
-    float rx;
-    float ry;
-    float L2;
-    UserValue(){
-        setZero();
-    }
-    void setZero(){
-        lx = 0;
-        ly = 0;
-        rx = 0;
-        ry = 0;
-        L2 = 0;
-    }
+struct UserValue
+{
+  float lx;
+  float ly;
+  float rx;
+  float ry;
+  float L2;
+  UserValue() {
+    setZero();
+  }
+  void setZero()
+  {
+    lx = 0;
+    ly = 0;
+    rx = 0;
+    ry = 0;
+    L2 = 0;
+  }
@@ -38 +40 @@
-class CmdPanel{
+class CmdPanel {
@@ -40,6 +42,8 @@
-    CmdPanel(){}
-    virtual ~CmdPanel(){}
-    UserCommand getUserCmd(){return userCmd;}
-    UserValue getUserValue(){return userValue;}
-    void setPassive(){userCmd = UserCommand::L2_B;}
-    void setZero(){userValue.setZero();}
+  CmdPanel() {
+  }
+  virtual ~CmdPanel() {
+  }
+  UserCommand getUserCmd() {return userCmd;}
+  UserValue getUserValue() {return userValue;}
+  void setPassive() {userCmd = UserCommand::L2_B;}
+  void setZero() {userValue.setZero();}
@@ -47 +51 @@
-    virtual void receiveHandle(UNITREE_LEGGED_SDK::LowState *lowState){};
+  virtual void receiveHandle(UNITREE_LEGGED_SDK::LowState * lowState) {}
@@ -48,0 +53 @@
+
@@ -50,3 +55,3 @@
-    virtual void* run(void *arg){return NULL;}
-    UserCommand userCmd;
-    UserValue userValue;
+  virtual void * run(void * arg) {return NULL;}
+  UserCommand userCmd;
+  UserValue userValue;
@@ -55 +60 @@
-#endif  // CMDPANEL_H
+#endif  // CMDPANEL_H

Code style divergence in file 'include/interface/IOInterface.h':

--- include/interface/IOInterface.h
+++ include/interface/IOInterface.h.uncrustify
@@ -12 +12 @@
-class IOInterface{
+class IOInterface {
@@ -14,5 +14,8 @@
-IOInterface(){}
-~IOInterface(){delete cmdPanel;}
-virtual void sendRecv(const LowlevelCmd *cmd, LowlevelState *state) = 0;
-void zeroCmdPanel(){cmdPanel-&gt;setZero();}
-void setPassive(){cmdPanel-&gt;setPassive();}
+  IOInterface() {
+  }
+  ~IOInterface() {
+    delete cmdPanel;
+  }
+  virtual void sendRecv(const LowlevelCmd * cmd, LowlevelState * state) = 0;
+  void zeroCmdPanel() {cmdPanel-&gt;setZero();}
+  void setPassive() {cmdPanel-&gt;setPassive();}
@@ -21 +24 @@
-CmdPanel *cmdPanel;
+  CmdPanel * cmdPanel;
@@ -24 +27 @@
-#endif  //IOINTERFACE_H
+#endif  //IOINTERFACE_H

Code style divergence in file 'include/interface/IOROS.h':

--- include/interface/IOROS.h
+++ include/interface/IOROS.h.uncrustify
@@ -18 +18 @@
-class IOROS : public IOInterface{
+class IOROS: public IOInterface {
@@ -20,3 +20,3 @@
-IOROS();
-~IOROS();
-void sendRecv(const LowlevelCmd *cmd, LowlevelState *state);
+  IOROS();
+  ~IOROS();
+  void sendRecv(const LowlevelCmd * cmd, LowlevelState * state);
@@ -25,8 +25,8 @@
-void sendCmd(const LowlevelCmd *cmd);
-void recvState(LowlevelState *state);
-ros::NodeHandle _nm;
-ros::Subscriber _servo_sub[12], _imu_sub;
-ros::Publisher _servo_pub[12];
-unitree_legged_msgs::LowCmd _lowCmd;
-unitree_legged_msgs::LowState _lowState;
-std::string _robot_name;
+  void sendCmd(const LowlevelCmd * cmd);
+  void recvState(LowlevelState * state);
+  ros::NodeHandle _nm;
+  ros::Subscriber _servo_sub[12], _imu_sub;
+  ros::Publisher _servo_pub[12];
+  unitree_legged_msgs::LowCmd _lowCmd;
+  unitree_legged_msgs::LowState _lowState;
+  std::string _robot_name;
@@ -35,2 +35,2 @@
-void initRecv();
-void initSend();
+  void initRecv();
+  void initSend();
@@ -39 +39 @@
-void imuCallback(const sensor_msgs::Imu &amp; msg);
+  void imuCallback(const sensor_msgs::Imu &amp; msg);
@@ -41,3 +41,3 @@
-void FRhipCallback(const unitree_legged_msgs::MotorState&amp; msg);
-void FRthighCallback(const unitree_legged_msgs::MotorState&amp; msg);
-void FRcalfCallback(const unitree_legged_msgs::MotorState&amp; msg);
+  void FRhipCallback(const unitree_legged_msgs::MotorState &amp; msg);
+  void FRthighCallback(const unitree_legged_msgs::MotorState &amp; msg);
+  void FRcalfCallback(const unitree_legged_msgs::MotorState &amp; msg);
@@ -45,3 +45,3 @@
-void FLhipCallback(const unitree_legged_msgs::MotorState&amp; msg);
-void FLthighCallback(const unitree_legged_msgs::MotorState&amp; msg);
-void FLcalfCallback(const unitree_legged_msgs::MotorState&amp; msg);
+  void FLhipCallback(const unitree_legged_msgs::MotorState &amp; msg);
+  void FLthighCallback(const unitree_legged_msgs::MotorState &amp; msg);
+  void FLcalfCallback(const unitree_legged_msgs::MotorState &amp; msg);
@@ -49,3 +49,3 @@
-void RRhipCallback(const unitree_legged_msgs::MotorState&amp; msg);
-void RRthighCallback(const unitree_legged_msgs::MotorState&amp; msg);
-void RRcalfCallback(const unitree_legged_msgs::MotorState&amp; msg);
+  void RRhipCallback(const unitree_legged_msgs::MotorState &amp; msg);
+  void RRthighCallback(const unitree_legged_msgs::MotorState &amp; msg);
+  void RRcalfCallback(const unitree_legged_msgs::MotorState &amp; msg);
@@ -53,3 +53,3 @@
-void RLhipCallback(const unitree_legged_msgs::MotorState&amp; msg);
-void RLthighCallback(const unitree_legged_msgs::MotorState&amp; msg);
-void RLcalfCallback(const unitree_legged_msgs::MotorState&amp; msg);
+  void RLhipCallback(const unitree_legged_msgs::MotorState &amp; msg);
+  void RLthighCallback(const unitree_legged_msgs::MotorState &amp; msg);
+  void RLcalfCallback(const unitree_legged_msgs::MotorState &amp; msg);
@@ -79 +79 @@
-class IOROS : public IOInterface{
+class IOROS: public IOInterface {
@@ -81,3 +81,3 @@
-IOROS(rclcpp::Node::SharedPtr node_ptr);
-~IOROS();
-void sendRecv(const LowlevelCmd *cmd, LowlevelState *state);
+  IOROS(rclcpp::Node::SharedPtr node_ptr);
+  ~IOROS();
+  void sendRecv(const LowlevelCmd * cmd, LowlevelState * state);
@@ -86,14 +86,16 @@
-static void RosShutDown(int sig);
-void sendCmd(const LowlevelCmd *cmd);
-void recvState(LowlevelState *state);
-rclcpp::Node::SharedPtr _nm;
-rclcpp::Subscription&lt;sensor_msgs::msg::Imu&gt;::SharedPtr _imu_sub;
-rclcpp::Subscription&lt;sensor_msgs::msg::JointState&gt;::SharedPtr _joint_state_sub;
-std::vector&lt;rclcpp::Subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;::SharedPtr&gt; _servo_sub;
-std::vector&lt;rclcpp::Publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;::SharedPtr&gt; _servo_pub;
-rclcpp::Publisher&lt;std_msgs::msg::Float64MultiArray&gt;::SharedPtr _joint_cmd_pub;
-ros2_unitree_legged_msgs::msg::LowCmd _lowCmd;
-ros2_unitree_legged_msgs::msg::LowState _lowState;
-std::string _robot_name;
-std::unordered_map&lt;std::string, int&gt; joint_index_map;
-std::thread executor_thread;
+  static void RosShutDown(int sig);
+  void sendCmd(const LowlevelCmd * cmd);
+  void recvState(LowlevelState * state);
+  rclcpp::Node::SharedPtr _nm;
+  rclcpp::Subscription &lt; sensor_msgs::msg::Imu &gt; ::SharedPtr _imu_sub;
+  rclcpp::Subscription &lt; sensor_msgs::msg::JointState &gt; ::SharedPtr _joint_state_sub;
+  std::vector &lt; rclcpp::Subscription &lt; ros2_unitree_legged_msgs::msg::MotorState &gt; ::SharedPtr &gt;
+  _servo_sub;
+  std::vector &lt; rclcpp::Publisher &lt; ros2_unitree_legged_msgs::msg::MotorCmd &gt; ::SharedPtr &gt;
+  _servo_pub;
+  rclcpp::Publisher &lt; std_msgs::msg::Float64MultiArray &gt; ::SharedPtr _joint_cmd_pub;
+  ros2_unitree_legged_msgs::msg::LowCmd _lowCmd;
+  ros2_unitree_legged_msgs::msg::LowState _lowState;
+  std::string _robot_name;
+  std::unordered_map &lt; std::string, int &gt; joint_index_map;
+  std::thread executor_thread;
@@ -101,2 +103,2 @@
-sensor_msgs::msg::JointState _joint_state;
-std_msgs::msg::Float64MultiArray _joint_cmd;
+  sensor_msgs::msg::JointState _joint_state;
+  std_msgs::msg::Float64MultiArray _joint_cmd;
@@ -105,2 +107,2 @@
-void initRecv();
-void initSend();
+  void initRecv();
+  void initSend();
@@ -109 +111 @@
-void imuCallback(const sensor_msgs::msg::Imu::SharedPtr msg);
+  void imuCallback(const sensor_msgs::msg::Imu::SharedPtr msg);
@@ -112,3 +114,3 @@
-void FRhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
-void FRthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
-void FRcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
+  void FRhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
+  void FRthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
+  void FRcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
@@ -116,3 +118,3 @@
-void FLhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
-void FLthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
-void FLcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
+  void FLhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
+  void FLthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
+  void FLcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
@@ -120,3 +122,3 @@
-void RRhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
-void RRthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
-void RRcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
+  void RRhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
+  void RRthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
+  void RRcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
@@ -124,3 +126,3 @@
-void RLhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
-void RLthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
-void RLcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
+  void RLhipCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
+  void RLthighCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
+  void RLcalfCallback(const ros2_unitree_legged_msgs::msg::MotorState::SharedPtr msg);
@@ -129,2 +131,2 @@
-void initializeJointIndexMap();
-void jointStateCallback(const sensor_msgs::msg::JointState::SharedPtr msg);
+  void initializeJointIndexMap();
+  void jointStateCallback(const sensor_msgs::msg::JointState::SharedPtr msg);
@@ -136 +138 @@
-#endif  // COMPILE_WITH_ROS2_MB
+#endif  // COMPILE_WITH_ROS2_MB

Code style divergence in file 'include/interface/IOSDK.h':

--- include/interface/IOSDK.h
+++ include/interface/IOSDK.h.uncrustify
@@ -22 +22 @@
-class IOSDK : public IOInterface{
+class IOSDK: public IOInterface {
@@ -24,3 +24,4 @@
-IOSDK();
-~IOSDK(){}
-void sendRecv(const LowlevelCmd *cmd, LowlevelState *state);
+  IOSDK();
+  ~IOSDK() {
+  }
+  void sendRecv(const LowlevelCmd * cmd, LowlevelState * state);
@@ -29,4 +30,4 @@
-UNITREE_LEGGED_SDK::UDP _udp;
-UNITREE_LEGGED_SDK::Safety _safe;
-UNITREE_LEGGED_SDK::LowCmd _lowCmd;
-UNITREE_LEGGED_SDK::LowState _lowState;
+  UNITREE_LEGGED_SDK::UDP _udp;
+  UNITREE_LEGGED_SDK::Safety _safe;
+  UNITREE_LEGGED_SDK::LowCmd _lowCmd;
+  UNITREE_LEGGED_SDK::LowState _lowState;
@@ -35,3 +36,3 @@
-    ros::NodeHandle _nh;
-    ros::Publisher _pub;
-    sensor_msgs::JointState _joint_state;
+  ros::NodeHandle _nh;
+  ros::Publisher _pub;
+  sensor_msgs::JointState _joint_state;
@@ -41,3 +42,3 @@
-    rclcpp::Node::SharedPtr _nh;
-    rclcpp::Publisher&lt;sensor_msgs::msg::JointState&gt;::SharedPtr _pub;
-    sensor_msgs::msg::JointState _joint_state;
+  rclcpp::Node::SharedPtr _nh;
+  rclcpp::Publisher &lt; sensor_msgs::msg::JointState &gt; ::SharedPtr _pub;
+  sensor_msgs::msg::JointState _joint_state;
@@ -48 +49 @@
-#endif  // IOSDK_H
+#endif  // IOSDK_H

Code style divergence in file 'include/interface/KeyBoard.h':

--- include/interface/KeyBoard.h
+++ include/interface/KeyBoard.h.uncrustify
@@ -17 +17 @@
-class KeyBoard : public CmdPanel{
+class KeyBoard: public CmdPanel {
@@ -19,2 +19,3 @@
-    KeyBoard();
-    ~KeyBoard();
+  KeyBoard();
+  ~KeyBoard();
+
@@ -22,4 +23,4 @@
-    static void* runKeyBoard(void *arg);
-    void* run(void *arg);
-    UserCommand checkCmd();
-    void changeValue();
+  static void * runKeyBoard(void * arg);
+  void * run(void * arg);
+  UserCommand checkCmd();
+  void changeValue();
@@ -27,8 +28,8 @@
-    pthread_t _tid;
-    float sensitivityLeft = 0.05;
-    float sensitivityRight = 0.05;
-    struct termios _oldSettings, _newSettings;
-    fd_set set;
-    int res;
-    int ret;
-    char _c;
+  pthread_t _tid;
+  float sensitivityLeft = 0.05;
+  float sensitivityRight = 0.05;
+  struct termios _oldSettings, _newSettings;
+  fd_set set;
+  int res;
+  int ret;
+  char _c;
@@ -37 +38 @@
-#endif  // KEYBOARD_H
+#endif  // KEYBOARD_H

Code style divergence in file 'include/interface/WirelessHandle.h':

--- include/interface/WirelessHandle.h
+++ include/interface/WirelessHandle.h.uncrustify
@@ -11 +11 @@
-class WirelessHandle : public CmdPanel{
+class WirelessHandle: public CmdPanel {
@@ -13,3 +13,5 @@
-    WirelessHandle();
-    ~WirelessHandle(){}
-    void receiveHandle(UNITREE_LEGGED_SDK::LowState *lowState);
+  WirelessHandle();
+  ~WirelessHandle() {
+  }
+  void receiveHandle(UNITREE_LEGGED_SDK::LowState * lowState);
+
@@ -17 +19 @@
-    xRockerBtnDataStruct _keyData;
+  xRockerBtnDataStruct _keyData;
@@ -20 +22 @@
-#endif  // WIRELESSHANDLE_H
+#endif  // WIRELESSHANDLE_H

Code style divergence in file 'include/message/LowlevelCmd.h':

--- include/message/LowlevelCmd.h
+++ include/message/LowlevelCmd.h.uncrustify
@@ -10,7 +10,8 @@
-struct MotorCmd{
-    unsigned int mode;
-    float q;
-    float dq;
-    float tau;
-    float Kp;
-    float Kd;
+struct MotorCmd
+{
+  unsigned int mode;
+  float q;
+  float dq;
+  float tau;
+  float Kp;
+  float Kd;
@@ -18,8 +19,8 @@
-    MotorCmd(){
-        mode = 0;
-        q = 0;
-        dq = 0;
-        tau = 0;
-        Kp = 0;
-        Kd = 0;
-    }
+  MotorCmd() {
+    mode = 0;
+    q = 0;
+    dq = 0;
+    tau = 0;
+    Kp = 0;
+    Kd = 0;
+  }
@@ -28,2 +29,3 @@
-struct LowlevelCmd{
-    MotorCmd motorCmd[12];
+struct LowlevelCmd
+{
+  MotorCmd motorCmd[12];
@@ -31,4 +33,4 @@
-    void setQ(Vec12 q){
-        for(int i(0); i&lt;12; ++i){
-            motorCmd[i].q = q(i);
-        }
+  void setQ(Vec12 q)
+  {
+    for (int i(0); i &lt; 12; ++i) {
+      motorCmd[i].q = q(i);
@@ -36,4 +38,11 @@
-    void setQ(int legID, Vec3 qi){
-        motorCmd[legID*3+0].q = qi(0);
-        motorCmd[legID*3+1].q = qi(1);
-        motorCmd[legID*3+2].q = qi(2);
+  }
+  void setQ(int legID, Vec3 qi)
+  {
+    motorCmd[legID * 3 + 0].q = qi(0);
+    motorCmd[legID * 3 + 1].q = qi(1);
+    motorCmd[legID * 3 + 2].q = qi(2);
+  }
+  void setQd(Vec12 qd)
+  {
+    for (int i(0); i &lt; 12; ++i) {
+      motorCmd[i].dq = qd(i);
@@ -41,4 +50,14 @@
-    void setQd(Vec12 qd){
-        for(int i(0); i&lt;12; ++i){
-            motorCmd[i].dq = qd(i);
-        }
+  }
+  void setQd(int legID, Vec3 qdi)
+  {
+    motorCmd[legID * 3 + 0].dq = qdi(0);
+    motorCmd[legID * 3 + 1].dq = qdi(1);
+    motorCmd[legID * 3 + 2].dq = qdi(2);
+  }
+  void setTau(Vec12 tau, Vec2 torqueLimit = Vec2(-50, 50))
+  {
+    for (int i(0); i &lt; 12; ++i) {
+      if (std::isnan(tau(i))) {
+        printf("[ERROR] The setTau function meets Nan\n");
+      }
+      motorCmd[i].tau = saturation(tau(i), torqueLimit);
@@ -46,4 +65,11 @@
-    void setQd(int legID, Vec3 qdi){
-        motorCmd[legID*3+0].dq = qdi(0);
-        motorCmd[legID*3+1].dq = qdi(1);
-        motorCmd[legID*3+2].dq = qdi(2);
+  }
+  void setZeroDq(int legID)
+  {
+    motorCmd[legID * 3 + 0].dq = 0;
+    motorCmd[legID * 3 + 1].dq = 0;
+    motorCmd[legID * 3 + 2].dq = 0;
+  }
+  void setZeroDq()
+  {
+    for (int i(0); i &lt; 4; ++i) {
+      setZeroDq(i);
@@ -51,7 +77,47 @@
-    void setTau(Vec12 tau, Vec2 torqueLimit = Vec2(-50, 50)){
-        for(int i(0); i&lt;12; ++i){
-            if(std::isnan(tau(i))){
-                printf("[ERROR] The setTau function meets Nan\n");
-            }
-            motorCmd[i].tau = saturation(tau(i), torqueLimit);
-        }
+  }
+  void setZeroTau(int legID)
+  {
+    motorCmd[legID * 3 + 0].tau = 0;
+    motorCmd[legID * 3 + 1].tau = 0;
+    motorCmd[legID * 3 + 2].tau = 0;
+  }
+  void setSimStanceGain(int legID)
+  {
+    motorCmd[legID * 3 + 0].mode = 10;
+    motorCmd[legID * 3 + 0].Kp = 180;
+    motorCmd[legID * 3 + 0].Kd = 8;
+    motorCmd[legID * 3 + 1].mode = 10;
+    motorCmd[legID * 3 + 1].Kp = 180;
+    motorCmd[legID * 3 + 1].Kd = 8;
+    motorCmd[legID * 3 + 2].mode = 10;
+    motorCmd[legID * 3 + 2].Kp = 300;
+    motorCmd[legID * 3 + 2].Kd = 15;
+  }
+  void setRealStanceGain(int legID)
+  {
+    motorCmd[legID * 3 + 0].mode = 10;
+    motorCmd[legID * 3 + 0].Kp = 60;
+    motorCmd[legID * 3 + 0].Kd = 5;
+    motorCmd[legID * 3 + 1].mode = 10;
+    motorCmd[legID * 3 + 1].Kp = 40;
+    motorCmd[legID * 3 + 1].Kd = 4;
+    motorCmd[legID * 3 + 2].mode = 10;
+    motorCmd[legID * 3 + 2].Kp = 80;
+    motorCmd[legID * 3 + 2].Kd = 7;
+  }
+  void setZeroGain(int legID)
+  {
+    motorCmd[legID * 3 + 0].mode = 10;
+    motorCmd[legID * 3 + 0].Kp = 0;
+    motorCmd[legID * 3 + 0].Kd = 0;
+    motorCmd[legID * 3 + 1].mode = 10;
+    motorCmd[legID * 3 + 1].Kp = 0;
+    motorCmd[legID * 3 + 1].Kd = 0;
+    motorCmd[legID * 3 + 2].mode = 10;
+    motorCmd[legID * 3 + 2].Kp = 0;
+    motorCmd[legID * 3 + 2].Kd = 0;
+  }
+  void setZeroGain()
+  {
+    for (int i(0); i &lt; 4; ++i) {
+      setZeroGain(i);
@@ -59,4 +125,17 @@
-    void setZeroDq(int legID){
-        motorCmd[legID*3+0].dq = 0;
-        motorCmd[legID*3+1].dq = 0;
-        motorCmd[legID*3+2].dq = 0;
+  }
+  void setStableGain(int legID)
+  {
+    motorCmd[legID * 3 + 0].mode = 10;
+    motorCmd[legID * 3 + 0].Kp = 0.8;
+    motorCmd[legID * 3 + 0].Kd = 0.8;
+    motorCmd[legID * 3 + 1].mode = 10;
+    motorCmd[legID * 3 + 1].Kp = 0.8;
+    motorCmd[legID * 3 + 1].Kd = 0.8;
+    motorCmd[legID * 3 + 2].mode = 10;
+    motorCmd[legID * 3 + 2].Kp = 0.8;
+    motorCmd[legID * 3 + 2].Kd = 0.8;
+  }
+  void setStableGain()
+  {
+    for (int i(0); i &lt; 4; ++i) {
+      setStableGain(i);
@@ -64,75 +143,13 @@
-    void setZeroDq(){
-        for(int i(0); i&lt;4; ++i){
-            setZeroDq(i);
-        }
-    }
-    void setZeroTau(int legID){
-        motorCmd[legID*3+0].tau = 0;
-        motorCmd[legID*3+1].tau = 0;
-        motorCmd[legID*3+2].tau = 0;
-    }
-    void setSimStanceGain(int legID){
-        motorCmd[legID*3+0].mode = 10;
-        motorCmd[legID*3+0].Kp = 180;
-        motorCmd[legID*3+0].Kd = 8;
-        motorCmd[legID*3+1].mode = 10;
-        motorCmd[legID*3+1].Kp = 180;
-        motorCmd[legID*3+1].Kd = 8;
-        motorCmd[legID*3+2].mode = 10;
-        motorCmd[legID*3+2].Kp = 300;
-        motorCmd[legID*3+2].Kd = 15;
-    }
-    void setRealStanceGain(int legID){
-        motorCmd[legID*3+0].mode = 10;
-        motorCmd[legID*3+0].Kp = 60;
-        motorCmd[legID*3+0].Kd = 5;
-        motorCmd[legID*3+1].mode = 10;
-        motorCmd[legID*3+1].Kp = 40;
-        motorCmd[legID*3+1].Kd = 4;
-        motorCmd[legID*3+2].mode = 10;
-        motorCmd[legID*3+2].Kp = 80;
-        motorCmd[legID*3+2].Kd = 7;
-    }
-    void setZeroGain(int legID){
-        motorCmd[legID*3+0].mode = 10;
-        motorCmd[legID*3+0].Kp = 0;
-        motorCmd[legID*3+0].Kd = 0;
-        motorCmd[legID*3+1].mode = 10;
-        motorCmd[legID*3+1].Kp = 0;
-        motorCmd[legID*3+1].Kd = 0;
-        motorCmd[legID*3+2].mode = 10;
-        motorCmd[legID*3+2].Kp = 0;
-        motorCmd[legID*3+2].Kd = 0;
-    }
-    void setZeroGain(){
-        for(int i(0); i&lt;4; ++i){
-            setZeroGain(i);
-        }
-    }
-    void setStableGain(int legID){
-        motorCmd[legID*3+0].mode = 10;
-        motorCmd[legID*3+0].Kp = 0.8;
-        motorCmd[legID*3+0].Kd = 0.8;
-        motorCmd[legID*3+1].mode = 10;
-        motorCmd[legID*3+1].Kp = 0.8;
-        motorCmd[legID*3+1].Kd = 0.8;
-        motorCmd[legID*3+2].mode = 10;
-        motorCmd[legID*3+2].Kp = 0.8;
-        motorCmd[legID*3+2].Kd = 0.8;
-    }
-    void setStableGain(){
-        for(int i(0); i&lt;4; ++i){
-            setStableGain(i);
-        }
-    }
-    void setSwingGain(int legID){
-        motorCmd[legID*3+0].mode = 10;
-        motorCmd[legID*3+0].Kp = 3;
-        motorCmd[legID*3+0].Kd = 2;
-        motorCmd[legID*3+1].mode = 10;
-        motorCmd[legID*3+1].Kp = 3;
-        motorCmd[legID*3+1].Kd = 2;
-        motorCmd[legID*3+2].mode = 10;
-        motorCmd[legID*3+2].Kp = 3;
-        motorCmd[legID*3+2].Kd = 2;
-    }
+  }
+  void setSwingGain(int legID)
+  {
+    motorCmd[legID * 3 + 0].mode = 10;
+    motorCmd[legID * 3 + 0].Kp = 3;
+    motorCmd[legID * 3 + 0].Kd = 2;
+    motorCmd[legID * 3 + 1].mode = 10;
+    motorCmd[legID * 3 + 1].Kp = 3;
+    motorCmd[legID * 3 + 1].Kd = 2;
+    motorCmd[legID * 3 + 2].mode = 10;
+    motorCmd[legID * 3 + 2].Kp = 3;
+    motorCmd[legID * 3 + 2].Kd = 2;
+  }
@@ -141 +158 @@
-#endif  //LOWLEVELCMD_H
+#endif  //LOWLEVELCMD_H

Code style divergence in file 'include/message/LowlevelState.h':

--- include/message/LowlevelState.h
+++ include/message/LowlevelState.h.uncrustify
@@ -15,5 +15,5 @@
-	unsigned int mode;
-    float q;
-    float dq;
-    float ddq;
-    float tauEst;
+  unsigned int mode;
+  float q;
+  float dq;
+  float ddq;
+  float tauEst;
@@ -21,6 +21,6 @@
-    MotorState(){
-        q = 0;
-        dq = 0;
-        ddq = 0;
-        tauEst = 0;
-    }
+  MotorState() {
+    q = 0;
+    dq = 0;
+    ddq = 0;
+    tauEst = 0;
+  }
@@ -31,3 +31,3 @@
-    float quaternion[4];    // w, x, y, z
-    float gyroscope[3];
-    float accelerometer[3];
+  float quaternion[4];      // w, x, y, z
+  float gyroscope[3];
+  float accelerometer[3];
@@ -35,7 +35,5 @@
-    IMU(){
-        for(int i = 0; i &lt; 3; i++){
-            quaternion[i] = 0;
-            gyroscope[i] = 0;
-            accelerometer[i] = 0;
-        }
-        quaternion[3] = 0;
+  IMU() {
+    for (int i = 0; i &lt; 3; i++) {
+      quaternion[i] = 0;
+      gyroscope[i] = 0;
+      accelerometer[i] = 0;
@@ -42,0 +41,2 @@
+    quaternion[3] = 0;
+  }
@@ -44,5 +44,6 @@
-    RotMat getRotMat(){
-        Quat quat;
-        quat &lt;&lt; quaternion[0], quaternion[1], quaternion[2], quaternion[3];
-        return quatToRotMat(quat);
-    }
+  RotMat getRotMat()
+  {
+    Quat quat;
+    quat &lt;&lt; quaternion[0], quaternion[1], quaternion[2], quaternion[3];
+    return quatToRotMat(quat);
+  }
@@ -50,5 +51,6 @@
-    Vec3 getAcc(){
-        Vec3 acc;
-        acc &lt;&lt; accelerometer[0], accelerometer[1], accelerometer[2];
-        return acc;
-    }
+  Vec3 getAcc()
+  {
+    Vec3 acc;
+    acc &lt;&lt; accelerometer[0], accelerometer[1], accelerometer[2];
+    return acc;
+  }
@@ -56,5 +58,6 @@
-    Vec3 getGyro(){
-        Vec3 gyro;
-        gyro &lt;&lt; gyroscope[0], gyroscope[1], gyroscope[2];
-        return gyro;
-    }
+  Vec3 getGyro()
+  {
+    Vec3 gyro;
+    gyro &lt;&lt; gyroscope[0], gyroscope[1], gyroscope[2];
+    return gyro;
+  }
@@ -62,5 +65,6 @@
-    Quat getQuat(){
-        Quat q;
-        q &lt;&lt; quaternion[0], quaternion[1], quaternion[2], quaternion[3];
-        return q;
-    }
+  Quat getQuat()
+  {
+    Quat q;
+    q &lt;&lt; quaternion[0], quaternion[1], quaternion[2], quaternion[3];
+    return q;
+  }
@@ -71,4 +75,4 @@
-    IMU imu;
-    MotorState motorState[12];
-    UserCommand userCmd;
-    UserValue userValue;
+  IMU imu;
+  MotorState motorState[12];
+  UserCommand userCmd;
+  UserValue userValue;
@@ -76,8 +80,7 @@
-    Vec34 getQ(){
-        Vec34 qLegs;
-        for(int i(0); i &lt; 4; ++i){
-            qLegs.col(i)(0) = motorState[3*i    ].q;
-            qLegs.col(i)(1) = motorState[3*i + 1].q;
-            qLegs.col(i)(2) = motorState[3*i + 2].q;
-        }
-        return qLegs;
+  Vec34 getQ()
+  {
+    Vec34 qLegs;
+    for (int i(0); i &lt; 4; ++i) {
+      qLegs.col(i)(0) = motorState[3 * i].q;
+      qLegs.col(i)(1) = motorState[3 * i + 1].q;
+      qLegs.col(i)(2) = motorState[3 * i + 2].q;
@@ -84,0 +88,2 @@
+    return qLegs;
+  }
@@ -86,8 +91,7 @@
-    Vec34 getQd(){
-        Vec34 qdLegs;
-        for(int i(0); i &lt; 4; ++i){
-            qdLegs.col(i)(0) = motorState[3*i    ].dq;
-            qdLegs.col(i)(1) = motorState[3*i + 1].dq;
-            qdLegs.col(i)(2) = motorState[3*i + 2].dq;
-        }
-        return qdLegs;
+  Vec34 getQd()
+  {
+    Vec34 qdLegs;
+    for (int i(0); i &lt; 4; ++i) {
+      qdLegs.col(i)(0) = motorState[3 * i].dq;
+      qdLegs.col(i)(1) = motorState[3 * i + 1].dq;
+      qdLegs.col(i)(2) = motorState[3 * i + 2].dq;
@@ -94,0 +99,2 @@
+    return qdLegs;
+  }
@@ -96,2 +102,39 @@
-    RotMat getRotMat(){
-        return imu.getRotMat();
+  RotMat getRotMat()
+  {
+    return imu.getRotMat();
+  }
+
+  Vec3 getAcc()
+  {
+    return imu.getAcc();
+  }
+
+  Vec3 getGyro()
+  {
+    return imu.getGyro();
+  }
+
+  Vec3 getAccGlobal()
+  {
+    return getRotMat() * getAcc();
+  }
+
+  Vec3 getGyroGlobal()
+  {
+    return getRotMat() * getGyro();
+  }
+
+  double getYaw()
+  {
+    return rotMatToRPY(getRotMat())(2);
+  }
+
+  double getDYaw()
+  {
+    return getGyroGlobal()(2);
+  }
+
+  void setQ(Vec12 q)
+  {
+    for (int i(0); i &lt; 12; ++i) {
+      motorState[i].q = q(i);
@@ -99,30 +142 @@
-
-    Vec3 getAcc(){
-        return imu.getAcc();
-    }
-
-    Vec3 getGyro(){
-        return imu.getGyro();
-    }
-
-    Vec3 getAccGlobal(){
-        return getRotMat() * getAcc();
-    }
-
-    Vec3 getGyroGlobal(){
-        return getRotMat() * getGyro();
-    }
-
-    double getYaw(){
-        return rotMatToRPY(getRotMat())(2);
-    }
-
-    double getDYaw(){
-        return getGyroGlobal()(2);
-    }
-
-    void setQ(Vec12 q){
-        for(int i(0); i&lt;12; ++i){
-            motorState[i].q = q(i);
-        }
-    }
+  }
@@ -131 +145 @@
-#endif  //LOWLEVELSTATE_HPP
+#endif  //LOWLEVELSTATE_HPP

Code style divergence in file 'include/message/unitree_joystick.h':

--- include/message/unitree_joystick.h
+++ include/message/unitree_joystick.h.uncrustify
@@ -10,19 +10,20 @@
-    struct {
-        uint8_t R1          :1;
-        uint8_t L1          :1;
-        uint8_t start       :1;
-        uint8_t select      :1;
-        uint8_t R2          :1;
-        uint8_t L2          :1;
-        uint8_t F1          :1;
-        uint8_t F2          :1;
-        uint8_t A           :1;
-        uint8_t B           :1;
-        uint8_t X           :1;
-        uint8_t Y           :1;
-        uint8_t up          :1;
-        uint8_t right       :1;
-        uint8_t down        :1;
-        uint8_t left        :1;
-    } components;
-    uint16_t value;
+  struct
+  {
+    uint8_t R1          : 1;
+    uint8_t L1          : 1;
+    uint8_t start       : 1;
+    uint8_t select      : 1;
+    uint8_t R2          : 1;
+    uint8_t L2          : 1;
+    uint8_t F1          : 1;
+    uint8_t F2          : 1;
+    uint8_t A           : 1;
+    uint8_t B           : 1;
+    uint8_t X           : 1;
+    uint8_t Y           : 1;
+    uint8_t up          : 1;
+    uint8_t right       : 1;
+    uint8_t down        : 1;
+    uint8_t left        : 1;
+  } components;
+  uint16_t value;
@@ -32,8 +33,9 @@
-typedef struct {
-    uint8_t head[2];
-    xKeySwitchUnion btn;
-    float lx;
-    float rx;
-    float ry;
-    float L2;
-    float ly;
+typedef struct
+{
+  uint8_t head[2];
+  xKeySwitchUnion btn;
+  float lx;
+  float rx;
+  float ry;
+  float L2;
+  float ly;
@@ -41 +43 @@
-    uint8_t idle[16];
+  uint8_t idle[16];
@@ -44 +46 @@
-#endif  // UNITREE_JOYSTICK_H
+#endif  // UNITREE_JOYSTICK_H

Code style divergence in file 'include/thirdParty/matplotlibcpp.h':

--- include/thirdParty/matplotlibcpp.h
+++ include/thirdParty/matplotlibcpp.h.uncrustify
@@ -43,74 +43,76 @@
-namespace detail {
-
-static std::string s_backend;
-
-struct _interpreter {
-    PyObject* s_python_function_arrow;
-    PyObject *s_python_function_show;
-    PyObject *s_python_function_close;
-    PyObject *s_python_function_draw;
-    PyObject *s_python_function_pause;
-    PyObject *s_python_function_save;
-    PyObject *s_python_function_figure;
-    PyObject *s_python_function_fignum_exists;
-    PyObject *s_python_function_plot;
-    PyObject *s_python_function_quiver;
-    PyObject* s_python_function_contour;
-    PyObject *s_python_function_semilogx;
-    PyObject *s_python_function_semilogy;
-    PyObject *s_python_function_loglog;
-    PyObject *s_python_function_fill;
-    PyObject *s_python_function_fill_between;
-    PyObject *s_python_function_hist;
-    PyObject *s_python_function_imshow;
-    PyObject *s_python_function_scatter;
-    PyObject *s_python_function_boxplot;
-    PyObject *s_python_function_subplot;
-    PyObject *s_python_function_subplot2grid;
-    PyObject *s_python_function_legend;
-    PyObject *s_python_function_xlim;
-    PyObject *s_python_function_ion;
-    PyObject *s_python_function_ginput;
-    PyObject *s_python_function_ylim;
-    PyObject *s_python_function_title;
-    PyObject *s_python_function_axis;
-    PyObject *s_python_function_axvline;
-    PyObject *s_python_function_axvspan;
-    PyObject *s_python_function_xlabel;
-    PyObject *s_python_function_ylabel;
-    PyObject *s_python_function_gca;
-    PyObject *s_python_function_xticks;
-    PyObject *s_python_function_yticks;
-    PyObject* s_python_function_margins;
-    PyObject *s_python_function_tick_params;
-    PyObject *s_python_function_grid;
-    PyObject* s_python_function_cla;
-    PyObject *s_python_function_clf;
-    PyObject *s_python_function_errorbar;
-    PyObject *s_python_function_annotate;
-    PyObject *s_python_function_tight_layout;
-    PyObject *s_python_colormap;
-    PyObject *s_python_empty_tuple;
-    PyObject *s_python_function_stem;
-    PyObject *s_python_function_xkcd;
-    PyObject *s_python_function_text;
-    PyObject *s_python_function_suptitle;
-    PyObject *s_python_function_bar;
-    PyObject *s_python_function_barh;
-    PyObject *s_python_function_colorbar;
-    PyObject *s_python_function_subplots_adjust;
-
-
-    /* For now, _interpreter is implemented as a singleton since its currently not possible to have
-       multiple independent embedded python interpreters without patching the python source code
-       or starting a separate process for each. [1]
-       Furthermore, many python objects expect that they are destructed in the same thread as they
-       were constructed. [2] So for advanced usage, a `kill()` function is provided so that library
-       users can manually ensure that the interpreter is constructed and destroyed within the
-       same thread.
-
-         1: http://bytes.com/topic/python/answers/793370-multiple-independent-python-interpreters-c-c-program
-         2: https://github.com/lava/matplotlib-cpp/pull/202#issue-436220256
-       */
-
-    static _interpreter&amp; get() {
+  namespace detail {
+
+    static std::string s_backend;
+
+    struct _interpreter
+    {
+      PyObject * s_python_function_arrow;
+      PyObject * s_python_function_show;
+      PyObject * s_python_function_close;
+      PyObject * s_python_function_draw;
+      PyObject * s_python_function_pause;
+      PyObject * s_python_function_save;
+      PyObject * s_python_function_figure;
+      PyObject * s_python_function_fignum_exists;
+      PyObject * s_python_function_plot;
+      PyObject * s_python_function_quiver;
+      PyObject * s_python_function_contour;
+      PyObject * s_python_function_semilogx;
+      PyObject * s_python_function_semilogy;
+      PyObject * s_python_function_loglog;
+      PyObject * s_python_function_fill;
+      PyObject * s_python_function_fill_between;
+      PyObject * s_python_function_hist;
+      PyObject * s_python_function_imshow;
+      PyObject * s_python_function_scatter;
+      PyObject * s_python_function_boxplot;
+      PyObject * s_python_function_subplot;
+      PyObject * s_python_function_subplot2grid;
+      PyObject * s_python_function_legend;
+      PyObject * s_python_function_xlim;
+      PyObject * s_python_function_ion;
+      PyObject * s_python_function_ginput;
+      PyObject * s_python_function_ylim;
+      PyObject * s_python_function_title;
+      PyObject * s_python_function_axis;
+      PyObject * s_python_function_axvline;
+      PyObject * s_python_function_axvspan;
+      PyObject * s_python_function_xlabel;
+      PyObject * s_python_function_ylabel;
+      PyObject * s_python_function_gca;
+      PyObject * s_python_function_xticks;
+      PyObject * s_python_function_yticks;
+      PyObject * s_python_function_margins;
+      PyObject * s_python_function_tick_params;
+      PyObject * s_python_function_grid;
+      PyObject * s_python_function_cla;
+      PyObject * s_python_function_clf;
+      PyObject * s_python_function_errorbar;
+      PyObject * s_python_function_annotate;
+      PyObject * s_python_function_tight_layout;
+      PyObject * s_python_colormap;
+      PyObject * s_python_empty_tuple;
+      PyObject * s_python_function_stem;
+      PyObject * s_python_function_xkcd;
+      PyObject * s_python_function_text;
+      PyObject * s_python_function_suptitle;
+      PyObject * s_python_function_bar;
+      PyObject * s_python_function_barh;
+      PyObject * s_python_function_colorbar;
+      PyObject * s_python_function_subplots_adjust;
+
+
+      /* For now, _interpreter is implemented as a singleton since its currently not possible to have
+         multiple independent embedded python interpreters without patching the python source code
+         or starting a separate process for each. [1]
+         Furthermore, many python objects expect that they are destructed in the same thread as they
+         were constructed. [2] So for advanced usage, a `kill()` function is provided so that library
+         users can manually ensure that the interpreter is constructed and destroyed within the
+         same thread.
+
+           1: http://bytes.com/topic/python/answers/793370-multiple-independent-python-interpreters-c-c-program
+           2: https://github.com/lava/matplotlib-cpp/pull/202#issue-436220256
+         */
+
+      static _interpreter &amp; get()
+      {
@@ -118,3 +120,4 @@
-    }
-
-    static _interpreter&amp; kill() {
+      }
+
+      static _interpreter &amp; kill()
+      {
@@ -122,4 +125,5 @@
-    }
-
-    // Stores the actual singleton object referenced by `get()` and `kill()`.
-    static _interpreter&amp; interkeeper(bool should_kill) {
+      }
+
+      // Stores the actual singleton object referenced by `get()` and `kill()`.
+      static _interpreter &amp; interkeeper(bool should_kill)
+      {
@@ -127,2 +131,3 @@
-        if (should_kill)
-            ctx.~_interpreter();
+        if (should_kill) {
+          ctx.~_interpreter();
+        }
@@ -130,10 +135,13 @@
-    }
-
-    PyObject* safe_import(PyObject* module, std::string fname) {
-        PyObject* fn = PyObject_GetAttrString(module, fname.c_str());
-
-        if (!fn)
-            throw std::runtime_error(std::string("Couldn't find required function: ") + fname);
-
-        if (!PyFunction_Check(fn))
-            throw std::runtime_error(fname + std::string(" is unexpectedly not a PyFunction."));
+      }
+
+      PyObject * safe_import(PyObject * module, std::string fname)
+      {
+        PyObject * fn = PyObject_GetAttrString(module, fname.c_str());
+
+        if (!fn) {
+          throw std::runtime_error(std::string("Couldn't find required function: ") + fname);
+        }
+
+        if (!PyFunction_Check(fn)) {
+          throw std::runtime_error(fname + std::string(" is unexpectedly not a PyFunction."));
+        }
@@ -142 +150 @@
-    }
+      }
@@ -145 +152,0 @@
-
@@ -149 +156,2 @@
-    void *import_numpy() {
+      void * import_numpy()
+      {
@@ -152 +160 @@
-    }
+      }
@@ -156 +164,2 @@
-    void import_numpy() {
+      void import_numpy()
+      {
@@ -158 +167 @@
-    }
+      }
@@ -163 +172 @@
-    _interpreter() {
+      _interpreter() {
@@ -174,3 +183,3 @@
-        wchar_t const *dummy_args[] = {L"Python", NULL};  // const is needed because literals must not be modified
-        wchar_t const **argv = dummy_args;
-        int             argc = sizeof(dummy_args)/sizeof(dummy_args[0])-1;
+        wchar_t const * dummy_args[] = {L"Python", NULL};  // const is needed because literals must not be modified
+        wchar_t const ** argv = dummy_args;
+        int argc = sizeof(dummy_args) / sizeof(dummy_args[0]) - 1;
@@ -180 +189 @@
-        char** argm = (char **)(argv); PySys_SetArgv(argc, argm);
+        char ** argm = (char **)(argv); PySys_SetArgv(argc, argm);
@@ -186,4 +195,4 @@
-        PyObject* matplotlibname = PyString_FromString("matplotlib");
-        PyObject* pyplotname = PyString_FromString("matplotlib.pyplot");
-        PyObject* cmname  = PyString_FromString("matplotlib.cm");
-        PyObject* pylabname  = PyString_FromString("pylab");
+        PyObject * matplotlibname = PyString_FromString("matplotlib");
+        PyObject * pyplotname = PyString_FromString("matplotlib.pyplot");
+        PyObject * cmname = PyString_FromString("matplotlib.cm");
+        PyObject * pylabname = PyString_FromString("pylab");
@@ -191 +200 @@
-            throw std::runtime_error("couldnt create string");
+          throw std::runtime_error("couldnt create string");
@@ -194 +203 @@
-        PyObject* matplotlib = PyImport_Import(matplotlibname);
+        PyObject * matplotlib = PyImport_Import(matplotlibname);
@@ -197,2 +206,2 @@
-            PyErr_Print();
-            throw std::runtime_error("Error loading module matplotlib!");
+          PyErr_Print();
+          throw std::runtime_error("Error loading module matplotlib!");
@@ -204 +213,3 @@
-            PyObject_CallMethod(matplotlib, const_cast&lt;char*&gt;("use"), const_cast&lt;char*&gt;("s"), s_backend.c_str());
+          PyObject_CallMethod(
+            matplotlib, const_cast &lt; char * &gt; ("use"),
+            const_cast &lt; char * &gt; ("s"), s_backend.c_str());
@@ -207 +218 @@
-        PyObject* pymod = PyImport_Import(pyplotname);
+        PyObject * pymod = PyImport_Import(pyplotname);
@@ -209 +220 @@
-        if (!pymod) { throw std::runtime_error("Error loading module matplotlib.pyplot!"); }
+        if (!pymod) {throw std::runtime_error("Error loading module matplotlib.pyplot!");}
@@ -213,3 +224,3 @@
-        if (!s_python_colormap) { throw std::runtime_error("Error loading module matplotlib.cm!"); }
-
-        PyObject* pylabmod = PyImport_Import(pylabname);
+        if (!s_python_colormap) {throw std::runtime_error("Error loading module matplotlib.cm!");}
+
+        PyObject * pylabmod = PyImport_Import(pylabname);
@@ -217 +228 @@
-        if (!pylabmod) { throw std::runtime_error("Error loading module pylab!"); }
+        if (!pylabmod) {throw std::runtime_error("Error loading module pylab!");}
@@ -234,3 +245,3 @@
-        s_python_function_hist = safe_import(pymod,"hist");
-        s_python_function_scatter = safe_import(pymod,"scatter");
-        s_python_function_boxplot = safe_import(pymod,"boxplot");
+        s_python_function_hist = safe_import(pymod, "hist");
+        s_python_function_scatter = safe_import(pymod, "scatter");
+        s_python_function_boxplot = safe_import(pymod, "boxplot");
@@ -257 +268 @@
-        s_python_function_annotate = safe_import(pymod,"annotate");
+        s_python_function_annotate = safe_import(pymod, "annotate");
@@ -266 +277 @@
-        s_python_function_bar = safe_import(pymod,"bar");
+        s_python_function_bar = safe_import(pymod, "bar");
@@ -269 +280 @@
-        s_python_function_subplots_adjust = safe_import(pymod,"subplots_adjust");
+        s_python_function_subplots_adjust = safe_import(pymod, "subplots_adjust");
@@ -274,3 +285,3 @@
-    }
-
-    ~_interpreter() {
+      }
+
+      ~_interpreter() {
@@ -278,4 +289,4 @@
-    }
-};
-
-} // end namespace detail
+      }
+    };
+
+  } // end namespace detail
@@ -292,2 +303,2 @@
-inline void backend(const std::string&amp; name)
-{
+  inline void backend(const std::string &amp; name)
+  {
@@ -295,4 +306,4 @@
-}
-
-inline bool annotate(std::string annotation, double x, double y)
-{
+  }
+
+  inline bool annotate(std::string annotation, double x, double y)
+  {
@@ -304,4 +315,4 @@
-    PyTuple_SetItem(xy,0,PyFloat_FromDouble(x));
-    PyTuple_SetItem(xy,1,PyFloat_FromDouble(y));
-
-    PyObject* kwargs = PyDict_New();
+    PyTuple_SetItem(xy, 0, PyFloat_FromDouble(x));
+    PyTuple_SetItem(xy, 1, PyFloat_FromDouble(y));
+
+    PyObject * kwargs = PyDict_New();
@@ -310 +321 @@
-    PyObject* args = PyTuple_New(1);
+    PyObject * args = PyTuple_New(1);
@@ -313,6 +324,7 @@
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_annotate, args, kwargs);
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-
-    if(res) Py_DECREF(res);
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_annotate, args, kwargs);
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+
+    if (res) {Py_DECREF(res);}
@@ -321,3 +333,3 @@
-}
-
-namespace detail {
+  }
+
+  namespace detail {
@@ -327,12 +339,12 @@
-template &lt;typename T&gt; struct select_npy_type { const static NPY_TYPES type = NPY_NOTYPE; }; //Default
-template &lt;&gt; struct select_npy_type&lt;double&gt; { const static NPY_TYPES type = NPY_DOUBLE; };
-template &lt;&gt; struct select_npy_type&lt;float&gt; { const static NPY_TYPES type = NPY_FLOAT; };
-template &lt;&gt; struct select_npy_type&lt;bool&gt; { const static NPY_TYPES type = NPY_BOOL; };
-template &lt;&gt; struct select_npy_type&lt;int8_t&gt; { const static NPY_TYPES type = NPY_INT8; };
-template &lt;&gt; struct select_npy_type&lt;int16_t&gt; { const static NPY_TYPES type = NPY_SHORT; };
-template &lt;&gt; struct select_npy_type&lt;int32_t&gt; { const static NPY_TYPES type = NPY_INT; };
-template &lt;&gt; struct select_npy_type&lt;int64_t&gt; { const static NPY_TYPES type = NPY_INT64; };
-template &lt;&gt; struct select_npy_type&lt;uint8_t&gt; { const static NPY_TYPES type = NPY_UINT8; };
-template &lt;&gt; struct select_npy_type&lt;uint16_t&gt; { const static NPY_TYPES type = NPY_USHORT; };
-template &lt;&gt; struct select_npy_type&lt;uint32_t&gt; { const static NPY_TYPES type = NPY_ULONG; };
-template &lt;&gt; struct select_npy_type&lt;uint64_t&gt; { const static NPY_TYPES type = NPY_UINT64; };
+    template &lt; typename T &gt; struct select_npy_type { const static NPY_TYPES type = NPY_NOTYPE; }; //Default
+    template &lt; &gt; struct select_npy_type &lt; double &gt; {const static NPY_TYPES type = NPY_DOUBLE;}
+    template &lt; &gt; struct select_npy_type &lt; float &gt; {const static NPY_TYPES type = NPY_FLOAT;}
+    template &lt; &gt; struct select_npy_type &lt; bool &gt; {const static NPY_TYPES type = NPY_BOOL;}
+    template &lt; &gt; struct select_npy_type &lt; int8_t &gt; {const static NPY_TYPES type = NPY_INT8;}
+    template &lt; &gt; struct select_npy_type &lt; int16_t &gt; {const static NPY_TYPES type = NPY_SHORT;}
+    template &lt; &gt; struct select_npy_type &lt; int32_t &gt; {const static NPY_TYPES type = NPY_INT;}
+    template &lt; &gt; struct select_npy_type &lt; int64_t &gt; {const static NPY_TYPES type = NPY_INT64;}
+    template &lt; &gt; struct select_npy_type &lt; uint8_t &gt; {const static NPY_TYPES type = NPY_UINT8;}
+    template &lt; &gt; struct select_npy_type &lt; uint16_t &gt; {const static NPY_TYPES type = NPY_USHORT;}
+    template &lt; &gt; struct select_npy_type &lt; uint32_t &gt; {const static NPY_TYPES type = NPY_ULONG;}
+    template &lt; &gt; struct select_npy_type &lt; uint64_t &gt; {const static NPY_TYPES type = NPY_UINT64;}
@@ -342,4 +354,5 @@
-static_assert(sizeof(long long) == 8);
-template &lt;&gt; struct select_npy_type&lt;long long&gt; { const static NPY_TYPES type = NPY_INT64; };
-static_assert(sizeof(unsigned long long) == 8);
-template &lt;&gt; struct select_npy_type&lt;unsigned long long&gt; { const static NPY_TYPES type = NPY_UINT64; };
+    static_assert(sizeof(long long) == 8);
+    template &lt; &gt; struct select_npy_type &lt; long long &gt; {const static NPY_TYPES type = NPY_INT64;}
+    static_assert(sizeof(unsigned long long) == 8);
+    template &lt; &gt; struct select_npy_type &lt; unsigned long long &gt;
+    {const static NPY_TYPES type = NPY_UINT64;}
@@ -348,12 +361,13 @@
-template&lt;typename Numeric&gt;
-PyObject* get_array(const std::vector&lt;Numeric&gt;&amp; v)
-{
-    npy_intp vsize = v.size();
-    NPY_TYPES type = select_npy_type&lt;Numeric&gt;::type;
-    if (type == NPY_NOTYPE) {
-        size_t memsize = v.size()*sizeof(double);
-        double* dp = static_cast&lt;double*&gt;(::malloc(memsize));
-        for (size_t i=0; i&lt;v.size(); ++i)
-            dp[i] = v[i];
-        PyObject* varray = PyArray_SimpleNewFromData(1, &amp;vsize, NPY_DOUBLE, dp);
-        PyArray_UpdateFlags(reinterpret_cast&lt;PyArrayObject*&gt;(varray), NPY_ARRAY_OWNDATA);
+    template &lt; typename Numeric &gt;
+    PyObject * get_array(const std::vector &lt; Numeric &gt; &amp; v)
+    {
+      npy_intp vsize = v.size();
+      NPY_TYPES type = select_npy_type &lt; Numeric &gt; ::type;
+      if (type == NPY_NOTYPE) {
+        size_t memsize = v.size() * sizeof(double);
+        double * dp = static_cast &lt; double * &gt; (::malloc(memsize));
+        for (size_t i = 0; i &lt; v.size(); ++i) {
+          dp[i] = v[i];
+        }
+        PyObject * varray = PyArray_SimpleNewFromData(1, &amp;vsize, NPY_DOUBLE, dp);
+        PyArray_UpdateFlags(reinterpret_cast &lt; PyArrayObject * &gt; (varray), NPY_ARRAY_OWNDATA);
@@ -361,16 +375,16 @@
-    }
-    
-    PyObject* varray = PyArray_SimpleNewFromData(1, &amp;vsize, type, (void*)(v.data()));
-    return varray;
-}
-
-
-template&lt;typename Numeric&gt;
-PyObject* get_2darray(const std::vector&lt;::std::vector&lt;Numeric&gt;&gt;&amp; v)
-{
-    if (v.size() &lt; 1) throw std::runtime_error("get_2d_array v too small");
-
-    npy_intp vsize[2] = {static_cast&lt;npy_intp&gt;(v.size()),
-                         static_cast&lt;npy_intp&gt;(v[0].size())};
-
-    PyArrayObject *varray =
+      }
+
+      PyObject * varray = PyArray_SimpleNewFromData(1, &amp;vsize, type, (void *)(v.data()));
+      return varray;
+    }
+
+
+    template &lt; typename Numeric &gt;
+    PyObject * get_2darray(const std::vector &lt; ::std::vector &lt; Numeric &gt;&gt; &amp; v)
+    {
+      if (v.size() &lt; 1) {throw std::runtime_error("get_2d_array v too small");}
+
+      npy_intp vsize[2] = {static_cast &lt; npy_intp &gt; (v.size()),
+        static_cast &lt; npy_intp &gt; (v[0].size())};
+
+      PyArrayObject * varray =
@@ -379,11 +393,12 @@
-    double *vd_begin = static_cast&lt;double *&gt;(PyArray_DATA(varray));
-
-    for (const ::std::vector&lt;Numeric&gt; &amp;v_row : v) {
-      if (v_row.size() != static_cast&lt;size_t&gt;(vsize[1]))
-        throw std::runtime_error("Missmatched array size");
-      std::copy(v_row.begin(), v_row.end(), vd_begin);
-      vd_begin += vsize[1];
-    }
-
-    return reinterpret_cast&lt;PyObject *&gt;(varray);
-}
+      double * vd_begin = static_cast &lt; double * &gt; (PyArray_DATA(varray));
+
+      for (const ::std::vector &lt; Numeric &gt; &amp; v_row : v) {
+        if (v_row.size() != static_cast &lt; size_t &gt; (vsize[1])) {
+          throw std::runtime_error("Missmatched array size");
+        }
+        std::copy(v_row.begin(), v_row.end(), vd_begin);
+        vd_begin += vsize[1];
+      }
+
+      return reinterpret_cast &lt; PyObject * &gt; (varray);
+    }
@@ -393,5 +408,5 @@
-template&lt;typename Numeric&gt;
-PyObject* get_array(const std::vector&lt;Numeric&gt;&amp; v)
-{
-    PyObject* list = PyList_New(v.size());
-    for(size_t i = 0; i &lt; v.size(); ++i) {
+    template &lt; typename Numeric &gt;
+    PyObject * get_array(const std::vector &lt; Numeric &gt; &amp; v)
+    {
+      PyObject * list = PyList_New(v.size());
+      for (size_t i = 0; i &lt; v.size(); ++i) {
@@ -399,3 +414,3 @@
-    }
-    return list;
-}
+      }
+      return list;
+    }
@@ -406,8 +421,8 @@
-inline PyObject * get_array(const std::vector&lt;std::string&gt;&amp; strings)
-{
-  PyObject* list = PyList_New(strings.size());
-  for (std::size_t i = 0; i &lt; strings.size(); ++i) {
-    PyList_SetItem(list, i, PyString_FromString(strings[i].c_str()));
-  }
-  return list;
-}
+    inline PyObject * get_array(const std::vector &lt; std::string &gt; &amp; strings)
+    {
+      PyObject * list = PyList_New(strings.size());
+      for (std::size_t i = 0; i &lt; strings.size(); ++i) {
+        PyList_SetItem(list, i, PyString_FromString(strings[i].c_str()));
+      }
+      return list;
+    }
@@ -416,11 +431,11 @@
-template&lt;typename Numeric&gt;
-PyObject* get_listlist(const std::vector&lt;std::vector&lt;Numeric&gt;&gt;&amp; ll)
-{
-  PyObject* listlist = PyList_New(ll.size());
-  for (std::size_t i = 0; i &lt; ll.size(); ++i) {
-    PyList_SetItem(listlist, i, get_array(ll[i]));
-  }
-  return listlist;
-}
-
-} // namespace detail
+    template &lt; typename Numeric &gt;
+    PyObject * get_listlist(const std::vector &lt; std::vector &lt; Numeric &gt;&gt; &amp; ll)
+    {
+      PyObject * listlist = PyList_New(ll.size());
+      for (std::size_t i = 0; i &lt; ll.size(); ++i) {
+        PyList_SetItem(listlist, i, get_array(ll[i]));
+      }
+      return listlist;
+    }
+
+  } // namespace detail
@@ -429 +444 @@
-/// 
+///
@@ -431,3 +446,5 @@
-template&lt;typename Numeric&gt;
-bool plot(const std::vector&lt;Numeric&gt; &amp;x, const std::vector&lt;Numeric&gt; &amp;y, const std::map&lt;std::string, std::string&gt;&amp; keywords)
-{
+  template &lt; typename Numeric &gt;
+  bool plot(
+    const std::vector &lt; Numeric &gt; &amp; x, const std::vector &lt; Numeric &gt; &amp; y,
+    const std::map &lt; std::string, std::string &gt; &amp; keywords)
+  {
@@ -439,2 +456,2 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
@@ -443 +460 @@
-    PyObject* args = PyTuple_New(2);
+    PyObject * args = PyTuple_New(2);
@@ -448,11 +465,13 @@
-    PyObject* kwargs = PyDict_New();
-    for(std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
-    {
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_plot, args, kwargs);
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-    if(res) Py_DECREF(res);
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res =
+      PyObject_Call(detail::_interpreter::get().s_python_function_plot, args, kwargs);
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+    if (res) {Py_DECREF(res);}
@@ -461 +480 @@
-}
+  }
@@ -466,183 +485,31 @@
-template &lt;typename Numeric&gt;
-void plot_surface(const std::vector&lt;::std::vector&lt;Numeric&gt;&gt; &amp;x,
-                  const std::vector&lt;::std::vector&lt;Numeric&gt;&gt; &amp;y,
-                  const std::vector&lt;::std::vector&lt;Numeric&gt;&gt; &amp;z,
-                  const std::map&lt;std::string, std::string&gt; &amp;keywords =
-                      std::map&lt;std::string, std::string&gt;())
-{
-  detail::_interpreter::get();
-
-  // We lazily load the modules here the first time this function is called
-  // because I'm not sure that we can assume "matplotlib installed" implies
-  // "mpl_toolkits installed" on all platforms, and we don't want to require
-  // it for people who don't need 3d plots.
-  static PyObject *mpl_toolkitsmod = nullptr, *axis3dmod = nullptr;
-  if (!mpl_toolkitsmod) {
-    detail::_interpreter::get();
-
-    PyObject* mpl_toolkits = PyString_FromString("mpl_toolkits");
-    PyObject* axis3d = PyString_FromString("mpl_toolkits.mplot3d");
-    if (!mpl_toolkits || !axis3d) { throw std::runtime_error("couldnt create string"); }
-
-    mpl_toolkitsmod = PyImport_Import(mpl_toolkits);
-    Py_DECREF(mpl_toolkits);
-    if (!mpl_toolkitsmod) { throw std::runtime_error("Error loading module mpl_toolkits!"); }
-
-    axis3dmod = PyImport_Import(axis3d);
-    Py_DECREF(axis3d);
-    if (!axis3dmod) { throw std::runtime_error("Error loading module mpl_toolkits.mplot3d!"); }
-  }
-
-  assert(x.size() == y.size());
-  assert(y.size() == z.size());
-
-  // using numpy arrays
-  PyObject *xarray = detail::get_2darray(x);
-  PyObject *yarray = detail::get_2darray(y);
-  PyObject *zarray = detail::get_2darray(z);
-
-  // construct positional args
-  PyObject *args = PyTuple_New(3);
-  PyTuple_SetItem(args, 0, xarray);
-  PyTuple_SetItem(args, 1, yarray);
-  PyTuple_SetItem(args, 2, zarray);
-
-  // Build up the kw args.
-  PyObject *kwargs = PyDict_New();
-  PyDict_SetItemString(kwargs, "rstride", PyInt_FromLong(1));
-  PyDict_SetItemString(kwargs, "cstride", PyInt_FromLong(1));
-
-  PyObject *python_colormap_coolwarm = PyObject_GetAttrString(
-      detail::_interpreter::get().s_python_colormap, "coolwarm");
-
-  PyDict_SetItemString(kwargs, "cmap", python_colormap_coolwarm);
-
-  for (std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin();
-       it != keywords.end(); ++it) {
-    PyDict_SetItemString(kwargs, it-&gt;first.c_str(),
-                         PyString_FromString(it-&gt;second.c_str()));
-  }
-
-
-  PyObject *fig =
-      PyObject_CallObject(detail::_interpreter::get().s_python_function_figure,
-                          detail::_interpreter::get().s_python_empty_tuple);
-  if (!fig) throw std::runtime_error("Call to figure() failed.");
-
-  PyObject *gca_kwargs = PyDict_New();
-  PyDict_SetItemString(gca_kwargs, "projection", PyString_FromString("3d"));
-
-  PyObject *gca = PyObject_GetAttrString(fig, "gca");
-  if (!gca) throw std::runtime_error("No gca");
-  Py_INCREF(gca);
-  PyObject *axis = PyObject_Call(
-      gca, detail::_interpreter::get().s_python_empty_tuple, gca_kwargs);
-
-  if (!axis) throw std::runtime_error("No axis");
-  Py_INCREF(axis);
-
-  Py_DECREF(gca);
-  Py_DECREF(gca_kwargs);
-
-  PyObject *plot_surface = PyObject_GetAttrString(axis, "plot_surface");
-  if (!plot_surface) throw std::runtime_error("No surface");
-  Py_INCREF(plot_surface);
-  PyObject *res = PyObject_Call(plot_surface, args, kwargs);
-  if (!res) throw std::runtime_error("failed surface");
-  Py_DECREF(plot_surface);
-
-  Py_DECREF(axis);
-  Py_DECREF(args);
-  Py_DECREF(kwargs);
-  if (res) Py_DECREF(res);
-}
-#endif // WITHOUT_NUMPY
-
-template &lt;typename Numeric&gt;
-void plot3(const std::vector&lt;Numeric&gt; &amp;x,
-                  const std::vector&lt;Numeric&gt; &amp;y,
-                  const std::vector&lt;Numeric&gt; &amp;z,
-                  const std::map&lt;std::string, std::string&gt; &amp;keywords =
-                      std::map&lt;std::string, std::string&gt;())
-{
-  detail::_interpreter::get();
-
-  // Same as with plot_surface: We lazily load the modules here the first time 
-  // this function is called because I'm not sure that we can assume "matplotlib 
-  // installed" implies "mpl_toolkits installed" on all platforms, and we don't 
-  // want to require it for people who don't need 3d plots.
-  static PyObject *mpl_toolkitsmod = nullptr, *axis3dmod = nullptr;
-  if (!mpl_toolkitsmod) {
-    detail::_interpreter::get();
-
-    PyObject* mpl_toolkits = PyString_FromString("mpl_toolkits");
-    PyObject* axis3d = PyString_FromString("mpl_toolkits.mplot3d");
-    if (!mpl_toolkits || !axis3d) { throw std::runtime_error("couldnt create string"); }
-
-    mpl_toolkitsmod = PyImport_Import(mpl_toolkits);
-    Py_DECREF(mpl_toolkits);
-    if (!mpl_toolkitsmod) { throw std::runtime_error("Error loading module mpl_toolkits!"); }
-
-    axis3dmod = PyImport_Import(axis3d);
-    Py_DECREF(axis3d);
-    if (!axis3dmod) { throw std::runtime_error("Error loading module mpl_toolkits.mplot3d!"); }
-  }
-
-  assert(x.size() == y.size());
-  assert(y.size() == z.size());
-
-  PyObject *xarray = detail::get_array(x);
-  PyObject *yarray = detail::get_array(y);
-  PyObject *zarray = detail::get_array(z);
-
-  // construct positional args
-  PyObject *args = PyTuple_New(3);
-  PyTuple_SetItem(args, 0, xarray);
-  PyTuple_SetItem(args, 1, yarray);
-  PyTuple_SetItem(args, 2, zarray);
-
-  // Build up the kw args.
-  PyObject *kwargs = PyDict_New();
-
-  for (std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin();
-       it != keywords.end(); ++it) {
-    PyDict_SetItemString(kwargs, it-&gt;first.c_str(),
-                         PyString_FromString(it-&gt;second.c_str()));
-  }
-
-  PyObject *fig =
-      PyObject_CallObject(detail::_interpreter::get().s_python_function_figure,
-                          detail::_interpreter::get().s_python_empty_tuple);
-  if (!fig) throw std::runtime_error("Call to figure() failed.");
-
-  PyObject *gca_kwargs = PyDict_New();
-  PyDict_SetItemString(gca_kwargs, "projection", PyString_FromString("3d"));
-
-  PyObject *gca = PyObject_GetAttrString(fig, "gca");
-  if (!gca) throw std::runtime_error("No gca");
-  Py_INCREF(gca);
-  PyObject *axis = PyObject_Call(
-      gca, detail::_interpreter::get().s_python_empty_tuple, gca_kwargs);
-
-  if (!axis) throw std::runtime_error("No axis");
-  Py_INCREF(axis);
-
-  Py_DECREF(gca);
-  Py_DECREF(gca_kwargs);
-
-  PyObject *plot3 = PyObject_GetAttrString(axis, "plot");
-  if (!plot3) throw std::runtime_error("No 3D line plot");
-  Py_INCREF(plot3);
-  PyObject *res = PyObject_Call(plot3, args, kwargs);
-  if (!res) throw std::runtime_error("Failed 3D line plot");
-  Py_DECREF(plot3);
-
-  Py_DECREF(axis);
-  Py_DECREF(args);
-  Py_DECREF(kwargs);
-  if (res) Py_DECREF(res);
-}
-
-template&lt;typename Numeric&gt;
-bool stem(const std::vector&lt;Numeric&gt; &amp;x, const std::vector&lt;Numeric&gt; &amp;y, const std::map&lt;std::string, std::string&gt;&amp; keywords)
-{
+  template &lt; typename Numeric &gt;
+  void plot_surface(
+    const std::vector &lt; ::std::vector &lt; Numeric &gt;&gt; &amp; x,
+    const std::vector &lt; ::std::vector &lt; Numeric &gt;&gt; &amp; y,
+    const std::vector &lt; ::std::vector &lt; Numeric &gt;&gt; &amp; z,
+    const std::map &lt; std::string, std::string &gt; &amp; keywords =
+    std::map &lt; std::string, std::string &gt; ())
+  {
+    detail::_interpreter::get();
+
+    // We lazily load the modules here the first time this function is called
+    // because I'm not sure that we can assume "matplotlib installed" implies
+    // "mpl_toolkits installed" on all platforms, and we don't want to require
+    // it for people who don't need 3d plots.
+    static PyObject * mpl_toolkitsmod = nullptr, * axis3dmod = nullptr;
+    if (!mpl_toolkitsmod) {
+      detail::_interpreter::get();
+
+      PyObject * mpl_toolkits = PyString_FromString("mpl_toolkits");
+      PyObject * axis3d = PyString_FromString("mpl_toolkits.mplot3d");
+      if (!mpl_toolkits || !axis3d) {throw std::runtime_error("couldnt create string");}
+
+      mpl_toolkitsmod = PyImport_Import(mpl_toolkits);
+      Py_DECREF(mpl_toolkits);
+      if (!mpl_toolkitsmod) {throw std::runtime_error("Error loading module mpl_toolkits!");}
+
+      axis3dmod = PyImport_Import(axis3d);
+      Py_DECREF(axis3d);
+      if (!axis3dmod) {throw std::runtime_error("Error loading module mpl_toolkits.mplot3d!");}
+    }
+
@@ -650,2 +517 @@
-
-    detail::_interpreter::get();
+    assert(y.size() == z.size());
@@ -654,2 +520,3 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
+    PyObject * xarray = detail::get_2darray(x);
+    PyObject * yarray = detail::get_2darray(y);
+    PyObject * zarray = detail::get_2darray(z);
@@ -658 +525 @@
-    PyObject* args = PyTuple_New(2);
+    PyObject * args = PyTuple_New(3);
@@ -661,23 +528,87 @@
-
-    // construct keyword args
-    PyObject* kwargs = PyDict_New();
-    for (std::map&lt;std::string, std::string&gt;::const_iterator it =
-            keywords.begin(); it != keywords.end(); ++it) {
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(),
-                PyString_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(
-            detail::_interpreter::get().s_python_function_stem, args, kwargs);
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-    if (res)
-        Py_DECREF(res);
-
-    return res;
-}
-
-template&lt; typename Numeric &gt;
-bool fill(const std::vector&lt;Numeric&gt;&amp; x, const std::vector&lt;Numeric&gt;&amp; y, const std::map&lt;std::string, std::string&gt;&amp; keywords)
-{
+    PyTuple_SetItem(args, 2, zarray);
+
+    // Build up the kw args.
+    PyObject * kwargs = PyDict_New();
+    PyDict_SetItemString(kwargs, "rstride", PyInt_FromLong(1));
+    PyDict_SetItemString(kwargs, "cstride", PyInt_FromLong(1));
+
+    PyObject * python_colormap_coolwarm = PyObject_GetAttrString(
+      detail::_interpreter::get().s_python_colormap, "coolwarm");
+
+    PyDict_SetItemString(kwargs, "cmap", python_colormap_coolwarm);
+
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(
+        kwargs, it-&gt;first.c_str(),
+        PyString_FromString(it-&gt;second.c_str()));
+    }
+
+
+    PyObject * fig =
+      PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_figure,
+      detail::_interpreter::get().s_python_empty_tuple);
+    if (!fig) {throw std::runtime_error("Call to figure() failed.");}
+
+    PyObject * gca_kwargs = PyDict_New();
+    PyDict_SetItemString(gca_kwargs, "projection", PyString_FromString("3d"));
+
+    PyObject * gca = PyObject_GetAttrString(fig, "gca");
+    if (!gca) {throw std::runtime_error("No gca");}
+    Py_INCREF(gca);
+    PyObject * axis = PyObject_Call(
+      gca, detail::_interpreter::get().s_python_empty_tuple, gca_kwargs);
+
+    if (!axis) {throw std::runtime_error("No axis");}
+    Py_INCREF(axis);
+
+    Py_DECREF(gca);
+    Py_DECREF(gca_kwargs);
+
+    PyObject * plot_surface = PyObject_GetAttrString(axis, "plot_surface");
+    if (!plot_surface) {throw std::runtime_error("No surface");}
+    Py_INCREF(plot_surface);
+    PyObject * res = PyObject_Call(plot_surface, args, kwargs);
+    if (!res) {throw std::runtime_error("failed surface");}
+    Py_DECREF(plot_surface);
+
+    Py_DECREF(axis);
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+    if (res) {Py_DECREF(res);}
+  }
+#endif // WITHOUT_NUMPY
+
+  template &lt; typename Numeric &gt;
+  void plot3(
+    const std::vector &lt; Numeric &gt; &amp; x,
+    const std::vector &lt; Numeric &gt; &amp; y,
+    const std::vector &lt; Numeric &gt; &amp; z,
+    const std::map &lt; std::string, std::string &gt; &amp; keywords =
+    std::map &lt; std::string, std::string &gt; ())
+  {
+    detail::_interpreter::get();
+
+    // Same as with plot_surface: We lazily load the modules here the first time
+    // this function is called because I'm not sure that we can assume "matplotlib
+    // installed" implies "mpl_toolkits installed" on all platforms, and we don't
+    // want to require it for people who don't need 3d plots.
+    static PyObject * mpl_toolkitsmod = nullptr, * axis3dmod = nullptr;
+    if (!mpl_toolkitsmod) {
+      detail::_interpreter::get();
+
+      PyObject * mpl_toolkits = PyString_FromString("mpl_toolkits");
+      PyObject * axis3d = PyString_FromString("mpl_toolkits.mplot3d");
+      if (!mpl_toolkits || !axis3d) {throw std::runtime_error("couldnt create string");}
+
+      mpl_toolkitsmod = PyImport_Import(mpl_toolkits);
+      Py_DECREF(mpl_toolkits);
+      if (!mpl_toolkitsmod) {throw std::runtime_error("Error loading module mpl_toolkits!");}
+
+      axis3dmod = PyImport_Import(axis3d);
+      Py_DECREF(axis3d);
+      if (!axis3dmod) {throw std::runtime_error("Error loading module mpl_toolkits.mplot3d!");}
+    }
+
@@ -685,6 +616,5 @@
-
-    detail::_interpreter::get();
-
-    // using numpy arrays
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
+    assert(y.size() == z.size());
+
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+    PyObject * zarray = detail::get_array(z);
@@ -693 +623 @@
-    PyObject* args = PyTuple_New(2);
+    PyObject * args = PyTuple_New(3);
@@ -695,0 +626,64 @@
+    PyTuple_SetItem(args, 2, zarray);
+
+    // Build up the kw args.
+    PyObject * kwargs = PyDict_New();
+
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(
+        kwargs, it-&gt;first.c_str(),
+        PyString_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * fig =
+      PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_figure,
+      detail::_interpreter::get().s_python_empty_tuple);
+    if (!fig) {throw std::runtime_error("Call to figure() failed.");}
+
+    PyObject * gca_kwargs = PyDict_New();
+    PyDict_SetItemString(gca_kwargs, "projection", PyString_FromString("3d"));
+
+    PyObject * gca = PyObject_GetAttrString(fig, "gca");
+    if (!gca) {throw std::runtime_error("No gca");}
+    Py_INCREF(gca);
+    PyObject * axis = PyObject_Call(
+      gca, detail::_interpreter::get().s_python_empty_tuple, gca_kwargs);
+
+    if (!axis) {throw std::runtime_error("No axis");}
+    Py_INCREF(axis);
+
+    Py_DECREF(gca);
+    Py_DECREF(gca_kwargs);
+
+    PyObject * plot3 = PyObject_GetAttrString(axis, "plot");
+    if (!plot3) {throw std::runtime_error("No 3D line plot");}
+    Py_INCREF(plot3);
+    PyObject * res = PyObject_Call(plot3, args, kwargs);
+    if (!res) {throw std::runtime_error("Failed 3D line plot");}
+    Py_DECREF(plot3);
+
+    Py_DECREF(axis);
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+    if (res) {Py_DECREF(res);}
+  }
+
+  template &lt; typename Numeric &gt;
+  bool stem(
+    const std::vector &lt; Numeric &gt; &amp; x, const std::vector &lt; Numeric &gt; &amp; y,
+    const std::map &lt; std::string, std::string &gt; &amp; keywords)
+  {
+    assert(x.size() == y.size());
+
+    detail::_interpreter::get();
+
+    // using numpy arrays
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+
+    // construct positional args
+    PyObject * args = PyTuple_New(2);
+    PyTuple_SetItem(args, 0, xarray);
+    PyTuple_SetItem(args, 1, yarray);
@@ -698 +692,41 @@
-    PyObject* kwargs = PyDict_New();
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it =
+      keywords.begin(); it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(
+        kwargs, it-&gt;first.c_str(),
+        PyString_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_stem, args, kwargs);
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+    if (res) {
+      Py_DECREF(res);
+    }
+
+    return res;
+  }
+
+  template &lt; typename Numeric &gt;
+  bool fill(
+    const std::vector &lt; Numeric &gt; &amp; x, const std::vector &lt; Numeric &gt; &amp; y,
+    const std::map &lt; std::string, std::string &gt; &amp; keywords)
+  {
+    assert(x.size() == y.size());
+
+    detail::_interpreter::get();
+
+    // using numpy arrays
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+
+    // construct positional args
+    PyObject * args = PyTuple_New(2);
+    PyTuple_SetItem(args, 0, xarray);
+    PyTuple_SetItem(args, 1, yarray);
+
+    // construct keyword args
+    PyObject * kwargs = PyDict_New();
@@ -700,9 +734,10 @@
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_fill, args, kwargs);
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-
-    if (res) Py_DECREF(res);
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res =
+      PyObject_Call(detail::_interpreter::get().s_python_function_fill, args, kwargs);
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+
+    if (res) {Py_DECREF(res);}
@@ -711,5 +746,8 @@
-}
-
-template&lt; typename Numeric &gt;
-bool fill_between(const std::vector&lt;Numeric&gt;&amp; x, const std::vector&lt;Numeric&gt;&amp; y1, const std::vector&lt;Numeric&gt;&amp; y2, const std::map&lt;std::string, std::string&gt;&amp; keywords)
-{
+  }
+
+  template &lt; typename Numeric &gt;
+  bool fill_between(
+    const std::vector &lt; Numeric &gt; &amp; x, const std::vector &lt; Numeric &gt; &amp; y1,
+    const std::vector &lt; Numeric &gt; &amp; y2, const std::map &lt; std::string,
+    std::string &gt; &amp; keywords)
+  {
@@ -722,3 +760,3 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* y1array = detail::get_array(y1);
-    PyObject* y2array = detail::get_array(y2);
+    PyObject * xarray = detail::get_array(x);
+    PyObject * y1array = detail::get_array(y1);
+    PyObject * y2array = detail::get_array(y2);
@@ -727 +765 @@
-    PyObject* args = PyTuple_New(3);
+    PyObject * args = PyTuple_New(3);
@@ -733,10 +771,13 @@
-    PyObject* kwargs = PyDict_New();
-    for(std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin(); it != keywords.end(); ++it) {
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_fill_between, args, kwargs);
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-    if(res) Py_DECREF(res);
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_fill_between, args, kwargs);
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+    if (res) {Py_DECREF(res);}
@@ -745,11 +786,13 @@
-}
-
-template &lt;typename Numeric&gt;
-bool arrow(Numeric x, Numeric y, Numeric end_x, Numeric end_y, const std::string&amp; fc = "r",
-           const std::string ec = "k", Numeric head_length = 0.25, Numeric head_width = 0.1625) {
-    PyObject* obj_x = PyFloat_FromDouble(x);
-    PyObject* obj_y = PyFloat_FromDouble(y);
-    PyObject* obj_end_x = PyFloat_FromDouble(end_x);
-    PyObject* obj_end_y = PyFloat_FromDouble(end_y);
-
-    PyObject* kwargs = PyDict_New();
+  }
+
+  template &lt; typename Numeric &gt;
+  bool arrow(
+    Numeric x, Numeric y, Numeric end_x, Numeric end_y, const std::string &amp; fc = "r",
+    const std::string ec = "k", Numeric head_length = 0.25, Numeric head_width = 0.1625)
+  {
+    PyObject * obj_x = PyFloat_FromDouble(x);
+    PyObject * obj_y = PyFloat_FromDouble(y);
+    PyObject * obj_end_x = PyFloat_FromDouble(end_x);
+    PyObject * obj_end_y = PyFloat_FromDouble(end_y);
+
+    PyObject * kwargs = PyDict_New();
@@ -761 +804 @@
-    PyObject* plot_args = PyTuple_New(4);
+    PyObject * plot_args = PyTuple_New(4);
@@ -767,2 +810,2 @@
-    PyObject* res =
-            PyObject_Call(detail::_interpreter::get().s_python_function_arrow, plot_args, kwargs);
+    PyObject * res =
+      PyObject_Call(detail::_interpreter::get().s_python_function_arrow, plot_args, kwargs);
@@ -772,2 +815,3 @@
-    if (res)
-        Py_DECREF(res);
+    if (res) {
+      Py_DECREF(res);
+    }
@@ -776,11 +820,12 @@
-}
-
-template&lt; typename Numeric&gt;
-bool hist(const std::vector&lt;Numeric&gt;&amp; y, long bins=10,std::string color="b",
-          double alpha=1.0, bool cumulative=false)
-{
-    detail::_interpreter::get();
-
-    PyObject* yarray = detail::get_array(y);
-
-    PyObject* kwargs = PyDict_New();
+  }
+
+  template &lt; typename Numeric &gt;
+  bool hist(
+    const std::vector &lt; Numeric &gt; &amp; y, long bins = 10, std::string color = "b",
+    double alpha = 1.0, bool cumulative = false)
+  {
+    detail::_interpreter::get();
+
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * kwargs = PyDict_New();
@@ -792 +837 @@
-    PyObject* plot_args = PyTuple_New(1);
+    PyObject * plot_args = PyTuple_New(1);
@@ -797 +842,2 @@
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_hist, plot_args, kwargs);
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_hist, plot_args, kwargs);
@@ -802 +848 @@
-    if(res) Py_DECREF(res);
+    if (res) {Py_DECREF(res);}
@@ -805 +851 @@
-}
+  }
@@ -808,18 +854,22 @@
-namespace detail {
-
-inline void imshow(void *ptr, const NPY_TYPES type, const int rows, const int columns, const int colors, const std::map&lt;std::string, std::string&gt; &amp;keywords, PyObject** out)
-{
-    assert(type == NPY_UINT8 || type == NPY_FLOAT);
-    assert(colors == 1 || colors == 3 || colors == 4);
-
-    detail::_interpreter::get();
-
-    // construct args
-    npy_intp dims[3] = { rows, columns, colors };
-    PyObject *args = PyTuple_New(1);
-    PyTuple_SetItem(args, 0, PyArray_SimpleNewFromData(colors == 1 ? 2 : 3, dims, type, ptr));
-
-    // construct keyword args
-    PyObject* kwargs = PyDict_New();
-    for(std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
-    {
+  namespace detail {
+
+    inline void imshow(
+      void * ptr, const NPY_TYPES type, const int rows, const int columns,
+      const int colors, const std::map &lt; std::string, std::string &gt; &amp; keywords,
+      PyObject ** out)
+    {
+      assert(type == NPY_UINT8 || type == NPY_FLOAT);
+      assert(colors == 1 || colors == 3 || colors == 4);
+
+      detail::_interpreter::get();
+
+      // construct args
+      npy_intp dims[3] = {rows, columns, colors};
+      PyObject * args = PyTuple_New(1);
+      PyTuple_SetItem(args, 0, PyArray_SimpleNewFromData(colors == 1 ? 2 : 3, dims, type, ptr));
+
+      // construct keyword args
+      PyObject * kwargs = PyDict_New();
+      for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+        it != keywords.end(); ++it)
+      {
@@ -827,6 +877,7 @@
-    }
-
-    PyObject *res = PyObject_Call(detail::_interpreter::get().s_python_function_imshow, args, kwargs);
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-    if (!res)
+      }
+
+      PyObject * res = PyObject_Call(
+        detail::_interpreter::get().s_python_function_imshow, args, kwargs);
+      Py_DECREF(args);
+      Py_DECREF(kwargs);
+      if (!res) {
@@ -834 +885,2 @@
-    if (out)
+      }
+      if (out) {
@@ -836 +888 @@
-    else
+      } else {
@@ -838,6 +890,10 @@
-}
-
-} // namespace detail
-
-inline void imshow(const unsigned char *ptr, const int rows, const int columns, const int colors, const std::map&lt;std::string, std::string&gt; &amp;keywords = {}, PyObject** out = nullptr)
-{
+      }
+    }
+
+  } // namespace detail
+
+  inline void imshow(
+    const unsigned char * ptr, const int rows, const int columns, const int colors,
+    const std::map &lt; std::string, std::string &gt; &amp; keywords = {},
+    PyObject ** out = nullptr)
+  {
@@ -845,4 +901,7 @@
-}
-
-inline void imshow(const float *ptr, const int rows, const int columns, const int colors, const std::map&lt;std::string, std::string&gt; &amp;keywords = {}, PyObject** out = nullptr)
-{
+  }
+
+  inline void imshow(
+    const float * ptr, const int rows, const int columns, const int colors,
+    const std::map &lt; std::string, std::string &gt; &amp; keywords = {},
+    PyObject ** out = nullptr)
+  {
@@ -850 +909 @@
-}
+  }
@@ -853,2 +912,2 @@
-void imshow(const cv::Mat &amp;image, const std::map&lt;std::string, std::string&gt; &amp;keywords = {})
-{
+  void imshow(const cv::Mat &amp; image, const std::map &lt; std::string, std::string &gt; &amp; keywords = {})
+  {
@@ -859 +918 @@
-    case CV_8U:
+      case CV_8U:
@@ -862 +921 @@
-    case CV_32F:
+      case CV_32F:
@@ -866 +925 @@
-    default:
+      default:
@@ -872 +931 @@
-    case 3:
+      case 3:
@@ -875 +934 @@
-    case 4:
+      case 4:
@@ -880 +939 @@
-}
+  }
@@ -884,6 +943,7 @@
-template&lt;typename NumericX, typename NumericY&gt;
-bool scatter(const std::vector&lt;NumericX&gt;&amp; x,
-             const std::vector&lt;NumericY&gt;&amp; y,
-             const double s=1.0, // The marker size in points**2
-             const std::map&lt;std::string, std::string&gt; &amp; keywords = {})
-{
+  template &lt; typename NumericX, typename NumericY &gt;
+  bool scatter(
+    const std::vector &lt; NumericX &gt; &amp; x,
+    const std::vector &lt; NumericY &gt; &amp; y,
+    const double s = 1.0,        // The marker size in points**2
+    const std::map &lt; std::string, std::string &gt; &amp; keywords = {})
+  {
@@ -894,4 +954,4 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
-
-    PyObject* kwargs = PyDict_New();
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * kwargs = PyDict_New();
@@ -899,6 +959,5 @@
-    for (const auto&amp; it : keywords)
-    {
-        PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));
-    }
-
-    PyObject* plot_args = PyTuple_New(2);
+    for (const auto &amp; it : keywords) {
+      PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));
+    }
+
+    PyObject * plot_args = PyTuple_New(2);
@@ -908 +967,2 @@
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_scatter, plot_args, kwargs);
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_scatter, plot_args, kwargs);
@@ -912 +972 @@
-    if(res) Py_DECREF(res);
+    if (res) {Py_DECREF(res);}
@@ -915,11 +975,12 @@
-}
-
-template&lt;typename Numeric&gt;
-bool boxplot(const std::vector&lt;std::vector&lt;Numeric&gt;&gt;&amp; data,
-             const std::vector&lt;std::string&gt;&amp; labels = {},
-             const std::map&lt;std::string, std::string&gt; &amp; keywords = {})
-{
-    detail::_interpreter::get();
-
-    PyObject* listlist = detail::get_listlist(data);
-    PyObject* args = PyTuple_New(1);
+  }
+
+  template &lt; typename Numeric &gt;
+  bool boxplot(
+    const std::vector &lt; std::vector &lt; Numeric &gt;&gt; &amp; data,
+    const std::vector &lt; std::string &gt; &amp; labels = {},
+    const std::map &lt; std::string, std::string &gt; &amp; keywords = {})
+  {
+    detail::_interpreter::get();
+
+    PyObject * listlist = detail::get_listlist(data);
+    PyObject * args = PyTuple_New(1);
@@ -928 +989 @@
-    PyObject* kwargs = PyDict_New();
+    PyObject * kwargs = PyDict_New();
@@ -932 +993 @@
-        PyDict_SetItemString(kwargs, "labels", detail::get_array(labels));
+      PyDict_SetItemString(kwargs, "labels", detail::get_array(labels));
@@ -936,11 +997,11 @@
-    for (const auto&amp; it : keywords)
-    {
-        PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_boxplot, args, kwargs);
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-
-    if(res) Py_DECREF(res);
+    for (const auto &amp; it : keywords) {
+      PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_boxplot, args, kwargs);
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+
+    if (res) {Py_DECREF(res);}
@@ -949,10 +1010,11 @@
-}
-
-template&lt;typename Numeric&gt;
-bool boxplot(const std::vector&lt;Numeric&gt;&amp; data,
-             const std::map&lt;std::string, std::string&gt; &amp; keywords = {})
-{
-    detail::_interpreter::get();
-
-    PyObject* vector = detail::get_array(data);
-    PyObject* args = PyTuple_New(1);
+  }
+
+  template &lt; typename Numeric &gt;
+  bool boxplot(
+    const std::vector &lt; Numeric &gt; &amp; data,
+    const std::map &lt; std::string, std::string &gt; &amp; keywords = {})
+  {
+    detail::_interpreter::get();
+
+    PyObject * vector = detail::get_array(data);
+    PyObject * args = PyTuple_New(1);
@@ -961,12 +1023,12 @@
-    PyObject* kwargs = PyDict_New();
-    for (const auto&amp; it : keywords)
-    {
-        PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_boxplot, args, kwargs);
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-
-    if(res) Py_DECREF(res);
+    PyObject * kwargs = PyDict_New();
+    for (const auto &amp; it : keywords) {
+      PyDict_SetItemString(kwargs, it.first.c_str(), PyString_FromString(it.second.c_str()));
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_boxplot, args, kwargs);
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+
+    if (res) {Py_DECREF(res);}
@@ -975,67 +1037,17 @@
-}
-
-template &lt;typename Numeric&gt;
-bool bar(const std::vector&lt;Numeric&gt; &amp;               x,
-         const std::vector&lt;Numeric&gt; &amp;               y,
-         std::string                                ec       = "black",
-         std::string                                ls       = "-",
-         double                                     lw       = 1.0,
-         const std::map&lt;std::string, std::string&gt; &amp; keywords = {})
-{
-  detail::_interpreter::get();
-
-  PyObject * xarray = detail::get_array(x);
-  PyObject * yarray = detail::get_array(y);
-
-  PyObject * kwargs = PyDict_New();
-
-  PyDict_SetItemString(kwargs, "ec", PyString_FromString(ec.c_str()));
-  PyDict_SetItemString(kwargs, "ls", PyString_FromString(ls.c_str()));
-  PyDict_SetItemString(kwargs, "lw", PyFloat_FromDouble(lw));
-
-  for (std::map&lt;std::string, std::string&gt;::const_iterator it =
-         keywords.begin();
-       it != keywords.end();
-       ++it) {
-    PyDict_SetItemString(
-      kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
-  }
-
-  PyObject * plot_args = PyTuple_New(2);
-  PyTuple_SetItem(plot_args, 0, xarray);
-  PyTuple_SetItem(plot_args, 1, yarray);
-
-  PyObject * res = PyObject_Call(
-    detail::_interpreter::get().s_python_function_bar, plot_args, kwargs);
-
-  Py_DECREF(plot_args);
-  Py_DECREF(kwargs);
-  if (res) Py_DECREF(res);
-
-  return res;
-}
-
-template &lt;typename Numeric&gt;
-bool bar(const std::vector&lt;Numeric&gt; &amp;               y,
-         std::string                                ec       = "black",
-         std::string                                ls       = "-",
-         double                                     lw       = 1.0,
-         const std::map&lt;std::string, std::string&gt; &amp; keywords = {})
-{
-  using T = typename std::remove_reference&lt;decltype(y)&gt;::type::value_type;
-
-  detail::_interpreter::get();
-
-  std::vector&lt;T&gt; x;
-  for (std::size_t i = 0; i &lt; y.size(); i++) { x.push_back(i); }
-
-  return bar(x, y, ec, ls, lw, keywords);
-}
-
-
-template&lt;typename Numeric&gt;
-bool barh(const std::vector&lt;Numeric&gt; &amp;x, const std::vector&lt;Numeric&gt; &amp;y, std::string ec = "black", std::string ls = "-", double lw = 1.0, const std::map&lt;std::string, std::string&gt; &amp;keywords = { }) {
-    PyObject *xarray = detail::get_array(x);
-    PyObject *yarray = detail::get_array(y);
-
-    PyObject *kwargs = PyDict_New();
+  }
+
+  template &lt; typename Numeric &gt;
+  bool bar(
+    const std::vector &lt; Numeric &gt; &amp; x,
+    const std::vector &lt; Numeric &gt; &amp; y,
+    std::string ec = "black",
+    std::string ls = "-",
+    double lw = 1.0,
+    const std::map &lt; std::string, std::string &gt; &amp; keywords = {})
+  {
+    detail::_interpreter::get();
+
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * kwargs = PyDict_New();
@@ -1047,5 +1059,10 @@
-    for (std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin(); it != keywords.end(); ++it) {
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject *plot_args = PyTuple_New(2);
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it =
+      keywords.begin();
+      it != keywords.end();
+      ++it)
+    {
+      PyDict_SetItemString(
+        kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * plot_args = PyTuple_New(2);
@@ -1055 +1072,2 @@
-    PyObject *res = PyObject_Call(detail::_interpreter::get().s_python_function_barh, plot_args, kwargs);
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_bar, plot_args, kwargs);
@@ -1059 +1077 @@
-    if (res) Py_DECREF(res);
+    if (res) {Py_DECREF(res);}
@@ -1062,18 +1080,50 @@
-}
-
-
-inline bool subplots_adjust(const std::map&lt;std::string, double&gt;&amp; keywords = {})
-{
-    detail::_interpreter::get();
-
-    PyObject* kwargs = PyDict_New();
-    for (std::map&lt;std::string, double&gt;::const_iterator it =
-            keywords.begin(); it != keywords.end(); ++it) {
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(),
-                             PyFloat_FromDouble(it-&gt;second));
-    }
-
-
-    PyObject* plot_args = PyTuple_New(0);
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_subplots_adjust, plot_args, kwargs);
+  }
+
+  template &lt; typename Numeric &gt;
+  bool bar(
+    const std::vector &lt; Numeric &gt; &amp; y,
+    std::string ec = "black",
+    std::string ls = "-",
+    double lw = 1.0,
+    const std::map &lt; std::string, std::string &gt; &amp; keywords = {})
+  {
+    using T = typename std::remove_reference &lt; decltype(y) &gt; ::type::value_type;
+
+    detail::_interpreter::get();
+
+    std::vector &lt; T &gt; x;
+    for (std::size_t i = 0; i &lt; y.size(); i++) {
+      x.push_back(i);
+    }
+
+    return bar(x, y, ec, ls, lw, keywords);
+  }
+
+
+  template &lt; typename Numeric &gt;
+  bool barh(
+    const std::vector &lt; Numeric &gt; &amp; x, const std::vector &lt; Numeric &gt; &amp; y,
+    std::string ec = "black", std::string ls = "-", double lw = 1.0,
+    const std::map &lt; std::string, std::string &gt; &amp; keywords = {})
+  {
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * kwargs = PyDict_New();
+
+    PyDict_SetItemString(kwargs, "ec", PyString_FromString(ec.c_str()));
+    PyDict_SetItemString(kwargs, "ls", PyString_FromString(ls.c_str()));
+    PyDict_SetItemString(kwargs, "lw", PyFloat_FromDouble(lw));
+
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * plot_args = PyTuple_New(2);
+    PyTuple_SetItem(plot_args, 0, xarray);
+    PyTuple_SetItem(plot_args, 1, yarray);
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_barh, plot_args, kwargs);
@@ -1083 +1133 @@
-    if(res) Py_DECREF(res);
+    if (res) {Py_DECREF(res);}
@@ -1086,10 +1136,39 @@
-}
-
-template&lt; typename Numeric&gt;
-bool named_hist(std::string label,const std::vector&lt;Numeric&gt;&amp; y, long bins=10, std::string color="b", double alpha=1.0)
-{
-    detail::_interpreter::get();
-
-    PyObject* yarray = detail::get_array(y);
-
-    PyObject* kwargs = PyDict_New();
+  }
+
+
+  inline bool subplots_adjust(const std::map &lt; std::string, double &gt; &amp; keywords = {})
+  {
+    detail::_interpreter::get();
+
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, double &gt; ::const_iterator it =
+      keywords.begin(); it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(
+        kwargs, it-&gt;first.c_str(),
+        PyFloat_FromDouble(it-&gt;second));
+    }
+
+
+    PyObject * plot_args = PyTuple_New(0);
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_subplots_adjust, plot_args, kwargs);
+
+    Py_DECREF(plot_args);
+    Py_DECREF(kwargs);
+    if (res) {Py_DECREF(res);}
+
+    return res;
+  }
+
+  template &lt; typename Numeric &gt;
+  bool named_hist(
+    std::string label, const std::vector &lt; Numeric &gt; &amp; y, long bins = 10,
+    std::string color = "b", double alpha = 1.0)
+  {
+    detail::_interpreter::get();
+
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * kwargs = PyDict_New();
@@ -1102 +1181 @@
-    PyObject* plot_args = PyTuple_New(1);
+    PyObject * plot_args = PyTuple_New(1);
@@ -1105 +1184,2 @@
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_hist, plot_args, kwargs);
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_hist, plot_args, kwargs);
@@ -1109 +1189 @@
-    if(res) Py_DECREF(res);
+    if (res) {Py_DECREF(res);}
@@ -1112,5 +1192,7 @@
-}
-
-template&lt;typename NumericX, typename NumericY&gt;
-bool plot(const std::vector&lt;NumericX&gt;&amp; x, const std::vector&lt;NumericY&gt;&amp; y, const std::string&amp; s = "")
-{
+  }
+
+  template &lt; typename NumericX, typename NumericY &gt;
+  bool plot(
+    const std::vector &lt; NumericX &gt; &amp; x, const std::vector &lt; NumericY &gt; &amp; y,
+    const std::string &amp; s = "")
+  {
@@ -1121,6 +1203,6 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
-
-    PyObject* pystring = PyString_FromString(s.c_str());
-
-    PyObject* plot_args = PyTuple_New(3);
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * pystring = PyString_FromString(s.c_str());
+
+    PyObject * plot_args = PyTuple_New(3);
@@ -1131 +1213,2 @@
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_plot, plot_args);
+    PyObject * res = PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_plot, plot_args);
@@ -1134 +1217 @@
-    if(res) Py_DECREF(res);
+    if (res) {Py_DECREF(res);}
@@ -1137,6 +1220,8 @@
-}
-
-template &lt;typename NumericX, typename NumericY, typename NumericZ&gt;
-bool contour(const std::vector&lt;NumericX&gt;&amp; x, const std::vector&lt;NumericY&gt;&amp; y,
-             const std::vector&lt;NumericZ&gt;&amp; z,
-             const std::map&lt;std::string, std::string&gt;&amp; keywords = {}) {
+  }
+
+  template &lt; typename NumericX, typename NumericY, typename NumericZ &gt;
+  bool contour(
+    const std::vector &lt; NumericX &gt; &amp; x, const std::vector &lt; NumericY &gt; &amp; y,
+    const std::vector &lt; NumericZ &gt; &amp; z,
+    const std::map &lt; std::string, std::string &gt; &amp; keywords = {})
+  {
@@ -1145,5 +1230,5 @@
-    PyObject* xarray = get_array(x);
-    PyObject* yarray = get_array(y);
-    PyObject* zarray = get_array(z);
-
-    PyObject* plot_args = PyTuple_New(3);
+    PyObject * xarray = get_array(x);
+    PyObject * yarray = get_array(y);
+    PyObject * zarray = get_array(z);
+
+    PyObject * plot_args = PyTuple_New(3);
@@ -1155,8 +1240,9 @@
-    PyObject* kwargs = PyDict_New();
-    for (std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin();
-         it != keywords.end(); ++it) {
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res =
-            PyObject_Call(detail::_interpreter::get().s_python_function_contour, plot_args, kwargs);
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res =
+      PyObject_Call(detail::_interpreter::get().s_python_function_contour, plot_args, kwargs);
@@ -1166,2 +1252,3 @@
-    if (res)
-        Py_DECREF(res);
+    if (res) {
+      Py_DECREF(res);
+    }
@@ -1170,5 +1257,8 @@
-}
-
-template&lt;typename NumericX, typename NumericY, typename NumericU, typename NumericW&gt;
-bool quiver(const std::vector&lt;NumericX&gt;&amp; x, const std::vector&lt;NumericY&gt;&amp; y, const std::vector&lt;NumericU&gt;&amp; u, const std::vector&lt;NumericW&gt;&amp; w, const std::map&lt;std::string, std::string&gt;&amp; keywords = {})
-{
+  }
+
+  template &lt; typename NumericX, typename NumericY, typename NumericU, typename NumericW &gt;
+  bool quiver(
+    const std::vector &lt; NumericX &gt; &amp; x, const std::vector &lt; NumericY &gt; &amp; y,
+    const std::vector &lt; NumericU &gt; &amp; u, const std::vector &lt; NumericW &gt; &amp; w,
+    const std::map &lt; std::string, std::string &gt; &amp; keywords = {})
+  {
@@ -1179,6 +1269,6 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
-    PyObject* uarray = detail::get_array(u);
-    PyObject* warray = detail::get_array(w);
-
-    PyObject* plot_args = PyTuple_New(4);
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+    PyObject * uarray = detail::get_array(u);
+    PyObject * warray = detail::get_array(w);
+
+    PyObject * plot_args = PyTuple_New(4);
@@ -1191,8 +1281,9 @@
-    PyObject* kwargs = PyDict_New();
-    for(std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
-    {
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(
-            detail::_interpreter::get().s_python_function_quiver, plot_args, kwargs);
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_quiver, plot_args, kwargs);
@@ -1202,2 +1293,3 @@
-    if (res)
-        Py_DECREF(res);
+    if (res) {
+      Py_DECREF(res);
+    }
@@ -1206,5 +1298,7 @@
-}
-
-template&lt;typename NumericX, typename NumericY&gt;
-bool stem(const std::vector&lt;NumericX&gt;&amp; x, const std::vector&lt;NumericY&gt;&amp; y, const std::string&amp; s = "")
-{
+  }
+
+  template &lt; typename NumericX, typename NumericY &gt;
+  bool stem(
+    const std::vector &lt; NumericX &gt; &amp; x, const std::vector &lt; NumericY &gt; &amp; y,
+    const std::string &amp; s = "")
+  {
@@ -1215,6 +1309,6 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
-
-    PyObject* pystring = PyString_FromString(s.c_str());
-
-    PyObject* plot_args = PyTuple_New(3);
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * pystring = PyString_FromString(s.c_str());
+
+    PyObject * plot_args = PyTuple_New(3);
@@ -1225,2 +1319,2 @@
-    PyObject* res = PyObject_CallObject(
-            detail::_interpreter::get().s_python_function_stem, plot_args);
+    PyObject * res = PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_stem, plot_args);
@@ -1229,2 +1323,3 @@
-    if (res)
-        Py_DECREF(res);
+    if (res) {
+      Py_DECREF(res);
+    }
@@ -1233,5 +1328,7 @@
-}
-
-template&lt;typename NumericX, typename NumericY&gt;
-bool semilogx(const std::vector&lt;NumericX&gt;&amp; x, const std::vector&lt;NumericY&gt;&amp; y, const std::string&amp; s = "")
-{
+  }
+
+  template &lt; typename NumericX, typename NumericY &gt;
+  bool semilogx(
+    const std::vector &lt; NumericX &gt; &amp; x, const std::vector &lt; NumericY &gt; &amp; y,
+    const std::string &amp; s = "")
+  {
@@ -1242,6 +1339,6 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
-
-    PyObject* pystring = PyString_FromString(s.c_str());
-
-    PyObject* plot_args = PyTuple_New(3);
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * pystring = PyString_FromString(s.c_str());
+
+    PyObject * plot_args = PyTuple_New(3);
@@ -1252 +1349,2 @@
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_semilogx, plot_args);
+    PyObject * res = PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_semilogx, plot_args);
@@ -1255 +1353 @@
-    if(res) Py_DECREF(res);
+    if (res) {Py_DECREF(res);}
@@ -1258,5 +1356,7 @@
-}
-
-template&lt;typename NumericX, typename NumericY&gt;
-bool semilogy(const std::vector&lt;NumericX&gt;&amp; x, const std::vector&lt;NumericY&gt;&amp; y, const std::string&amp; s = "")
-{
+  }
+
+  template &lt; typename NumericX, typename NumericY &gt;
+  bool semilogy(
+    const std::vector &lt; NumericX &gt; &amp; x, const std::vector &lt; NumericY &gt; &amp; y,
+    const std::string &amp; s = "")
+  {
@@ -1267,6 +1367,6 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
-
-    PyObject* pystring = PyString_FromString(s.c_str());
-
-    PyObject* plot_args = PyTuple_New(3);
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * pystring = PyString_FromString(s.c_str());
+
+    PyObject * plot_args = PyTuple_New(3);
@@ -1277 +1377,2 @@
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_semilogy, plot_args);
+    PyObject * res = PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_semilogy, plot_args);
@@ -1280 +1381 @@
-    if(res) Py_DECREF(res);
+    if (res) {Py_DECREF(res);}
@@ -1283,5 +1384,7 @@
-}
-
-template&lt;typename NumericX, typename NumericY&gt;
-bool loglog(const std::vector&lt;NumericX&gt;&amp; x, const std::vector&lt;NumericY&gt;&amp; y, const std::string&amp; s = "")
-{
+  }
+
+  template &lt; typename NumericX, typename NumericY &gt;
+  bool loglog(
+    const std::vector &lt; NumericX &gt; &amp; x, const std::vector &lt; NumericY &gt; &amp; y,
+    const std::string &amp; s = "")
+  {
@@ -1292,6 +1395,6 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
-
-    PyObject* pystring = PyString_FromString(s.c_str());
-
-    PyObject* plot_args = PyTuple_New(3);
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * pystring = PyString_FromString(s.c_str());
+
+    PyObject * plot_args = PyTuple_New(3);
@@ -1302 +1405,2 @@
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_loglog, plot_args);
+    PyObject * res = PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_loglog, plot_args);
@@ -1305 +1409 @@
-    if(res) Py_DECREF(res);
+    if (res) {Py_DECREF(res);}
@@ -1308,5 +1412,8 @@
-}
-
-template&lt;typename NumericX, typename NumericY&gt;
-bool errorbar(const std::vector&lt;NumericX&gt; &amp;x, const std::vector&lt;NumericY&gt; &amp;y, const std::vector&lt;NumericX&gt; &amp;yerr, const std::map&lt;std::string, std::string&gt; &amp;keywords = {})
-{
+  }
+
+  template &lt; typename NumericX, typename NumericY &gt;
+  bool errorbar(
+    const std::vector &lt; NumericX &gt; &amp; x, const std::vector &lt; NumericY &gt; &amp; y,
+    const std::vector &lt; NumericX &gt; &amp; yerr, const std::map &lt; std::string,
+    std::string &gt; &amp; keywords = {})
+  {
@@ -1317,3 +1424,3 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
-    PyObject* yerrarray = detail::get_array(yerr);
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+    PyObject * yerrarray = detail::get_array(yerr);
@@ -1322,4 +1429,5 @@
-    PyObject* kwargs = PyDict_New();
-    for(std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
-    {
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
@@ -1330 +1438 @@
-    PyObject *plot_args = PyTuple_New(2);
+    PyObject * plot_args = PyTuple_New(2);
@@ -1334 +1442,2 @@
-    PyObject *res = PyObject_Call(detail::_interpreter::get().s_python_function_errorbar, plot_args, kwargs);
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_errorbar, plot_args, kwargs);
@@ -1339,4 +1448,5 @@
-    if (res)
-        Py_DECREF(res);
-    else
-        throw std::runtime_error("Call to errorbar() failed.");
+    if (res) {
+      Py_DECREF(res);
+    } else {
+      throw std::runtime_error("Call to errorbar() failed.");
+    }
@@ -1345,8 +1455,10 @@
-}
-
-template&lt;typename Numeric&gt;
-bool named_plot(const std::string&amp; name, const std::vector&lt;Numeric&gt;&amp; y, const std::string&amp; format = "")
-{
-    detail::_interpreter::get();
-
-    PyObject* kwargs = PyDict_New();
+  }
+
+  template &lt; typename Numeric &gt;
+  bool named_plot(
+    const std::string &amp; name, const std::vector &lt; Numeric &gt; &amp; y,
+    const std::string &amp; format = "")
+  {
+    detail::_interpreter::get();
+
+    PyObject * kwargs = PyDict_New();
@@ -1355,5 +1467,5 @@
-    PyObject* yarray = detail::get_array(y);
-
-    PyObject* pystring = PyString_FromString(format.c_str());
-
-    PyObject* plot_args = PyTuple_New(2);
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * pystring = PyString_FromString(format.c_str());
+
+    PyObject * plot_args = PyTuple_New(2);
@@ -1364 +1476,2 @@
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);
@@ -1368 +1481 @@
-    if (res) Py_DECREF(res);
+    if (res) {Py_DECREF(res);}
@@ -1371,8 +1484,10 @@
-}
-
-template&lt;typename Numeric&gt;
-bool named_plot(const std::string&amp; name, const std::vector&lt;Numeric&gt;&amp; x, const std::vector&lt;Numeric&gt;&amp; y, const std::string&amp; format = "")
-{
-    detail::_interpreter::get();
-
-    PyObject* kwargs = PyDict_New();
+  }
+
+  template &lt; typename Numeric &gt;
+  bool named_plot(
+    const std::string &amp; name, const std::vector &lt; Numeric &gt; &amp; x,
+    const std::vector &lt; Numeric &gt; &amp; y, const std::string &amp; format = "")
+  {
+    detail::_interpreter::get();
+
+    PyObject * kwargs = PyDict_New();
@@ -1381,6 +1496,6 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
-
-    PyObject* pystring = PyString_FromString(format.c_str());
-
-    PyObject* plot_args = PyTuple_New(3);
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * pystring = PyString_FromString(format.c_str());
+
+    PyObject * plot_args = PyTuple_New(3);
@@ -1391 +1506,2 @@
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);
@@ -1395 +1511 @@
-    if (res) Py_DECREF(res);
+    if (res) {Py_DECREF(res);}
@@ -1398,8 +1514,10 @@
-}
-
-template&lt;typename Numeric&gt;
-bool named_semilogx(const std::string&amp; name, const std::vector&lt;Numeric&gt;&amp; x, const std::vector&lt;Numeric&gt;&amp; y, const std::string&amp; format = "")
-{
-    detail::_interpreter::get();
-
-    PyObject* kwargs = PyDict_New();
+  }
+
+  template &lt; typename Numeric &gt;
+  bool named_semilogx(
+    const std::string &amp; name, const std::vector &lt; Numeric &gt; &amp; x,
+    const std::vector &lt; Numeric &gt; &amp; y, const std::string &amp; format = "")
+  {
+    detail::_interpreter::get();
+
+    PyObject * kwargs = PyDict_New();
@@ -1408,6 +1526,6 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
-
-    PyObject* pystring = PyString_FromString(format.c_str());
-
-    PyObject* plot_args = PyTuple_New(3);
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * pystring = PyString_FromString(format.c_str());
+
+    PyObject * plot_args = PyTuple_New(3);
@@ -1418 +1536,2 @@
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_semilogx, plot_args, kwargs);
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_semilogx, plot_args, kwargs);
@@ -1422 +1541 @@
-    if (res) Py_DECREF(res);
+    if (res) {Py_DECREF(res);}
@@ -1425,8 +1544,10 @@
-}
-
-template&lt;typename Numeric&gt;
-bool named_semilogy(const std::string&amp; name, const std::vector&lt;Numeric&gt;&amp; x, const std::vector&lt;Numeric&gt;&amp; y, const std::string&amp; format = "")
-{
-    detail::_interpreter::get();
-
-    PyObject* kwargs = PyDict_New();
+  }
+
+  template &lt; typename Numeric &gt;
+  bool named_semilogy(
+    const std::string &amp; name, const std::vector &lt; Numeric &gt; &amp; x,
+    const std::vector &lt; Numeric &gt; &amp; y, const std::string &amp; format = "")
+  {
+    detail::_interpreter::get();
+
+    PyObject * kwargs = PyDict_New();
@@ -1435,6 +1556,6 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
-
-    PyObject* pystring = PyString_FromString(format.c_str());
-
-    PyObject* plot_args = PyTuple_New(3);
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * pystring = PyString_FromString(format.c_str());
+
+    PyObject * plot_args = PyTuple_New(3);
@@ -1445 +1566,2 @@
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_semilogy, plot_args, kwargs);
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_semilogy, plot_args, kwargs);
@@ -1449 +1571 @@
-    if (res) Py_DECREF(res);
+    if (res) {Py_DECREF(res);}
@@ -1452,8 +1574,10 @@
-}
-
-template&lt;typename Numeric&gt;
-bool named_loglog(const std::string&amp; name, const std::vector&lt;Numeric&gt;&amp; x, const std::vector&lt;Numeric&gt;&amp; y, const std::string&amp; format = "")
-{
-    detail::_interpreter::get();
-
-    PyObject* kwargs = PyDict_New();
+  }
+
+  template &lt; typename Numeric &gt;
+  bool named_loglog(
+    const std::string &amp; name, const std::vector &lt; Numeric &gt; &amp; x,
+    const std::vector &lt; Numeric &gt; &amp; y, const std::string &amp; format = "")
+  {
+    detail::_interpreter::get();
+
+    PyObject * kwargs = PyDict_New();
@@ -1462,6 +1586,6 @@
-    PyObject* xarray = detail::get_array(x);
-    PyObject* yarray = detail::get_array(y);
-
-    PyObject* pystring = PyString_FromString(format.c_str());
-
-    PyObject* plot_args = PyTuple_New(3);
+    PyObject * xarray = detail::get_array(x);
+    PyObject * yarray = detail::get_array(y);
+
+    PyObject * pystring = PyString_FromString(format.c_str());
+
+    PyObject * plot_args = PyTuple_New(3);
@@ -1471 +1595,2 @@
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_loglog, plot_args, kwargs);
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_loglog, plot_args, kwargs);
@@ -1475 +1600 @@
-    if (res) Py_DECREF(res);
+    if (res) {Py_DECREF(res);}
@@ -1478,23 +1603,31 @@
-}
-
-template&lt;typename Numeric&gt;
-bool plot(const std::vector&lt;Numeric&gt;&amp; y, const std::string&amp; format = "")
-{
-    std::vector&lt;Numeric&gt; x(y.size());
-    for(size_t i=0; i&lt;x.size(); ++i) x.at(i) = i;
-    return plot(x,y,format);
-}
-
-template&lt;typename Numeric&gt;
-bool plot(const std::vector&lt;Numeric&gt;&amp; y, const std::map&lt;std::string, std::string&gt;&amp; keywords)
-{
-    std::vector&lt;Numeric&gt; x(y.size());
-    for(size_t i=0; i&lt;x.size(); ++i) x.at(i) = i;
-    return plot(x,y,keywords);
-}
-
-template&lt;typename Numeric&gt;
-bool stem(const std::vector&lt;Numeric&gt;&amp; y, const std::string&amp; format = "")
-{
-    std::vector&lt;Numeric&gt; x(y.size());
-    for (size_t i = 0; i &lt; x.size(); ++i) x.at(i) = i;
+  }
+
+  template &lt; typename Numeric &gt;
+  bool plot(const std::vector &lt; Numeric &gt; &amp; y, const std::string &amp; format = "")
+  {
+    std::vector &lt; Numeric &gt; x(y.size());
+    for (size_t i = 0; i &lt; x.size(); ++i) {
+      x.at(i) = i;
+    }
+    return plot(x, y, format);
+  }
+
+  template &lt; typename Numeric &gt;
+  bool plot(
+    const std::vector &lt; Numeric &gt; &amp; y, const std::map &lt; std::string,
+    std::string &gt; &amp; keywords)
+  {
+    std::vector &lt; Numeric &gt; x(y.size());
+    for (size_t i = 0; i &lt; x.size(); ++i) {
+      x.at(i) = i;
+    }
+    return plot(x, y, keywords);
+  }
+
+  template &lt; typename Numeric &gt;
+  bool stem(const std::vector &lt; Numeric &gt; &amp; y, const std::string &amp; format = "")
+  {
+    std::vector &lt; Numeric &gt; x(y.size());
+    for (size_t i = 0; i &lt; x.size(); ++i) {
+      x.at(i) = i;
+    }
@@ -1502,8 +1635,8 @@
-}
-
-template&lt;typename Numeric&gt;
-void text(Numeric x, Numeric y, const std::string&amp; s = "")
-{
-    detail::_interpreter::get();
-
-    PyObject* args = PyTuple_New(3);
+  }
+
+  template &lt; typename Numeric &gt;
+  void text(Numeric x, Numeric y, const std::string &amp; s = "")
+  {
+    detail::_interpreter::get();
+
+    PyObject * args = PyTuple_New(3);
@@ -1514,15 +1647,19 @@
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_text, args);
-    if(!res) throw std::runtime_error("Call to text() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(res);
-}
-
-inline void colorbar(PyObject* mappable = NULL, const std::map&lt;std::string, float&gt;&amp; keywords = {})
-{
-    if (mappable == NULL)
-        throw std::runtime_error("Must call colorbar with PyObject* returned from an image, contour, surface, etc.");
-
-    detail::_interpreter::get();
-
-    PyObject* args = PyTuple_New(1);
+    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_text, args);
+    if (!res) {throw std::runtime_error("Call to text() failed.");}
+
+    Py_DECREF(args);
+    Py_DECREF(res);
+  }
+
+  inline void colorbar(
+    PyObject * mappable = NULL, const std::map &lt; std::string,
+    float &gt; &amp; keywords = {})
+  {
+    if (mappable == NULL) {
+      throw std::runtime_error(
+        "Must call colorbar with PyObject* returned from an image, contour, surface, etc.");
+    }
+
+    detail::_interpreter::get();
+
+    PyObject * args = PyTuple_New(1);
@@ -1531,38 +1668,42 @@
-    PyObject* kwargs = PyDict_New();
-    for(std::map&lt;std::string, float&gt;::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
-    {
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyFloat_FromDouble(it-&gt;second));
-    }
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_colorbar, args, kwargs);
-    if(!res) throw std::runtime_error("Call to colorbar() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-    Py_DECREF(res);
-}
-
-
-inline long figure(long number = -1)
-{
-    detail::_interpreter::get();
-
-    PyObject *res;
-    if (number == -1)
-        res = PyObject_CallObject(detail::_interpreter::get().s_python_function_figure, detail::_interpreter::get().s_python_empty_tuple);
-    else {
-        assert(number &gt; 0);
-
-        // Make sure interpreter is initialised
-        detail::_interpreter::get();
-
-        PyObject *args = PyTuple_New(1);
-        PyTuple_SetItem(args, 0, PyLong_FromLong(number));
-        res = PyObject_CallObject(detail::_interpreter::get().s_python_function_figure, args);
-        Py_DECREF(args);
-    }
-
-    if(!res) throw std::runtime_error("Call to figure() failed.");
-
-    PyObject* num = PyObject_GetAttrString(res, "number");
-    if (!num) throw std::runtime_error("Could not get number attribute of figure object");
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, float &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyFloat_FromDouble(it-&gt;second));
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_colorbar, args, kwargs);
+    if (!res) {throw std::runtime_error("Call to colorbar() failed.");}
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+    Py_DECREF(res);
+  }
+
+
+  inline long figure(long number = -1)
+  {
+    detail::_interpreter::get();
+
+    PyObject * res;
+    if (number == -1) {
+      res = PyObject_CallObject(
+        detail::_interpreter::get().s_python_function_figure,
+        detail::_interpreter::get().s_python_empty_tuple);
+    } else {
+      assert(number &gt; 0);
+
+      // Make sure interpreter is initialised
+      detail::_interpreter::get();
+
+      PyObject * args = PyTuple_New(1);
+      PyTuple_SetItem(args, 0, PyLong_FromLong(number));
+      res = PyObject_CallObject(detail::_interpreter::get().s_python_function_figure, args);
+      Py_DECREF(args);
+    }
+
+    if (!res) {throw std::runtime_error("Call to figure() failed.");}
+
+    PyObject * num = PyObject_GetAttrString(res, "number");
+    if (!num) {throw std::runtime_error("Could not get number attribute of figure object");}
@@ -1575,7 +1716,7 @@
-}
-
-inline bool fignum_exists(long number)
-{
-    detail::_interpreter::get();
-
-    PyObject *args = PyTuple_New(1);
+  }
+
+  inline bool fignum_exists(long number)
+  {
+    detail::_interpreter::get();
+
+    PyObject * args = PyTuple_New(1);
@@ -1583,2 +1724,3 @@
-    PyObject *res = PyObject_CallObject(detail::_interpreter::get().s_python_function_fignum_exists, args);
-    if(!res) throw std::runtime_error("Call to fignum_exists() failed.");
+    PyObject * res = PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_fignum_exists, args);
+    if (!res) {throw std::runtime_error("Call to fignum_exists() failed.");}
@@ -1591,4 +1733,4 @@
-}
-
-inline void figure_size(size_t w, size_t h)
-{
+  }
+
+  inline void figure_size(size_t w, size_t h)
+  {
@@ -1598 +1740 @@
-    PyObject* size = PyTuple_New(2);
+    PyObject * size = PyTuple_New(2);
@@ -1602 +1744 @@
-    PyObject* kwargs = PyDict_New();
+    PyObject * kwargs = PyDict_New();
@@ -1606,43 +1748,49 @@
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_figure,
-            detail::_interpreter::get().s_python_empty_tuple, kwargs);
-
-    Py_DECREF(kwargs);
-
-    if(!res) throw std::runtime_error("Call to figure_size() failed.");
-    Py_DECREF(res);
-}
-
-inline void legend()
-{
-    detail::_interpreter::get();
-
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_legend, detail::_interpreter::get().s_python_empty_tuple);
-    if(!res) throw std::runtime_error("Call to legend() failed.");
-
-    Py_DECREF(res);
-}
-
-inline void legend(const std::map&lt;std::string, std::string&gt;&amp; keywords)
-{
-  detail::_interpreter::get();
-
-  // construct keyword args
-  PyObject* kwargs = PyDict_New();
-  for(std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
-  {
-    PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
-  }
-
-  PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_legend, detail::_interpreter::get().s_python_empty_tuple, kwargs);
-  if(!res) throw std::runtime_error("Call to legend() failed.");
-
-  Py_DECREF(kwargs);
-  Py_DECREF(res);  
-}
-
-template&lt;typename Numeric&gt;
-void ylim(Numeric left, Numeric right)
-{
-    detail::_interpreter::get();
-
-    PyObject* list = PyList_New(2);
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_figure,
+      detail::_interpreter::get().s_python_empty_tuple, kwargs);
+
+    Py_DECREF(kwargs);
+
+    if (!res) {throw std::runtime_error("Call to figure_size() failed.");}
+    Py_DECREF(res);
+  }
+
+  inline void legend()
+  {
+    detail::_interpreter::get();
+
+    PyObject * res = PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_legend,
+      detail::_interpreter::get().s_python_empty_tuple);
+    if (!res) {throw std::runtime_error("Call to legend() failed.");}
+
+    Py_DECREF(res);
+  }
+
+  inline void legend(const std::map &lt; std::string, std::string &gt; &amp; keywords)
+  {
+    detail::_interpreter::get();
+
+    // construct keyword args
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_legend,
+      detail::_interpreter::get().s_python_empty_tuple, kwargs);
+    if (!res) {throw std::runtime_error("Call to legend() failed.");}
+
+    Py_DECREF(kwargs);
+    Py_DECREF(res);
+  }
+
+  template &lt; typename Numeric &gt;
+  void ylim(Numeric left, Numeric right)
+  {
+    detail::_interpreter::get();
+
+    PyObject * list = PyList_New(2);
@@ -1652 +1800 @@
-    PyObject* args = PyTuple_New(1);
+    PyObject * args = PyTuple_New(1);
@@ -1655,13 +1803,13 @@
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_ylim, args);
-    if(!res) throw std::runtime_error("Call to ylim() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(res);
-}
-
-template&lt;typename Numeric&gt;
-void xlim(Numeric left, Numeric right)
-{
-    detail::_interpreter::get();
-
-    PyObject* list = PyList_New(2);
+    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_ylim, args);
+    if (!res) {throw std::runtime_error("Call to ylim() failed.");}
+
+    Py_DECREF(args);
+    Py_DECREF(res);
+  }
+
+  template &lt; typename Numeric &gt;
+  void xlim(Numeric left, Numeric right)
+  {
+    detail::_interpreter::get();
+
+    PyObject * list = PyList_New(2);
@@ -1671 +1819 @@
-    PyObject* args = PyTuple_New(1);
+    PyObject * args = PyTuple_New(1);
@@ -1674,18 +1822,18 @@
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_xlim, args);
-    if(!res) throw std::runtime_error("Call to xlim() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(res);
-}
-
-
-inline double* xlim()
-{
-    detail::_interpreter::get();
-
-    PyObject* args = PyTuple_New(0);
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_xlim, args);
-    PyObject* left = PyTuple_GetItem(res,0);
-    PyObject* right = PyTuple_GetItem(res,1);
-
-    double* arr = new double[2];
+    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_xlim, args);
+    if (!res) {throw std::runtime_error("Call to xlim() failed.");}
+
+    Py_DECREF(args);
+    Py_DECREF(res);
+  }
+
+
+  inline double * xlim()
+  {
+    detail::_interpreter::get();
+
+    PyObject * args = PyTuple_New(0);
+    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_xlim, args);
+    PyObject * left = PyTuple_GetItem(res, 0);
+    PyObject * right = PyTuple_GetItem(res, 1);
+
+    double * arr = new double[2];
@@ -1695 +1843 @@
-    if(!res) throw std::runtime_error("Call to xlim() failed.");
+    if (!res) {throw std::runtime_error("Call to xlim() failed.");}
@@ -1699,13 +1847,13 @@
-}
-
-
-inline double* ylim()
-{
-    detail::_interpreter::get();
-
-    PyObject* args = PyTuple_New(0);
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_ylim, args);
-    PyObject* left = PyTuple_GetItem(res,0);
-    PyObject* right = PyTuple_GetItem(res,1);
-
-    double* arr = new double[2];
+  }
+
+
+  inline double * ylim()
+  {
+    detail::_interpreter::get();
+
+    PyObject * args = PyTuple_New(0);
+    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_ylim, args);
+    PyObject * left = PyTuple_GetItem(res, 0);
+    PyObject * right = PyTuple_GetItem(res, 1);
+
+    double * arr = new double[2];
@@ -1715 +1863 @@
-    if(!res) throw std::runtime_error("Call to ylim() failed.");
+    if (!res) {throw std::runtime_error("Call to ylim() failed.");}
@@ -1719,5 +1867,8 @@
-}
-
-template&lt;typename Numeric&gt;
-inline void xticks(const std::vector&lt;Numeric&gt; &amp;ticks, const std::vector&lt;std::string&gt; &amp;labels = {}, const std::map&lt;std::string, std::string&gt;&amp; keywords = {})
-{
+  }
+
+  template &lt; typename Numeric &gt;
+  inline void xticks(
+    const std::vector &lt; Numeric &gt; &amp; ticks,
+    const std::vector &lt; std::string &gt; &amp; labels = {}, const std::map &lt; std::string,
+    std::string &gt; &amp; keywords = {})
+  {
@@ -1729,7 +1880,7 @@
-    PyObject* ticksarray = detail::get_array(ticks);
-
-    PyObject* args;
-    if(labels.size() == 0) {
-        // construct positional args
-        args = PyTuple_New(1);
-        PyTuple_SetItem(args, 0, ticksarray);
+    PyObject * ticksarray = detail::get_array(ticks);
+
+    PyObject * args;
+    if (labels.size() == 0) {
+      // construct positional args
+      args = PyTuple_New(1);
+      PyTuple_SetItem(args, 0, ticksarray);
@@ -1737,9 +1888,10 @@
-        // make tuple of tick labels
-        PyObject* labelstuple = PyTuple_New(labels.size());
-        for (size_t i = 0; i &lt; labels.size(); i++)
-            PyTuple_SetItem(labelstuple, i, PyUnicode_FromString(labels[i].c_str()));
-
-        // construct positional args
-        args = PyTuple_New(2);
-        PyTuple_SetItem(args, 0, ticksarray);
-        PyTuple_SetItem(args, 1, labelstuple);
+      // make tuple of tick labels
+      PyObject * labelstuple = PyTuple_New(labels.size());
+      for (size_t i = 0; i &lt; labels.size(); i++) {
+        PyTuple_SetItem(labelstuple, i, PyUnicode_FromString(labels[i].c_str()));
+      }
+
+      // construct positional args
+      args = PyTuple_New(2);
+      PyTuple_SetItem(args, 0, ticksarray);
+      PyTuple_SetItem(args, 1, labelstuple);
@@ -1749,18 +1901,22 @@
-    PyObject* kwargs = PyDict_New();
-    for(std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
-    {
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_xticks, args, kwargs);
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-    if(!res) throw std::runtime_error("Call to xticks() failed");
-
-    Py_DECREF(res);
-}
-
-template&lt;typename Numeric&gt;
-inline void xticks(const std::vector&lt;Numeric&gt; &amp;ticks, const std::map&lt;std::string, std::string&gt;&amp; keywords)
-{
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_xticks, args, kwargs);
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+    if (!res) {throw std::runtime_error("Call to xticks() failed");}
+
+    Py_DECREF(res);
+  }
+
+  template &lt; typename Numeric &gt;
+  inline void xticks(
+    const std::vector &lt; Numeric &gt; &amp; ticks, const std::map &lt; std::string,
+    std::string &gt; &amp; keywords)
+  {
@@ -1768,5 +1924,8 @@
-}
-
-template&lt;typename Numeric&gt;
-inline void yticks(const std::vector&lt;Numeric&gt; &amp;ticks, const std::vector&lt;std::string&gt; &amp;labels = {}, const std::map&lt;std::string, std::string&gt;&amp; keywords = {})
-{
+  }
+
+  template &lt; typename Numeric &gt;
+  inline void yticks(
+    const std::vector &lt; Numeric &gt; &amp; ticks,
+    const std::vector &lt; std::string &gt; &amp; labels = {}, const std::map &lt; std::string,
+    std::string &gt; &amp; keywords = {})
+  {
@@ -1778,7 +1937,7 @@
-    PyObject* ticksarray = detail::get_array(ticks);
-
-    PyObject* args;
-    if(labels.size() == 0) {
-        // construct positional args
-        args = PyTuple_New(1);
-        PyTuple_SetItem(args, 0, ticksarray);
+    PyObject * ticksarray = detail::get_array(ticks);
+
+    PyObject * args;
+    if (labels.size() == 0) {
+      // construct positional args
+      args = PyTuple_New(1);
+      PyTuple_SetItem(args, 0, ticksarray);
@@ -1786,9 +1945,10 @@
-        // make tuple of tick labels
-        PyObject* labelstuple = PyTuple_New(labels.size());
-        for (size_t i = 0; i &lt; labels.size(); i++)
-            PyTuple_SetItem(labelstuple, i, PyUnicode_FromString(labels[i].c_str()));
-
-        // construct positional args
-        args = PyTuple_New(2);
-        PyTuple_SetItem(args, 0, ticksarray);
-        PyTuple_SetItem(args, 1, labelstuple);
+      // make tuple of tick labels
+      PyObject * labelstuple = PyTuple_New(labels.size());
+      for (size_t i = 0; i &lt; labels.size(); i++) {
+        PyTuple_SetItem(labelstuple, i, PyUnicode_FromString(labels[i].c_str()));
+      }
+
+      // construct positional args
+      args = PyTuple_New(2);
+      PyTuple_SetItem(args, 0, ticksarray);
+      PyTuple_SetItem(args, 1, labelstuple);
@@ -1798,18 +1958,22 @@
-    PyObject* kwargs = PyDict_New();
-    for(std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
-    {
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_yticks, args, kwargs);
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-    if(!res) throw std::runtime_error("Call to yticks() failed");
-
-    Py_DECREF(res);
-}
-
-template&lt;typename Numeric&gt;
-inline void yticks(const std::vector&lt;Numeric&gt; &amp;ticks, const std::map&lt;std::string, std::string&gt;&amp; keywords)
-{
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_yticks, args, kwargs);
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+    if (!res) {throw std::runtime_error("Call to yticks() failed");}
+
+    Py_DECREF(res);
+  }
+
+  template &lt; typename Numeric &gt;
+  inline void yticks(
+    const std::vector &lt; Numeric &gt; &amp; ticks, const std::map &lt; std::string,
+    std::string &gt; &amp; keywords)
+  {
@@ -1817,4 +1981,4 @@
-}
-
-template &lt;typename Numeric&gt; inline void margins(Numeric margin)
-{
+  }
+
+  template &lt; typename Numeric &gt; inline void margins(Numeric margin)
+  {
@@ -1822 +1986 @@
-    PyObject* args = PyTuple_New(1);
+    PyObject * args = PyTuple_New(1);
@@ -1825,11 +1989,12 @@
-    PyObject* res =
-            PyObject_CallObject(detail::_interpreter::get().s_python_function_margins, args);
-    if (!res)
-        throw std::runtime_error("Call to margins() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(res);
-}
-
-template &lt;typename Numeric&gt; inline void margins(Numeric margin_x, Numeric margin_y)
-{
+    PyObject * res =
+      PyObject_CallObject(detail::_interpreter::get().s_python_function_margins, args);
+    if (!res) {
+      throw std::runtime_error("Call to margins() failed.");
+    }
+
+    Py_DECREF(args);
+    Py_DECREF(res);
+  }
+
+  template &lt; typename Numeric &gt; inline void margins(Numeric margin_x, Numeric margin_y)
+  {
@@ -1837 +2002 @@
-    PyObject* args = PyTuple_New(2);
+    PyObject * args = PyTuple_New(2);
@@ -1841,40 +2006,17 @@
-    PyObject* res =
-            PyObject_CallObject(detail::_interpreter::get().s_python_function_margins, args);
-    if (!res)
-        throw std::runtime_error("Call to margins() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(res);
-}
-
-
-inline void tick_params(const std::map&lt;std::string, std::string&gt;&amp; keywords, const std::string axis = "both")
-{
-  detail::_interpreter::get();
-
-  // construct positional args
-  PyObject* args;
-  args = PyTuple_New(1);
-  PyTuple_SetItem(args, 0, PyString_FromString(axis.c_str()));
-
-  // construct keyword args
-  PyObject* kwargs = PyDict_New();
-  for (std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
-  {
-    PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
-  }
-
-
-  PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_tick_params, args, kwargs);
-
-  Py_DECREF(args);
-  Py_DECREF(kwargs);
-  if (!res) throw std::runtime_error("Call to tick_params() failed");
-
-  Py_DECREF(res);
-}
-
-inline void subplot(long nrows, long ncols, long plot_number)
-{
-    detail::_interpreter::get();
-    
+    PyObject * res =
+      PyObject_CallObject(detail::_interpreter::get().s_python_function_margins, args);
+    if (!res) {
+      throw std::runtime_error("Call to margins() failed.");
+    }
+
+    Py_DECREF(args);
+    Py_DECREF(res);
+  }
+
+
+  inline void tick_params(
+    const std::map &lt; std::string, std::string &gt; &amp; keywords,
+    const std::string axis = "both")
+  {
+    detail::_interpreter::get();
+
@@ -1882 +2024,29 @@
-    PyObject* args = PyTuple_New(3);
+    PyObject * args;
+    args = PyTuple_New(1);
+    PyTuple_SetItem(args, 0, PyString_FromString(axis.c_str()));
+
+    // construct keyword args
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
+    }
+
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_tick_params, args, kwargs);
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+    if (!res) {throw std::runtime_error("Call to tick_params() failed");}
+
+    Py_DECREF(res);
+  }
+
+  inline void subplot(long nrows, long ncols, long plot_number)
+  {
+    detail::_interpreter::get();
+
+    // construct positional args
+    PyObject * args = PyTuple_New(3);
@@ -1887,12 +2057,15 @@
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_subplot, args);
-    if(!res) throw std::runtime_error("Call to subplot() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(res);
-}
-
-inline void subplot2grid(long nrows, long ncols, long rowid=0, long colid=0, long rowspan=1, long colspan=1)
-{
-    detail::_interpreter::get();
-
-    PyObject* shape = PyTuple_New(2);
+    PyObject * res =
+      PyObject_CallObject(detail::_interpreter::get().s_python_function_subplot, args);
+    if (!res) {throw std::runtime_error("Call to subplot() failed.");}
+
+    Py_DECREF(args);
+    Py_DECREF(res);
+  }
+
+  inline void subplot2grid(
+    long nrows, long ncols, long rowid = 0, long colid = 0, long rowspan = 1,
+    long colspan = 1)
+  {
+    detail::_interpreter::get();
+
+    PyObject * shape = PyTuple_New(2);
@@ -1902 +2075 @@
-    PyObject* loc = PyTuple_New(2);
+    PyObject * loc = PyTuple_New(2);
@@ -1906 +2079 @@
-    PyObject* args = PyTuple_New(4);
+    PyObject * args = PyTuple_New(4);
@@ -1912,2 +2085,3 @@
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_subplot2grid, args);
-    if(!res) throw std::runtime_error("Call to subplot2grid() failed.");
+    PyObject * res = PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_subplot2grid, args);
+    if (!res) {throw std::runtime_error("Call to subplot2grid() failed.");}
@@ -1919,8 +2093,10 @@
-}
-
-inline void title(const std::string &amp;titlestr, const std::map&lt;std::string, std::string&gt; &amp;keywords = {})
-{
-    detail::_interpreter::get();
-
-    PyObject* pytitlestr = PyString_FromString(titlestr.c_str());
-    PyObject* args = PyTuple_New(1);
+  }
+
+  inline void title(
+    const std::string &amp; titlestr, const std::map &lt; std::string,
+    std::string &gt; &amp; keywords = {})
+  {
+    detail::_interpreter::get();
+
+    PyObject * pytitlestr = PyString_FromString(titlestr.c_str());
+    PyObject * args = PyTuple_New(1);
@@ -1929 +2105 @@
-    PyObject* kwargs = PyDict_New();
+    PyObject * kwargs = PyDict_New();
@@ -1931,17 +2107,20 @@
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_title, args, kwargs);
-    if(!res) throw std::runtime_error("Call to title() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-    Py_DECREF(res);
-}
-
-inline void suptitle(const std::string &amp;suptitlestr, const std::map&lt;std::string, std::string&gt; &amp;keywords = {})
-{
-    detail::_interpreter::get();
-    
-    PyObject* pysuptitlestr = PyString_FromString(suptitlestr.c_str());
-    PyObject* args = PyTuple_New(1);
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res =
+      PyObject_Call(detail::_interpreter::get().s_python_function_title, args, kwargs);
+    if (!res) {throw std::runtime_error("Call to title() failed.");}
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+    Py_DECREF(res);
+  }
+
+  inline void suptitle(
+    const std::string &amp; suptitlestr, const std::map &lt; std::string,
+    std::string &gt; &amp; keywords = {})
+  {
+    detail::_interpreter::get();
+
+    PyObject * pysuptitlestr = PyString_FromString(suptitlestr.c_str());
+    PyObject * args = PyTuple_New(1);
@@ -1950 +2129 @@
-    PyObject* kwargs = PyDict_New();
+    PyObject * kwargs = PyDict_New();
@@ -1952,17 +2131,18 @@
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_suptitle, args, kwargs);
-    if(!res) throw std::runtime_error("Call to suptitle() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-    Py_DECREF(res);
-}
-
-inline void axis(const std::string &amp;axisstr)
-{
-    detail::_interpreter::get();
-
-    PyObject* str = PyString_FromString(axisstr.c_str());
-    PyObject* args = PyTuple_New(1);
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_suptitle, args, kwargs);
+    if (!res) {throw std::runtime_error("Call to suptitle() failed.");}
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+    Py_DECREF(res);
+  }
+
+  inline void axis(const std::string &amp; axisstr)
+  {
+    detail::_interpreter::get();
+
+    PyObject * str = PyString_FromString(axisstr.c_str());
+    PyObject * args = PyTuple_New(1);
@@ -1971,9 +2151,11 @@
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_axis, args);
-    if(!res) throw std::runtime_error("Call to title() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(res);
-}
-
-inline void axvline(double x, double ymin = 0., double ymax = 1., const std::map&lt;std::string, std::string&gt;&amp; keywords = std::map&lt;std::string, std::string&gt;())
-{
+    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_axis, args);
+    if (!res) {throw std::runtime_error("Call to title() failed.");}
+
+    Py_DECREF(args);
+    Py_DECREF(res);
+  }
+
+  inline void axvline(
+    double x, double ymin = 0., double ymax = 1., const std::map &lt; std::string,
+    std::string &gt; &amp; keywords = std::map &lt; std::string, std::string &gt; ())
+  {
@@ -1983 +2165 @@
-    PyObject* args = PyTuple_New(3);
+    PyObject * args = PyTuple_New(3);
@@ -1989,16 +2171,21 @@
-    PyObject* kwargs = PyDict_New();
-    for(std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
-    {
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_axvline, args, kwargs);
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-
-    if(res) Py_DECREF(res);
-}
-
-inline void axvspan(double xmin, double xmax, double ymin = 0., double ymax = 1., const std::map&lt;std::string, std::string&gt;&amp; keywords = std::map&lt;std::string, std::string&gt;())
-{
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_axvline, args, kwargs);
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+
+    if (res) {Py_DECREF(res);}
+  }
+
+  inline void axvspan(
+    double xmin, double xmax, double ymin = 0., double ymax = 1.,
+    const std::map &lt; std::string,
+    std::string &gt; &amp; keywords = std::map &lt; std::string, std::string &gt; ())
+  {
@@ -2006 +2193 @@
-    PyObject* args = PyTuple_New(4);
+    PyObject * args = PyTuple_New(4);
@@ -2013,22 +2200,27 @@
-    PyObject* kwargs = PyDict_New();
-    for(std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
-    {
-    if (it-&gt;first == "linewidth" || it-&gt;first == "alpha")
-            PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyFloat_FromDouble(std::stod(it-&gt;second)));
-    else
-            PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_axvspan, args, kwargs);
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-
-    if(res) Py_DECREF(res);
-}
-
-inline void xlabel(const std::string &amp;str, const std::map&lt;std::string, std::string&gt; &amp;keywords = {})
-{
-    detail::_interpreter::get();
-
-    PyObject* pystr = PyString_FromString(str.c_str());
-    PyObject* args = PyTuple_New(1);
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      if (it-&gt;first == "linewidth" || it-&gt;first == "alpha") {
+        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyFloat_FromDouble(std::stod(it-&gt;second)));
+      } else {
+        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyString_FromString(it-&gt;second.c_str()));
+      }
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_axvspan, args, kwargs);
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+
+    if (res) {Py_DECREF(res);}
+  }
+
+  inline void xlabel(
+    const std::string &amp; str, const std::map &lt; std::string,
+    std::string &gt; &amp; keywords = {})
+  {
+    detail::_interpreter::get();
+
+    PyObject * pystr = PyString_FromString(str.c_str());
+    PyObject * args = PyTuple_New(1);
@@ -2037 +2229 @@
-    PyObject* kwargs = PyDict_New();
+    PyObject * kwargs = PyDict_New();
@@ -2039,17 +2231,20 @@
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_xlabel, args, kwargs);
-    if(!res) throw std::runtime_error("Call to xlabel() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-    Py_DECREF(res);
-}
-
-inline void ylabel(const std::string &amp;str, const std::map&lt;std::string, std::string&gt;&amp; keywords = {})
-{
-    detail::_interpreter::get();
-
-    PyObject* pystr = PyString_FromString(str.c_str());
-    PyObject* args = PyTuple_New(1);
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_xlabel, args, kwargs);
+    if (!res) {throw std::runtime_error("Call to xlabel() failed.");}
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+    Py_DECREF(res);
+  }
+
+  inline void ylabel(
+    const std::string &amp; str, const std::map &lt; std::string,
+    std::string &gt; &amp; keywords = {})
+  {
+    detail::_interpreter::get();
+
+    PyObject * pystr = PyString_FromString(str.c_str());
+    PyObject * args = PyTuple_New(1);
@@ -2058 +2253 @@
-    PyObject* kwargs = PyDict_New();
+    PyObject * kwargs = PyDict_New();
@@ -2060,18 +2255,21 @@
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_ylabel, args, kwargs);
-    if(!res) throw std::runtime_error("Call to ylabel() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(kwargs);
-    Py_DECREF(res);
-}
-
-inline void set_zlabel(const std::string &amp;str, const std::map&lt;std::string, std::string&gt;&amp; keywords = {})
-{
-    detail::_interpreter::get();
-
-    // Same as with plot_surface: We lazily load the modules here the first time 
-    // this function is called because I'm not sure that we can assume "matplotlib 
-    // installed" implies "mpl_toolkits installed" on all platforms, and we don't 
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_ylabel, args, kwargs);
+    if (!res) {throw std::runtime_error("Call to ylabel() failed.");}
+
+    Py_DECREF(args);
+    Py_DECREF(kwargs);
+    Py_DECREF(res);
+  }
+
+  inline void set_zlabel(
+    const std::string &amp; str, const std::map &lt; std::string,
+    std::string &gt; &amp; keywords = {})
+  {
+    detail::_interpreter::get();
+
+    // Same as with plot_surface: We lazily load the modules here the first time
+    // this function is called because I'm not sure that we can assume "matplotlib
+    // installed" implies "mpl_toolkits installed" on all platforms, and we don't
@@ -2079 +2277 @@
-    static PyObject *mpl_toolkitsmod = nullptr, *axis3dmod = nullptr;
+    static PyObject * mpl_toolkitsmod = nullptr, * axis3dmod = nullptr;
@@ -2081,15 +2279,15 @@
-        PyObject* mpl_toolkits = PyString_FromString("mpl_toolkits");
-        PyObject* axis3d = PyString_FromString("mpl_toolkits.mplot3d");
-        if (!mpl_toolkits || !axis3d) { throw std::runtime_error("couldnt create string"); }
-
-        mpl_toolkitsmod = PyImport_Import(mpl_toolkits);
-        Py_DECREF(mpl_toolkits);
-        if (!mpl_toolkitsmod) { throw std::runtime_error("Error loading module mpl_toolkits!"); }
-
-        axis3dmod = PyImport_Import(axis3d);
-        Py_DECREF(axis3d);
-        if (!axis3dmod) { throw std::runtime_error("Error loading module mpl_toolkits.mplot3d!"); }
-    }
-
-    PyObject* pystr = PyString_FromString(str.c_str());
-    PyObject* args = PyTuple_New(1);
+      PyObject * mpl_toolkits = PyString_FromString("mpl_toolkits");
+      PyObject * axis3d = PyString_FromString("mpl_toolkits.mplot3d");
+      if (!mpl_toolkits || !axis3d) {throw std::runtime_error("couldnt create string");}
+
+      mpl_toolkitsmod = PyImport_Import(mpl_toolkits);
+      Py_DECREF(mpl_toolkits);
+      if (!mpl_toolkitsmod) {throw std::runtime_error("Error loading module mpl_toolkits!");}
+
+      axis3dmod = PyImport_Import(axis3d);
+      Py_DECREF(axis3d);
+      if (!axis3dmod) {throw std::runtime_error("Error loading module mpl_toolkits.mplot3d!");}
+    }
+
+    PyObject * pystr = PyString_FromString(str.c_str());
+    PyObject * args = PyTuple_New(1);
@@ -2098 +2296 @@
-    PyObject* kwargs = PyDict_New();
+    PyObject * kwargs = PyDict_New();
@@ -2100,5 +2298,6 @@
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject *ax =
-    PyObject_CallObject(detail::_interpreter::get().s_python_function_gca,
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * ax =
+      PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_gca,
@@ -2106 +2305 @@
-    if (!ax) throw std::runtime_error("Call to gca() failed.");
+    if (!ax) {throw std::runtime_error("Call to gca() failed.");}
@@ -2109,2 +2308,2 @@
-    PyObject *zlabel = PyObject_GetAttrString(ax, "set_zlabel");
-    if (!zlabel) throw std::runtime_error("Attribute set_zlabel not found.");
+    PyObject * zlabel = PyObject_GetAttrString(ax, "set_zlabel");
+    if (!zlabel) {throw std::runtime_error("Attribute set_zlabel not found.");}
@@ -2113,2 +2312,2 @@
-    PyObject *res = PyObject_Call(zlabel, args, kwargs);
-    if (!res) throw std::runtime_error("Call to set_zlabel() failed.");
+    PyObject * res = PyObject_Call(zlabel, args, kwargs);
+    if (!res) {throw std::runtime_error("Call to set_zlabel() failed.");}
@@ -2120,8 +2319,8 @@
-    if (res) Py_DECREF(res);
-}
-
-inline void grid(bool flag)
-{
-    detail::_interpreter::get();
-
-    PyObject* pyflag = flag ? Py_True : Py_False;
+    if (res) {Py_DECREF(res);}
+  }
+
+  inline void grid(bool flag)
+  {
+    detail::_interpreter::get();
+
+    PyObject * pyflag = flag ? Py_True : Py_False;
@@ -2130 +2329 @@
-    PyObject* args = PyTuple_New(1);
+    PyObject * args = PyTuple_New(1);
@@ -2133,68 +2332,15 @@
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_grid, args);
-    if(!res) throw std::runtime_error("Call to grid() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(res);
-}
-
-inline void show(const bool block = true)
-{
-    detail::_interpreter::get();
-
-    PyObject* res;
-    if(block)
-    {
-        res = PyObject_CallObject(
-                detail::_interpreter::get().s_python_function_show,
-                detail::_interpreter::get().s_python_empty_tuple);
-    }
-    else
-    {
-        PyObject *kwargs = PyDict_New();
-        PyDict_SetItemString(kwargs, "block", Py_False);
-        res = PyObject_Call( detail::_interpreter::get().s_python_function_show, detail::_interpreter::get().s_python_empty_tuple, kwargs);
-       Py_DECREF(kwargs);
-    }
-
-
-    if (!res) throw std::runtime_error("Call to show() failed.");
-
-    Py_DECREF(res);
-}
-
-inline void close()
-{
-    detail::_interpreter::get();
-
-    PyObject* res = PyObject_CallObject(
-            detail::_interpreter::get().s_python_function_close,
-            detail::_interpreter::get().s_python_empty_tuple);
-
-    if (!res) throw std::runtime_error("Call to close() failed.");
-
-    Py_DECREF(res);
-}
-
-inline void xkcd() {
-    detail::_interpreter::get();
-
-    PyObject* res;
-    PyObject *kwargs = PyDict_New();
-
-    res = PyObject_Call(detail::_interpreter::get().s_python_function_xkcd,
-            detail::_interpreter::get().s_python_empty_tuple, kwargs);
-
-    Py_DECREF(kwargs);
-
-    if (!res)
-        throw std::runtime_error("Call to show() failed.");
-
-    Py_DECREF(res);
-}
-
-inline void draw()
-{
-    detail::_interpreter::get();
-
-    PyObject* res = PyObject_CallObject(
-        detail::_interpreter::get().s_python_function_draw,
+    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_grid, args);
+    if (!res) {throw std::runtime_error("Call to grid() failed.");}
+
+    Py_DECREF(args);
+    Py_DECREF(res);
+  }
+
+  inline void show(const bool block = true)
+  {
+    detail::_interpreter::get();
+
+    PyObject * res;
+    if (block) {
+      res = PyObject_CallObject(
+        detail::_interpreter::get().s_python_function_show,
@@ -2202,12 +2348,67 @@
-
-    if (!res) throw std::runtime_error("Call to draw() failed.");
-
-    Py_DECREF(res);
-}
-
-template&lt;typename Numeric&gt;
-inline void pause(Numeric interval)
-{
-    detail::_interpreter::get();
-
-    PyObject* args = PyTuple_New(1);
+    } else {
+      PyObject * kwargs = PyDict_New();
+      PyDict_SetItemString(kwargs, "block", Py_False);
+      res = PyObject_Call(
+        detail::_interpreter::get().s_python_function_show,
+        detail::_interpreter::get().s_python_empty_tuple, kwargs);
+      Py_DECREF(kwargs);
+    }
+
+
+    if (!res) {throw std::runtime_error("Call to show() failed.");}
+
+    Py_DECREF(res);
+  }
+
+  inline void close()
+  {
+    detail::_interpreter::get();
+
+    PyObject * res = PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_close,
+      detail::_interpreter::get().s_python_empty_tuple);
+
+    if (!res) {throw std::runtime_error("Call to close() failed.");}
+
+    Py_DECREF(res);
+  }
+
+  inline void xkcd()
+  {
+    detail::_interpreter::get();
+
+    PyObject * res;
+    PyObject * kwargs = PyDict_New();
+
+    res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_xkcd,
+      detail::_interpreter::get().s_python_empty_tuple, kwargs);
+
+    Py_DECREF(kwargs);
+
+    if (!res) {
+      throw std::runtime_error("Call to show() failed.");
+    }
+
+    Py_DECREF(res);
+  }
+
+  inline void draw()
+  {
+    detail::_interpreter::get();
+
+    PyObject * res = PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_draw,
+      detail::_interpreter::get().s_python_empty_tuple);
+
+    if (!res) {throw std::runtime_error("Call to draw() failed.");}
+
+    Py_DECREF(res);
+  }
+
+  template &lt; typename Numeric &gt;
+  inline void pause(Numeric interval)
+  {
+    detail::_interpreter::get();
+
+    PyObject * args = PyTuple_New(1);
@@ -2216,14 +2417,14 @@
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_pause, args);
-    if(!res) throw std::runtime_error("Call to pause() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(res);
-}
-
-inline void save(const std::string&amp; filename)
-{
-    detail::_interpreter::get();
-
-    PyObject* pyfilename = PyString_FromString(filename.c_str());
-
-    PyObject* args = PyTuple_New(1);
+    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_pause, args);
+    if (!res) {throw std::runtime_error("Call to pause() failed.");}
+
+    Py_DECREF(args);
+    Py_DECREF(res);
+  }
+
+  inline void save(const std::string &amp; filename)
+  {
+    detail::_interpreter::get();
+
+    PyObject * pyfilename = PyString_FromString(filename.c_str());
+
+    PyObject * args = PyTuple_New(1);
@@ -2232,48 +2433,56 @@
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_save, args);
-    if (!res) throw std::runtime_error("Call to save() failed.");
-
-    Py_DECREF(args);
-    Py_DECREF(res);
-}
-
-inline void clf() {
-    detail::_interpreter::get();
-
-    PyObject *res = PyObject_CallObject(
-        detail::_interpreter::get().s_python_function_clf,
-        detail::_interpreter::get().s_python_empty_tuple);
-
-    if (!res) throw std::runtime_error("Call to clf() failed.");
-
-    Py_DECREF(res);
-}
-
-inline void cla() {
-    detail::_interpreter::get();
-
-    PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_cla,
-                                        detail::_interpreter::get().s_python_empty_tuple);
-
-    if (!res)
-        throw std::runtime_error("Call to cla() failed.");
-
-    Py_DECREF(res);
-}
-
-inline void ion() {
-    detail::_interpreter::get();
-
-    PyObject *res = PyObject_CallObject(
-        detail::_interpreter::get().s_python_function_ion,
-        detail::_interpreter::get().s_python_empty_tuple);
-
-    if (!res) throw std::runtime_error("Call to ion() failed.");
-
-    Py_DECREF(res);
-}
-
-inline std::vector&lt;std::array&lt;double, 2&gt;&gt; ginput(const int numClicks = 1, const std::map&lt;std::string, std::string&gt;&amp; keywords = {})
-{
-    detail::_interpreter::get();
-
-    PyObject *args = PyTuple_New(1);
+    PyObject * res = PyObject_CallObject(detail::_interpreter::get().s_python_function_save, args);
+    if (!res) {throw std::runtime_error("Call to save() failed.");}
+
+    Py_DECREF(args);
+    Py_DECREF(res);
+  }
+
+  inline void clf()
+  {
+    detail::_interpreter::get();
+
+    PyObject * res = PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_clf,
+      detail::_interpreter::get().s_python_empty_tuple);
+
+    if (!res) {throw std::runtime_error("Call to clf() failed.");}
+
+    Py_DECREF(res);
+  }
+
+  inline void cla()
+  {
+    detail::_interpreter::get();
+
+    PyObject * res = PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_cla,
+      detail::_interpreter::get().s_python_empty_tuple);
+
+    if (!res) {
+      throw std::runtime_error("Call to cla() failed.");
+    }
+
+    Py_DECREF(res);
+  }
+
+  inline void ion()
+  {
+    detail::_interpreter::get();
+
+    PyObject * res = PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_ion,
+      detail::_interpreter::get().s_python_empty_tuple);
+
+    if (!res) {throw std::runtime_error("Call to ion() failed.");}
+
+    Py_DECREF(res);
+  }
+
+  inline std::vector &lt; std::array &lt; double, 2 &gt;&gt; ginput(
+    const int numClicks = 1,
+    const std::map &lt; std::string,
+    std::string &gt; &amp; keywords = {})
+  {
+    detail::_interpreter::get();
+
+    PyObject * args = PyTuple_New(1);
@@ -2283,12 +2492,13 @@
-    PyObject* kwargs = PyDict_New();
-    for(std::map&lt;std::string, std::string&gt;::const_iterator it = keywords.begin(); it != keywords.end(); ++it)
-    {
-        PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
-    }
-
-    PyObject* res = PyObject_Call(
-        detail::_interpreter::get().s_python_function_ginput, args, kwargs);
-
-    Py_DECREF(kwargs);
-    Py_DECREF(args);
-    if (!res) throw std::runtime_error("Call to ginput() failed.");
+    PyObject * kwargs = PyDict_New();
+    for (std::map &lt; std::string, std::string &gt; ::const_iterator it = keywords.begin();
+      it != keywords.end(); ++it)
+    {
+      PyDict_SetItemString(kwargs, it-&gt;first.c_str(), PyUnicode_FromString(it-&gt;second.c_str()));
+    }
+
+    PyObject * res = PyObject_Call(
+      detail::_interpreter::get().s_python_function_ginput, args, kwargs);
+
+    Py_DECREF(kwargs);
+    Py_DECREF(args);
+    if (!res) {throw std::runtime_error("Call to ginput() failed.");}
@@ -2297 +2507 @@
-    std::vector&lt;std::array&lt;double, 2&gt;&gt; out;
+    std::vector &lt; std::array &lt; double, 2 &gt;&gt; out;
@@ -2300,5 +2510,5 @@
-        PyObject *current = PyList_GetItem(res, i);
-        std::array&lt;double, 2&gt; position;
-        position[0] = PyFloat_AsDouble(PyTuple_GetItem(current, 0));
-        position[1] = PyFloat_AsDouble(PyTuple_GetItem(current, 1));
-        out.push_back(position);
+      PyObject * current = PyList_GetItem(res, i);
+      std::array &lt; double, 2 &gt; position;
+      position[0] = PyFloat_AsDouble(PyTuple_GetItem(current, 0));
+      position[1] = PyFloat_AsDouble(PyTuple_GetItem(current, 1));
+      out.push_back(position);
@@ -2309 +2519 @@
-}
+  }
@@ -2312,11 +2522,12 @@
-inline void tight_layout() {
-    detail::_interpreter::get();
-
-    PyObject *res = PyObject_CallObject(
-        detail::_interpreter::get().s_python_function_tight_layout,
-        detail::_interpreter::get().s_python_empty_tuple);
-
-    if (!res) throw std::runtime_error("Call to tight_layout() failed.");
-
-    Py_DECREF(res);
-}
+  inline void tight_layout()
+  {
+    detail::_interpreter::get();
+
+    PyObject * res = PyObject_CallObject(
+      detail::_interpreter::get().s_python_function_tight_layout,
+      detail::_interpreter::get().s_python_empty_tuple);
+
+    if (!res) {throw std::runtime_error("Call to tight_layout() failed.");}
+
+    Py_DECREF(res);
+  }
@@ -2326,27 +2537,28 @@
-namespace detail {
-
-template&lt;typename T&gt;
-using is_function = typename std::is_function&lt;std::remove_pointer&lt;std::remove_reference&lt;T&gt;&gt;&gt;::type;
-
-template&lt;bool obj, typename T&gt;
-struct is_callable_impl;
-
-template&lt;typename T&gt;
-struct is_callable_impl&lt;false, T&gt;
-{
-    typedef is_function&lt;T&gt; type;
-}; // a non-object is callable iff it is a function
-
-template&lt;typename T&gt;
-struct is_callable_impl&lt;true, T&gt;
-{
-    struct Fallback { void operator()(); };
-    struct Derived : T, Fallback { };
-
-    template&lt;typename U, U&gt; struct Check;
-
-    template&lt;typename U&gt;
-    static std::true_type test( ... ); // use a variadic function to make sure (1) it accepts everything and (2) its always the worst match
-
-    template&lt;typename U&gt;
-    static std::false_type test( Check&lt;void(Fallback::*)(), &amp;U::operator()&gt;* );
+  namespace detail {
+
+    template &lt; typename T &gt;
+    using is_function = typename std::is_function &lt; std::remove_pointer &lt; std::remove_reference &lt;
+      T &gt;&gt; &gt; ::type;
+
+    template &lt; bool obj, typename T &gt;
+    struct is_callable_impl;
+
+    template &lt; typename T &gt;
+    struct is_callable_impl &lt; false, T &gt;
+    {
+      typedef is_function &lt; T &gt; type;
+    } // a non-object is callable iff it is a function
+
+    template &lt; typename T &gt;
+    struct is_callable_impl &lt; true, T &gt;
+    {
+      struct Fallback { void operator()(); };
+      struct Derived : T, Fallback {};
+
+      template &lt; typename U, U &gt; struct Check;
+
+      template &lt; typename U &gt;
+      static std::true_type test(...); // use a variadic function to make sure (1) it accepts everything and (2) its always the worst match
+
+      template &lt; typename U &gt;
+      static std::false_type test(Check &lt; void (Fallback::*)(), &amp; U::operator() &gt; *);
@@ -2355,21 +2567,21 @@
-    typedef decltype(test&lt;Derived&gt;(nullptr)) type;
-    typedef decltype(&amp;Fallback::operator()) dtype;
-    static constexpr bool value = type::value;
-}; // an object is callable iff it defines operator()
-
-template&lt;typename T&gt;
-struct is_callable
-{
-    // dispatch to is_callable_impl&lt;true, T&gt; or is_callable_impl&lt;false, T&gt; depending on whether T is of class type or not
-    typedef typename is_callable_impl&lt;std::is_class&lt;T&gt;::value, T&gt;::type type;
-};
-
-template&lt;typename IsYDataCallable&gt;
-struct plot_impl { };
-
-template&lt;&gt;
-struct plot_impl&lt;std::false_type&gt;
-{
-    template&lt;typename IterableX, typename IterableY&gt;
-    bool operator()(const IterableX&amp; x, const IterableY&amp; y, const std::string&amp; format)
-    {
+      typedef decltype(test &lt; Derived &gt; (nullptr)) type;
+      typedef decltype( &amp; Fallback::operator ()) dtype;
+      static constexpr bool value = type::value;
+    } // an object is callable iff it defines operator()
+
+    template &lt; typename T &gt;
+    struct is_callable
+    {
+      // dispatch to is_callable_impl&lt;true, T&gt; or is_callable_impl&lt;false, T&gt; depending on whether T is of class type or not
+      typedef typename is_callable_impl &lt; std::is_class &lt; T &gt; ::value, T &gt; ::type type;
+    };
+
+    template &lt; typename IsYDataCallable &gt;
+    struct plot_impl {};
+
+    template &lt; &gt;
+    struct plot_impl &lt; std::false_type &gt;
+    {
+      template &lt; typename IterableX, typename IterableY &gt;
+      bool operator()(const IterableX &amp; x, const IterableY &amp; y, const std::string &amp; format)
+      {
@@ -2387,3 +2599,3 @@
-        PyObject* xlist = PyList_New(xs);
-        PyObject* ylist = PyList_New(ys);
-        PyObject* pystring = PyString_FromString(format.c_str());
+        PyObject * xlist = PyList_New(xs);
+        PyObject * ylist = PyList_New(ys);
+        PyObject * pystring = PyString_FromString(format.c_str());
@@ -2392,3 +2604,3 @@
-        for(size_t i = 0; i &lt; xs; ++i) {
-            PyList_SetItem(xlist, i, PyFloat_FromDouble(*itx++));
-            PyList_SetItem(ylist, i, PyFloat_FromDouble(*ity++));
+        for (size_t i = 0; i &lt; xs; ++i) {
+          PyList_SetItem(xlist, i, PyFloat_FromDouble(*itx++));
+          PyList_SetItem(ylist, i, PyFloat_FromDouble(*ity++));
@@ -2397 +2609 @@
-        PyObject* plot_args = PyTuple_New(3);
+        PyObject * plot_args = PyTuple_New(3);
@@ -2402 +2614,2 @@
-        PyObject* res = PyObject_CallObject(detail::_interpreter::get().s_python_function_plot, plot_args);
+        PyObject * res = PyObject_CallObject(
+          detail::_interpreter::get().s_python_function_plot, plot_args);
@@ -2405 +2618 @@
-        if(res) Py_DECREF(res);
+        if (res) {Py_DECREF(res);}
@@ -2408,10 +2621,10 @@
-    }
-};
-
-template&lt;&gt;
-struct plot_impl&lt;std::true_type&gt;
-{
-    template&lt;typename Iterable, typename Callable&gt;
-    bool operator()(const Iterable&amp; ticks, const Callable&amp; f, const std::string&amp; format)
-    {
-        if(begin(ticks) == end(ticks)) return true;
+      }
+    }
+
+    template &lt; &gt;
+    struct plot_impl &lt; std::true_type &gt;
+    {
+      template &lt; typename Iterable, typename Callable &gt;
+      bool operator()(const Iterable &amp; ticks, const Callable &amp; f, const std::string &amp; format)
+      {
+        if (begin(ticks) == end(ticks)) {return true;}
@@ -2421,7 +2634,9 @@
-        std::vector&lt;double&gt; y;
-        for(auto x : ticks) y.push_back(f(x));
-        return plot_impl&lt;std::false_type&gt;()(ticks,y,format);
-    }
-};
-
-} // end namespace detail
+        std::vector &lt; double &gt; y;
+        for (auto x : ticks) {
+          y.push_back(f(x));
+        }
+        return plot_impl &lt; std::false_type &gt; ()(ticks, y, format);
+      }
+    }
+
+  } // end namespace detail
@@ -2430,8 +2645,9 @@
-template&lt;typename... Args&gt;
-bool plot() { return true; }
-
-template&lt;typename A, typename B, typename... Args&gt;
-bool plot(const A&amp; a, const B&amp; b, const std::string&amp; format, Args... args)
-{
-    return detail::plot_impl&lt;typename detail::is_callable&lt;B&gt;::type&gt;()(a,b,format) &amp;&amp; plot(args...);
-}
+  template &lt; typename ... Args &gt;
+  bool plot() {return true;}
+
+  template &lt; typename A, typename B, typename ... Args &gt;
+  bool plot(const A &amp; a, const B &amp; b, const std::string &amp; format, Args... args)
+  {
+    return detail::plot_impl &lt; typename detail::is_callable &lt; B &gt; ::type &gt; ()(a, b, format) &amp;&amp; plot(
+      args ...);
+  }
@@ -2443,11 +2659,18 @@
-inline bool plot(const std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; y, const std::string&amp; format = "") {
-    return plot&lt;double,double&gt;(x,y,format);
-}
-
-inline bool plot(const std::vector&lt;double&gt;&amp; y, const std::string&amp; format = "") {
-    return plot&lt;double&gt;(y,format);
-}
-
-inline bool plot(const std::vector&lt;double&gt;&amp; x, const std::vector&lt;double&gt;&amp; y, const std::map&lt;std::string, std::string&gt;&amp; keywords) {
-    return plot&lt;double&gt;(x,y,keywords);
-}
+  inline bool plot(
+    const std::vector &lt; double &gt; &amp; x, const std::vector &lt; double &gt; &amp; y,
+    const std::string &amp; format = "")
+  {
+    return plot &lt; double, double &gt; (x, y, format);
+  }
+
+  inline bool plot(const std::vector &lt; double &gt; &amp; y, const std::string &amp; format = "")
+  {
+    return plot &lt; double &gt; (y, format);
+  }
+
+  inline bool plot(
+    const std::vector &lt; double &gt; &amp; x, const std::vector &lt; double &gt; &amp; y,
+    const std::map &lt; std::string, std::string &gt; &amp; keywords)
+  {
+    return plot &lt; double &gt; (x, y, keywords);
+  }
@@ -2458,2 +2681,2 @@
-class Plot
-{
+  class Plot
+  {
@@ -2462,16 +2685,56 @@
-    template&lt;typename Numeric&gt;
-    Plot(const std::string&amp; name, const std::vector&lt;Numeric&gt;&amp; x, const std::vector&lt;Numeric&gt;&amp; y, const std::string&amp; format = "") {
-        detail::_interpreter::get();
-
-        assert(x.size() == y.size());
-
-        PyObject* kwargs = PyDict_New();
-        if(name != "")
-            PyDict_SetItemString(kwargs, "label", PyString_FromString(name.c_str()));
-
-        PyObject* xarray = detail::get_array(x);
-        PyObject* yarray = detail::get_array(y);
-
-        PyObject* pystring = PyString_FromString(format.c_str());
-
-        PyObject* plot_args = PyTuple_New(3);
+    template &lt; typename Numeric &gt;
+    Plot(
+      const std::string &amp; name, const std::vector &lt; Numeric &gt; &amp;x,
+      const std::vector &lt; Numeric &gt; &amp;y, const std::string &amp; format = "") {
+      detail::_interpreter::get();
+
+      assert(x.size() == y.size());
+
+      PyObject * kwargs = PyDict_New();
+      if (name != "") {
+        PyDict_SetItemString(kwargs, "label", PyString_FromString(name.c_str()));
+      }
+
+      PyObject * xarray = detail::get_array(x);
+      PyObject * yarray = detail::get_array(y);
+
+      PyObject * pystring = PyString_FromString(format.c_str());
+
+      PyObject * plot_args = PyTuple_New(3);
+      PyTuple_SetItem(plot_args, 0, xarray);
+      PyTuple_SetItem(plot_args, 1, yarray);
+      PyTuple_SetItem(plot_args, 2, pystring);
+
+      PyObject * res = PyObject_Call(
+        detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);
+
+      Py_DECREF(kwargs);
+      Py_DECREF(plot_args);
+
+      if (res) {
+        line = PyList_GetItem(res, 0);
+
+        if (line) {
+          set_data_fct = PyObject_GetAttrString(line, "set_data");
+        } else {
+          Py_DECREF(line);
+        }
+        Py_DECREF(res);
+      }
+    }
+
+    // shorter initialization with name or format only
+    // basically calls line, = plot([], [])
+    Plot(const std::string &amp; name = "", const std::string &amp; format = "")
+      : Plot(name, std::vector &lt; double &gt; (), std::vector &lt; double &gt; (), format) {
+    }
+
+    template &lt; typename Numeric &gt;
+    bool update(const std::vector &lt; Numeric &gt; &amp; x, const std::vector &lt; Numeric &gt; &amp; y)
+    {
+      assert(x.size() == y.size());
+      if (set_data_fct) {
+        PyObject * xarray = detail::get_array(x);
+        PyObject * yarray = detail::get_array(y);
+
+        PyObject * plot_args = PyTuple_New(2);
@@ -2480,41 +2743,6 @@
-        PyTuple_SetItem(plot_args, 2, pystring);
-
-        PyObject* res = PyObject_Call(detail::_interpreter::get().s_python_function_plot, plot_args, kwargs);
-
-        Py_DECREF(kwargs);
-        Py_DECREF(plot_args);
-
-        if(res)
-        {
-            line= PyList_GetItem(res, 0);
-
-            if(line)
-                set_data_fct = PyObject_GetAttrString(line,"set_data");
-            else
-                Py_DECREF(line);
-            Py_DECREF(res);
-        }
-    }
-
-    // shorter initialization with name or format only
-    // basically calls line, = plot([], [])
-    Plot(const std::string&amp; name = "", const std::string&amp; format = "")
-        : Plot(name, std::vector&lt;double&gt;(), std::vector&lt;double&gt;(), format) {}
-
-    template&lt;typename Numeric&gt;
-    bool update(const std::vector&lt;Numeric&gt;&amp; x, const std::vector&lt;Numeric&gt;&amp; y) {
-        assert(x.size() == y.size());
-        if(set_data_fct)
-        {
-            PyObject* xarray = detail::get_array(x);
-            PyObject* yarray = detail::get_array(y);
-
-            PyObject* plot_args = PyTuple_New(2);
-            PyTuple_SetItem(plot_args, 0, xarray);
-            PyTuple_SetItem(plot_args, 1, yarray);
-
-            PyObject* res = PyObject_CallObject(set_data_fct, plot_args);
-            if (res) Py_DECREF(res);
-            return res;
-        }
-        return false;
+
+        PyObject * res = PyObject_CallObject(set_data_fct, plot_args);
+        if (res) {Py_DECREF(res);}
+        return res;
+      }
+      return false;
@@ -2524,2 +2752,3 @@
-    bool clear() {
-        return update(std::vector&lt;double&gt;(), std::vector&lt;double&gt;());
+    bool clear()
+    {
+      return update(std::vector &lt; double &gt; (), std::vector &lt; double &gt; ());
@@ -2529,9 +2758,9 @@
-    void remove() {
-        if(line)
-        {
-            auto remove_fct = PyObject_GetAttrString(line,"remove");
-            PyObject* args = PyTuple_New(0);
-            PyObject* res = PyObject_CallObject(remove_fct, args);
-            if (res) Py_DECREF(res);
-        }
-        decref();
+    void remove()
+    {
+      if (line) {
+        auto remove_fct = PyObject_GetAttrString(line, "remove");
+        PyObject * args = PyTuple_New(0);
+        PyObject * res = PyObject_CallObject(remove_fct, args);
+        if (res) {Py_DECREF(res);}
+      }
+      decref();
@@ -2541,2 +2770,3 @@
-        decref();
-    }
+      decref();
+    }
+
@@ -2544,12 +2774,14 @@
-
-    void decref() {
-        if(line)
-            Py_DECREF(line);
-        if(set_data_fct)
-            Py_DECREF(set_data_fct);
-    }
-
-
-    PyObject* line = nullptr;
-    PyObject* set_data_fct = nullptr;
-};
+    void decref()
+    {
+      if (line) {
+        Py_DECREF(line);
+      }
+      if (set_data_fct) {
+        Py_DECREF(set_data_fct);
+      }
+    }
+
+
+    PyObject * line = nullptr;
+    PyObject * set_data_fct = nullptr;
+  };

Code style divergence in file 'include/thirdParty/quadProgpp/Array.hh':

--- include/thirdParty/quadProgpp/Array.hh
+++ include/thirdParty/quadProgpp/Array.hh.uncrustify
@@ -4 +4 @@
-// Copyright (C) 2001--2008 Andrea Schaerf, Luca Di Gaspero. 
+// Copyright (C) 2001--2008 Andrea Schaerf, Luca Di Gaspero.
@@ -21,113 +21,121 @@
-enum MType { DIAG };
-
-template &lt;typename T&gt;
-class Vector
-{
-public: 
-  Vector(); 
-  Vector(const unsigned int n);  
-  Vector(const T&amp; a, const unsigned int n); //initialize to constant value 
-  Vector(const T* a, const unsigned int n); // Initialize to array 
-  Vector(const Vector &amp;rhs); // copy constructor 
-  ~Vector(); // destructor
-	
-  inline void set(const T* a, const unsigned int n);
-  Vector&lt;T&gt; extract(const std::set&lt;unsigned int&gt;&amp; indexes) const;
-  inline T&amp; operator[](const unsigned int&amp; i); //i-th element 
-  inline const T&amp; operator[](const unsigned int&amp; i) const; 
-	
-  inline unsigned int size() const;
-  inline void resize(const unsigned int n);
-  inline void resize(const T&amp; a, const unsigned int n);
-	
-  Vector&lt;T&gt;&amp; operator=(const Vector&lt;T&gt;&amp; rhs); //assignment 
-  Vector&lt;T&gt;&amp; operator=(const T&amp; a); //assign a to every element 
-  inline Vector&lt;T&gt;&amp; operator+=(const Vector&lt;T&gt;&amp; rhs);
-  inline Vector&lt;T&gt;&amp; operator-=(const Vector&lt;T&gt;&amp; rhs);
-  inline Vector&lt;T&gt;&amp; operator*=(const Vector&lt;T&gt;&amp; rhs);
-  inline Vector&lt;T&gt;&amp; operator/=(const Vector&lt;T&gt;&amp; rhs);
-  inline Vector&lt;T&gt;&amp; operator^=(const Vector&lt;T&gt;&amp; rhs);
-  inline Vector&lt;T&gt;&amp; operator+=(const T&amp; a);
-  inline Vector&lt;T&gt;&amp; operator-=(const T&amp; a);
-  inline Vector&lt;T&gt;&amp; operator*=(const T&amp; a);
-  inline Vector&lt;T&gt;&amp; operator/=(const T&amp; a);
-  inline Vector&lt;T&gt;&amp; operator^=(const T&amp; a);
-private: 
-  unsigned int n; // size of array. upper index is n-1 
-  T* v; // storage for data
-}; 
-
-template &lt;typename T&gt; 
-Vector&lt;T&gt;::Vector() 
-  : n(0), v(0) 
-{} 
-
-template &lt;typename T&gt; 
-Vector&lt;T&gt;::Vector(const unsigned int n) 
-  : v(new T[n]) 
-{
-  this-&gt;n = n;
-} 
-
-template &lt;typename T&gt; 
-Vector&lt;T&gt;::Vector(const T&amp; a, const unsigned int n) 
-  : v(new T[n])
-{ 
-  this-&gt;n = n;
-  for (unsigned int i = 0; i &lt; n; i++) 
-    v[i] = a; 
-} 
-
-template &lt;typename T&gt; 
-Vector&lt;T&gt;::Vector(const T* a, const unsigned int n) 
-  : v(new T[n])
-{ 
-  this-&gt;n = n;
-  for (unsigned int i = 0; i &lt; n; i++) 
-    v[i] = *a++; 
-} 
-
-template &lt;typename T&gt; 
-Vector&lt;T&gt;::Vector(const Vector&lt;T&gt;&amp; rhs) 
-  : v(new T[rhs.n])
-{ 
-  this-&gt;n = rhs.n;
-  for (unsigned int	i = 0; i &lt; n; i++) 
-    v[i] = rhs[i]; 
-} 
-
-template &lt;typename T&gt; 
-Vector&lt;T&gt;::~Vector() 
-{ 
-  if (v != 0) 
-    delete[] (v); 
-} 
-
-template &lt;typename T&gt; 
-void Vector&lt;T&gt;::resize(const unsigned int n) 
-{
-  if (n == this-&gt;n)
-    return;
-  if (v != 0) 
-    delete[] (v); 
-  v = new T[n];
-  this-&gt;n = n;
-} 
-
-template &lt;typename T&gt; 
-void Vector&lt;T&gt;::resize(const T&amp; a, const unsigned int n) 
-{
-  resize(n);
-  for (unsigned int i = 0; i &lt; n; i++)
-    v[i] = a;
-} 
-
-
-template &lt;typename T&gt; 
-inline Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator=(const Vector&lt;T&gt;&amp; rhs) 
-// postcondition: normal assignment via copying has been performed; 
-// if vector and rhs were different sizes, vector 
-// has been resized to match the size of rhs 
-{ 
-  if (this != &amp;rhs) 
-    { 
+  enum MType { DIAG };
+
+  template &lt; typename T &gt;
+  class Vector
+  {
+public:
+    Vector();
+    Vector(const unsigned int n);
+    Vector(const T &amp; a, const unsigned int n); //initialize to constant value
+    Vector(const T * a, const unsigned int n); // Initialize to array
+    Vector(const Vector &amp; rhs); // copy constructor
+    ~Vector(); // destructor
+
+    inline void set(const T * a, const unsigned int n);
+    Vector &lt; T &gt; extract(const std::set &lt; unsigned int &gt; &amp;indexes) const;
+    inline T &amp; operator[] (const unsigned int &amp; i); //i-th element
+    inline const T &amp; operator[] (const unsigned int &amp; i) const;
+
+    inline unsigned int size() const;
+    inline void resize(const unsigned int n);
+    inline void resize(const T &amp; a, const unsigned int n);
+
+    Vector &lt; T &gt; &amp; operator = (const Vector &lt; T &gt; &amp;rhs); //assignment
+    Vector &lt; T &gt; &amp; operator = (const T &amp; a); //assign a to every element
+    inline Vector &lt; T &gt; &amp; operator += (const Vector &lt; T &gt; &amp;rhs);
+    inline Vector &lt; T &gt; &amp; operator -= (const Vector &lt; T &gt; &amp;rhs);
+    inline Vector &lt; T &gt; &amp; operator *= (const Vector &lt; T &gt; &amp;rhs);
+    inline Vector &lt; T &gt; &amp; operator /= (const Vector &lt; T &gt; &amp;rhs);
+    inline Vector &lt; T &gt; &amp; operator ^= (const Vector &lt; T &gt; &amp;rhs);
+    inline Vector &lt; T &gt; &amp; operator += (const T &amp; a);
+    inline Vector &lt; T &gt; &amp; operator -= (const T &amp; a);
+    inline Vector &lt; T &gt; &amp; operator *= (const T &amp; a);
+    inline Vector &lt; T &gt; &amp; operator /= (const T &amp; a);
+    inline Vector &lt; T &gt; &amp; operator ^= (const T &amp; a);
+
+private:
+    unsigned int n; // size of array. upper index is n-1
+    T * v; // storage for data
+  };
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; ::Vector()
+    : n(0), v(0)
+  {
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; ::Vector(const unsigned int n)
+    : v(new T[n])
+  {
+    this-&gt;n = n;
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; ::Vector(const T &amp; a, const unsigned int n)
+    : v(new T[n])
+  {
+    this-&gt;n = n;
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] = a;
+    }
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; ::Vector(const T * a, const unsigned int n)
+    : v(new T[n])
+  {
+    this-&gt;n = n;
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] = *a++;
+    }
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; ::Vector(const Vector &lt; T &gt; &amp;rhs)
+    : v(new T[rhs.n])
+  {
+    this-&gt;n = rhs.n;
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] = rhs[i];
+    }
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; ::~Vector()
+  {
+    if (v != 0) {
+      delete[] (v);
+    }
+  }
+
+  template &lt; typename T &gt;
+  void Vector &lt; T &gt; ::resize(const unsigned int n)
+  {
+    if (n == this-&gt;n) {
+      return;
+    }
+    if (v != 0) {
+      delete[] (v);
+    }
+    v = new T[n];
+    this-&gt;n = n;
+  }
+
+  template &lt; typename T &gt;
+  void Vector &lt; T &gt; ::resize(const T &amp; a, const unsigned int n)
+  {
+    resize(n);
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] = a;
+    }
+  }
+
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; &amp; Vector &lt; T &gt; ::operator = (const Vector &lt; T &gt; &amp;rhs)
+// postcondition: normal assignment via copying has been performed;
+// if vector and rhs were different sizes, vector
+// has been resized to match the size of rhs
+  {
+    if (this != &amp;rhs) {
@@ -135,47 +143,51 @@
-      for (unsigned int i = 0; i &lt; n; i++) 
-	v[i] = rhs[i]; 
-    } 
-  return *this; 
-} 
-
-template &lt;typename T&gt; 
-inline Vector&lt;T&gt; &amp; Vector&lt;T&gt;::operator=(const T&amp; a) //assign a to every element 
-{ 
-  for (unsigned int i = 0; i &lt; n; i++) 
-    v[i] = a; 
-  return *this; 
-} 
-
-template &lt;typename T&gt; 
-inline T &amp; Vector&lt;T&gt;::operator[](const unsigned int&amp; i) //subscripting 
-{ 
-  return v[i]; 
-}
-
-template &lt;typename T&gt;
-inline const T&amp; Vector&lt;T&gt;::operator[](const unsigned int&amp; i) const //subscripting 
-{ 
-  return v[i]; 
-} 
-
-template &lt;typename T&gt; 
-inline unsigned int Vector&lt;T&gt;::size() const 
-{ 
-  return n; 
-}
-
-template &lt;typename T&gt; 
-inline void Vector&lt;T&gt;::set(const T* a, unsigned int n) 
-{ 
-  resize(n);
-  for (unsigned int i = 0; i &lt; n; i++) 
-    v[i] = a[i]; 
-} 
-
-template &lt;typename T&gt; 
-inline Vector&lt;T&gt; Vector&lt;T&gt;::extract(const std::set&lt;unsigned int&gt;&amp; indexes) const
-{
-  Vector&lt;T&gt; tmp(indexes.size());
-  unsigned int i = 0;
-	
-  for (std::set&lt;unsigned int&gt;::const_iterator el = indexes.begin(); el != indexes.end(); el++)
+      for (unsigned int i = 0; i &lt; n; i++) {
+        v[i] = rhs[i];
+      }
+    }
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; &amp; Vector &lt; T &gt; ::operator = (const T &amp; a) //assign a to every element
+  {
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] = a;
+    }
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  inline T &amp; Vector &lt; T &gt; ::operator[] (const unsigned int &amp; i) //subscripting
+  {
+    return v[i];
+  }
+
+  template &lt; typename T &gt;
+  inline const T &amp; Vector &lt; T &gt; ::operator[] (const unsigned int &amp; i) const //subscripting
+  {
+    return v[i];
+  }
+
+  template &lt; typename T &gt;
+  inline unsigned int Vector &lt; T &gt; ::size() const
+  {
+    return n;
+  }
+
+  template &lt; typename T &gt;
+  inline void Vector &lt; T &gt; ::set(const T * a, unsigned int n)
+  {
+    resize(n);
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] = a[i];
+    }
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; Vector &lt; T &gt; ::extract(const std::set &lt; unsigned int &gt; &amp;indexes) const
+  {
+    Vector &lt; T &gt; tmp(indexes.size());
+    unsigned int i = 0;
+
+    for (std::set &lt; unsigned int &gt; ::const_iterator el = indexes.begin(); el != indexes.end();
+      el++)
@@ -183,2 +195,3 @@
-      if (*el &gt;= n)
-	throw std::logic_error("Error extracting subvector: the indexes are out of vector bounds");
+      if (*el &gt;= n) {
+        throw std::logic_error("Error extracting subvector: the indexes are out of vector bounds");
+      }
@@ -187,345 +200,398 @@
-	
-  return tmp;
-}
-
-template &lt;typename T&gt; 
-inline Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator+=(const Vector&lt;T&gt;&amp; rhs)
-{
-  if (this-&gt;size() != rhs.size())
-    throw std::logic_error("Operator+=: vectors have different sizes");
-  for (unsigned int i = 0; i &lt; n; i++)
-    v[i] += rhs[i];
-	
-  return *this;
-}
-
-
-template &lt;typename T&gt; 
-inline Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator+=(const T&amp; a)
-{
-  for (unsigned int i = 0; i &lt; n; i++)
-    v[i] += a;
-	
-  return *this;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator+(const Vector&lt;T&gt;&amp; rhs)
-{
-  return rhs;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator+(const Vector&lt;T&gt;&amp; lhs, const Vector&lt;T&gt;&amp; rhs)
-{
-  if (lhs.size() != rhs.size())
-    throw std::logic_error("Operator+: vectors have different sizes");
-  Vector&lt;T&gt; tmp(lhs.size());
-  for (unsigned int i = 0; i &lt; lhs.size(); i++)
-    tmp[i] = lhs[i] + rhs[i];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator+(const Vector&lt;T&gt;&amp; lhs, const T&amp; a)
-{
-  Vector&lt;T&gt; tmp(lhs.size());
-  for (unsigned int i = 0; i &lt; lhs.size(); i++)
-    tmp[i] = lhs[i] + a;
-		
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator+(const T&amp; a, const Vector&lt;T&gt;&amp; rhs)
-{
-  Vector&lt;T&gt; tmp(rhs.size());
-  for (unsigned int i = 0; i &lt; rhs.size(); i++)
-    tmp[i] = a + rhs[i];
-		
-  return tmp;
-}
-
-template &lt;typename T&gt; 
-inline Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator-=(const Vector&lt;T&gt;&amp; rhs)
-{
-  if (this-&gt;size() != rhs.size())
-    throw std::logic_error("Operator-=: vectors have different sizes");
-  for (unsigned int i = 0; i &lt; n; i++)
-    v[i] -= rhs[i];
-	
-  return *this;
-}
-
-
-template &lt;typename T&gt; 
-inline Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator-=(const T&amp; a)
-{
-  for (unsigned int i = 0; i &lt; n; i++)
-    v[i] -= a;
-	
-  return *this;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator-(const Vector&lt;T&gt;&amp; rhs)
-{
-  return (T)(-1) * rhs;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator-(const Vector&lt;T&gt;&amp; lhs, const Vector&lt;T&gt;&amp; rhs)
-{
-  if (lhs.size() != rhs.size())
-    throw std::logic_error("Operator-: vectors have different sizes");
-  Vector&lt;T&gt; tmp(lhs.size());
-  for (unsigned int i = 0; i &lt; lhs.size(); i++)
-    tmp[i] = lhs[i] - rhs[i];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator-(const Vector&lt;T&gt;&amp; lhs, const T&amp; a)
-{
-  Vector&lt;T&gt; tmp(lhs.size());
-  for (unsigned int i = 0; i &lt; lhs.size(); i++)
-    tmp[i] = lhs[i] - a;
-		
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator-(const T&amp; a, const Vector&lt;T&gt;&amp; rhs)
-{
-  Vector&lt;T&gt; tmp(rhs.size());
-  for (unsigned int i = 0; i &lt; rhs.size(); i++)
-    tmp[i] = a - rhs[i];
-		
-  return tmp;
-}
-
-template &lt;typename T&gt; 
-inline Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator*=(const Vector&lt;T&gt;&amp; rhs)
-{
-  if (this-&gt;size() != rhs.size())
-    throw std::logic_error("Operator*=: vectors have different sizes");
-  for (unsigned int i = 0; i &lt; n; i++)
-    v[i] *= rhs[i];
-	
-  return *this;
-}
-
-
-template &lt;typename T&gt; 
-inline Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator*=(const T&amp; a)
-{
-  for (unsigned int i = 0; i &lt; n; i++)
-    v[i] *= a;
-	
-  return *this;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator*(const Vector&lt;T&gt;&amp; lhs, const Vector&lt;T&gt;&amp; rhs)
-{
-  if (lhs.size() != rhs.size())
-    throw std::logic_error("Operator*: vectors have different sizes");
-  Vector&lt;T&gt; tmp(lhs.size());
-  for (unsigned int i = 0; i &lt; lhs.size(); i++)
-    tmp[i] = lhs[i] * rhs[i];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator*(const Vector&lt;T&gt;&amp; lhs, const T&amp; a)
-{
-  Vector&lt;T&gt; tmp(lhs.size());
-  for (unsigned int i = 0; i &lt; lhs.size(); i++)
-    tmp[i] = lhs[i] * a;
-		
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator*(const T&amp; a, const Vector&lt;T&gt;&amp; rhs)
-{
-  Vector&lt;T&gt; tmp(rhs.size());
-  for (unsigned int i = 0; i &lt; rhs.size(); i++)
-    tmp[i] = a * rhs[i];
-		
-  return tmp;
-}
-
-template &lt;typename T&gt; 
-inline Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator/=(const Vector&lt;T&gt;&amp; rhs)
-{
-  if (this-&gt;size() != rhs.size())
-    throw std::logic_error("Operator/=: vectors have different sizes");
-  for (unsigned int i = 0; i &lt; n; i++)
-    v[i] /= rhs[i];
-	
-  return *this;
-}
-
-
-template &lt;typename T&gt; 
-inline Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator/=(const T&amp; a)
-{
-  for (unsigned int i = 0; i &lt; n; i++)
-    v[i] /= a;
-	
-  return *this;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator/(const Vector&lt;T&gt;&amp; lhs, const Vector&lt;T&gt;&amp; rhs)
-{
-  if (lhs.size() != rhs.size())
-    throw std::logic_error("Operator/: vectors have different sizes");
-  Vector&lt;T&gt; tmp(lhs.size());
-  for (unsigned int i = 0; i &lt; lhs.size(); i++)
-    tmp[i] = lhs[i] / rhs[i];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator/(const Vector&lt;T&gt;&amp; lhs, const T&amp; a)
-{
-  Vector&lt;T&gt; tmp(lhs.size());
-  for (unsigned int i = 0; i &lt; lhs.size(); i++)
-    tmp[i] = lhs[i] / a;
-		
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator/(const T&amp; a, const Vector&lt;T&gt;&amp; rhs)
-{
-  Vector&lt;T&gt; tmp(rhs.size());
-  for (unsigned int i = 0; i &lt; rhs.size(); i++)
-    tmp[i] = a / rhs[i];
-		
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator^(const Vector&lt;T&gt;&amp; lhs, const Vector&lt;T&gt;&amp; rhs)
-{
-  if (lhs.size() != rhs.size())
-    throw std::logic_error("Operator^: vectors have different sizes");
-  Vector&lt;T&gt; tmp(lhs.size());
-  for (unsigned int i = 0; i &lt; lhs.size(); i++)
-    tmp[i] = pow(lhs[i], rhs[i]);
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator^(const Vector&lt;T&gt;&amp; lhs, const T&amp; a)
-{
-  Vector&lt;T&gt; tmp(lhs.size());
-  for (unsigned int i = 0; i &lt; lhs.size(); i++)
-    tmp[i] = pow(lhs[i], a);
-		
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; operator^(const T&amp; a, const Vector&lt;T&gt;&amp; rhs)
-{
-  Vector&lt;T&gt; tmp(rhs.size());
-  for (unsigned int i = 0; i &lt; rhs.size(); i++)
-    tmp[i] = pow(a, rhs[i]);
-		
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator^=(const Vector&lt;T&gt;&amp; rhs)
-{
-  if (this-&gt;size() != rhs.size())
-    throw std::logic_error("Operator^=: vectors have different sizes");
-  for (unsigned int i = 0; i &lt; n; i++)
-    v[i] = pow(v[i], rhs[i]);
-		
-  return *this;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt;&amp; Vector&lt;T&gt;::operator^=(const T&amp; a)
-{
-  for (unsigned int i = 0; i &lt; n; i++)
-    v[i] = pow(v[i], a);
-		
-  return *this;
-}
-
-template &lt;typename T&gt;
-inline bool operator==(const Vector&lt;T&gt;&amp; v, const Vector&lt;T&gt;&amp; w)
-{
-  if (v.size() != w.size())
-    throw std::logic_error("Vectors of different size are not confrontable");
-  for (unsigned i = 0; i &lt; v.size(); i++)
-    if (v[i] != w[i])
-      return false;
-  return true;
-}
-
-template &lt;typename T&gt;
-inline bool operator!=(const Vector&lt;T&gt;&amp; v, const Vector&lt;T&gt;&amp; w)
-{
-  if (v.size() != w.size())
-    throw std::logic_error("Vectors of different size are not confrontable");
-  for (unsigned i = 0; i &lt; v.size(); i++)
-    if (v[i] != w[i])
-      return true;
-  return false;
-}
-
-template &lt;typename T&gt;
-inline bool operator&lt;(const Vector&lt;T&gt;&amp; v, const Vector&lt;T&gt;&amp; w)
-{
-  if (v.size() != w.size())
-    throw std::logic_error("Vectors of different size are not confrontable");
-  for (unsigned i = 0; i &lt; v.size(); i++)
-    if (v[i] &gt;= w[i])
-      return false;
-  return true;
-}
-
-template &lt;typename T&gt;
-inline bool operator&lt;=(const Vector&lt;T&gt;&amp; v, const Vector&lt;T&gt;&amp; w)
-{
-  if (v.size() != w.size())
-    throw std::logic_error("Vectors of different size are not confrontable");
-  for (unsigned i = 0; i &lt; v.size(); i++)
-    if (v[i] &gt; w[i])
-      return false;
-  return true;
-}
-
-template &lt;typename T&gt;
-inline bool operator&gt;(const Vector&lt;T&gt;&amp; v, const Vector&lt;T&gt;&amp; w)
-{
-  if (v.size() != w.size())
-    throw std::logic_error("Vectors of different size are not confrontable");
-  for (unsigned i = 0; i &lt; v.size(); i++)
-    if (v[i] &lt;= w[i])
-      return false;
-  return true;
-}
-
-template &lt;typename T&gt;
-inline bool operator&gt;=(const Vector&lt;T&gt;&amp; v, const Vector&lt;T&gt;&amp; w)
-{
-  if (v.size() != w.size())
-    throw std::logic_error("Vectors of different size are not confrontable");
-  for (unsigned i = 0; i &lt; v.size(); i++)
-    if (v[i] &lt; w[i])
-      return false;
-  return true;
-}
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; &amp; Vector &lt; T &gt; ::operator += (const Vector &lt; T &gt; &amp;rhs)
+  {
+    if (this-&gt;size() != rhs.size()) {
+      throw std::logic_error("Operator+=: vectors have different sizes");
+    }
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] += rhs[i];
+    }
+
+    return *this;
+  }
+
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; &amp; Vector &lt; T &gt; ::operator += (const T &amp; a)
+  {
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] += a;
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator + (const Vector &lt; T &gt; &amp;rhs)
+  {
+    return rhs;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator + (const Vector &lt; T &gt; &amp;lhs, const Vector &lt; T &gt; &amp;rhs)
+  {
+    if (lhs.size() != rhs.size()) {
+      throw std::logic_error("Operator+: vectors have different sizes");
+    }
+    Vector &lt; T &gt; tmp(lhs.size());
+    for (unsigned int i = 0; i &lt; lhs.size(); i++) {
+      tmp[i] = lhs[i] + rhs[i];
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator + (const Vector &lt; T &gt; &amp;lhs, const T &amp; a)
+  {
+    Vector &lt; T &gt; tmp(lhs.size());
+    for (unsigned int i = 0; i &lt; lhs.size(); i++) {
+      tmp[i] = lhs[i] + a;
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator + (const T &amp; a, const Vector &lt; T &gt; &amp;rhs)
+  {
+    Vector &lt; T &gt; tmp(rhs.size());
+    for (unsigned int i = 0; i &lt; rhs.size(); i++) {
+      tmp[i] = a + rhs[i];
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; &amp; Vector &lt; T &gt; ::operator -= (const Vector &lt; T &gt; &amp;rhs)
+  {
+    if (this-&gt;size() != rhs.size()) {
+      throw std::logic_error("Operator-=: vectors have different sizes");
+    }
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] -= rhs[i];
+    }
+
+    return *this;
+  }
+
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; &amp; Vector &lt; T &gt; ::operator -= (const T &amp; a)
+  {
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] -= a;
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator - (const Vector &lt; T &gt; &amp;rhs)
+  {
+    return (T)(-1) * rhs;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator - (const Vector &lt; T &gt; &amp;lhs, const Vector &lt; T &gt; &amp;rhs)
+  {
+    if (lhs.size() != rhs.size()) {
+      throw std::logic_error("Operator-: vectors have different sizes");
+    }
+    Vector &lt; T &gt; tmp(lhs.size());
+    for (unsigned int i = 0; i &lt; lhs.size(); i++) {
+      tmp[i] = lhs[i] - rhs[i];
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator - (const Vector &lt; T &gt; &amp;lhs, const T &amp; a)
+  {
+    Vector &lt; T &gt; tmp(lhs.size());
+    for (unsigned int i = 0; i &lt; lhs.size(); i++) {
+      tmp[i] = lhs[i] - a;
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator - (const T &amp; a, const Vector &lt; T &gt; &amp;rhs)
+  {
+    Vector &lt; T &gt; tmp(rhs.size());
+    for (unsigned int i = 0; i &lt; rhs.size(); i++) {
+      tmp[i] = a - rhs[i];
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; &amp; Vector &lt; T &gt; ::operator *= (const Vector &lt; T &gt; &amp;rhs)
+  {
+    if (this-&gt;size() != rhs.size()) {
+      throw std::logic_error("Operator*=: vectors have different sizes");
+    }
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] *= rhs[i];
+    }
+
+    return *this;
+  }
+
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; &amp; Vector &lt; T &gt; ::operator *= (const T &amp; a)
+  {
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] *= a;
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator * (const Vector &lt; T &gt; &amp;lhs, const Vector &lt; T &gt; &amp;rhs)
+  {
+    if (lhs.size() != rhs.size()) {
+      throw std::logic_error("Operator*: vectors have different sizes");
+    }
+    Vector &lt; T &gt; tmp(lhs.size());
+    for (unsigned int i = 0; i &lt; lhs.size(); i++) {
+      tmp[i] = lhs[i] * rhs[i];
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator * (const Vector &lt; T &gt; &amp;lhs, const T &amp; a)
+  {
+    Vector &lt; T &gt; tmp(lhs.size());
+    for (unsigned int i = 0; i &lt; lhs.size(); i++) {
+      tmp[i] = lhs[i] * a;
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator * (const T &amp; a, const Vector &lt; T &gt; &amp;rhs)
+  {
+    Vector &lt; T &gt; tmp(rhs.size());
+    for (unsigned int i = 0; i &lt; rhs.size(); i++) {
+      tmp[i] = a * rhs[i];
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; &amp; Vector &lt; T &gt; ::operator /= (const Vector &lt; T &gt; &amp;rhs)
+  {
+    if (this-&gt;size() != rhs.size()) {
+      throw std::logic_error("Operator/=: vectors have different sizes");
+    }
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] /= rhs[i];
+    }
+
+    return *this;
+  }
+
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; &amp; Vector &lt; T &gt; ::operator /= (const T &amp; a)
+  {
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] /= a;
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator / (const Vector &lt; T &gt; &amp;lhs, const Vector &lt; T &gt; &amp;rhs)
+  {
+    if (lhs.size() != rhs.size()) {
+      throw std::logic_error("Operator/: vectors have different sizes");
+    }
+    Vector &lt; T &gt; tmp(lhs.size());
+    for (unsigned int i = 0; i &lt; lhs.size(); i++) {
+      tmp[i] = lhs[i] / rhs[i];
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator / (const Vector &lt; T &gt; &amp;lhs, const T &amp; a)
+  {
+    Vector &lt; T &gt; tmp(lhs.size());
+    for (unsigned int i = 0; i &lt; lhs.size(); i++) {
+      tmp[i] = lhs[i] / a;
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator / (const T &amp; a, const Vector &lt; T &gt; &amp;rhs)
+  {
+    Vector &lt; T &gt; tmp(rhs.size());
+    for (unsigned int i = 0; i &lt; rhs.size(); i++) {
+      tmp[i] = a / rhs[i];
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator ^ (const Vector &lt; T &gt; &amp;lhs, const Vector &lt; T &gt; &amp;rhs)
+  {
+    if (lhs.size() != rhs.size()) {
+      throw std::logic_error("Operator^: vectors have different sizes");
+    }
+    Vector &lt; T &gt; tmp(lhs.size());
+    for (unsigned int i = 0; i &lt; lhs.size(); i++) {
+      tmp[i] = pow(lhs[i], rhs[i]);
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator ^ (const Vector &lt; T &gt; &amp;lhs, const T &amp; a)
+  {
+    Vector &lt; T &gt; tmp(lhs.size());
+    for (unsigned int i = 0; i &lt; lhs.size(); i++) {
+      tmp[i] = pow(lhs[i], a);
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; operator ^ (const T &amp; a, const Vector &lt; T &gt; &amp;rhs)
+  {
+    Vector &lt; T &gt; tmp(rhs.size());
+    for (unsigned int i = 0; i &lt; rhs.size(); i++) {
+      tmp[i] = pow(a, rhs[i]);
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; &amp; Vector &lt; T &gt; ::operator ^= (const Vector &lt; T &gt; &amp;rhs)
+  {
+    if (this-&gt;size() != rhs.size()) {
+      throw std::logic_error("Operator^=: vectors have different sizes");
+    }
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] = pow(v[i], rhs[i]);
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; &amp; Vector &lt; T &gt; ::operator ^= (const T &amp; a)
+  {
+    for (unsigned int i = 0; i &lt; n; i++) {
+      v[i] = pow(v[i], a);
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  inline bool operator == (const Vector &lt; T &gt; &amp;v, const Vector &lt; T &gt; &amp;w)
+  {
+    if (v.size() != w.size()) {
+      throw std::logic_error("Vectors of different size are not confrontable");
+    }
+    for (unsigned i = 0; i &lt; v.size(); i++) {
+      if (v[i] != w[i]) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  template &lt; typename T &gt;
+  inline bool operator != (const Vector &lt; T &gt; &amp;v, const Vector &lt; T &gt; &amp;w)
+  {
+    if (v.size() != w.size()) {
+      throw std::logic_error("Vectors of different size are not confrontable");
+    }
+    for (unsigned i = 0; i &lt; v.size(); i++) {
+      if (v[i] != w[i]) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  template &lt; typename T &gt;
+  inline bool operator &lt; (const Vector &lt; T &gt; &amp;v, const Vector &lt; T &gt; &amp;w)
+  {
+    if (v.size() != w.size()) {
+      throw std::logic_error("Vectors of different size are not confrontable");
+    }
+    for (unsigned i = 0; i &lt; v.size(); i++) {
+      if (v[i] &gt;= w[i]) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  template &lt; typename T &gt;
+  inline bool operator &lt;= (const Vector &lt; T &gt; &amp;v, const Vector &lt; T &gt; &amp;w)
+  {
+    if (v.size() != w.size()) {
+      throw std::logic_error("Vectors of different size are not confrontable");
+    }
+    for (unsigned i = 0; i &lt; v.size(); i++) {
+      if (v[i] &gt; w[i]) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  template &lt; typename T &gt;
+  inline bool operator &gt; (const Vector &lt; T &gt; &amp;v, const Vector &lt; T &gt; &amp;w)
+  {
+    if (v.size() != w.size()) {
+      throw std::logic_error("Vectors of different size are not confrontable");
+    }
+    for (unsigned i = 0; i &lt; v.size(); i++) {
+      if (v[i] &lt;= w[i]) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  template &lt; typename T &gt;
+  inline bool operator &gt;= (const Vector &lt; T &gt; &amp;v, const Vector &lt; T &gt; &amp;w)
+  {
+    if (v.size() != w.size()) {
+      throw std::logic_error("Vectors of different size are not confrontable");
+    }
+    for (unsigned i = 0; i &lt; v.size(); i++) {
+      if (v[i] &lt; w[i]) {
+        return false;
+      }
+    }
+    return true;
+  }
@@ -534 +600 @@
-   Input/Output 
+   Input/Output
@@ -536,35 +602,37 @@
-template &lt;typename T&gt;
-inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vector&lt;T&gt;&amp; v)
-{
-  os &lt;&lt; std::endl &lt;&lt; v.size() &lt;&lt; std::endl;
-  for (unsigned int i = 0; i &lt; v.size() - 1; i++)
-    os &lt;&lt; std::setw(20) &lt;&lt; std::setprecision(16) &lt;&lt; v[i] &lt;&lt; ", ";
-  os &lt;&lt; std::setw(20) &lt;&lt; std::setprecision(16) &lt;&lt; v[v.size() - 1] &lt;&lt; std::endl;
-	
-  return os;
-}
-
-template &lt;typename T&gt;
-std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Vector&lt;T&gt;&amp; v)
-{
-  int elements;
-  char comma;
-  is &gt;&gt; elements;
-  v.resize(elements);
-  for (unsigned int i = 0; i &lt; elements; i++)
-    is &gt;&gt; v[i] &gt;&gt; comma;
-	
-  return is;
-}
-
-/**
-   Index utilities
-*/
-
-std::set&lt;unsigned int&gt; seq(unsigned int s, unsigned int e);
-
-std::set&lt;unsigned int&gt; singleton(unsigned int i);
-
-template &lt;typename T&gt;
-class CanonicalBaseVector : public Vector&lt;T&gt;
-{
+  template &lt; typename T &gt;
+  inline std::ostream &amp; operator &lt;&lt; (std::ostream &amp; os, const Vector &lt; T &gt; &amp;v)
+      {
+      os &lt;&lt; std::endl &lt;&lt; v.size() &lt;&lt; std::endl;
+      for (unsigned int i = 0; i &lt; v.size() - 1; i++) {
+        os &lt;&lt; std::setw(20) &lt;&lt; std::setprecision(16) &lt;&lt; v[i] &lt;&lt; ", ";
+      }
+      os &lt;&lt; std::setw(20) &lt;&lt; std::setprecision(16) &lt;&lt; v[v.size() - 1] &lt;&lt; std::endl;
+
+      return os;
+    }
+
+    template &lt; typename T &gt;
+    std::istream &amp; operator &gt;&gt; (std::istream &amp; is, Vector &lt; T &gt; &amp;v)
+      {
+      int elements;
+      char comma;
+      is &gt;&gt; elements;
+      v.resize(elements);
+      for (unsigned int i = 0; i &lt; elements; i++) {
+        is &gt;&gt; v[i] &gt;&gt; comma;
+      }
+
+      return is;
+    }
+
+    /**
+       Index utilities
+    */
+
+    std::set &lt; unsigned int &gt; seq(unsigned int s, unsigned int e);
+
+  std::set &lt; unsigned int &gt; singleton(unsigned int i);
+
+  template &lt; typename T &gt;
+  class CanonicalBaseVector: public Vector &lt; T &gt;
+  {
@@ -572,2 +640,3 @@
-  CanonicalBaseVector(unsigned int i, unsigned int n);
-  inline void reset(unsigned int i);
+    CanonicalBaseVector(unsigned int i, unsigned int n);
+    inline void reset(unsigned int i);
+
@@ -575,15 +644,17 @@
-  unsigned int e;
-};
-
-template &lt;typename T&gt;
-CanonicalBaseVector&lt;T&gt;::CanonicalBaseVector(unsigned int i, unsigned int n)
-  : Vector&lt;T&gt;((T)0, n), e(i)
-{ (*this)[e] = (T)1; }
-
-template &lt;typename T&gt;
-inline void CanonicalBaseVector&lt;T&gt;::reset(unsigned int i)
-{ 
-  (*this)[e] = (T)0; 
-  e = i; 
-  (*this)[e] = (T)1;
-}
+    unsigned int e;
+  }
+
+  template &lt; typename T &gt;
+  CanonicalBaseVector &lt; T &gt; ::CanonicalBaseVector(unsigned int i, unsigned int n)
+    : Vector &lt; T &gt; ((T)0, n), e(i)
+  {
+    (*this)[e] = (T)1;
+  }
+
+  template &lt; typename T &gt;
+  inline void CanonicalBaseVector &lt; T &gt; ::reset(unsigned int i)
+  {
+    (*this)[e] = (T)0;
+    e = i;
+    (*this)[e] = (T)1;
+  }
@@ -593,52 +664,55 @@
-template &lt;typename T&gt;
-inline T sum(const Vector&lt;T&gt;&amp; v)
-{
-  T tmp = (T)0;
-  for (unsigned int i = 0; i &lt; v.size(); i++)
-    tmp += v[i];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline T prod(const Vector&lt;T&gt;&amp; v)
-{
-  T tmp = (T)1;
-  for (unsigned int i = 0; i &lt; v.size(); i++)
-    tmp *= v[i];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline T mean(const Vector&lt;T&gt;&amp; v)
-{
-  T sum = (T)0;
-  for (unsigned int i = 0; i &lt; v.size(); i++)
-    sum += v[i];
-  return sum / v.size();
-}
-
-template &lt;typename T&gt;
-inline T median(const Vector&lt;T&gt;&amp; v)
-{
-  Vector&lt;T&gt; tmp = sort(v);
-  if (v.size() % 2 == 1) // it is an odd-sized vector
-    return tmp[v.size() / 2];
-  else
-    return 0.5 * (tmp[v.size() / 2 - 1] + tmp[v.size() / 2]);
-}
-
-template &lt;typename T&gt;
-inline T stdev(const Vector&lt;T&gt;&amp; v, bool sample_correction = false)
-{
-  return sqrt(var(v, sample_correction));
-}
-
-template &lt;typename T&gt;
-inline T var(const Vector&lt;T&gt;&amp; v, bool sample_correction = false)
-{
-  T sum = (T)0, ssum = (T)0;
-  unsigned int n = v.size();
-  for (unsigned int i = 0; i &lt; n; i++)
-    {	
+  template &lt; typename T &gt;
+  inline T sum(const Vector &lt; T &gt; &amp; v)
+  {
+    T tmp = (T)0;
+    for (unsigned int i = 0; i &lt; v.size(); i++) {
+      tmp += v[i];
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline T prod(const Vector &lt; T &gt; &amp; v)
+  {
+    T tmp = (T)1;
+    for (unsigned int i = 0; i &lt; v.size(); i++) {
+      tmp *= v[i];
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline T mean(const Vector &lt; T &gt; &amp; v)
+  {
+    T sum = (T)0;
+    for (unsigned int i = 0; i &lt; v.size(); i++) {
+      sum += v[i];
+    }
+    return sum / v.size();
+  }
+
+  template &lt; typename T &gt;
+  inline T median(const Vector &lt; T &gt; &amp; v)
+  {
+    Vector &lt; T &gt; tmp = sort(v);
+    if (v.size() % 2 == 1) { // it is an odd-sized vector
+      return tmp[v.size() / 2];
+    } else {
+      return 0.5 * (tmp[v.size() / 2 - 1] + tmp[v.size() / 2]);
+    }
+  }
+
+  template &lt; typename T &gt;
+  inline T stdev(const Vector &lt; T &gt; &amp; v, bool sample_correction = false)
+  {
+    return sqrt(var(v, sample_correction));
+  }
+
+  template &lt; typename T &gt;
+  inline T var(const Vector &lt; T &gt; &amp; v, bool sample_correction = false)
+  {
+    T sum = (T)0, ssum = (T)0;
+    unsigned int n = v.size();
+    for (unsigned int i = 0; i &lt; n; i++) {
@@ -648,60 +722,69 @@
-  if (!sample_correction)
-    return (ssum / n) - (sum / n) * (sum / n);
-  else
-    return n * ((ssum / n) - (sum / n) * (sum / n)) / (n - 1);
-}
-
-template &lt;typename T&gt;
-inline T max(const Vector&lt;T&gt;&amp; v)
-{
-  T value = v[0];
-  for (unsigned int i = 1; i &lt; v.size(); i++)
-    value = std::max(v[i], value);
-	
-  return value;
-}
-
-template &lt;typename T&gt;
-inline T min(const Vector&lt;T&gt;&amp; v)
-{
-  T value = v[0];
-  for (unsigned int i = 1; i &lt; v.size(); i++)
-    value = std::min(v[i], value);
-	
-  return value;
-}
-
-template &lt;typename T&gt;
-inline unsigned int index_max(const Vector&lt;T&gt;&amp; v)
-{
-  unsigned int max = 0;
-  for (unsigned int i = 1; i &lt; v.size(); i++)
-    if (v[i] &gt; v[max])
-      max = i;
-	
-  return max;
-}
-
-template &lt;typename T&gt;
-inline unsigned int index_min(const Vector&lt;T&gt;&amp; v)
-{
-  unsigned int min = 0;
-  for (unsigned int i = 1; i &lt; v.size(); i++)
-    if (v[i] &lt; v[min])
-      min = i;
-	
-  return min;
-}
-
-
-template &lt;typename T&gt;
-inline T dot_prod(const Vector&lt;T&gt;&amp; a, const Vector&lt;T&gt;&amp; b)
-{
-  T sum = (T)0;
-  if (a.size() != b.size())
-    throw std::logic_error("Dotprod error: the vectors are not the same size");
-  for (unsigned int i = 0; i &lt; a.size(); i++)
-    sum += a[i] * b[i];
-	
-  return sum;
-}
+    if (!sample_correction) {
+      return (ssum / n) - (sum / n) * (sum / n);
+    } else {
+      return n * ((ssum / n) - (sum / n) * (sum / n)) / (n - 1);
+    }
+  }
+
+  template &lt; typename T &gt;
+  inline T max(const Vector &lt; T &gt; &amp; v)
+  {
+    T value = v[0];
+    for (unsigned int i = 1; i &lt; v.size(); i++) {
+      value = std::max(v[i], value);
+    }
+
+    return value;
+  }
+
+  template &lt; typename T &gt;
+  inline T min(const Vector &lt; T &gt; &amp; v)
+  {
+    T value = v[0];
+    for (unsigned int i = 1; i &lt; v.size(); i++) {
+      value = std::min(v[i], value);
+    }
+
+    return value;
+  }
+
+  template &lt; typename T &gt;
+  inline unsigned int index_max(const Vector &lt; T &gt; &amp; v)
+  {
+    unsigned int max = 0;
+    for (unsigned int i = 1; i &lt; v.size(); i++) {
+      if (v[i] &gt; v[max]) {
+        max = i;
+      }
+    }
+
+    return max;
+  }
+
+  template &lt; typename T &gt;
+  inline unsigned int index_min(const Vector &lt; T &gt; &amp; v)
+  {
+    unsigned int min = 0;
+    for (unsigned int i = 1; i &lt; v.size(); i++) {
+      if (v[i] &lt; v[min]) {
+        min = i;
+      }
+    }
+
+    return min;
+  }
+
+
+  template &lt; typename T &gt;
+  inline T dot_prod(const Vector &lt; T &gt; &amp; a, const Vector &lt; T &gt; &amp; b)
+  {
+    T sum = (T)0;
+    if (a.size() != b.size()) {
+      throw std::logic_error("Dotprod error: the vectors are not the same size");
+    }
+    for (unsigned int i = 0; i &lt; a.size(); i++) {
+      sum += a[i] * b[i];
+    }
+
+    return sum;
+  }
@@ -713,67 +796,72 @@
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; exp(const Vector&lt;T&gt;&amp; v)
-{
-  Vector&lt;T&gt; tmp(v.size());
-  for (unsigned int i = 0; i &lt; v.size(); i++)
-    tmp[i] = exp(v[i]);
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; log(const Vector&lt;T&gt;&amp; v)
-{
-  Vector&lt;T&gt; tmp(v.size());
-  for (unsigned int i = 0; i &lt; v.size(); i++)
-    tmp[i] = log(v[i]);
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; vec_sqrt(const Vector&lt;T&gt;&amp; v)
-{
-  Vector&lt;T&gt; tmp(v.size());
-  for (unsigned int i = 0; i &lt; v.size(); i++)
-    tmp[i] = sqrt(v[i]);
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; pow(const Vector&lt;T&gt;&amp; v, double a)
-{
-  Vector&lt;T&gt; tmp(v.size());
-  for (unsigned int i = 0; i &lt; v.size(); i++)
-    tmp[i] = pow(v[i], a);
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; abs(const Vector&lt;T&gt;&amp; v)
-{
-  Vector&lt;T&gt; tmp(v.size());
-  for (unsigned int i = 0; i &lt; v.size(); i++)
-    tmp[i] = (T)fabs(v[i]);
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; sign(const Vector&lt;T&gt;&amp; v)
-{
-  Vector&lt;T&gt; tmp(v.size());
-  for (unsigned int i = 0; i &lt; v.size(); i++)
-    tmp[i] = v[i] &gt; 0 ? +1 : v[i] == 0 ? 0 : -1;
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline unsigned int partition(Vector&lt;T&gt;&amp; v, unsigned int begin, unsigned int end)
-{
-  unsigned int i = begin + 1, j = begin + 1;
-  T pivot = v[begin];
-  while (j &lt;= end) 
-    {
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; exp(const Vector &lt; T &gt; &amp;v)
+  {
+    Vector &lt; T &gt; tmp(v.size());
+    for (unsigned int i = 0; i &lt; v.size(); i++) {
+      tmp[i] = exp(v[i]);
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; log(const Vector &lt; T &gt; &amp;v)
+  {
+    Vector &lt; T &gt; tmp(v.size());
+    for (unsigned int i = 0; i &lt; v.size(); i++) {
+      tmp[i] = log(v[i]);
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; vec_sqrt(const Vector &lt; T &gt; &amp;v)
+  {
+    Vector &lt; T &gt; tmp(v.size());
+    for (unsigned int i = 0; i &lt; v.size(); i++) {
+      tmp[i] = sqrt(v[i]);
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; pow(const Vector &lt; T &gt; &amp;v, double a)
+  {
+    Vector &lt; T &gt; tmp(v.size());
+    for (unsigned int i = 0; i &lt; v.size(); i++) {
+      tmp[i] = pow(v[i], a);
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; abs(const Vector &lt; T &gt; &amp;v)
+  {
+    Vector &lt; T &gt; tmp(v.size());
+    for (unsigned int i = 0; i &lt; v.size(); i++) {
+      tmp[i] = (T)fabs(v[i]);
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; sign(const Vector &lt; T &gt; &amp;v)
+  {
+    Vector &lt; T &gt; tmp(v.size());
+    for (unsigned int i = 0; i &lt; v.size(); i++) {
+      tmp[i] = v[i] &gt; 0 ? +1 : v[i] == 0 ? 0 : -1;
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline unsigned int partition(Vector &lt; T &gt; &amp; v, unsigned int begin, unsigned int end)
+  {
+    unsigned int i = begin + 1, j = begin + 1;
+    T pivot = v[begin];
+    while (j &lt;= end) {
@@ -781,2 +869,2 @@
-	std::swap(v[i], v[j]);
-	i++;
+        std::swap(v[i], v[j]);
+        i++;
@@ -786,11 +874,10 @@
-  v[begin] = v[i - 1];
-  v[i - 1] = pivot;
-  return i - 2;
-}
-	
-
-template &lt;typename T&gt;
-inline void quicksort(Vector&lt;T&gt;&amp; v, unsigned int begin, unsigned int end)
-{
-  if (end &gt; begin)
-    {
+    v[begin] = v[i - 1];
+    v[i - 1] = pivot;
+    return i - 2;
+  }
+
+
+  template &lt; typename T &gt;
+  inline void quicksort(Vector &lt; T &gt; &amp; v, unsigned int begin, unsigned int end)
+  {
+    if (end &gt; begin) {
@@ -801,19 +888,341 @@
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; sort(const Vector&lt;T&gt;&amp; v)
-{
-  Vector&lt;T&gt; tmp(v);
-  
-  quicksort&lt;T&gt;(tmp, 0, tmp.size() - 1);
-  
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;double&gt; rank(const Vector&lt;T&gt;&amp; v)
-{
-  Vector&lt;T&gt; tmp(v);
-  Vector&lt;double&gt; tmp_rank(0.0, v.size());	
-	
-  for (unsigned int i = 0; i &lt; tmp.size(); i++)
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; sort(const Vector &lt; T &gt; &amp;v)
+  {
+    Vector &lt; T &gt; tmp(v);
+
+    quicksort &lt; T &gt; (tmp, 0, tmp.size() - 1);
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; double &gt; rank(const Vector &lt; T &gt; &amp;v)
+  {
+    Vector &lt; T &gt; tmp(v);
+    Vector &lt; double &gt; tmp_rank(0.0, v.size());
+
+    for (unsigned int i = 0; i &lt; tmp.size(); i++) {
+      unsigned int smaller = 0, equal = 0;
+      for (unsigned int j = 0; j &lt; tmp.size(); j++) {
+        if (i == j) {
+          continue;
+        } else if (tmp[j] &lt; tmp[i]) {
+          smaller++;
+        } else if (tmp[j] == tmp[i]) {
+          equal++;
+        }
+      }
+      tmp_rank[i] = smaller + 1;
+      if (equal &gt; 0) {
+        for (unsigned int j = 1; j &lt;= equal; j++) {
+          tmp_rank[i] += smaller + 1 + j;
+        }
+        tmp_rank[i] /= (double)(equal + 1);
+      }
+    }
+
+    return tmp_rank;
+  }
+
+//enum MType { DIAG };
+
+  template &lt; typename T &gt;
+  class Matrix
+  {
+public:
+    Matrix(); // Default constructor
+    Matrix(const unsigned int n, const unsigned int m); // Construct a n x m matrix
+    Matrix(const T &amp; a, const unsigned int n, const unsigned int m); // Initialize the content to constant a
+    Matrix(MType t, const T &amp; a, const T &amp; o, const unsigned int n, const unsigned int m);
+    Matrix(MType t, const Vector &lt; T &gt; &amp;v, const T &amp; o, const unsigned int n, const unsigned int m);
+    Matrix(const T * a, const unsigned int n, const unsigned int m); // Initialize to array
+    Matrix(const Matrix &lt; T &gt; &amp;rhs); // Copy constructor
+    ~Matrix(); // destructor
+
+    inline T * operator[] (const unsigned int &amp; i) {return v[i];} // Subscripting: row i
+    inline const T * operator[] (const unsigned int &amp; i) const {return v[i];} // const subsctipting
+
+    inline void resize(const unsigned int n, const unsigned int m);
+    inline void resize(const T &amp; a, const unsigned int n, const unsigned int m);
+
+
+    inline Vector &lt; T &gt; extractRow(const unsigned int i) const;
+    inline Vector &lt; T &gt; extractColumn(const unsigned int j) const;
+    inline Vector &lt; T &gt; extractDiag() const;
+    inline Matrix &lt; T &gt; extractRows(const std::set &lt; unsigned int &gt; &amp;indexes) const;
+    inline Matrix &lt; T &gt; extractColumns(const std::set &lt; unsigned int &gt; &amp;indexes) const;
+    inline Matrix &lt; T &gt; extract(
+      const std::set &lt; unsigned int &gt; &amp;r_indexes,
+      const std::set &lt; unsigned int &gt; &amp;c_indexes) const;
+
+    inline void set(const T * a, unsigned int n, unsigned int m);
+    inline void set(
+      const std::set &lt; unsigned int &gt; &amp; r_indexes,
+      const std::set &lt; unsigned int &gt; &amp; c_indexes, const Matrix &lt; T &gt; &amp; m);
+    inline void setRow(const unsigned int index, const Vector &lt; T &gt; &amp; v);
+    inline void setRow(const unsigned int index, const Matrix &lt; T &gt; &amp; v);
+    inline void setRows(const std::set &lt; unsigned int &gt; &amp; indexes, const Matrix &lt; T &gt; &amp; m);
+    inline void setColumn(const unsigned int index, const Vector &lt; T &gt; &amp; v);
+    inline void setColumn(const unsigned int index, const Matrix &lt; T &gt; &amp; v);
+    inline void setColumns(const std::set &lt; unsigned int &gt; &amp; indexes, const Matrix &lt; T &gt; &amp; m);
+
+
+    inline unsigned int nrows() const {return n;} // number of rows
+    inline unsigned int ncols() const {return m;} // number of columns
+
+    inline Matrix &lt; T &gt; &amp; operator = (const Matrix &lt; T &gt; &amp;rhs); // Assignment operator
+    inline Matrix &lt; T &gt; &amp; operator = (const T &amp; a); // Assign to every element value a
+    inline Matrix &lt; T &gt; &amp; operator += (const Matrix &lt; T &gt; &amp;rhs);
+    inline Matrix &lt; T &gt; &amp; operator -= (const Matrix &lt; T &gt; &amp;rhs);
+    inline Matrix &lt; T &gt; &amp; operator *= (const Matrix &lt; T &gt; &amp;rhs);
+    inline Matrix &lt; T &gt; &amp; operator /= (const Matrix &lt; T &gt; &amp;rhs);
+    inline Matrix &lt; T &gt; &amp; operator ^= (const Matrix &lt; T &gt; &amp;rhs);
+    inline Matrix &lt; T &gt; &amp; operator += (const T &amp; a);
+    inline Matrix &lt; T &gt; &amp; operator -= (const T &amp; a);
+    inline Matrix &lt; T &gt; &amp; operator *= (const T &amp; a);
+    inline Matrix &lt; T &gt; &amp; operator /= (const T &amp; a);
+    inline Matrix &lt; T &gt; &amp; operator ^= (const T &amp; a);
+    inline operator Vector &lt; T &gt; ();
+
+private:
+    unsigned int n; // number of rows
+    unsigned int m; // number of columns
+    T ** v; // storage for data
+  };
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; ::Matrix()
+    : n(0), m(0), v(0)
+  {
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; ::Matrix(unsigned int n, unsigned int m)
+    : v(new T *[n])
+  {
+    this-&gt;n = n; this-&gt;m = m;
+    v[0] = new T[m * n];
+    for (unsigned int i = 1; i &lt; n; i++) {
+      v[i] = v[i - 1] + m;
+    }
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; ::Matrix(const T &amp; a, unsigned int n, unsigned int m)
+    : v(new T *[n])
+  {
+    this-&gt;n = n; this-&gt;m = m;
+    v[0] = new T[m * n];
+    for (unsigned int i = 1; i &lt; n; i++) {
+      v[i] = v[i - 1] + m;
+    }
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] = a;
+      }
+    }
+  }
+
+  template &lt; class T &gt;
+  Matrix &lt; T &gt; ::Matrix(const T * a, unsigned int n, unsigned int m)
+    : v(new T *[n])
+  {
+    this-&gt;n = n; this-&gt;m = m;
+    v[0] = new T[m * n];
+    for (unsigned int i = 1; i &lt; n; i++) {
+      v[i] = v[i - 1] + m;
+    }
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] = *a++;
+      }
+    }
+  }
+
+  template &lt; class T &gt;
+  Matrix &lt; T &gt; ::Matrix(MType t, const T &amp; a, const T &amp; o, unsigned int n, unsigned int m)
+    : v(new T *[n])
+  {
+    this-&gt;n = n; this-&gt;m = m;
+    v[0] = new T[m * n];
+    for (unsigned int i = 1; i &lt; n; i++) {
+      v[i] = v[i - 1] + m;
+    }
+    switch (t) {
+      case DIAG:
+        for (unsigned int i = 0; i &lt; n; i++) {
+          for (unsigned int j = 0; j &lt; m; j++) {
+            if (i != j) {
+              v[i][j] = o;
+            } else {
+              v[i][j] = a;
+            }
+          }
+        }
+        break;
+      default:
+        throw std::logic_error("Matrix type not supported");
+    }
+  }
+
+  template &lt; class T &gt;
+  Matrix &lt; T &gt; ::Matrix(MType t, const Vector &lt; T &gt; &amp;a, const T &amp; o, unsigned int n, unsigned int m)
+    : v(new T *[n])
+  {
+    this-&gt;n = n; this-&gt;m = m;
+    v[0] = new T[m * n];
+    for (unsigned int i = 1; i &lt; n; i++) {
+      v[i] = v[i - 1] + m;
+    }
+    switch (t) {
+      case DIAG:
+        for (unsigned int i = 0; i &lt; n; i++) {
+          for (unsigned int j = 0; j &lt; m; j++) {
+            if (i != j) {
+              v[i][j] = o;
+            } else {
+              v[i][j] = a[i];
+            }
+          }
+        }
+        break;
+      default:
+        throw std::logic_error("Matrix type not supported");
+    }
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; ::Matrix(const Matrix &lt; T &gt; &amp;rhs)
+    : v(new T *[rhs.n])
+  {
+    n = rhs.n; m = rhs.m;
+    v[0] = new T[m * n];
+    for (unsigned int i = 1; i &lt; n; i++) {
+      v[i] = v[i - 1] + m;
+    }
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] = rhs[i][j];
+      }
+    }
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; ::~Matrix()
+  {
+    if (v != 0) {
+      delete[] (v[0]);
+      delete[] (v);
+    }
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; &amp; Matrix &lt; T &gt; ::operator = (const Matrix &lt; T &gt; &amp;rhs)
+// postcondition: normal assignment via copying has been performed;
+// if matrix and rhs were different sizes, matrix
+// has been resized to match the size of rhs
+  {
+    if (this != &amp;rhs) {
+      resize(rhs.n, rhs.m);
+      for (unsigned int i = 0; i &lt; n; i++) {
+        for (unsigned int j = 0; j &lt; m; j++) {
+          v[i][j] = rhs[i][j];
+        }
+      }
+    }
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; &amp; Matrix &lt; T &gt; ::operator = (const T &amp; a) // assign a to every element
+  {
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] = a;
+      }
+    }
+    return *this;
+  }
+
+
+  template &lt; typename T &gt;
+  inline void Matrix &lt; T &gt; ::resize(const unsigned int n, const unsigned int m)
+  {
+    if (n == this-&gt;n &amp;&amp; m == this-&gt;m) {
+      return;
+    }
+    if (v != 0) {
+      delete[] (v[0]);
+      delete[] (v);
+    }
+    this-&gt;n = n; this-&gt;m = m;
+    v = new T *[n];
+    v[0] = new T[m * n];
+    for (unsigned int i = 1; i &lt; n; i++) {
+      v[i] = v[i - 1] + m;
+    }
+  }
+
+  template &lt; typename T &gt;
+  inline void Matrix &lt; T &gt; ::resize(const T &amp; a, const unsigned int n, const unsigned int m)
+  {
+    resize(n, m);
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] = a;
+      }
+    }
+  }
+
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; Matrix &lt; T &gt; ::extractRow(const unsigned int i) const
+  {
+    if (i &gt;= n) {
+      throw std::logic_error("Error in extractRow: trying to extract a row out of matrix bounds");
+    }
+    Vector &lt; T &gt; tmp(v[i], m);
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; Matrix &lt; T &gt; ::extractColumn(const unsigned int j) const
+  {
+    if (j &gt;= m) {
+      throw std::logic_error("Error in extractRow: trying to extract a row out of matrix bounds");
+    }
+    Vector &lt; T &gt; tmp(n);
+
+    for (unsigned int i = 0; i &lt; n; i++) {
+      tmp[i] = v[i][j];
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Vector &lt; T &gt; Matrix &lt; T &gt; ::extractDiag() const
+  {
+    unsigned int d = std::min(n, m);
+
+    Vector &lt; T &gt; tmp(d);
+
+    for (unsigned int i = 0; i &lt; d; i++) {
+      tmp[i] = v[i][i];
+    }
+
+    return tmp;
+
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; Matrix &lt; T &gt; ::extractRows(const std::set &lt; unsigned int &gt; &amp;indexes) const
+  {
+    Matrix &lt; T &gt; tmp(indexes.size(), m);
+    unsigned int i = 0;
+
+    for (std::set &lt; unsigned int &gt; ::const_iterator el = indexes.begin(); el != indexes.end();
+      el++)
@@ -821,132 +1230,20 @@
-      unsigned int smaller = 0, equal = 0;
-      for (unsigned int j = 0; j &lt; tmp.size(); j++)
-	if (i == j)
-	  continue;
-	else
-	  if (tmp[j] &lt; tmp[i])
-	    smaller++;
-	  else if (tmp[j] == tmp[i])
-	    equal++;
-      tmp_rank[i] = smaller + 1;
-      if (equal &gt; 0)
-	{
-	  for (unsigned int j = 1; j &lt;= equal; j++)
-	    tmp_rank[i] += smaller + 1 + j;
-	  tmp_rank[i] /= (double)(equal + 1);
-	}
-    }
-	
-  return tmp_rank;
-}
-
-//enum MType { DIAG };
-
-template &lt;typename T&gt;
-class Matrix 
-{
-public:
-  Matrix(); // Default constructor
-  Matrix(const unsigned int n, const unsigned int m); // Construct a n x m matrix
-  Matrix(const T&amp; a, const unsigned int n, const unsigned int m); // Initialize the content to constant a
-  Matrix(MType t, const T&amp; a, const T&amp; o, const unsigned int n, const unsigned int m);
-  Matrix(MType t, const Vector&lt;T&gt;&amp; v, const T&amp; o, const unsigned int n, const unsigned int m);
-  Matrix(const T* a, const unsigned int n, const unsigned int m); // Initialize to array 
-  Matrix(const Matrix&lt;T&gt;&amp; rhs); // Copy constructor
-  ~Matrix(); // destructor
-	
-  inline T* operator[](const unsigned int&amp; i) { return v[i]; } // Subscripting: row i
-  inline const T* operator[](const unsigned int&amp; i) const { return v[i]; }; // const subsctipting
-	
-  inline void resize(const unsigned int n, const unsigned int m);
-  inline void resize(const T&amp; a, const unsigned int n, const unsigned int m);
-	
-	
-  inline Vector&lt;T&gt; extractRow(const unsigned int i) const; 
-  inline Vector&lt;T&gt; extractColumn(const unsigned int j) const;
-  inline Vector&lt;T&gt; extractDiag() const;
-  inline Matrix&lt;T&gt; extractRows(const std::set&lt;unsigned int&gt;&amp; indexes) const;
-  inline Matrix&lt;T&gt; extractColumns(const std::set&lt;unsigned int&gt;&amp; indexes) const;
-  inline Matrix&lt;T&gt; extract(const std::set&lt;unsigned int&gt;&amp; r_indexes, const std::set&lt;unsigned int&gt;&amp; c_indexes) const;
-	
-  inline void set(const T* a, unsigned int n, unsigned int m);
-  inline void set(const std::set&lt;unsigned int&gt;&amp; r_indexes, const std::set&lt;unsigned int&gt;&amp; c_indexes, const Matrix&lt;T&gt;&amp; m);
-  inline void setRow(const unsigned int index, const Vector&lt;T&gt;&amp; v);
-  inline void setRow(const unsigned int index, const Matrix&lt;T&gt;&amp; v);
-  inline void setRows(const std::set&lt;unsigned int&gt;&amp; indexes, const Matrix&lt;T&gt;&amp; m);
-  inline void setColumn(const unsigned int index, const Vector&lt;T&gt;&amp; v);
-  inline void setColumn(const unsigned int index, const Matrix&lt;T&gt;&amp; v);
-  inline void setColumns(const std::set&lt;unsigned int&gt;&amp; indexes, const Matrix&lt;T&gt;&amp; m);
-	
-	
-  inline unsigned int nrows() const { return n; } // number of rows
-  inline unsigned int ncols() const { return m; } // number of columns
-	
-  inline Matrix&lt;T&gt;&amp; operator=(const Matrix&lt;T&gt;&amp; rhs); // Assignment operator
-  inline Matrix&lt;T&gt;&amp; operator=(const T&amp; a); // Assign to every element value a
-  inline Matrix&lt;T&gt;&amp; operator+=(const Matrix&lt;T&gt;&amp; rhs);
-  inline Matrix&lt;T&gt;&amp; operator-=(const Matrix&lt;T&gt;&amp; rhs);
-  inline Matrix&lt;T&gt;&amp; operator*=(const Matrix&lt;T&gt;&amp; rhs);
-  inline Matrix&lt;T&gt;&amp; operator/=(const Matrix&lt;T&gt;&amp; rhs);
-  inline Matrix&lt;T&gt;&amp; operator^=(const Matrix&lt;T&gt;&amp; rhs);
-  inline Matrix&lt;T&gt;&amp; operator+=(const T&amp; a);
-  inline Matrix&lt;T&gt;&amp; operator-=(const T&amp; a);
-  inline Matrix&lt;T&gt;&amp; operator*=(const T&amp; a);
-  inline Matrix&lt;T&gt;&amp; operator/=(const T&amp; a);
-  inline Matrix&lt;T&gt;&amp; operator^=(const T&amp; a);
-  inline operator Vector&lt;T&gt;();
-private:
-  unsigned int n; // number of rows
-  unsigned int m; // number of columns
-  T **v; // storage for data
-};
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt;::Matrix() 
-  : n(0), m(0), v(0)
-{}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt;::Matrix(unsigned int n, unsigned int m)
-  : v(new T*[n])
-{
-  this-&gt;n = n; this-&gt;m = m;
-  v[0] = new T[m * n];
-  for (unsigned int i = 1; i &lt; n; i++)
-    v[i] = v[i - 1] + m;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt;::Matrix(const T&amp; a, unsigned int n, unsigned int m)
-  : v(new T*[n])
-{
-  this-&gt;n = n; this-&gt;m = m;
-  v[0] = new T[m * n];
-  for (unsigned int i = 1; i &lt; n; i++)
-    v[i] = v[i - 1] + m;
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] = a;
-}
-
-template &lt;class T&gt; 
-Matrix&lt;T&gt;::Matrix(const T* a, unsigned int n, unsigned int m) 
-  : v(new T*[n])
-{ 
-  this-&gt;n = n; this-&gt;m = m;
-  v[0] = new T[m * n]; 
-  for (unsigned int i = 1; i &lt; n; i++)
-    v[i] = v[i - 1] + m; 
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] = *a++; 
-} 
-
-template &lt;class T&gt; 
-Matrix&lt;T&gt;::Matrix(MType t, const T&amp; a, const T&amp; o, unsigned int n, unsigned int m) 
-  : v(new T*[n])
-{ 
-  this-&gt;n = n; this-&gt;m = m;
-  v[0] = new T[m * n]; 
-  for (unsigned int i = 1; i &lt; n; i++)
-    v[i] = v[i - 1] + m; 
-  switch (t)
+      for (unsigned int j = 0; j &lt; m; j++) {
+        if (*el &gt;= n) {
+          throw std::logic_error("Error extracting rows: the indexes are out of matrix bounds");
+        }
+        tmp[i][j] = v[*el][j];
+      }
+      i++;
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; Matrix &lt; T &gt; ::extractColumns(const std::set &lt; unsigned int &gt; &amp;indexes) const
+  {
+    Matrix &lt; T &gt; tmp(n, indexes.size());
+    unsigned int j = 0;
+
+    for (std::set &lt; unsigned int &gt; ::const_iterator el = indexes.begin(); el != indexes.end();
+      el++)
@@ -954,22 +1251,22 @@
-    case DIAG:
-      for (unsigned int i = 0; i &lt; n; i++)
-	for (unsigned int j = 0; j &lt; m; j++)
-	  if (i != j)
-	    v[i][j] = o; 
-	  else
-	    v[i][j] = a;
-      break;
-    default:
-      throw std::logic_error("Matrix type not supported");
-    }
-} 
-
-template &lt;class T&gt; 
-Matrix&lt;T&gt;::Matrix(MType t, const Vector&lt;T&gt;&amp; a, const T&amp; o, unsigned int n, unsigned int m) 
-  : v(new T*[n])
-{ 
-  this-&gt;n = n; this-&gt;m = m;
-  v[0] = new T[m * n]; 
-  for (unsigned int i = 1; i &lt; n; i++)
-    v[i] = v[i - 1] + m; 
-  switch (t)
+      for (unsigned int i = 0; i &lt; n; i++) {
+        if (*el &gt;= m) {
+          throw std::logic_error("Error extracting columns: the indexes are out of matrix bounds");
+        }
+        tmp[i][j] = v[i][*el];
+      }
+      j++;
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; Matrix &lt; T &gt; ::extract(
+    const std::set &lt; unsigned int &gt; &amp;r_indexes,
+    const std::set &lt; unsigned int &gt; &amp;c_indexes) const
+  {
+    Matrix &lt; T &gt; tmp(r_indexes.size(), c_indexes.size());
+    unsigned int i = 0, j;
+
+    for (std::set &lt; unsigned int &gt; ::const_iterator r_el = r_indexes.begin();
+      r_el != r_indexes.end(); r_el++)
@@ -977,42 +1274,61 @@
-    case DIAG:
-      for (unsigned int i = 0; i &lt; n; i++)
-	for (unsigned int j = 0; j &lt; m; j++)
-	  if (i != j)
-	    v[i][j] = o; 
-	  else
-	    v[i][j] = a[i];
-      break;
-    default:
-      throw std::logic_error("Matrix type not supported");
-    }
-} 
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt;::Matrix(const Matrix&lt;T&gt;&amp; rhs)
-  : v(new T*[rhs.n])
-{
-  n = rhs.n; m = rhs.m;
-  v[0] = new T[m * n]; 
-  for (unsigned int i = 1; i &lt; n; i++)
-    v[i] = v[i - 1] + m;
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] = rhs[i][j];
-}
-
-template &lt;typename T&gt; 
-Matrix&lt;T&gt;::~Matrix() 
-{ 
-  if (v != 0) { 
-    delete[] (v[0]); 
-    delete[] (v); 
-  } 
-}
-				
-template &lt;typename T&gt; 
-inline Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::operator=(const Matrix&lt;T&gt; &amp;rhs) 
-// postcondition: normal assignment via copying has been performed; 
-// if matrix and rhs were different sizes, matrix 
-// has been resized to match the size of rhs 
-{ 
-  if (this != &amp;rhs) 
+      if (*r_el &gt;= n) {
+        throw std::logic_error("Error extracting submatrix: the indexes are out of matrix bounds");
+      }
+      j = 0;
+      for (std::set &lt; unsigned int &gt; ::const_iterator c_el = c_indexes.begin();
+        c_el != c_indexes.end(); c_el++)
+      {
+        if (*c_el &gt;= m) {
+          throw std::logic_error("Error extracting rows: the indexes are out of matrix bounds");
+        }
+        tmp[i][j] = v[*r_el][*c_el];
+        j++;
+      }
+      i++;
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline void Matrix &lt; T &gt; ::setRow(unsigned int i, const Vector &lt; T &gt; &amp;a)
+  {
+    if (i &gt;= n) {
+      throw std::logic_error("Error in setRow: trying to set a row out of matrix bounds");
+    }
+    if (this-&gt;m != a.size()) {
+      throw std::logic_error("Error setting matrix row: ranges are not compatible");
+    }
+    for (unsigned int j = 0; j &lt; ncols(); j++) {
+      v[i][j] = a[j];
+    }
+  }
+
+  template &lt; typename T &gt;
+  inline void Matrix &lt; T &gt; ::setRow(unsigned int i, const Matrix &lt; T &gt; &amp;a)
+  {
+    if (i &gt;= n) {
+      throw std::logic_error("Error in setRow: trying to set a row out of matrix bounds");
+    }
+    if (this-&gt;m != a.ncols()) {
+      throw std::logic_error("Error setting matrix column: ranges are not compatible");
+    }
+    if (a.nrows() != 1) {
+      throw std::logic_error("Error setting matrix column with a non-row matrix");
+    }
+    for (unsigned int j = 0; j &lt; ncols(); j++) {
+      v[i][j] = a[0][j];
+    }
+  }
+
+  template &lt; typename T &gt;
+  inline void Matrix &lt; T &gt;
+  ::setRows(const std::set &lt; unsigned int &gt; &amp;indexes, const Matrix &lt; T &gt; &amp;m)
+  {
+    unsigned int i = 0;
+
+    if (indexes.size() != m.nrows() || this-&gt;m != m.ncols()) {
+      throw std::logic_error("Error setting matrix rows: ranges are not compatible");
+    }
+    for (std::set &lt; unsigned int &gt; ::const_iterator el = indexes.begin(); el != indexes.end();
+      el++)
@@ -1020,90 +1336,54 @@
-      resize(rhs.n, rhs.m);
-      for (unsigned int i = 0; i &lt; n; i++)
-	for (unsigned int j = 0; j &lt; m; j++)
-	  v[i][j] = rhs[i][j]; 
-    } 
-  return *this; 
-} 
-
-template &lt;typename T&gt; 
-inline Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::operator=(const T&amp; a) // assign a to every element 
-{ 
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] = a; 
-  return *this; 
-} 
-
-
-template &lt;typename T&gt; 
-inline void Matrix&lt;T&gt;::resize(const unsigned int n, const unsigned int m) 
-{
-  if (n == this-&gt;n &amp;&amp; m == this-&gt;m)
-    return;
-  if (v != 0) 
-    { 
-      delete[] (v[0]); 
-      delete[] (v); 
-    } 
-  this-&gt;n = n; this-&gt;m = m;
-  v = new T*[n]; 
-  v[0] = new T[m * n];  
-  for (unsigned int i = 1; i &lt; n; i++)
-    v[i] = v[i - 1] + m;
-} 
-
-template &lt;typename T&gt; 
-inline void Matrix&lt;T&gt;::resize(const T&amp; a, const unsigned int n, const unsigned int m) 
-{
-  resize(n, m);
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] = a;
-} 
-
-
-
-template &lt;typename T&gt; 
-inline Vector&lt;T&gt; Matrix&lt;T&gt;::extractRow(const unsigned int i) const
-{
-  if (i &gt;= n)
-    throw std::logic_error("Error in extractRow: trying to extract a row out of matrix bounds");
-  Vector&lt;T&gt; tmp(v[i], m);
-	
-  return tmp;
-}
-
-template &lt;typename T&gt; 
-inline Vector&lt;T&gt; Matrix&lt;T&gt;::extractColumn(const unsigned int j) const
-{
-  if (j &gt;= m)
-    throw std::logic_error("Error in extractRow: trying to extract a row out of matrix bounds");
-  Vector&lt;T&gt; tmp(n);
-	
-  for (unsigned int i = 0; i &lt; n; i++)
-    tmp[i] = v[i][j];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Vector&lt;T&gt; Matrix&lt;T&gt;::extractDiag() const
-{
-  unsigned int d = std::min(n, m);
-  
-  Vector&lt;T&gt; tmp(d);
-	
-  for (unsigned int i = 0; i &lt; d; i++)
-    tmp[i] = v[i][i];
-	
-  return tmp;
-	
-}
-
-template &lt;typename T&gt; 
-inline Matrix&lt;T&gt; Matrix&lt;T&gt;::extractRows(const std::set&lt;unsigned int&gt;&amp; indexes) const
-{
-  Matrix&lt;T&gt; tmp(indexes.size(), m);
-  unsigned int i = 0;
-	
-  for (std::set&lt;unsigned int&gt;::const_iterator el = indexes.begin(); el != indexes.end(); el++)
+      for (unsigned int j = 0; j &lt; ncols(); j++) {
+        if (*el &gt;= n) {
+          throw std::logic_error("Error in setRows: trying to set a row out of matrix bounds");
+        }
+        v[*el][j] = m[i][j];
+      }
+      i++;
+    }
+  }
+
+  template &lt; typename T &gt;
+  inline void Matrix &lt; T &gt; ::setColumn(unsigned int j, const Vector &lt; T &gt; &amp;a)
+  {
+    if (j &gt;= m) {
+      throw std::logic_error("Error in setColumn: trying to set a column out of matrix bounds");
+    }
+    if (this-&gt;n != a.size()) {
+      throw std::logic_error("Error setting matrix column: ranges are not compatible");
+    }
+    for (unsigned int i = 0; i &lt; nrows(); i++) {
+      v[i][j] = a[i];
+    }
+  }
+
+  template &lt; typename T &gt;
+  inline void Matrix &lt; T &gt; ::setColumn(unsigned int j, const Matrix &lt; T &gt; &amp;a)
+  {
+    if (j &gt;= m) {
+      throw std::logic_error("Error in setColumn: trying to set a column out of matrix bounds");
+    }
+    if (this-&gt;n != a.nrows()) {
+      throw std::logic_error("Error setting matrix column: ranges are not compatible");
+    }
+    if (a.ncols() != 1) {
+      throw std::logic_error("Error setting matrix column with a non-column matrix");
+    }
+    for (unsigned int i = 0; i &lt; nrows(); i++) {
+      v[i][j] = a[i][0];
+    }
+  }
+
+
+  template &lt; typename T &gt;
+  inline void Matrix &lt; T &gt; ::setColumns(
+    const std::set &lt; unsigned int &gt; &amp;indexes,
+    const Matrix &lt; T &gt; &amp;a)
+  {
+    unsigned int j = 0;
+
+    if (indexes.size() != a.ncols() || this-&gt;n != a.nrows()) {
+      throw std::logic_error("Error setting matrix columns: ranges are not compatible");
+    }
+    for (std::set &lt; unsigned int &gt; ::const_iterator el = indexes.begin(); el != indexes.end();
+      el++)
@@ -1111,6 +1391,37 @@
-      for (unsigned int j = 0; j &lt; m; j++)
-	{
-	  if (*el &gt;= n)
-	    throw std::logic_error("Error extracting rows: the indexes are out of matrix bounds");
-	  tmp[i][j] = v[*el][j];
-	}
+      for (unsigned int i = 0; i &lt; nrows(); i++) {
+        if (*el &gt;= m) {
+          throw std::logic_error(
+            "Error in setColumns: trying to set a column out of matrix bounds");
+        }
+        v[i][*el] = a[i][j];
+      }
+      j++;
+    }
+  }
+
+  template &lt; typename T &gt;
+  inline void Matrix &lt; T &gt; ::set(
+    const std::set &lt; unsigned int &gt; &amp;r_indexes,
+    const std::set &lt; unsigned int &gt; &amp;c_indexes, const Matrix &lt; T &gt; &amp;a)
+  {
+    unsigned int i = 0, j;
+    if (c_indexes.size() != a.ncols() || r_indexes.size() != a.nrows()) {
+      throw std::logic_error("Error setting matrix elements: ranges are not compatible");
+    }
+
+    for (std::set &lt; unsigned int &gt; ::const_iterator r_el = r_indexes.begin();
+      r_el != r_indexes.end(); r_el++)
+    {
+      if (*r_el &gt;= n) {
+        throw std::logic_error("Error in set: trying to set a row out of matrix bounds");
+      }
+      j = 0;
+      for (std::set &lt; unsigned int &gt; ::const_iterator c_el = c_indexes.begin();
+        c_el != c_indexes.end(); c_el++)
+      {
+        if (*c_el &gt;= m) {
+          throw std::logic_error("Error in set: trying to set a column out of matrix bounds");
+        }
+        v[*r_el][*c_el] = a[i][j];
+        j++;
+      }
@@ -1119,479 +1430,391 @@
-	
-  return tmp;
-}
-
-template &lt;typename T&gt; 
-inline Matrix&lt;T&gt; Matrix&lt;T&gt;::extractColumns(const std::set&lt;unsigned int&gt;&amp; indexes) const
-{
-  Matrix&lt;T&gt; tmp(n, indexes.size());
-  unsigned int j = 0;
-	
-  for (std::set&lt;unsigned int&gt;::const_iterator el = indexes.begin(); el != indexes.end(); el++)
-    {
-      for (unsigned int i = 0; i &lt; n; i++)
-	{
-	  if (*el &gt;= m)
-	    throw std::logic_error("Error extracting columns: the indexes are out of matrix bounds");
-	  tmp[i][j] = v[i][*el];
-	}
-      j++;
-    }
-	
-  return tmp;
-}
-
-template &lt;typename T&gt; 
-inline Matrix&lt;T&gt; Matrix&lt;T&gt;::extract(const std::set&lt;unsigned int&gt;&amp; r_indexes, const std::set&lt;unsigned int&gt;&amp; c_indexes) const
-{
-  Matrix&lt;T&gt; tmp(r_indexes.size(), c_indexes.size());
-  unsigned int i = 0, j;
-	
-  for (std::set&lt;unsigned int&gt;::const_iterator r_el = r_indexes.begin(); r_el != r_indexes.end(); r_el++)
-    {
-      if (*r_el &gt;= n)
-	throw std::logic_error("Error extracting submatrix: the indexes are out of matrix bounds");
-      j = 0;
-      for (std::set&lt;unsigned int&gt;::const_iterator c_el = c_indexes.begin(); c_el != c_indexes.end(); c_el++)
-	{
-	  if (*c_el &gt;= m)
-	    throw std::logic_error("Error extracting rows: the indexes are out of matrix bounds");
-	  tmp[i][j] = v[*r_el][*c_el];
-	  j++;
-	}
-      i++;
-    }
-	
-  return tmp;
-}
-
-template &lt;typename T&gt; 
-inline void Matrix&lt;T&gt;::setRow(unsigned int i, const Vector&lt;T&gt;&amp; a)
-{	
-  if (i &gt;= n)
-    throw std::logic_error("Error in setRow: trying to set a row out of matrix bounds");
-  if (this-&gt;m != a.size())
-    throw std::logic_error("Error setting matrix row: ranges are not compatible");
-  for (unsigned int j = 0; j &lt; ncols(); j++)
-    v[i][j] = a[j];
-}
-
-template &lt;typename T&gt; 
-inline void Matrix&lt;T&gt;::setRow(unsigned int i, const Matrix&lt;T&gt;&amp; a)
-{	
-  if (i &gt;= n)
-    throw std::logic_error("Error in setRow: trying to set a row out of matrix bounds");
-  if (this-&gt;m != a.ncols())
-    throw std::logic_error("Error setting matrix column: ranges are not compatible");
-  if (a.nrows() != 1)
-    throw std::logic_error("Error setting matrix column with a non-row matrix");
-  for (unsigned int j = 0; j &lt; ncols(); j++)
-    v[i][j] = a[0][j];
-}
-
-template &lt;typename T&gt; 
-inline void Matrix&lt;T&gt;::setRows(const std::set&lt;unsigned int&gt;&amp; indexes, const Matrix&lt;T&gt;&amp; m)
-{
-  unsigned int i = 0;
-	
-  if (indexes.size() != m.nrows() || this-&gt;m != m.ncols())
-    throw std::logic_error("Error setting matrix rows: ranges are not compatible");
-  for (std::set&lt;unsigned int&gt;::const_iterator el = indexes.begin(); el != indexes.end(); el++)
-    {
-      for (unsigned int j = 0; j &lt; ncols(); j++)
-	{
-	  if (*el &gt;= n)
-	    throw std::logic_error("Error in setRows: trying to set a row out of matrix bounds");
-	  v[*el][j] = m[i][j];
-	}
-      i++;
-    }
-}
-
-template &lt;typename T&gt; 
-inline void Matrix&lt;T&gt;::setColumn(unsigned int j, const Vector&lt;T&gt;&amp; a)
-{	
-  if (j &gt;= m)
-    throw std::logic_error("Error in setColumn: trying to set a column out of matrix bounds");
-  if (this-&gt;n != a.size())
-    throw std::logic_error("Error setting matrix column: ranges are not compatible");
-  for (unsigned int i = 0; i &lt; nrows(); i++)
-    v[i][j] = a[i];
-}
-
-template &lt;typename T&gt; 
-inline void Matrix&lt;T&gt;::setColumn(unsigned int j, const Matrix&lt;T&gt;&amp; a)
-{	
-  if (j &gt;= m)
-    throw std::logic_error("Error in setColumn: trying to set a column out of matrix bounds");
-  if (this-&gt;n != a.nrows())
-    throw std::logic_error("Error setting matrix column: ranges are not compatible");
-  if (a.ncols() != 1)
-    throw std::logic_error("Error setting matrix column with a non-column matrix");
-  for (unsigned int i = 0; i &lt; nrows(); i++)
-    v[i][j] = a[i][0];
-}
-
-
-template &lt;typename T&gt; 
-inline void Matrix&lt;T&gt;::setColumns(const std::set&lt;unsigned int&gt;&amp; indexes, const Matrix&lt;T&gt;&amp; a)
-{
-  unsigned int j = 0;
-	
-  if (indexes.size() != a.ncols() || this-&gt;n != a.nrows())
-    throw std::logic_error("Error setting matrix columns: ranges are not compatible");
-  for (std::set&lt;unsigned int&gt;::const_iterator el = indexes.begin(); el != indexes.end(); el++)
-    {
-      for (unsigned int i = 0; i &lt; nrows(); i++)
-	{
-	  if (*el &gt;= m)
-	    throw std::logic_error("Error in setColumns: trying to set a column out of matrix bounds");
-	  v[i][*el] = a[i][j];
-	}
-      j++;
-    }
-}
-
-template &lt;typename T&gt; 
-inline void Matrix&lt;T&gt;::set(const std::set&lt;unsigned int&gt;&amp; r_indexes, const std::set&lt;unsigned int&gt;&amp; c_indexes, const Matrix&lt;T&gt;&amp; a)
-{
-  unsigned int i = 0, j;
-  if (c_indexes.size() != a.ncols() || r_indexes.size() != a.nrows())
-    throw std::logic_error("Error setting matrix elements: ranges are not compatible");
-	
-  for (std::set&lt;unsigned int&gt;::const_iterator r_el = r_indexes.begin(); r_el != r_indexes.end(); r_el++)
-    {
-      if (*r_el &gt;= n)
-	throw std::logic_error("Error in set: trying to set a row out of matrix bounds");
-      j = 0;
-      for (std::set&lt;unsigned int&gt;::const_iterator c_el = c_indexes.begin(); c_el != c_indexes.end(); c_el++)
-	{
-	  if (*c_el &gt;= m)
-	    throw std::logic_error("Error in set: trying to set a column out of matrix bounds");
-	  v[*r_el][*c_el] = a[i][j];
-	  j++;
-	}
-      i++;
-    }
-}
-
-template &lt;typename T&gt; 
-inline void Matrix&lt;T&gt;::set(const T* a, unsigned int n, unsigned int m)
-{
-  if (this-&gt;n != n || this-&gt;m != m)
-    resize(n, m);
-  unsigned int k = 0;
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] = a[k++];
-}
-
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator+(const Matrix&lt;T&gt;&amp; rhs)
-{
-  return rhs;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator+(const Matrix&lt;T&gt;&amp; lhs, const Matrix&lt;T&gt;&amp; rhs)
-{
-  if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows())
-    throw std::logic_error("Operator+: matrices have different sizes");
-  Matrix&lt;T&gt; tmp(lhs.nrows(), lhs.ncols());
-  for (unsigned int i = 0; i &lt; lhs.nrows(); i++)
-    for (unsigned int j = 0; j &lt; lhs.ncols(); j++)
-      tmp[i][j] = lhs[i][j] + rhs[i][j];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator+(const Matrix&lt;T&gt;&amp; lhs, const T&amp; a)
-{
-  Matrix&lt;T&gt; tmp(lhs.nrows(), lhs.ncols());
-  for (unsigned int i = 0; i &lt; lhs.nrows(); i++)
-    for (unsigned int j = 0; j &lt; lhs.ncols(); j++)
-      tmp[i][j] = lhs[i][j] + a;
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator+(const T&amp; a, const Matrix&lt;T&gt;&amp; rhs)
-{
-  Matrix&lt;T&gt; tmp(rhs.nrows(), rhs.ncols());
-  for (unsigned int i = 0; i &lt; rhs.nrows(); i++)
-    for (unsigned int j = 0; j &lt; rhs.ncols(); j++)
-      tmp[i][j] = a + rhs[i][j];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::operator+=(const Matrix&lt;T&gt;&amp; rhs)
-{
-  if (m != rhs.ncols() || n != rhs.nrows())
-    throw std::logic_error("Operator+=: matrices have different sizes");
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] += rhs[i][j];
-	
-  return *this;
-}
-
-template &lt;typename T&gt;
-inline Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::operator+=(const T&amp; a)
-{
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] += a;
-	
-  return *this;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator-(const Matrix&lt;T&gt;&amp; rhs)
-{	
-  return (T)(-1) * rhs;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator-(const Matrix&lt;T&gt;&amp; lhs, const Matrix&lt;T&gt;&amp; rhs)
-{
-  if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows())
-    throw std::logic_error("Operator-: matrices have different sizes");
-  Matrix&lt;T&gt; tmp(lhs.nrows(), lhs.ncols());
-  for (unsigned int i = 0; i &lt; lhs.nrows(); i++)
-    for (unsigned int j = 0; j &lt; lhs.ncols(); j++)
-      tmp[i][j] = lhs[i][j] - rhs[i][j];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator-(const Matrix&lt;T&gt;&amp; lhs, const T&amp; a)
-{
-  Matrix&lt;T&gt; tmp(lhs.nrows(), lhs.ncols());
-  for (unsigned int i = 0; i &lt; lhs.nrows(); i++)
-    for (unsigned int j = 0; j &lt; lhs.ncols(); j++)
-      tmp[i][j] = lhs[i][j] - a;
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator-(const T&amp; a, const Matrix&lt;T&gt;&amp; rhs)
-{
-  Matrix&lt;T&gt; tmp(rhs.nrows(), rhs.ncols());
-  for (unsigned int i = 0; i &lt; rhs.nrows(); i++)
-    for (unsigned int j = 0; j &lt; rhs.ncols(); j++)
-      tmp[i][j] = a - rhs[i][j];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::operator-=(const Matrix&lt;T&gt;&amp; rhs)
-{
-  if (m != rhs.ncols() || n != rhs.nrows())
-    throw std::logic_error("Operator-=: matrices have different sizes");
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] -= rhs[i][j];
-	
-  return *this;
-}
-
-template &lt;typename T&gt;
-inline Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::operator-=(const T&amp; a)
-{
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] -= a;
-	
-  return *this;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator*(const Matrix&lt;T&gt;&amp; lhs, const Matrix&lt;T&gt;&amp; rhs)
-{
-  if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows())
-    throw std::logic_error("Operator*: matrices have different sizes");
-  Matrix&lt;T&gt; tmp(lhs.nrows(), lhs.ncols());
-  for (unsigned int i = 0; i &lt; lhs.nrows(); i++)
-    for (unsigned int j = 0; j &lt; lhs.ncols(); j++)
-      tmp[i][j] = lhs[i][j] * rhs[i][j];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator*(const Matrix&lt;T&gt;&amp; lhs, const T&amp; a)
-{
-  Matrix&lt;T&gt; tmp(lhs.nrows(), lhs.ncols());
-  for (unsigned int i = 0; i &lt; lhs.nrows(); i++)
-    for (unsigned int j = 0; j &lt; lhs.ncols(); j++)
-      tmp[i][j] = lhs[i][j] * a;
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator*(const T&amp; a, const Matrix&lt;T&gt;&amp; rhs)
-{
-  Matrix&lt;T&gt; tmp(rhs.nrows(), rhs.ncols());
-  for (unsigned int i = 0; i &lt; rhs.nrows(); i++)
-    for (unsigned int j = 0; j &lt; rhs.ncols(); j++)
-      tmp[i][j] = a * rhs[i][j];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::operator*=(const Matrix&lt;T&gt;&amp; rhs)
-{
-  if (m != rhs.ncols() || n != rhs.nrows())
-    throw std::logic_error("Operator*=: matrices have different sizes");
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] *= rhs[i][j];
-	
-  return *this;
-}
-
-template &lt;typename T&gt;
-inline Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::operator*=(const T&amp; a)
-{
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] *= a;
-	
-  return *this;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator/(const Matrix&lt;T&gt;&amp; lhs, const Matrix&lt;T&gt;&amp; rhs)
-{
-  if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows())
-    throw std::logic_error("Operator+: matrices have different sizes");
-  Matrix&lt;T&gt; tmp(lhs.nrows(), lhs.ncols());
-  for (unsigned int i = 0; i &lt; lhs.nrows(); i++)
-    for (unsigned int j = 0; j &lt; lhs.ncols(); j++)
-      tmp[i][j] = lhs[i][j] / rhs[i][j];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator/(const Matrix&lt;T&gt;&amp; lhs, const T&amp; a)
-{
-  Matrix&lt;T&gt; tmp(lhs.nrows(), lhs.ncols());
-  for (unsigned int i = 0; i &lt; lhs.nrows(); i++)
-    for (unsigned int j = 0; j &lt; lhs.ncols(); j++)
-      tmp[i][j] = lhs[i][j] / a;
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator/(const T&amp; a, const Matrix&lt;T&gt;&amp; rhs)
-{
-  Matrix&lt;T&gt; tmp(rhs.nrows(), rhs.ncols());
-  for (unsigned int i = 0; i &lt; rhs.nrows(); i++)
-    for (unsigned int j = 0; j &lt; rhs.ncols(); j++)
-      tmp[i][j] = a / rhs[i][j];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::operator/=(const Matrix&lt;T&gt;&amp; rhs)
-{
-  if (m != rhs.ncols() || n != rhs.nrows())
-    throw std::logic_error("Operator+=: matrices have different sizes");
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] /= rhs[i][j];
-	
-  return *this;
-}
-
-template &lt;typename T&gt;
-inline Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::operator/=(const T&amp; a)
-{
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] /= a;
-	
-  return *this;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; operator^(const Matrix&lt;T&gt;&amp; lhs, const T&amp; a)
-{
-  Matrix&lt;T&gt; tmp(lhs.nrows(), lhs.ncols());
-  for (unsigned int i = 0; i &lt; lhs.nrows(); i++)
-    for (unsigned int j = 0; j &lt; lhs.ncols(); j++)
-      tmp[i][j] = pow(lhs[i][j], a);
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::operator^=(const Matrix&lt;T&gt;&amp; rhs)
-{
-  if (m != rhs.ncols() || n != rhs.nrows())
-    throw std::logic_error("Operator^=: matrices have different sizes");
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] = pow(v[i][j], rhs[i][j]);
-	
-  return *this;
-}
-
-
-template &lt;typename T&gt;
-inline Matrix&lt;T&gt;&amp; Matrix&lt;T&gt;::operator^=(const T&amp; a)
-{
-  for (unsigned int i = 0; i &lt; n; i++)
-    for (unsigned int j = 0; j &lt; m; j++)
-      v[i][j] = pow(v[i][j], a);
-	
-  return *this;
-}
-
-template &lt;typename T&gt;
-inline Matrix&lt;T&gt;::operator Vector&lt;T&gt;()
-{
-  if (n &gt; 1 &amp;&amp; m &gt; 1)
-    throw std::logic_error("Error matrix cast to vector: trying to cast a multi-dimensional matrix");
-  if (n == 1)
-    return extractRow(0);
-  else
-    return extractColumn(0);
-}
-
-template &lt;typename T&gt;
-inline bool operator==(const Matrix&lt;T&gt;&amp; a, const Matrix&lt;T&gt;&amp; b)
-{
-  if (a.nrows() != b.nrows() || a.ncols() != b.ncols())
-    throw std::logic_error("Matrices of different size are not confrontable");
-  for (unsigned i = 0; i &lt; a.nrows(); i++)
-    for (unsigned j = 0; j &lt; a.ncols(); j++)
-      if (a[i][j] != b[i][j])
-	return false;
-  return true;
-}
-
-template &lt;typename T&gt;
-inline bool operator!=(const Matrix&lt;T&gt;&amp; a, const Matrix&lt;T&gt;&amp; b)
-{
-  if (a.nrows() != b.nrows() || a.ncols() != b.ncols())
-    throw std::logic_error("Matrices of different size are not confrontable");
-  for (unsigned i = 0; i &lt; a.nrows(); i++)
-    for (unsigned j = 0; j &lt; a.ncols(); j++)
-      if (a[i][j] != b[i][j])
-	return true;
-  return false;
-}
-
+  }
+
+  template &lt; typename T &gt;
+  inline void Matrix &lt; T &gt; ::set(const T * a, unsigned int n, unsigned int m)
+  {
+    if (this-&gt;n != n || this-&gt;m != m) {
+      resize(n, m);
+    }
+    unsigned int k = 0;
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] = a[k++];
+      }
+    }
+  }
+
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator + (const Matrix &lt; T &gt; &amp;rhs)
+  {
+    return rhs;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator + (const Matrix &lt; T &gt; &amp;lhs, const Matrix &lt; T &gt; &amp;rhs)
+  {
+    if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows()) {
+      throw std::logic_error("Operator+: matrices have different sizes");
+    }
+    Matrix &lt; T &gt; tmp(lhs.nrows(), lhs.ncols());
+    for (unsigned int i = 0; i &lt; lhs.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; lhs.ncols(); j++) {
+        tmp[i][j] = lhs[i][j] + rhs[i][j];
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator + (const Matrix &lt; T &gt; &amp;lhs, const T &amp; a)
+  {
+    Matrix &lt; T &gt; tmp(lhs.nrows(), lhs.ncols());
+    for (unsigned int i = 0; i &lt; lhs.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; lhs.ncols(); j++) {
+        tmp[i][j] = lhs[i][j] + a;
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator + (const T &amp; a, const Matrix &lt; T &gt; &amp;rhs)
+  {
+    Matrix &lt; T &gt; tmp(rhs.nrows(), rhs.ncols());
+    for (unsigned int i = 0; i &lt; rhs.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; rhs.ncols(); j++) {
+        tmp[i][j] = a + rhs[i][j];
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; &amp; Matrix &lt; T &gt; ::operator += (const Matrix &lt; T &gt; &amp;rhs)
+  {
+    if (m != rhs.ncols() || n != rhs.nrows()) {
+      throw std::logic_error("Operator+=: matrices have different sizes");
+    }
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] += rhs[i][j];
+      }
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; &amp; Matrix &lt; T &gt; ::operator += (const T &amp; a)
+  {
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] += a;
+      }
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator - (const Matrix &lt; T &gt; &amp;rhs)
+  {
+    return (T)(-1) * rhs;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator - (const Matrix &lt; T &gt; &amp;lhs, const Matrix &lt; T &gt; &amp;rhs)
+  {
+    if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows()) {
+      throw std::logic_error("Operator-: matrices have different sizes");
+    }
+    Matrix &lt; T &gt; tmp(lhs.nrows(), lhs.ncols());
+    for (unsigned int i = 0; i &lt; lhs.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; lhs.ncols(); j++) {
+        tmp[i][j] = lhs[i][j] - rhs[i][j];
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator - (const Matrix &lt; T &gt; &amp;lhs, const T &amp; a)
+  {
+    Matrix &lt; T &gt; tmp(lhs.nrows(), lhs.ncols());
+    for (unsigned int i = 0; i &lt; lhs.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; lhs.ncols(); j++) {
+        tmp[i][j] = lhs[i][j] - a;
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator - (const T &amp; a, const Matrix &lt; T &gt; &amp;rhs)
+  {
+    Matrix &lt; T &gt; tmp(rhs.nrows(), rhs.ncols());
+    for (unsigned int i = 0; i &lt; rhs.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; rhs.ncols(); j++) {
+        tmp[i][j] = a - rhs[i][j];
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; &amp; Matrix &lt; T &gt; ::operator -= (const Matrix &lt; T &gt; &amp;rhs)
+  {
+    if (m != rhs.ncols() || n != rhs.nrows()) {
+      throw std::logic_error("Operator-=: matrices have different sizes");
+    }
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] -= rhs[i][j];
+      }
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; &amp; Matrix &lt; T &gt; ::operator -= (const T &amp; a)
+  {
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] -= a;
+      }
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator * (const Matrix &lt; T &gt; &amp;lhs, const Matrix &lt; T &gt; &amp;rhs)
+  {
+    if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows()) {
+      throw std::logic_error("Operator*: matrices have different sizes");
+    }
+    Matrix &lt; T &gt; tmp(lhs.nrows(), lhs.ncols());
+    for (unsigned int i = 0; i &lt; lhs.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; lhs.ncols(); j++) {
+        tmp[i][j] = lhs[i][j] * rhs[i][j];
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator * (const Matrix &lt; T &gt; &amp;lhs, const T &amp; a)
+  {
+    Matrix &lt; T &gt; tmp(lhs.nrows(), lhs.ncols());
+    for (unsigned int i = 0; i &lt; lhs.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; lhs.ncols(); j++) {
+        tmp[i][j] = lhs[i][j] * a;
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator * (const T &amp; a, const Matrix &lt; T &gt; &amp;rhs)
+  {
+    Matrix &lt; T &gt; tmp(rhs.nrows(), rhs.ncols());
+    for (unsigned int i = 0; i &lt; rhs.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; rhs.ncols(); j++) {
+        tmp[i][j] = a * rhs[i][j];
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; &amp; Matrix &lt; T &gt; ::operator *= (const Matrix &lt; T &gt; &amp;rhs)
+  {
+    if (m != rhs.ncols() || n != rhs.nrows()) {
+      throw std::logic_error("Operator*=: matrices have different sizes");
+    }
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] *= rhs[i][j];
+      }
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; &amp; Matrix &lt; T &gt; ::operator *= (const T &amp; a)
+  {
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] *= a;
+      }
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator / (const Matrix &lt; T &gt; &amp;lhs, const Matrix &lt; T &gt; &amp;rhs)
+  {
+    if (lhs.ncols() != rhs.ncols() || lhs.nrows() != rhs.nrows()) {
+      throw std::logic_error("Operator+: matrices have different sizes");
+    }
+    Matrix &lt; T &gt; tmp(lhs.nrows(), lhs.ncols());
+    for (unsigned int i = 0; i &lt; lhs.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; lhs.ncols(); j++) {
+        tmp[i][j] = lhs[i][j] / rhs[i][j];
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator / (const Matrix &lt; T &gt; &amp;lhs, const T &amp; a)
+  {
+    Matrix &lt; T &gt; tmp(lhs.nrows(), lhs.ncols());
+    for (unsigned int i = 0; i &lt; lhs.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; lhs.ncols(); j++) {
+        tmp[i][j] = lhs[i][j] / a;
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator / (const T &amp; a, const Matrix &lt; T &gt; &amp;rhs)
+  {
+    Matrix &lt; T &gt; tmp(rhs.nrows(), rhs.ncols());
+    for (unsigned int i = 0; i &lt; rhs.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; rhs.ncols(); j++) {
+        tmp[i][j] = a / rhs[i][j];
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; &amp; Matrix &lt; T &gt; ::operator /= (const Matrix &lt; T &gt; &amp;rhs)
+  {
+    if (m != rhs.ncols() || n != rhs.nrows()) {
+      throw std::logic_error("Operator+=: matrices have different sizes");
+    }
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] /= rhs[i][j];
+      }
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; &amp; Matrix &lt; T &gt; ::operator /= (const T &amp; a)
+  {
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] /= a;
+      }
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; operator ^ (const Matrix &lt; T &gt; &amp;lhs, const T &amp; a)
+  {
+    Matrix &lt; T &gt; tmp(lhs.nrows(), lhs.ncols());
+    for (unsigned int i = 0; i &lt; lhs.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; lhs.ncols(); j++) {
+        tmp[i][j] = pow(lhs[i][j], a);
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; &amp; Matrix &lt; T &gt; ::operator ^= (const Matrix &lt; T &gt; &amp;rhs)
+  {
+    if (m != rhs.ncols() || n != rhs.nrows()) {
+      throw std::logic_error("Operator^=: matrices have different sizes");
+    }
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] = pow(v[i][j], rhs[i][j]);
+      }
+    }
+
+    return *this;
+  }
+
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; &amp; Matrix &lt; T &gt; ::operator ^= (const T &amp; a)
+  {
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = 0; j &lt; m; j++) {
+        v[i][j] = pow(v[i][j], a);
+      }
+    }
+
+    return *this;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; T &gt; ::operator Vector &lt; T &gt; ()
+  {
+    if (n &gt; 1 &amp;&amp; m &gt; 1) {
+      throw std::logic_error(
+        "Error matrix cast to vector: trying to cast a multi-dimensional matrix");
+    }
+    if (n == 1) {
+      return extractRow(0);
+    } else {
+      return extractColumn(0);
+    }
+  }
+
+  template &lt; typename T &gt;
+  inline bool operator == (const Matrix &lt; T &gt; &amp;a, const Matrix &lt; T &gt; &amp;b)
+  {
+    if (a.nrows() != b.nrows() || a.ncols() != b.ncols()) {
+      throw std::logic_error("Matrices of different size are not confrontable");
+    }
+    for (unsigned i = 0; i &lt; a.nrows(); i++) {
+      for (unsigned j = 0; j &lt; a.ncols(); j++) {
+        if (a[i][j] != b[i][j]) {
+          return false;
+        }
+      }
+    }
+    return true;
+  }
+
+  template &lt; typename T &gt;
+  inline bool operator != (const Matrix &lt; T &gt; &amp;a, const Matrix &lt; T &gt; &amp;b)
+  {
+    if (a.nrows() != b.nrows() || a.ncols() != b.ncols()) {
+      throw std::logic_error("Matrices of different size are not confrontable");
+    }
+    for (unsigned i = 0; i &lt; a.nrows(); i++) {
+      for (unsigned j = 0; j &lt; a.ncols(); j++) {
+        if (a[i][j] != b[i][j]) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
@@ -1601 +1824 @@
-   Input/Output 
+   Input/Output
@@ -1603,300 +1826,297 @@
-template &lt;typename T&gt;
-std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matrix&lt;T&gt;&amp; m)
-{
-  os &lt;&lt; std::endl &lt;&lt; m.nrows() &lt;&lt; " " &lt;&lt; m.ncols() &lt;&lt; std::endl;
-  for (unsigned int i = 0; i &lt; m.nrows(); i++)
-    {
-      for (unsigned int j = 0; j &lt; m.ncols() - 1; j++)
-	os &lt;&lt; std::setw(20) &lt;&lt; std::setprecision(16) &lt;&lt; m[i][j] &lt;&lt; ", ";
-      os &lt;&lt; std::setw(20) &lt;&lt; std::setprecision(16) &lt;&lt; m[i][m.ncols() - 1] &lt;&lt; std::endl;
-    }
-	
-  return os;
-}
-
-template &lt;typename T&gt;
-std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Matrix&lt;T&gt;&amp; m)
-{
-  int rows, cols;
-  char comma;
-  is &gt;&gt; rows &gt;&gt; cols;
-  m.resize(rows, cols);
-  for (unsigned int i = 0; i &lt; rows; i++)
-    for (unsigned int j = 0; j &lt; cols; j++)
-      is &gt;&gt; m[i][j] &gt;&gt; comma;
-	
-  return is;
-}
-
-template &lt;typename T&gt;
-T sign(const T&amp; v)
-{
-  if (v &gt;= (T)0.0)
-    return (T)1.0;
-  else
-    return (T)-1.0;
-}
-
-template &lt;typename T&gt;
-T dist(const T&amp; a, const T&amp; b)
-{
-  T abs_a = (T)fabs(a), abs_b = (T)fabs(b);
-  if (abs_a &gt; abs_b)
-    return abs_a * sqrt((T)1.0 + (abs_b / abs_a) * (abs_b / abs_a));
-  else
-    return (abs_b == (T)0.0 ? (T)0.0 : abs_b * sqrt((T)1.0 + (abs_a / abs_b) * (abs_a / abs_b)));
-}
-
-template &lt;typename T&gt;
-void svd(const Matrix&lt;T&gt;&amp; A, Matrix&lt;T&gt;&amp; U, Vector&lt;T&gt;&amp; W, Matrix&lt;T&gt;&amp; V)
-{
-  int m = A.nrows(), n = A.ncols(), i, j, k, l, jj, nm;
-  const unsigned int max_its = 30;
-  bool flag;
-  Vector&lt;T&gt; rv1(n);
-  U = A;
-  W.resize(n);
-  V.resize(n, n);
-  T anorm, c, f, g, h, s, scale, x, y, z;
-  g = scale = anorm = (T)0.0;
-	
-  // Householder reduction to bidiagonal form
-  for (i = 0; i &lt; n; i++)
-    {
-      l = i + 1;
-      rv1[i] = scale * g;
-      g = s = scale = (T)0.0;
-      if (i &lt; m)
-	{
-	  for (k = i; k &lt; m; k++)
-	    scale += fabs(U[k][i]);
-	  if (scale != (T)0.0)
-	    {
-	      for (k = i; k &lt; m; k++)
-		{
-		  U[k][i] /= scale;
-		  s += U[k][i] * U[k][i];
-		}
-	      f = U[i][i];
-	      g = -sign(f) * sqrt(s);
-	      h = f * g - s;
-	      U[i][i] = f - g;
-	      for (j = l; j &lt; n; j++)
-		{
-		  s = (T)0.0;
-		  for (k = i; k &lt; m; k++)
-		    s += U[k][i] * U[k][j];
-		  f = s / h;
-		  for (k = i; k &lt; m; k++)
-		    U[k][j] += f * U[k][i];
-		}
-	      for (k = i; k &lt; m; k++)
-		U[k][i] *= scale;
-	    }
-	}
-      W[i] = scale * g;
-      g = s = scale = (T)0.0;
-      if (i &lt; m &amp;&amp; i != n - 1)
-	{
-	  for (k = l; k &lt; n; k++)
-	    scale += fabs(U[i][k]);
-	  if (scale != (T)0.0)
-	    {
-	      for (k = l; k &lt; n; k++)
-		{
-		  U[i][k] /= scale;
-		  s += U[i][k] * U[i][k];					
-		}
-	      f = U[i][l];
-	      g = -sign(f) * sqrt(s);
-	      h = f * g - s;
-	      U[i][l] = f - g;
-	      for (k = l; k &lt;n; k++)
-		rv1[k] = U[i][k] / h;
-	      for (j = l; j &lt; m; j++)
-		{
-		  s = (T)0.0;
-		  for (k = l; k &lt; n; k++)
-		    s += U[j][k] * U[i][k];
-		  for (k = l; k &lt; n; k++)
-		    U[j][k] += s * rv1[k];
-		}
-	      for (k = l; k &lt; n; k++)
-		U[i][k] *= scale;
-	    }
-	}
-      anorm = std::max(anorm, fabs(W[i]) + fabs(rv1[i]));
-    }
-  // Accumulation of right-hand transformations
-  for (i = n - 1; i &gt;= 0; i--)
-    {
-      if (i &lt; n - 1) 
-	{
-	  if (g != (T)0.0)
-	    {
-	      for (j = l; j &lt; n; j++)
-		V[j][i] = (U[i][j] / U[i][l]) / g;
-	      for (j = l; j &lt; n; j++)
-		{
-		  s = (T)0.0;
-		  for (k = l; k &lt; n; k++)
-		    s += U[i][k] * V[k][j];
-		  for (k = l; k &lt; n; k++)
-		    V[k][j] += s * V[k][i];
-		}
-	    }
-	  for (j = l; j &lt; n; j++)
-	    V[i][j] = V[j][i] = (T)0.0;
-	}
-      V[i][i] = (T)1.0;
-      g = rv1[i];
-      l = i;
-    }
-  // Accumulation of left-hand transformations
-  for (i = std::min(m, n) - 1; i &gt;= 0; i--)
-    {
-      l = i + 1;
-      g = W[i];
-      for (j = l; j &lt; n; j++)
-	U[i][j] = (T)0.0;
-      if (g != (T)0.0)
-	{
-	  g = (T)1.0 / g;
-	  for (j = l; j &lt; n; j++)
-	    {
-	      s = (T)0.0;
-	      for (k = l; k &lt; m; k++)
-		s += U[k][i] * U[k][j];
-	      f = (s / U[i][i]) * g;
-	      for (k = i; k &lt; m; k++)
-		U[k][j] += f * U[k][i];
-	    }
-	  for (j = i; j &lt; m; j++)
-	    U[j][i] *= g;
-	}
-      else
-	for (j = i; j &lt; m; j++)
-	  U[j][i] = (T)0.0;
-      U[i][i]++;
-    }
-  // Diagonalization of the bidiagonal form: loop over singular values, and over allowed iterations.
-  for (k = n - 1; k &gt;= 0; k--)
-    {
-      for (unsigned int its = 0; its &lt; max_its; its++)
-	{
-	  flag = true;
-	  for (l = k; l &gt;= 0; l--) // FIXME: in NR it was l &gt;= 1 but there subscripts start from one
-	    { // Test for splitting
-	      nm = l - 1; // Note that rV[0] is always zero
-	      if ((T)(fabs(rv1[l]) + anorm) == anorm)
-		{
-		  flag = false;
-		  break;
-		}
-	      if ((T)(fabs(W[nm]) + anorm) == anorm)
-		break;
-	    }
-	  if (flag)
-	    {
-	      // Cancellation of rv1[l], if l &gt; 0 FIXME: it was l &gt; 1 in NR
-	      c = (T)0.0;
-	      s = (T)1.0;
-	      for (i = l; i &lt;= k; i++)
-		{
-		  f = s * rv1[i];
-		  rv1[i] *= c;
-		  if ((T)(fabs(f) + anorm) == anorm)
-		    break;
-		  g = W[i];
-		  h = dist(f, g);
-		  W[i] = h;
-		  h = (T)1.0 / h;
-		  c = g * h;
-		  s = -f * h;
-		  for (j = 0; j &lt; m; j++)
-		    {
-		      y = U[j][nm];
-		      z = U[j][i];
-		      U[j][nm] = y * c + z * s;
-		      U[j][i] = z * c - y * s;
-		    }
-		}
-	    }
-	  z = W[k];
-	  if (l == k)
-	    {  // Convergence
-	      if (z &lt; (T)0.0)
-		{ // Singular value is made nonnegative
-		  W[k] = -z;
-		  for (j = 0; j &lt; n; j++)
-		    V[j][k] = -V[j][k];
-		}
-	      break;
-	    }
-	  if (its == max_its)
-	    throw std::logic_error("Error svd: no convergence in the maximum number of iterations");
-	  x = W[l];
-	  nm = k - 1;
-	  y = W[nm];
-	  g = rv1[nm];
-	  h = rv1[k];
-	  f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);
-	  g = dist(f, (T)1.0);
-	  f = ((x - z) * (x + z) + h * ((y / (f + sign(f)*fabs(g))) - h)) / x;
-	  c = s = (T)1.0; // Next QR transformation
-	  for (j = l; j &lt;= nm; j++)
-	    {
-	      i = j + 1;
-	      g = rv1[i];
-	      y = W[i];
-	      h = s * g;
-	      g *= c;
-	      z = dist(f, h);
-	      rv1[j] = z;
-	      c = f / z;
-	      s = h / z;
-	      f = x * c + g * s;
-	      g = g * c - x * s;
-	      h = y * s;
-	      y *= c;
-	      for (jj = 0; jj &lt; n; jj++)
-		{
-		  x = V[jj][j];
-		  z = V[jj][i];
-		  V[jj][j] = x * c + z * s;
-		  V[jj][i] = z * c - x * s;
-		}
-	      z = dist(f, h);
-	      W[j] = z; 
-	      if (z != 0) // Rotation can be arbitrary if z = 0
-		{
-		  z = (T)1.0 / z;
-		  c = f * z;
-		  s = h * z;
-		}
-	      f = c * g + s * y;
-	      x = c * y - s * g;
-	      for (jj = 0; jj &lt; m; jj++)
-		{
-		  y = U[jj][j];
-		  z = U[jj][i];
-		  U[jj][j] = y * c + z * s;
-		  U[jj][i] = z * c - y * s;
-		}
-	    }
-	  rv1[l] = (T)0.0;
-	  rv1[k] = f;
-	  W[k] = x;
-	}
-    }	
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; pinv(const Matrix&lt;T&gt;&amp; A)
-{
-  Matrix&lt;T&gt; U, V, x, tmp(A.ncols(), A.nrows());
-  Vector&lt;T&gt; W;
-  CanonicalBaseVector&lt;T&gt; e(0, A.nrows());
-  svd(A, U, W, V);
-  for (unsigned int i = 0; i &lt; A.nrows(); i++)
-    {
+  template &lt; typename T &gt;
+  std::ostream &amp; operator &lt;&lt; (std::ostream &amp; os, const Matrix &lt; T &gt; &amp;m)
+      {
+      os &lt;&lt; std::endl &lt;&lt; m.nrows() &lt;&lt; " " &lt;&lt; m.ncols() &lt;&lt; std::endl;
+      for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+        for (unsigned int j = 0; j &lt; m.ncols() - 1; j++) {
+          os &lt;&lt; std::setw(20) &lt;&lt; std::setprecision(16) &lt;&lt; m[i][j] &lt;&lt; ", ";
+        }
+        os &lt;&lt; std::setw(20) &lt;&lt; std::setprecision(16) &lt;&lt; m[i][m.ncols() - 1] &lt;&lt; std::endl;
+      }
+
+      return os;
+    }
+
+    template &lt; typename T &gt;
+    std::istream &amp; operator &gt;&gt; (std::istream &amp; is, Matrix &lt; T &gt; &amp;m)
+      {
+      int rows, cols;
+      char comma;
+      is &gt;&gt; rows &gt;&gt; cols;
+      m.resize(rows, cols);
+      for (unsigned int i = 0; i &lt; rows; i++) {
+        for (unsigned int j = 0; j &lt; cols; j++) {
+          is &gt;&gt; m[i][j] &gt;&gt; comma;
+        }
+      }
+
+      return is;
+    }
+
+    template &lt; typename T &gt;
+    T sign(const T &amp; v)
+      {
+      if (v &gt;= (T)0.0) {
+        return (T)1.0;
+      } else {
+        return (T)-1.0;
+      }
+    }
+
+    template &lt; typename T &gt;
+    T dist(const T &amp; a, const T &amp; b)
+      {
+      T abs_a = (T)fabs(a), abs_b = (T)fabs(b);
+      if (abs_a &gt; abs_b) {
+        return abs_a * sqrt((T)1.0 + (abs_b / abs_a) * (abs_b / abs_a));
+      } else {
+        return abs_b == (T)0.0 ? (T)0.0 : abs_b * sqrt((T)1.0 + (abs_a / abs_b) * (abs_a / abs_b));
+      }
+    }
+
+    template &lt; typename T &gt;
+    void svd(const Matrix &lt; T &gt; &amp; A, Matrix &lt; T &gt; &amp; U, Vector &lt; T &gt; &amp; W, Matrix &lt; T &gt; &amp; V)
+      {
+      int m = A.nrows(), n = A.ncols(), i, j, k, l, jj, nm;
+      const unsigned int max_its = 30;
+      bool flag;
+      Vector &lt; T &gt; rv1(n);
+      U = A;
+      W.resize(n);
+      V.resize(n, n);
+      T anorm, c, f, g, h, s, scale, x, y, z;
+      g = scale = anorm = (T)0.0;
+
+      // Householder reduction to bidiagonal form
+      for (i = 0; i &lt; n; i++) {
+        l = i + 1;
+        rv1[i] = scale * g;
+        g = s = scale = (T)0.0;
+        if (i &lt; m) {
+          for (k = i; k &lt; m; k++) {
+            scale += fabs(U[k][i]);
+          }
+          if (scale != (T)0.0) {
+            for (k = i; k &lt; m; k++) {
+              U[k][i] /= scale;
+              s += U[k][i] * U[k][i];
+            }
+            f = U[i][i];
+            g = -sign(f) * sqrt(s);
+            h = f * g - s;
+            U[i][i] = f - g;
+            for (j = l; j &lt; n; j++) {
+              s = (T)0.0;
+              for (k = i; k &lt; m; k++) {
+                s += U[k][i] * U[k][j];
+              }
+              f = s / h;
+              for (k = i; k &lt; m; k++) {
+                U[k][j] += f * U[k][i];
+              }
+            }
+            for (k = i; k &lt; m; k++) {
+              U[k][i] *= scale;
+            }
+          }
+        }
+        W[i] = scale * g;
+        g = s = scale = (T)0.0;
+        if (i &lt; m &amp;&amp; i != n - 1) {
+          for (k = l; k &lt; n; k++) {
+            scale += fabs(U[i][k]);
+          }
+          if (scale != (T)0.0) {
+            for (k = l; k &lt; n; k++) {
+              U[i][k] /= scale;
+              s += U[i][k] * U[i][k];
+            }
+            f = U[i][l];
+            g = -sign(f) * sqrt(s);
+            h = f * g - s;
+            U[i][l] = f - g;
+            for (k = l; k &lt; n; k++) {
+              rv1[k] = U[i][k] / h;
+            }
+            for (j = l; j &lt; m; j++) {
+              s = (T)0.0;
+              for (k = l; k &lt; n; k++) {
+                s += U[j][k] * U[i][k];
+              }
+              for (k = l; k &lt; n; k++) {
+                U[j][k] += s * rv1[k];
+              }
+            }
+            for (k = l; k &lt; n; k++) {
+              U[i][k] *= scale;
+            }
+          }
+        }
+        anorm = std::max(anorm, fabs(W[i]) + fabs(rv1[i]));
+      }
+      // Accumulation of right-hand transformations
+      for (i = n - 1; i &gt;= 0; i--) {
+        if (i &lt; n - 1) {
+          if (g != (T)0.0) {
+            for (j = l; j &lt; n; j++) {
+              V[j][i] = (U[i][j] / U[i][l]) / g;
+            }
+            for (j = l; j &lt; n; j++) {
+              s = (T)0.0;
+              for (k = l; k &lt; n; k++) {
+                s += U[i][k] * V[k][j];
+              }
+              for (k = l; k &lt; n; k++) {
+                V[k][j] += s * V[k][i];
+              }
+            }
+          }
+          for (j = l; j &lt; n; j++) {
+            V[i][j] = V[j][i] = (T)0.0;
+          }
+        }
+        V[i][i] = (T)1.0;
+        g = rv1[i];
+        l = i;
+      }
+      // Accumulation of left-hand transformations
+      for (i = std::min(m, n) - 1; i &gt;= 0; i--) {
+        l = i + 1;
+        g = W[i];
+        for (j = l; j &lt; n; j++) {
+          U[i][j] = (T)0.0;
+        }
+        if (g != (T)0.0) {
+          g = (T)1.0 / g;
+          for (j = l; j &lt; n; j++) {
+            s = (T)0.0;
+            for (k = l; k &lt; m; k++) {
+              s += U[k][i] * U[k][j];
+            }
+            f = (s / U[i][i]) * g;
+            for (k = i; k &lt; m; k++) {
+              U[k][j] += f * U[k][i];
+            }
+          }
+          for (j = i; j &lt; m; j++) {
+            U[j][i] *= g;
+          }
+        } else {
+          for (j = i; j &lt; m; j++) {
+            U[j][i] = (T)0.0;
+          }
+        }
+        U[i][i]++;
+      }
+      // Diagonalization of the bidiagonal form: loop over singular values, and over allowed iterations.
+      for (k = n - 1; k &gt;= 0; k--) {
+        for (unsigned int its = 0; its &lt; max_its; its++) {
+          flag = true;
+          for (l = k; l &gt;= 0; l--) { // FIXME: in NR it was l &gt;= 1 but there subscripts start from one
+            // Test for splitting
+            nm = l - 1;   // Note that rV[0] is always zero
+            if ((T)(fabs(rv1[l]) + anorm) == anorm) {
+              flag = false;
+              break;
+            }
+            if ((T)(fabs(W[nm]) + anorm) == anorm) {
+              break;
+            }
+          }
+          if (flag) {
+            // Cancellation of rv1[l], if l &gt; 0 FIXME: it was l &gt; 1 in NR
+            c = (T)0.0;
+            s = (T)1.0;
+            for (i = l; i &lt;= k; i++) {
+              f = s * rv1[i];
+              rv1[i] *= c;
+              if ((T)(fabs(f) + anorm) == anorm) {
+                break;
+              }
+              g = W[i];
+              h = dist(f, g);
+              W[i] = h;
+              h = (T)1.0 / h;
+              c = g * h;
+              s = -f * h;
+              for (j = 0; j &lt; m; j++) {
+                y = U[j][nm];
+                z = U[j][i];
+                U[j][nm] = y * c + z * s;
+                U[j][i] = z * c - y * s;
+              }
+            }
+          }
+          z = W[k];
+          if (l == k) { // Convergence
+            if (z &lt; (T)0.0) { // Singular value is made nonnegative
+              W[k] = -z;
+              for (j = 0; j &lt; n; j++) {
+                V[j][k] = -V[j][k];
+              }
+            }
+            break;
+          }
+          if (its == max_its) {
+            throw std::logic_error("Error svd: no convergence in the maximum number of iterations");
+          }
+          x = W[l];
+          nm = k - 1;
+          y = W[nm];
+          g = rv1[nm];
+          h = rv1[k];
+          f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);
+          g = dist(f, (T)1.0);
+          f = ((x - z) * (x + z) + h * ((y / (f + sign(f) * fabs(g))) - h)) / x;
+          c = s = (T)1.0; // Next QR transformation
+          for (j = l; j &lt;= nm; j++) {
+            i = j + 1;
+            g = rv1[i];
+            y = W[i];
+            h = s * g;
+            g *= c;
+            z = dist(f, h);
+            rv1[j] = z;
+            c = f / z;
+            s = h / z;
+            f = x * c + g * s;
+            g = g * c - x * s;
+            h = y * s;
+            y *= c;
+            for (jj = 0; jj &lt; n; jj++) {
+              x = V[jj][j];
+              z = V[jj][i];
+              V[jj][j] = x * c + z * s;
+              V[jj][i] = z * c - x * s;
+            }
+            z = dist(f, h);
+            W[j] = z;
+            if (z != 0) { // Rotation can be arbitrary if z = 0
+              z = (T)1.0 / z;
+              c = f * z;
+              s = h * z;
+            }
+            f = c * g + s * y;
+            x = c * y - s * g;
+            for (jj = 0; jj &lt; m; jj++) {
+              y = U[jj][j];
+              z = U[jj][i];
+              U[jj][j] = y * c + z * s;
+              U[jj][i] = z * c - y * s;
+            }
+          }
+          rv1[l] = (T)0.0;
+          rv1[k] = f;
+          W[k] = x;
+        }
+      }
+      }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; pinv(const Matrix &lt; T &gt; &amp;A)
+  {
+    Matrix &lt; T &gt; U, V, x, tmp(A.ncols(), A.nrows());
+    Vector &lt; T &gt; W;
+    CanonicalBaseVector &lt; T &gt; e(0, A.nrows());
+    svd(A, U, W, V);
+    for (unsigned int i = 0; i &lt; A.nrows(); i++) {
@@ -1904,20 +2124,25 @@
-      tmp.setColumn(i, dot_prod(dot_prod(dot_prod(V, Matrix&lt;double&gt;(DIAG, 1.0 / W, 0.0, W.size(), W.size())), t(U)), e));
-    }
-		
-  return tmp;
-}
-
-template &lt;typename T&gt;
-int lu(const Matrix&lt;T&gt;&amp; A, Matrix&lt;T&gt;&amp; LU, Vector&lt;unsigned int&gt;&amp; index)
-{
-  if (A.ncols() != A.nrows())
-    throw std::logic_error("Error in LU decomposition: matrix must be squared");
-  int i, p, j, k, n = A.ncols(), ex;
-  T val, tmp;
-  Vector&lt;T&gt; d(n);
-  LU = A;
-  index.resize(n);
-	
-  ex = 1;
-  for (i = 0; i &lt; n; i++)
-    {
+      tmp.setColumn(
+        i,
+        dot_prod(
+          dot_prod(
+            dot_prod(V, Matrix &lt; double &gt; (DIAG, 1.0 / W, 0.0, W.size(), W.size())),
+            t(U)), e));
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  int lu(const Matrix &lt; T &gt; &amp; A, Matrix &lt; T &gt; &amp; LU, Vector &lt; unsigned int &gt; &amp; index)
+  {
+    if (A.ncols() != A.nrows()) {
+      throw std::logic_error("Error in LU decomposition: matrix must be squared");
+    }
+    int i, p, j, k, n = A.ncols(), ex;
+    T val, tmp;
+    Vector &lt; T &gt; d(n);
+    LU = A;
+    index.resize(n);
+
+    ex = 1;
+    for (i = 0; i &lt; n; i++) {
@@ -1926,4 +2151,6 @@
-      for (j = 0; j &lt; n; j++)
-	val = std::max(val, (T)fabs(LU[i][j]));
-      if (val == (T)0.0)
-	std::logic_error("Error in LU decomposition: matrix was singular");
+      for (j = 0; j &lt; n; j++) {
+        val = std::max(val, (T)fabs(LU[i][j]));
+      }
+      if (val == (T)0.0) {
+        std::logic_error("Error in LU decomposition: matrix was singular");
+      }
@@ -1933,2 +2160 @@
-  for (k = 0; k &lt; n - 1; k++)
-    {
+    for (k = 0; k &lt; n - 1; k++) {
@@ -1937,50 +2163,54 @@
-      for (i = k + 1; i &lt; n; i++)
-	{
-	  tmp = fabs(LU[i][k]) / d[i];
-	  if (tmp &gt; val)
-	    {
-	      val = tmp;
-	      p = i;
-	    }
-	}
-      if (val == (T)0.0)
-	std::logic_error("Error in LU decomposition: matrix was singular");
-      if (p &gt; k)
-	{
-	  ex = -ex;
-	  std::swap(index[k], index[p]);
-	  std::swap(d[k], d[p]);
-	  for (j = 0; j &lt; n; j++)
-	    std::swap(LU[k][j], LU[p][j]);
-	}
-		
-      for (i = k + 1; i &lt; n; i++)
-	{
-	  LU[i][k] /= LU[k][k];
-	  for (j = k + 1; j &lt; n; j++)
-	    LU[i][j] -= LU[i][k] * LU[k][j];
-	}
-    }
-  if (LU[n - 1][n - 1] == (T)0.0)
-    std::logic_error("Error in LU decomposition: matrix was singular");
-		
-  return ex;
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; lu_solve(const Matrix&lt;T&gt;&amp; LU, const Vector&lt;T&gt;&amp; b, Vector&lt;unsigned int&gt;&amp; index)
-{
-  if (LU.ncols() != LU.nrows())
-    throw std::logic_error("Error in LU solve: LU matrix should be squared");
-  unsigned int n = LU.ncols();
-  if (b.size() != n)
-    throw std::logic_error("Error in LU solve: b vector must be of the same dimensions of LU matrix");
-  Vector&lt;T&gt; x((T)0.0, n);
-  int i, j, p;
-  T sum;
-	
-  p = index[0];
-  x[0] = b[p];
-	
-  for (i = 1; i &lt; n; i++)
-    {
+      for (i = k + 1; i &lt; n; i++) {
+        tmp = fabs(LU[i][k]) / d[i];
+        if (tmp &gt; val) {
+          val = tmp;
+          p = i;
+        }
+      }
+      if (val == (T)0.0) {
+        std::logic_error("Error in LU decomposition: matrix was singular");
+      }
+      if (p &gt; k) {
+        ex = -ex;
+        std::swap(index[k], index[p]);
+        std::swap(d[k], d[p]);
+        for (j = 0; j &lt; n; j++) {
+          std::swap(LU[k][j], LU[p][j]);
+        }
+      }
+
+      for (i = k + 1; i &lt; n; i++) {
+        LU[i][k] /= LU[k][k];
+        for (j = k + 1; j &lt; n; j++) {
+          LU[i][j] -= LU[i][k] * LU[k][j];
+        }
+      }
+    }
+    if (LU[n - 1][n - 1] == (T)0.0) {
+      std::logic_error("Error in LU decomposition: matrix was singular");
+    }
+
+    return ex;
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; lu_solve(
+    const Matrix &lt; T &gt; &amp;LU, const Vector &lt; T &gt; &amp;b,
+    Vector &lt; unsigned int &gt; &amp;index)
+  {
+    if (LU.ncols() != LU.nrows()) {
+      throw std::logic_error("Error in LU solve: LU matrix should be squared");
+    }
+    unsigned int n = LU.ncols();
+    if (b.size() != n) {
+      throw std::logic_error(
+        "Error in LU solve: b vector must be of the same dimensions of LU matrix");
+    }
+    Vector &lt; T &gt; x((T)0.0, n);
+    int i, j, p;
+    T sum;
+
+    p = index[0];
+    x[0] = b[p];
+
+    for (i = 1; i &lt; n; i++) {
@@ -1988,2 +2218,3 @@
-      for (j = 0; j &lt; i; j++)
-	sum += LU[i][j] * x[j];
+      for (j = 0; j &lt; i; j++) {
+        sum += LU[i][j] * x[j];
+      }
@@ -1993,3 +2224,2 @@
-  x[n - 1] /= LU[n - 1][n - 1];
-  for (i = n - 2; i &gt;= 0; i--)
-    {
+    x[n - 1] /= LU[n - 1][n - 1];
+    for (i = n - 2; i &gt;= 0; i--) {
@@ -1997,2 +2227,3 @@
-      for (j = i + 1; j &lt; n; j++)
-	sum += LU[i][j] * x[j];
+      for (j = i + 1; j &lt; n; j++) {
+        sum += LU[i][j] * x[j];
+      }
@@ -2001,22 +2232,24 @@
-  return x;
-}
-
-template &lt;typename T&gt;
-void lu_solve(const Matrix&lt;T&gt;&amp; LU, Vector&lt;T&gt;&amp; x, const Vector&lt;T&gt;&amp; b, Vector&lt;unsigned int&gt;&amp; index)
-{
-  x = lu_solve(LU, b, index);
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; lu_inverse(const Matrix&lt;T&gt;&amp; A)
-{
-  if (A.ncols() != A.nrows())
-    throw std::logic_error("Error in LU invert: matrix must be squared");	
-  unsigned int n = A.ncols();
-  Matrix&lt;T&gt; A1(n, n), LU;
-  Vector&lt;unsigned int&gt; index;
-	
-  lu(A, LU, index);
-  CanonicalBaseVector&lt;T&gt; e(0, n);
-  for (unsigned i = 0; i &lt; n; i++)
-    {
+    return x;
+  }
+
+  template &lt; typename T &gt;
+  void lu_solve(
+    const Matrix &lt; T &gt; &amp; LU, Vector &lt; T &gt; &amp; x, const Vector &lt; T &gt; &amp; b,
+    Vector &lt; unsigned int &gt; &amp; index)
+  {
+    x = lu_solve(LU, b, index);
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; lu_inverse(const Matrix &lt; T &gt; &amp;A)
+  {
+    if (A.ncols() != A.nrows()) {
+      throw std::logic_error("Error in LU invert: matrix must be squared");
+    }
+    unsigned int n = A.ncols();
+    Matrix &lt; T &gt; A1(n, n), LU;
+    Vector &lt; unsigned int &gt; index;
+
+    lu(A, LU, index);
+    CanonicalBaseVector &lt; T &gt; e(0, n);
+    for (unsigned i = 0; i &lt; n; i++) {
@@ -2026,94 +2259,103 @@
-	
-  return A1;
-}
-
-template &lt;typename T&gt;
-T lu_det(const Matrix&lt;T&gt;&amp; A)
-{
-  if (A.ncols() != A.nrows())
-    throw std::logic_error("Error in LU determinant: matrix must be squared");	
-  unsigned int d;
-  Matrix&lt;T&gt; LU;
-  Vector&lt;unsigned int&gt; index;
-	
-  d = lu(A, LU, index);
-	
-  return d * prod(LU.extractDiag());
-}
-
-template &lt;typename T&gt;
-void cholesky(const Matrix&lt;T&gt; A, Matrix&lt;T&gt;&amp; LL) 
-{
-  if (A.ncols() != A.nrows())
-    throw std::logic_error("Error in Cholesky decomposition: matrix must be squared");
-  int n = A.ncols();
-  double sum;
-  LL = A;
-	
-  for (unsigned int i = 0; i &lt; n; i++)
-    {
-      for (unsigned int j = i; j &lt; n; j++)
-	{
-	  sum = LL[i][j];
-	  for (int k = i - 1; k &gt;= 0; k--)
-	    sum -= LL[i][k] * LL[j][k];
-	  if (i == j) 
-	    {
-	      if (sum &lt;= 0.0)
-		throw std::logic_error("Error in Cholesky decomposition: matrix is not postive definite");
-	      LL[i][i] = sqrt(sum);
-	    }
-	  else
-	    LL[j][i] = sum / LL[i][i];
-	}
-      for (unsigned int k = i + 1; k &lt; n; k++)
-	LL[i][k] = LL[k][i];
-    } 
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; cholesky(const Matrix&lt;T&gt; A) 
-{
-  Matrix&lt;T&gt; LL;
-  cholesky(A, LL);
-	
-  return LL;
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; cholesky_solve(const Matrix&lt;T&gt;&amp; LL, const Vector&lt;T&gt;&amp; b)
-{
-  if (LL.ncols() != LL.nrows())
-    throw std::logic_error("Error in Cholesky solve: matrix must be squared");
-  unsigned int n = LL.ncols();
-  if (b.size() != n)
-    throw std::logic_error("Error in Cholesky decomposition: b vector must be of the same dimensions of LU matrix");
-  Vector&lt;T&gt; x, y;
-	
-  /* Solve L * y = b */
-  forward_elimination(LL, y, b);
-  /* Solve L^T * x = y */
-  backward_elimination(LL, x, y);
-	
-  return x;
-}
-
-template &lt;typename T&gt;
-void cholesky_solve(const Matrix&lt;T&gt;&amp; LL, Vector&lt;T&gt;&amp; x, const Vector&lt;T&gt;&amp; b)
-{
-  x = cholesky_solve(LL, b);
-}
-
-template &lt;typename T&gt;
-void forward_elimination(const Matrix&lt;T&gt;&amp; L, Vector&lt;T&gt;&amp; y, const Vector&lt;T&gt; b)
-{
-  if (L.ncols() != L.nrows())
-    throw std::logic_error("Error in Forward elimination: matrix must be squared (lower triangular)");
-  if (b.size() != L.nrows())
-    throw std::logic_error("Error in Forward elimination: b vector must be of the same dimensions of L matrix");
-  unsigned int n = b.size();
-  y.resize(n);
-	
-  y[0] = b[0] / L[0][0];
-  for (unsigned int i = 1; i &lt; n; i++)
-    {
+
+    return A1;
+  }
+
+  template &lt; typename T &gt;
+  T lu_det(const Matrix &lt; T &gt; &amp; A)
+  {
+    if (A.ncols() != A.nrows()) {
+      throw std::logic_error("Error in LU determinant: matrix must be squared");
+    }
+    unsigned int d;
+    Matrix &lt; T &gt; LU;
+    Vector &lt; unsigned int &gt; index;
+
+    d = lu(A, LU, index);
+
+    return d * prod(LU.extractDiag());
+  }
+
+  template &lt; typename T &gt;
+  void cholesky(const Matrix &lt; T &gt; A, Matrix &lt; T &gt; &amp; LL)
+  {
+    if (A.ncols() != A.nrows()) {
+      throw std::logic_error("Error in Cholesky decomposition: matrix must be squared");
+    }
+    int n = A.ncols();
+    double sum;
+    LL = A;
+
+    for (unsigned int i = 0; i &lt; n; i++) {
+      for (unsigned int j = i; j &lt; n; j++) {
+        sum = LL[i][j];
+        for (int k = i - 1; k &gt;= 0; k--) {
+          sum -= LL[i][k] * LL[j][k];
+        }
+        if (i == j) {
+          if (sum &lt;= 0.0) {
+            throw std::logic_error(
+              "Error in Cholesky decomposition: matrix is not postive definite");
+          }
+          LL[i][i] = sqrt(sum);
+        } else {
+          LL[j][i] = sum / LL[i][i];
+        }
+      }
+      for (unsigned int k = i + 1; k &lt; n; k++) {
+        LL[i][k] = LL[k][i];
+      }
+    }
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; cholesky(const Matrix &lt; T &gt; A)
+  {
+    Matrix &lt; T &gt; LL;
+    cholesky(A, LL);
+
+    return LL;
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; cholesky_solve(const Matrix &lt; T &gt; &amp;LL, const Vector &lt; T &gt; &amp;b)
+  {
+    if (LL.ncols() != LL.nrows()) {
+      throw std::logic_error("Error in Cholesky solve: matrix must be squared");
+    }
+    unsigned int n = LL.ncols();
+    if (b.size() != n) {
+      throw std::logic_error(
+        "Error in Cholesky decomposition: b vector must be of the same dimensions of LU matrix");
+    }
+    Vector &lt; T &gt; x, y;
+
+    /* Solve L * y = b */
+    forward_elimination(LL, y, b);
+    /* Solve L^T * x = y */
+    backward_elimination(LL, x, y);
+
+    return x;
+  }
+
+  template &lt; typename T &gt;
+  void cholesky_solve(const Matrix &lt; T &gt; &amp; LL, Vector &lt; T &gt; &amp; x, const Vector &lt; T &gt; &amp; b)
+  {
+    x = cholesky_solve(LL, b);
+  }
+
+  template &lt; typename T &gt;
+  void forward_elimination(const Matrix &lt; T &gt; &amp; L, Vector &lt; T &gt; &amp; y, const Vector &lt; T &gt; b)
+  {
+    if (L.ncols() != L.nrows()) {
+      throw std::logic_error(
+        "Error in Forward elimination: matrix must be squared (lower triangular)");
+    }
+    if (b.size() != L.nrows()) {
+      throw std::logic_error(
+        "Error in Forward elimination: b vector must be of the same dimensions of L matrix");
+    }
+    unsigned int n = b.size();
+    y.resize(n);
+
+    y[0] = b[0] / L[0][0];
+    for (unsigned int i = 1; i &lt; n; i++) {
@@ -2121,2 +2363,3 @@
-      for (unsigned int j = 0; j &lt; i; j++)
-	y[i] -= L[i][j] * y[j];
+      for (unsigned int j = 0; j &lt; i; j++) {
+        y[i] -= L[i][j] * y[j];
+      }
@@ -2125,24 +2368,27 @@
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; forward_elimination(const Matrix&lt;T&gt;&amp; L, const Vector&lt;T&gt; b)
-{
-  Vector&lt;T&gt; y;
-  forward_elimination(L, y, b);
-	
-  return y;
-}
-
-template &lt;typename T&gt;
-void backward_elimination(const Matrix&lt;T&gt;&amp; U, Vector&lt;T&gt;&amp; x, const Vector&lt;T&gt;&amp; y)
-{
-  if (U.ncols() != U.nrows())
-    throw std::logic_error("Error in Backward elimination: matrix must be squared (upper triangular)");
-  if (y.size() != U.nrows())
-    throw std::logic_error("Error in Backward elimination: b vector must be of the same dimensions of U matrix");
-  int n = y.size();
-  x.resize(n);
-	
-  x[n - 1] = y[n - 1] / U[n - 1][n - 1];
-  for (int i = n - 2; i &gt;= 0; i--)
-    {
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; forward_elimination(const Matrix &lt; T &gt; &amp;L, const Vector &lt; T &gt; b)
+  {
+    Vector &lt; T &gt; y;
+    forward_elimination(L, y, b);
+
+    return y;
+  }
+
+  template &lt; typename T &gt;
+  void backward_elimination(const Matrix &lt; T &gt; &amp; U, Vector &lt; T &gt; &amp; x, const Vector &lt; T &gt; &amp; y)
+  {
+    if (U.ncols() != U.nrows()) {
+      throw std::logic_error(
+        "Error in Backward elimination: matrix must be squared (upper triangular)");
+    }
+    if (y.size() != U.nrows()) {
+      throw std::logic_error(
+        "Error in Backward elimination: b vector must be of the same dimensions of U matrix");
+    }
+    int n = y.size();
+    x.resize(n);
+
+    x[n - 1] = y[n - 1] / U[n - 1][n - 1];
+    for (int i = n - 2; i &gt;= 0; i--) {
@@ -2150,2 +2396,3 @@
-      for (int j = i + 1; j &lt; n; j++)
-	x[i] -= U[i][j] * x[j];
+      for (int j = i + 1; j &lt; n; j++) {
+        x[i] -= U[i][j] * x[j];
+      }
@@ -2154,10 +2401,10 @@
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; backward_elimination(const Matrix&lt;T&gt;&amp; U, const Vector&lt;T&gt; y)
-{
-  Vector&lt;T&gt; x;
-  forward_elimination(U, x, y);
-	
-  return x;
-}
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; backward_elimination(const Matrix &lt; T &gt; &amp;U, const Vector &lt; T &gt; y)
+  {
+    Vector &lt; T &gt; x;
+    forward_elimination(U, x, y);
+
+    return x;
+  }
@@ -2173,7 +2420,9 @@
-template &lt;typename T&gt;
-void random(Matrix&lt;T&gt;&amp; m)
-{
-  for (unsigned int i = 0; i &lt; m.nrows(); i++)
-    for (unsigned int j = 0; j &lt; m.ncols(); j++)
-      m[i][j] = (T)(rand() / double(RAND_MAX));
-}
+  template &lt; typename T &gt;
+  void random(Matrix &lt; T &gt; &amp; m)
+  {
+    for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; m.ncols(); j++) {
+        m[i][j] = (T)(rand() / double(RAND_MAX));
+      }
+    }
+  }
@@ -2185,68 +2434,80 @@
-template &lt;typename T&gt;
-Vector&lt;T&gt; sum(const Matrix&lt;T&gt;&amp; m)
-{
-  Vector&lt;T&gt; tmp((T)0, m.ncols());
-  for (unsigned int j = 0; j &lt; m.ncols(); j++)
-    for (unsigned int i = 0; i &lt; m.nrows(); i++)
-      tmp[j] += m[i][j];
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; r_sum(const Matrix&lt;T&gt;&amp; m)
-{
-  Vector&lt;T&gt; tmp((T)0, m.nrows());
-  for (unsigned int i = 0; i &lt; m.nrows(); i++)
-    for (unsigned int j = 0; j &lt; m.ncols(); j++)
-      tmp[i] += m[i][j];
-  return tmp;
-}
-
-template &lt;typename T&gt;
-T all_sum(const Matrix&lt;T&gt;&amp; m)
-{
-  T tmp = (T)0;
-  for (unsigned int i = 0; i &lt; m.nrows(); i++)
-    for (unsigned int j = 0; j &lt; m.ncols(); j++)
-      tmp += m[i][j];
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; prod(const Matrix&lt;T&gt;&amp; m)
-{
-  Vector&lt;T&gt; tmp((T)1, m.ncols());
-  for (unsigned int j = 0; j &lt; m.ncols(); j++)
-    for (unsigned int i = 0; i &lt; m.nrows(); i++)
-      tmp[j] *= m[i][j];
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; r_prod(const Matrix&lt;T&gt;&amp; m)
-{
-  Vector&lt;T&gt; tmp((T)1, m.nrows());
-  for (unsigned int i = 0; i &lt; m.nrows(); i++)
-    for (unsigned int j = 0; j &lt; m.ncols(); j++)
-      tmp[i] *= m[i][j];
-  return tmp;
-}
-
-template &lt;typename T&gt;
-T all_prod(const Matrix&lt;T&gt;&amp; m)
-{
-  T tmp = (T)1;
-  for (unsigned int i = 0; i &lt; m.nrows(); i++)
-    for (unsigned int j = 0; j &lt; m.ncols(); j++)
-      tmp *= m[i][j];
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; mean(const Matrix&lt;T&gt;&amp; m)
-{
-  Vector&lt;T&gt; res((T)0, m.ncols());
-  for (unsigned int j = 0; j &lt; m.ncols(); j++)
-    {
-      for (unsigned int i = 0; i &lt; m.nrows(); i++)
-	res[j] += m[i][j];
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; sum(const Matrix &lt; T &gt; &amp;m)
+  {
+    Vector &lt; T &gt; tmp((T)0, m.ncols());
+    for (unsigned int j = 0; j &lt; m.ncols(); j++) {
+      for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+        tmp[j] += m[i][j];
+      }
+    }
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; r_sum(const Matrix &lt; T &gt; &amp;m)
+  {
+    Vector &lt; T &gt; tmp((T)0, m.nrows());
+    for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; m.ncols(); j++) {
+        tmp[i] += m[i][j];
+      }
+    }
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  T all_sum(const Matrix &lt; T &gt; &amp; m)
+  {
+    T tmp = (T)0;
+    for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; m.ncols(); j++) {
+        tmp += m[i][j];
+      }
+    }
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; prod(const Matrix &lt; T &gt; &amp;m)
+  {
+    Vector &lt; T &gt; tmp((T)1, m.ncols());
+    for (unsigned int j = 0; j &lt; m.ncols(); j++) {
+      for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+        tmp[j] *= m[i][j];
+      }
+    }
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; r_prod(const Matrix &lt; T &gt; &amp;m)
+  {
+    Vector &lt; T &gt; tmp((T)1, m.nrows());
+    for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; m.ncols(); j++) {
+        tmp[i] *= m[i][j];
+      }
+    }
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  T all_prod(const Matrix &lt; T &gt; &amp; m)
+  {
+    T tmp = (T)1;
+    for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; m.ncols(); j++) {
+        tmp *= m[i][j];
+      }
+    }
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; mean(const Matrix &lt; T &gt; &amp;m)
+  {
+    Vector &lt; T &gt; res((T)0, m.ncols());
+    for (unsigned int j = 0; j &lt; m.ncols(); j++) {
+      for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+        res[j] += m[i][j];
+      }
@@ -2255,12 +2516,12 @@
-	
-  return res;
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; r_mean(const Matrix&lt;T&gt;&amp; m)
-{
-  Vector&lt;T&gt; res((T)0, m.rows());
-  for (unsigned int i = 0; i &lt; m.nrows(); i++)
-    {
-      for (unsigned int j = 0; j &lt; m.ncols(); j++)
-	res[i] += m[i][j];
+
+    return res;
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; r_mean(const Matrix &lt; T &gt; &amp;m)
+  {
+    Vector &lt; T &gt; res((T)0, m.rows());
+    for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; m.ncols(); j++) {
+        res[i] += m[i][j];
+      }
@@ -2269,22 +2530,23 @@
-	
-  return res;
-}
-
-template &lt;typename T&gt;
-T all_mean(const Matrix&lt;T&gt;&amp; m)
-{
-  T tmp = (T)0;
-  for (unsigned int i = 0; i &lt; m.nrows(); i++)
-    for (unsigned int j = 0; j &lt; m.ncols(); j++)
-      tmp += m[i][j];
-  return tmp / (m.nrows() * m.ncols());
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; var(const Matrix&lt;T&gt;&amp; m, bool sample_correction = false)
-{
-  Vector&lt;T&gt; res((T)0, m.ncols());
-  unsigned int n = m.nrows();
-  double sum, ssum;
-  for (unsigned int j = 0; j &lt; m.ncols(); j++)
-    {	
+
+    return res;
+  }
+
+  template &lt; typename T &gt;
+  T all_mean(const Matrix &lt; T &gt; &amp; m)
+  {
+    T tmp = (T)0;
+    for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; m.ncols(); j++) {
+        tmp += m[i][j];
+      }
+    }
+    return tmp / (m.nrows() * m.ncols());
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; var(const Matrix &lt; T &gt; &amp;m, bool sample_correction = false)
+  {
+    Vector &lt; T &gt; res((T)0, m.ncols());
+    unsigned int n = m.nrows();
+    double sum, ssum;
+    for (unsigned int j = 0; j &lt; m.ncols(); j++) {
@@ -2292,28 +2554,27 @@
-      for (unsigned int i = 0; i &lt; m.nrows(); i++)
-	{
-	  sum += m[i][j];
-	  ssum += (m[i][j] * m[i][j]);
-	}
-      if (!sample_correction)
-	res[j] = (ssum / n) - (sum / n) * (sum / n);
-      else
-	res[j] = n * ((ssum / n) - (sum / n) * (sum / n)) / (n - 1);		 
-    }
-	
-  return res;
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; stdev(const Matrix&lt;T&gt;&amp; m, bool sample_correction = false)
-{
-  return vec_sqrt(var(m, sample_correction));
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; r_var(const Matrix&lt;T&gt;&amp; m, bool sample_correction = false)
-{
-  Vector&lt;T&gt; res((T)0, m.nrows());
-  double sum, ssum;
-  unsigned int n = m.ncols();
-  for (unsigned int i = 0; i &lt; m.nrows(); i++)
-    {	
+      for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+        sum += m[i][j];
+        ssum += (m[i][j] * m[i][j]);
+      }
+      if (!sample_correction) {
+        res[j] = (ssum / n) - (sum / n) * (sum / n);
+      } else {
+        res[j] = n * ((ssum / n) - (sum / n) * (sum / n)) / (n - 1);
+      }
+    }
+
+    return res;
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; stdev(const Matrix &lt; T &gt; &amp;m, bool sample_correction = false)
+  {
+    return vec_sqrt(var(m, sample_correction));
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; r_var(const Matrix &lt; T &gt; &amp;m, bool sample_correction = false)
+  {
+    Vector &lt; T &gt; res((T)0, m.nrows());
+    double sum, ssum;
+    unsigned int n = m.ncols();
+    for (unsigned int i = 0; i &lt; m.nrows(); i++) {
@@ -2321,27 +2582,26 @@
-      for (unsigned int j = 0; j &lt; m.ncols(); j++)
-	{
-	  sum += m[i][j];
-	  ssum += (m[i][j] * m[i][j]);
-	}
-      if (!sample_correction)
-	res[i] = (ssum / n) - (sum / n) * (sum / n);
-      else
-	res[i] = n * ((ssum / n) - (sum / n) * (sum / n)) / (n - 1);
-    }
-	
-  return res;
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; r_stdev(const Matrix&lt;T&gt;&amp; m, bool sample_correction = false)
-{
-  return vec_sqrt(r_var(m, sample_correction));
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; max(const Matrix&lt;T&gt;&amp; m)
-{
-  Vector&lt;T&gt; res(m.ncols());
-  double value;
-  for (unsigned int j = 0; j &lt; m.ncols(); j++)
-    {
+      for (unsigned int j = 0; j &lt; m.ncols(); j++) {
+        sum += m[i][j];
+        ssum += (m[i][j] * m[i][j]);
+      }
+      if (!sample_correction) {
+        res[i] = (ssum / n) - (sum / n) * (sum / n);
+      } else {
+        res[i] = n * ((ssum / n) - (sum / n) * (sum / n)) / (n - 1);
+      }
+    }
+
+    return res;
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; r_stdev(const Matrix &lt; T &gt; &amp;m, bool sample_correction = false)
+  {
+    return vec_sqrt(r_var(m, sample_correction));
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; max(const Matrix &lt; T &gt; &amp;m)
+  {
+    Vector &lt; T &gt; res(m.ncols());
+    double value;
+    for (unsigned int j = 0; j &lt; m.ncols(); j++) {
@@ -2349,2 +2609,3 @@
-      for (unsigned int i = 1; i &lt; m.nrows(); i++)
-	value = std::max(m[i][j], value);
+      for (unsigned int i = 1; i &lt; m.nrows(); i++) {
+        value = std::max(m[i][j], value);
+      }
@@ -2353,11 +2614,10 @@
-	
-  return res;
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; r_max(const Matrix&lt;T&gt;&amp; m)
-{
-  Vector&lt;T&gt; res(m.nrows());
-  double value;
-  for (unsigned int i = 0; i &lt; m.nrows(); i++)
-    {
+
+    return res;
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; r_max(const Matrix &lt; T &gt; &amp;m)
+  {
+    Vector &lt; T &gt; res(m.nrows());
+    double value;
+    for (unsigned int i = 0; i &lt; m.nrows(); i++) {
@@ -2365,2 +2625,3 @@
-      for (unsigned int j = 1; j &lt; m.ncols(); j++)
-	value = std::max(m[i][j], value);
+      for (unsigned int j = 1; j &lt; m.ncols(); j++) {
+        value = std::max(m[i][j], value);
+      }
@@ -2369,11 +2630,10 @@
-	
-  return res;
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; min(const Matrix&lt;T&gt;&amp; m)
-{
-  Vector&lt;T&gt; res(m.ncols());
-  double value;
-  for (unsigned int j = 0; j &lt; m.ncols(); j++)
-    {
+
+    return res;
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; min(const Matrix &lt; T &gt; &amp;m)
+  {
+    Vector &lt; T &gt; res(m.ncols());
+    double value;
+    for (unsigned int j = 0; j &lt; m.ncols(); j++) {
@@ -2381,2 +2641,3 @@
-      for (unsigned int i = 1; i &lt; m.nrows(); i++)
-	value = std::min(m[i][j], value);
+      for (unsigned int i = 1; i &lt; m.nrows(); i++) {
+        value = std::min(m[i][j], value);
+      }
@@ -2385,11 +2646,10 @@
-	
-  return res;
-}
-
-template &lt;typename T&gt;
-Vector&lt;T&gt; r_min(const Matrix&lt;T&gt;&amp; m)
-{
-  Vector&lt;T&gt; res(m.nrows());
-  double value;
-  for (unsigned int i = 0; i &lt; m.nrows(); i++)
-    {
+
+    return res;
+  }
+
+  template &lt; typename T &gt;
+  Vector &lt; T &gt; r_min(const Matrix &lt; T &gt; &amp;m)
+  {
+    Vector &lt; T &gt; res(m.nrows());
+    double value;
+    for (unsigned int i = 0; i &lt; m.nrows(); i++) {
@@ -2397,2 +2657,3 @@
-      for (unsigned int j = 1; j &lt; m.ncols(); j++)
-	value = std::min(m[i][j], value);
+      for (unsigned int j = 1; j &lt; m.ncols(); j++) {
+        value = std::min(m[i][j], value);
+      }
@@ -2401,4 +2662,3 @@
-	
-  return res;
-}
-
+
+    return res;
+  }
@@ -2411,23 +2671,27 @@
-template &lt;typename T&gt;
-Matrix&lt;T&gt; exp(const Matrix&lt;T&gt;&amp;m)
-{
-  Matrix&lt;T&gt; tmp(m.nrows(), m.ncols());
-	
-  for (unsigned int i = 0; i &lt; m.nrows(); i++)
-    for (unsigned int j = 0; j &lt; m.ncols(); j++)
-      tmp[i][j] = exp(m[i][j]);
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; mat_sqrt(const Matrix&lt;T&gt;&amp;m)
-{
-  Matrix&lt;T&gt; tmp(m.nrows(), m.ncols());
-	
-  for (unsigned int i = 0; i &lt; m.nrows(); i++)
-    for (unsigned int j = 0; j &lt; m.ncols(); j++)
-      tmp[i][j] = sqrt(m[i][j]);
-	
-  return tmp;
-}
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; exp(const Matrix &lt; T &gt; &amp;m)
+  {
+    Matrix &lt; T &gt; tmp(m.nrows(), m.ncols());
+
+    for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; m.ncols(); j++) {
+        tmp[i][j] = exp(m[i][j]);
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; mat_sqrt(const Matrix &lt; T &gt; &amp;m)
+  {
+    Matrix &lt; T &gt; tmp(m.nrows(), m.ncols());
+
+    for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; m.ncols(); j++) {
+        tmp[i][j] = sqrt(m[i][j]);
+      }
+    }
+
+    return tmp;
+  }
@@ -2439,47 +2703,55 @@
-template &lt;typename T&gt;
-Matrix&lt;T&gt; kron(const Vector&lt;T&gt;&amp; b, const Vector&lt;T&gt;&amp; a)
-{
-  Matrix&lt;T&gt; tmp(b.size(), a.size());
-  for (unsigned int i = 0; i &lt; b.size(); i++)
-    for (unsigned int j = 0; j &lt; a.size(); j++)
-      tmp[i][j] = a[j] * b[i];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; t(const Matrix&lt;T&gt;&amp; a)
-{
-  Matrix&lt;T&gt; tmp(a.ncols(), a.nrows());
-  for (unsigned int i = 0; i &lt; a.nrows(); i++)
-    for (unsigned int j = 0; j &lt; a.ncols(); j++)
-      tmp[j][i] = a[i][j];
-	
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; dot_prod(const Matrix&lt;T&gt;&amp; a, const Matrix&lt;T&gt;&amp; b)
-{
-  if (a.ncols() != b.nrows())
-    throw std::logic_error("Error matrix dot product: dimensions of the matrices are not compatible");
-  Matrix&lt;T&gt; tmp(a.nrows(), b.ncols());
-  for (unsigned int i = 0; i &lt; tmp.nrows(); i++)
-    for (unsigned int j = 0; j &lt; tmp.ncols(); j++)
-      {
-	tmp[i][j] = (T)0;
-	for (unsigned int k = 0; k &lt; a.ncols(); k++)
-	  tmp[i][j] += a[i][k] * b[k][j];
-      }
-			
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; dot_prod(const Matrix&lt;T&gt;&amp; a, const Vector&lt;T&gt;&amp; b)
-{
-  if (a.ncols() != b.size())
-    throw std::logic_error("Error matrix dot product: dimensions of the matrix and the vector are not compatible");
-  Matrix&lt;T&gt; tmp(a.nrows(), 1);
-  for (unsigned int i = 0; i &lt; tmp.nrows(); i++)
-    {
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; kron(const Vector &lt; T &gt; &amp;b, const Vector &lt; T &gt; &amp;a)
+  {
+    Matrix &lt; T &gt; tmp(b.size(), a.size());
+    for (unsigned int i = 0; i &lt; b.size(); i++) {
+      for (unsigned int j = 0; j &lt; a.size(); j++) {
+        tmp[i][j] = a[j] * b[i];
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; t(const Matrix &lt; T &gt; &amp;a)
+  {
+    Matrix &lt; T &gt; tmp(a.ncols(), a.nrows());
+    for (unsigned int i = 0; i &lt; a.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; a.ncols(); j++) {
+        tmp[j][i] = a[i][j];
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; dot_prod(const Matrix &lt; T &gt; &amp;a, const Matrix &lt; T &gt; &amp;b)
+  {
+    if (a.ncols() != b.nrows()) {
+      throw std::logic_error(
+        "Error matrix dot product: dimensions of the matrices are not compatible");
+    }
+    Matrix &lt; T &gt; tmp(a.nrows(), b.ncols());
+    for (unsigned int i = 0; i &lt; tmp.nrows(); i++) {
+      for (unsigned int j = 0; j &lt; tmp.ncols(); j++) {
+        tmp[i][j] = (T)0;
+        for (unsigned int k = 0; k &lt; a.ncols(); k++) {
+          tmp[i][j] += a[i][k] * b[k][j];
+        }
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; dot_prod(const Matrix &lt; T &gt; &amp;a, const Vector &lt; T &gt; &amp;b)
+  {
+    if (a.ncols() != b.size()) {
+      throw std::logic_error(
+        "Error matrix dot product: dimensions of the matrix and the vector are not compatible");
+    }
+    Matrix &lt; T &gt; tmp(a.nrows(), 1);
+    for (unsigned int i = 0; i &lt; tmp.nrows(); i++) {
@@ -2487,15 +2759,17 @@
-      for (unsigned int k = 0; k &lt; a.ncols(); k++)
-	tmp[i][0] += a[i][k] * b[k];
-    }
-		
-  return tmp;
-}
-
-template &lt;typename T&gt;
-Matrix&lt;T&gt; dot_prod(const Vector&lt;T&gt;&amp; a, const Matrix&lt;T&gt;&amp; b)
-{
-  if (a.size() != b.nrows())
-    throw std::logic_error("Error matrix dot product: dimensions of the vector and matrix are not compatible");
-  Matrix&lt;T&gt; tmp(1, b.ncols());
-  for (unsigned int j = 0; j &lt; tmp.ncols(); j++)
-    {
+      for (unsigned int k = 0; k &lt; a.ncols(); k++) {
+        tmp[i][0] += a[i][k] * b[k];
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  Matrix &lt; T &gt; dot_prod(const Vector &lt; T &gt; &amp;a, const Matrix &lt; T &gt; &amp;b)
+  {
+    if (a.size() != b.nrows()) {
+      throw std::logic_error(
+        "Error matrix dot product: dimensions of the vector and matrix are not compatible");
+    }
+    Matrix &lt; T &gt; tmp(1, b.ncols());
+    for (unsigned int j = 0; j &lt; tmp.ncols(); j++) {
@@ -2503,26 +2777,29 @@
-      for (unsigned int k = 0; k &lt; a.size(); k++)
-	tmp[0][j] += a[k] * b[k][j];
-    }
-		
-  return tmp;
-}
-
-template &lt;typename T&gt;
-inline Matrix&lt;double&gt; rank(const Matrix&lt;T&gt; m)
-{
-  Matrix&lt;double&gt; tmp(m.nrows(), m.ncols());
-  for (unsigned int j = 0; j &lt; m.ncols(); j++)
-    tmp.setColumn(j, rank&lt;T&gt;(m.extractColumn(j)));
-  
-  return tmp;                  
-}
-
-template &lt;typename T&gt;
-inline Matrix&lt;double&gt; r_rank(const Matrix&lt;T&gt; m)
-{
-  Matrix&lt;double&gt; tmp(m.nrows(), m.ncols());
-  for (unsigned int i = 0; i &lt; m.nrows(); i++)
-    tmp.setRow(i, rank&lt;T&gt;(m.extractRow(i)));
-  
-  return tmp;                  
-}
+      for (unsigned int k = 0; k &lt; a.size(); k++) {
+        tmp[0][j] += a[k] * b[k][j];
+      }
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; double &gt; rank(const Matrix &lt; T &gt; m)
+  {
+    Matrix &lt; double &gt; tmp(m.nrows(), m.ncols());
+    for (unsigned int j = 0; j &lt; m.ncols(); j++) {
+      tmp.setColumn(j, rank &lt; T &gt; (m.extractColumn(j)));
+    }
+
+    return tmp;
+  }
+
+  template &lt; typename T &gt;
+  inline Matrix &lt; double &gt; r_rank(const Matrix &lt; T &gt; m)
+  {
+    Matrix &lt; double &gt; tmp(m.nrows(), m.ncols());
+    for (unsigned int i = 0; i &lt; m.nrows(); i++) {
+      tmp.setRow(i, rank &lt; T &gt; (m.extractRow(i)));
+    }
+
+    return tmp;
+  }

Code style divergence in file 'include/thirdParty/quadProgpp/QuadProg++.hh':

--- include/thirdParty/quadProgpp/QuadProg++.hh
+++ include/thirdParty/quadProgpp/QuadProg++.hh.uncrustify
@@ -2,3 +2,3 @@
- File $Id: QuadProg++.hh 232 2007-06-21 12:29:00Z digasper $ 
- 
- The quadprog_solve() function implements the algorithm of Goldfarb and Idnani 
+ File $Id: QuadProg++.hh 232 2007-06-21 12:29:00Z digasper $
+
+ The quadprog_solve() function implements the algorithm of Goldfarb and Idnani
@@ -7 +7 @@
-	 
+
@@ -14 +14 @@
-	 
+
@@ -18 +18 @@
-				
+
@@ -21 +21 @@
-				
+
@@ -26 +26 @@
- 
+
@@ -30 +30 @@
- 
+
@@ -35,2 +35,2 @@
-  1. pay attention in setting up the vectors ce0 and ci0. 
-	   If the constraints of your problem are specified in the form 
+  1. pay attention in setting up the vectors ce0 and ci0.
+	   If the constraints of your problem are specified in the form
@@ -38,2 +38,2 @@
-  2. The matrices have column dimension equal to MATRIX_DIM, 
-     a constant set to 20 in this file (by means of a #define macro). 
+  2. The matrices have column dimension equal to MATRIX_DIM,
+     a constant set to 20 in this file (by means of a #define macro).
@@ -43 +43 @@
-     the G = L^T L cholesky factorization for further computations inside the function. 
+     the G = L^T L cholesky factorization for further computations inside the function.
@@ -46 +46 @@
-    
+
@@ -48 +48 @@
-  			 DIEGM - University of Udine, Italy
+                         DIEGM - University of Udine, Italy
@@ -51 +51 @@
- 
+
@@ -54 +54 @@
- 
+
@@ -56 +56 @@
- 
+
@@ -70,4 +70,5 @@
-double solve_quadprog(Matrix&lt;double&gt;&amp; G, Vector&lt;double&gt;&amp; g0, 
-                      const Matrix&lt;double&gt;&amp; CE, const Vector&lt;double&gt;&amp; ce0,  
-                      const Matrix&lt;double&gt;&amp; CI, const Vector&lt;double&gt;&amp; ci0, 
-                      Vector&lt;double&gt;&amp; x);
+  double solve_quadprog(
+    Matrix &lt; double &gt; &amp; G, Vector &lt; double &gt; &amp; g0,
+    const Matrix &lt; double &gt; &amp; CE, const Vector &lt; double &gt; &amp; ce0,
+    const Matrix &lt; double &gt; &amp; CI, const Vector &lt; double &gt; &amp; ci0,
+    Vector &lt; double &gt; &amp; x);

Code style divergence in file 'src/FSM/FSM.cpp':

--- src/FSM/FSM.cpp
+++ src/FSM/FSM.cpp.uncrustify
@@ -7,2 +7,3 @@
-FSM::FSM(CtrlComponents *ctrlComp)
-    :_ctrlComp(ctrlComp){
+FSM::FSM(CtrlComponents * ctrlComp)
+: _ctrlComp(ctrlComp)
+{
@@ -10,8 +11,8 @@
-    _stateList.invalid = nullptr;
-    _stateList.passive = new State_Passive(_ctrlComp);
-    _stateList.fixedStand = new State_FixedStand(_ctrlComp);
-    _stateList.freeStand = new State_FreeStand(_ctrlComp);
-    _stateList.trotting = new State_Trotting(_ctrlComp);
-    _stateList.balanceTest = new State_BalanceTest(_ctrlComp);
-    _stateList.swingTest = new State_SwingTest(_ctrlComp);
-    _stateList.stepTest = new State_StepTest(_ctrlComp);
+  _stateList.invalid = nullptr;
+  _stateList.passive = new State_Passive(_ctrlComp);
+  _stateList.fixedStand = new State_FixedStand(_ctrlComp);
+  _stateList.freeStand = new State_FreeStand(_ctrlComp);
+  _stateList.trotting = new State_Trotting(_ctrlComp);
+  _stateList.balanceTest = new State_BalanceTest(_ctrlComp);
+  _stateList.swingTest = new State_SwingTest(_ctrlComp);
+  _stateList.stepTest = new State_StepTest(_ctrlComp);
@@ -19 +20 @@
-    _stateList.moveBase = new State_move_base(_ctrlComp);
+  _stateList.moveBase = new State_move_base(_ctrlComp);
@@ -22 +23 @@
-    _stateList.moveBase = new State_move_base(_ctrlComp);
+  _stateList.moveBase = new State_move_base(_ctrlComp);
@@ -24 +25 @@
-    initialize();
+  initialize();
@@ -27,2 +28,3 @@
-FSM::~FSM(){
-    _stateList.deletePtr();
+FSM::~FSM()
+{
+  _stateList.deletePtr();
@@ -31,5 +33,6 @@
-void FSM::initialize(){
-    _currentState = _stateList.passive;
-    _currentState -&gt; enter();
-    _nextState = _currentState;
-    _mode = FSMMode::NORMAL;
+void FSM::initialize()
+{
+  _currentState = _stateList.passive;
+  _currentState-&gt;enter();
+  _nextState = _currentState;
+  _mode = FSMMode::NORMAL;
@@ -38,7 +41,18 @@
-void FSM::run(){
-    _startTime = getSystemTime();
-    _ctrlComp-&gt;sendRecv();
-    _ctrlComp-&gt;runWaveGen();
-    _ctrlComp-&gt;estimator-&gt;run();
-    if(!checkSafty()){
-        _ctrlComp-&gt;ioInter-&gt;setPassive();
+void FSM::run()
+{
+  _startTime = getSystemTime();
+  _ctrlComp-&gt;sendRecv();
+  _ctrlComp-&gt;runWaveGen();
+  _ctrlComp-&gt;estimator-&gt;run();
+  if (!checkSafty()) {
+    _ctrlComp-&gt;ioInter-&gt;setPassive();
+  }
+
+  if (_mode == FSMMode::NORMAL) {
+    _currentState-&gt;run();
+    _nextStateName = _currentState-&gt;checkChange();
+    if (_nextStateName != _currentState-&gt;_stateName) {
+      _mode = FSMMode::CHANGE;
+      _nextState = getNextState(_nextStateName);
+      std::cout &lt;&lt; "Switched from " &lt;&lt; _currentState-&gt;_stateNameString
+                &lt;&lt; " to " &lt;&lt; _nextState-&gt;_stateNameString &lt;&lt; std::endl;
@@ -45,0 +60,7 @@
+  } else if (_mode == FSMMode::CHANGE) {
+    _currentState-&gt;exit();
+    _currentState = _nextState;
+    _currentState-&gt;enter();
+    _mode = FSMMode::NORMAL;
+    _currentState-&gt;run();
+  }
@@ -47,19 +68 @@
-    if(_mode == FSMMode::NORMAL){
-        _currentState-&gt;run();
-        _nextStateName = _currentState-&gt;checkChange();
-        if(_nextStateName != _currentState-&gt;_stateName){
-            _mode = FSMMode::CHANGE;
-            _nextState = getNextState(_nextStateName);
-            std::cout &lt;&lt; "Switched from " &lt;&lt; _currentState-&gt;_stateNameString
-                      &lt;&lt; " to " &lt;&lt; _nextState-&gt;_stateNameString &lt;&lt; std::endl;
-        }
-    }
-    else if(_mode == FSMMode::CHANGE){
-        _currentState-&gt;exit();
-        _currentState = _nextState;
-        _currentState-&gt;enter();
-        _mode = FSMMode::NORMAL;
-        _currentState-&gt;run();
-    }
-
-    absoluteWait(_startTime, (long long)(_ctrlComp-&gt;dt * 1000000));
+  absoluteWait(_startTime, (long long)(_ctrlComp-&gt;dt * 1000000));
@@ -68,3 +71,3 @@
-FSMState* FSM::getNextState(FSMStateName stateName){
-    switch (stateName)
-    {
+FSMState * FSM::getNextState(FSMStateName stateName)
+{
+  switch (stateName) {
@@ -72,2 +75,2 @@
-        return _stateList.invalid;
-        break;
+      return _stateList.invalid;
+      break;
@@ -75,2 +78,2 @@
-        return _stateList.passive;
-        break;
+      return _stateList.passive;
+      break;
@@ -78,2 +81,2 @@
-        return _stateList.fixedStand;
-        break;
+      return _stateList.fixedStand;
+      break;
@@ -81,2 +84,2 @@
-        return _stateList.freeStand;
-        break;
+      return _stateList.freeStand;
+      break;
@@ -84,2 +87,2 @@
-        return _stateList.trotting;
-        break;
+      return _stateList.trotting;
+      break;
@@ -87,2 +90,2 @@
-        return _stateList.balanceTest;
-        break;
+      return _stateList.balanceTest;
+      break;
@@ -90,2 +93,2 @@
-        return _stateList.swingTest;
-        break;
+      return _stateList.swingTest;
+      break;
@@ -93,2 +96,2 @@
-        return _stateList.stepTest;
-        break;
+      return _stateList.stepTest;
+      break;
@@ -97,2 +100,2 @@
-        return _stateList.moveBase;
-        break;
+      return _stateList.moveBase;
+      break;
@@ -102,2 +105,2 @@
-        return _stateList.moveBase;
-        break;
+      return _stateList.moveBase;
+      break;
@@ -106,3 +109,3 @@
-        return _stateList.invalid;
-        break;
-    }
+      return _stateList.invalid;
+      break;
+  }
@@ -111,8 +114,9 @@
-bool FSM::checkSafty(){
-    // The angle with z axis less than 60 degree
-    if(_ctrlComp-&gt;lowState-&gt;getRotMat()(2,2) &lt; 0.5 ){
-        return false;
-    }else{
-        return true;
-    }
-}
+bool FSM::checkSafty()
+{
+  // The angle with z axis less than 60 degree
+  if (_ctrlComp-&gt;lowState-&gt;getRotMat()(2, 2) &lt; 0.5) {
+    return false;
+  } else {
+    return true;
+  }
+}

Code style divergence in file 'src/FSM/FSMState.cpp':

--- src/FSM/FSMState.cpp
+++ src/FSM/FSMState.cpp.uncrustify
@@ -6,5 +6,6 @@
-FSMState::FSMState(CtrlComponents *ctrlComp, FSMStateName stateName, std::string stateNameString)
-            :_ctrlComp(ctrlComp), _stateName(stateName), _stateNameString(stateNameString){
-    _lowCmd = _ctrlComp-&gt;lowCmd;
-    _lowState = _ctrlComp-&gt;lowState;
-}
+FSMState::FSMState(CtrlComponents * ctrlComp, FSMStateName stateName, std::string stateNameString)
+: _ctrlComp(ctrlComp), _stateName(stateName), _stateNameString(stateNameString)
+{
+  _lowCmd = _ctrlComp-&gt;lowCmd;
+  _lowState = _ctrlComp-&gt;lowState;
+}

Code style divergence in file 'src/FSM/State_BalanceTest.cpp':

--- src/FSM/State_BalanceTest.cpp
+++ src/FSM/State_BalanceTest.cpp.uncrustify
@@ -6,4 +6,5 @@
-State_BalanceTest::State_BalanceTest(CtrlComponents *ctrlComp)
-                  :FSMState(ctrlComp, FSMStateName::BALANCETEST, "balanceTest"),
-                  _est(ctrlComp-&gt;estimator), _robModel(ctrlComp-&gt;robotModel), 
-                  _balCtrl(ctrlComp-&gt;balCtrl), _contact(ctrlComp-&gt;contact){
+State_BalanceTest::State_BalanceTest(CtrlComponents * ctrlComp)
+: FSMState(ctrlComp, FSMStateName::BALANCETEST, "balanceTest"),
+  _est(ctrlComp-&gt;estimator), _robModel(ctrlComp-&gt;robotModel),
+  _balCtrl(ctrlComp-&gt;balCtrl), _contact(ctrlComp-&gt;contact)
+{
@@ -11,8 +12,8 @@
-    _xMax = 0.05;
-    _xMin = -_xMax;
-    _yMax = 0.05;
-    _yMin = -_yMax;
-    _zMax = 0.04;
-    _zMin = -_zMax;
-    _yawMax = 20 * M_PI / 180;
-    _yawMin = -_yawMax;
+  _xMax = 0.05;
+  _xMin = -_xMax;
+  _yMax = 0.05;
+  _yMin = -_yMax;
+  _zMax = 0.04;
+  _zMin = -_zMax;
+  _yawMax = 20 * M_PI / 180;
+  _yawMin = -_yawMax;
@@ -20,2 +21,2 @@
-    _Kpp = Vec3(150, 150, 150).asDiagonal();
-    _Kdp = Vec3(25, 25, 25).asDiagonal();
+  _Kpp = Vec3(150, 150, 150).asDiagonal();
+  _Kdp = Vec3(25, 25, 25).asDiagonal();
@@ -23,2 +24,2 @@
-    _kpw = 200;
-    _Kdw = Vec3(30, 30, 30).asDiagonal();
+  _kpw = 200;
+  _Kdw = Vec3(30, 30, 30).asDiagonal();
@@ -27,4 +28,5 @@
-void State_BalanceTest::enter(){
-    _pcdInit = _est-&gt;getPosition();
-    _pcd = _pcdInit;
-    _RdInit = _lowState-&gt;getRotMat();
+void State_BalanceTest::enter()
+{
+  _pcdInit = _est-&gt;getPosition();
+  _pcd = _pcdInit;
+  _RdInit = _lowState-&gt;getRotMat();
@@ -32,2 +34,2 @@
-    _ctrlComp-&gt;setAllStance();
-    _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
+  _ctrlComp-&gt;setAllStance();
+  _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
@@ -36,2 +38,3 @@
-void State_BalanceTest::run(){
-    _userValue = _lowState-&gt;userValue;
+void State_BalanceTest::run()
+{
+  _userValue = _lowState-&gt;userValue;
@@ -39,3 +42,3 @@
-    _pcd(0) = _pcdInit(0) + invNormalize(_userValue.ly, _xMin, _xMax);
-    _pcd(1) = _pcdInit(1) - invNormalize(_userValue.lx, _yMin, _yMax);
-    _pcd(2) = _pcdInit(2) + invNormalize(_userValue.ry, _zMin, _zMax);
+  _pcd(0) = _pcdInit(0) + invNormalize(_userValue.ly, _xMin, _xMax);
+  _pcd(1) = _pcdInit(1) - invNormalize(_userValue.lx, _yMin, _yMax);
+  _pcd(2) = _pcdInit(2) + invNormalize(_userValue.ry, _zMin, _zMax);
@@ -43,2 +46,2 @@
-    float yaw = invNormalize(_userValue.rx, _yawMin, _yawMax);
-    _Rd = rpyToRotMat(0, 0, yaw)*_RdInit;
+  float yaw = invNormalize(_userValue.rx, _yawMin, _yawMax);
+  _Rd = rpyToRotMat(0, 0, yaw) * _RdInit;
@@ -46,2 +49,2 @@
-    _posBody = _est-&gt;getPosition();
-    _velBody = _est-&gt;getVelocity();
+  _posBody = _est-&gt;getPosition();
+  _velBody = _est-&gt;getVelocity();
@@ -49,2 +52,2 @@
-    _B2G_RotMat = _lowState-&gt;getRotMat();
-    _G2B_RotMat = _B2G_RotMat.transpose();
+  _B2G_RotMat = _lowState-&gt;getRotMat();
+  _G2B_RotMat = _B2G_RotMat.transpose();
@@ -52 +55 @@
-    calcTau();
+  calcTau();
@@ -54,3 +57,3 @@
-    _lowCmd-&gt;setStableGain();
-    _lowCmd-&gt;setTau(_tau);
-    _lowCmd-&gt;setQ(_q);
+  _lowCmd-&gt;setStableGain();
+  _lowCmd-&gt;setTau(_tau);
+  _lowCmd-&gt;setQ(_q);
@@ -59,2 +62,3 @@
-void State_BalanceTest::exit(){
-    _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
+void State_BalanceTest::exit()
+{
+  _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
@@ -63,10 +67,9 @@
-FSMStateName State_BalanceTest::checkChange(){
-    if(_lowState-&gt;userCmd == UserCommand::L2_B){
-        return FSMStateName::PASSIVE;
-    }
-    else if(_lowState-&gt;userCmd == UserCommand::L2_A){
-        return FSMStateName::FIXEDSTAND;
-    }
-    else{
-        return FSMStateName::BALANCETEST;
-    }
+FSMStateName State_BalanceTest::checkChange()
+{
+  if (_lowState-&gt;userCmd == UserCommand::L2_B) {
+    return FSMStateName::PASSIVE;
+  } else if (_lowState-&gt;userCmd == UserCommand::L2_A) {
+    return FSMStateName::FIXEDSTAND;
+  } else {
+    return FSMStateName::BALANCETEST;
+  }
@@ -75 +78,2 @@
-void State_BalanceTest::calcTau(){
+void State_BalanceTest::calcTau()
+{
@@ -77,2 +81,3 @@
-    _ddPcd = _Kpp*(_pcd - _posBody) + _Kdp * (Vec3(0, 0, 0) - _velBody);
-    _dWbd  = _kpw*rotMatToExp(_Rd*_G2B_RotMat) + _Kdw * (Vec3(0, 0, 0) - _lowState-&gt;getGyroGlobal());
+  _ddPcd = _Kpp * (_pcd - _posBody) + _Kdp * (Vec3(0, 0, 0) - _velBody);
+  _dWbd = _kpw * rotMatToExp(_Rd * _G2B_RotMat) + _Kdw *
+    (Vec3(0, 0, 0) - _lowState-&gt;getGyroGlobal());
@@ -80 +85 @@
-    _posFeet2BGlobal = _est-&gt;getPosFeet2BGlobal();
+  _posFeet2BGlobal = _est-&gt;getPosFeet2BGlobal();
@@ -82,2 +87,2 @@
-    _forceFeetGlobal = - _balCtrl-&gt;calF(_ddPcd, _dWbd, _B2G_RotMat, _posFeet2BGlobal, *_contact);
-    _forceFeetBody = _G2B_RotMat * _forceFeetGlobal;
+  _forceFeetGlobal = -_balCtrl-&gt;calF(_ddPcd, _dWbd, _B2G_RotMat, _posFeet2BGlobal, *_contact);
+  _forceFeetBody = _G2B_RotMat * _forceFeetGlobal;
@@ -85,3 +90,3 @@
-    _q = vec34ToVec12(_lowState-&gt;getQ());
-    _tau = _robModel-&gt;getTau(_q, _forceFeetBody);
-}
+  _q = vec34ToVec12(_lowState-&gt;getQ());
+  _tau = _robModel-&gt;getTau(_q, _forceFeetBody);
+}

Code style divergence in file 'src/FSM/State_FixedStand.cpp':

--- src/FSM/State_FixedStand.cpp
+++ src/FSM/State_FixedStand.cpp.uncrustify
@@ -7,2 +7,2 @@
-State_FixedStand::State_FixedStand(CtrlComponents *ctrlComp)
-                :FSMState(ctrlComp, FSMStateName::FIXEDSTAND, "fixed stand"){}
+State_FixedStand::State_FixedStand(CtrlComponents * ctrlComp)
+: FSMState(ctrlComp, FSMStateName::FIXEDSTAND, "fixed stand") {}
@@ -10,10 +10,7 @@
-void State_FixedStand::enter(){
-    for(int i=0; i&lt;4; i++){
-        if(_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::GAZEBO){
-            _lowCmd-&gt;setSimStanceGain(i);
-        }
-        else if(_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::REALROBOT){
-            _lowCmd-&gt;setRealStanceGain(i);
-        }
-        _lowCmd-&gt;setZeroDq(i);
-        _lowCmd-&gt;setZeroTau(i);
+void State_FixedStand::enter()
+{
+  for (int i = 0; i &lt; 4; i++) {
+    if (_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::GAZEBO) {
+      _lowCmd-&gt;setSimStanceGain(i);
+    } else if (_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::REALROBOT) {
+      _lowCmd-&gt;setRealStanceGain(i);
@@ -21,5 +18,8 @@
-    for(int i=0; i&lt;12; i++){
-        _lowCmd-&gt;motorCmd[i].q = _lowState-&gt;motorState[i].q;
-        _startPos[i] = _lowState-&gt;motorState[i].q;
-    }
-    _ctrlComp-&gt;setAllStance();
+    _lowCmd-&gt;setZeroDq(i);
+    _lowCmd-&gt;setZeroTau(i);
+  }
+  for (int i = 0; i &lt; 12; i++) {
+    _lowCmd-&gt;motorCmd[i].q = _lowState-&gt;motorState[i].q;
+    _startPos[i] = _lowState-&gt;motorState[i].q;
+  }
+  _ctrlComp-&gt;setAllStance();
@@ -28,6 +28,7 @@
-void State_FixedStand::run(){
-    _percent += (float)1/_duration;
-    _percent = _percent &gt; 1 ? 1 : _percent;
-    for(int j=0; j&lt;12; j++){
-        _lowCmd-&gt;motorCmd[j].q = (1 - _percent)*_startPos[j] + _percent*_targetPos[j]; 
-    }
+void State_FixedStand::run()
+{
+  _percent += (float)1 / _duration;
+  _percent = _percent &gt; 1 ? 1 : _percent;
+  for (int j = 0; j &lt; 12; j++) {
+    _lowCmd-&gt;motorCmd[j].q = (1 - _percent) * _startPos[j] + _percent * _targetPos[j];
+  }
@@ -36,2 +37,3 @@
-void State_FixedStand::exit(){
-    _percent = 0;
+void State_FixedStand::exit()
+{
+  _percent = 0;
@@ -40,19 +42,15 @@
-FSMStateName State_FixedStand::checkChange(){
-    if(_lowState-&gt;userCmd == UserCommand::L2_B){
-        return FSMStateName::PASSIVE;
-    }
-    else if(_lowState-&gt;userCmd == UserCommand::L2_X){
-        return FSMStateName::FREESTAND;
-    }
-    else if(_lowState-&gt;userCmd == UserCommand::START){
-        return FSMStateName::TROTTING;
-    }
-    else if(_lowState-&gt;userCmd == UserCommand::L1_X){
-        return FSMStateName::BALANCETEST;
-    }
-    else if(_lowState-&gt;userCmd == UserCommand::L1_A){
-        return FSMStateName::SWINGTEST;
-    }
-    else if(_lowState-&gt;userCmd == UserCommand::L1_Y){
-        return FSMStateName::STEPTEST;
-    }
+FSMStateName State_FixedStand::checkChange()
+{
+  if (_lowState-&gt;userCmd == UserCommand::L2_B) {
+    return FSMStateName::PASSIVE;
+  } else if (_lowState-&gt;userCmd == UserCommand::L2_X) {
+    return FSMStateName::FREESTAND;
+  } else if (_lowState-&gt;userCmd == UserCommand::START) {
+    return FSMStateName::TROTTING;
+  } else if (_lowState-&gt;userCmd == UserCommand::L1_X) {
+    return FSMStateName::BALANCETEST;
+  } else if (_lowState-&gt;userCmd == UserCommand::L1_A) {
+    return FSMStateName::SWINGTEST;
+  } else if (_lowState-&gt;userCmd == UserCommand::L1_Y) {
+    return FSMStateName::STEPTEST;
+  }
@@ -60,3 +58,3 @@
-    else if(_lowState-&gt;userCmd == UserCommand::L2_Y){
-        return FSMStateName::MOVE_BASE;
-    }
+  else if (_lowState-&gt;userCmd == UserCommand::L2_Y) {
+    return FSMStateName::MOVE_BASE;
+  }
@@ -66,3 +64,3 @@
-    else if(_lowState-&gt;userCmd == UserCommand::L2_Y){
-        return FSMStateName::MOVE_BASE;
-    }
+  else if (_lowState-&gt;userCmd == UserCommand::L2_Y) {
+    return FSMStateName::MOVE_BASE;
+  }
@@ -70,4 +68,4 @@
-    else{
-        return FSMStateName::FIXEDSTAND;
-    }
-}
+  else {
+    return FSMStateName::FIXEDSTAND;
+  }
+}

Code style divergence in file 'src/FSM/State_FreeStand.cpp':

--- src/FSM/State_FreeStand.cpp
+++ src/FSM/State_FreeStand.cpp.uncrustify
@@ -6,10 +6,11 @@
-State_FreeStand::State_FreeStand(CtrlComponents *ctrlComp)
-             :FSMState(ctrlComp, FSMStateName::FREESTAND, "free stand"){
-    _rowMax = 20 * M_PI / 180;
-    _rowMin = -_rowMax;
-    _pitchMax = 15 * M_PI / 180;
-    _pitchMin = -_pitchMax;
-    _yawMax = 20 * M_PI / 180;
-    _yawMin = -_yawMax;
-    _heightMax = 0.04;
-    _heightMin = -_heightMax;
+State_FreeStand::State_FreeStand(CtrlComponents * ctrlComp)
+: FSMState(ctrlComp, FSMStateName::FREESTAND, "free stand")
+{
+  _rowMax = 20 * M_PI / 180;
+  _rowMin = -_rowMax;
+  _pitchMax = 15 * M_PI / 180;
+  _pitchMin = -_pitchMax;
+  _yawMax = 20 * M_PI / 180;
+  _yawMin = -_yawMax;
+  _heightMax = 0.04;
+  _heightMin = -_heightMax;
@@ -18,10 +19,7 @@
-void State_FreeStand::enter(){
-    for(int i=0; i&lt;4; i++){
-        if(_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::GAZEBO){
-            _lowCmd-&gt;setSimStanceGain(i);
-        }
-        else if(_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::REALROBOT){
-            _lowCmd-&gt;setRealStanceGain(i);
-        }
-        _lowCmd-&gt;setZeroDq(i);
-        _lowCmd-&gt;setZeroTau(i);
+void State_FreeStand::enter()
+{
+  for (int i = 0; i &lt; 4; i++) {
+    if (_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::GAZEBO) {
+      _lowCmd-&gt;setSimStanceGain(i);
+    } else if (_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::REALROBOT) {
+      _lowCmd-&gt;setRealStanceGain(i);
@@ -28,0 +27,3 @@
+    _lowCmd-&gt;setZeroDq(i);
+    _lowCmd-&gt;setZeroTau(i);
+  }
@@ -30,5 +31,5 @@
-    for(int i=0; i&lt;12; i++){
-        _lowCmd-&gt;motorCmd[i].q = _lowState-&gt;motorState[i].q;
-    }
-    _initVecOX = _ctrlComp-&gt;robotModel-&gt;getX(*_lowState);
-    _initVecXP = _ctrlComp-&gt;robotModel-&gt;getVecXP(*_lowState);
+  for (int i = 0; i &lt; 12; i++) {
+    _lowCmd-&gt;motorCmd[i].q = _lowState-&gt;motorState[i].q;
+  }
+  _initVecOX = _ctrlComp-&gt;robotModel-&gt;getX(*_lowState);
+  _initVecXP = _ctrlComp-&gt;robotModel-&gt;getVecXP(*_lowState);
@@ -36,2 +37,2 @@
-    _ctrlComp-&gt;setAllStance();
-    _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
+  _ctrlComp-&gt;setAllStance();
+  _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
@@ -40,3 +41,4 @@
-void State_FreeStand::run(){
-    Vec34 vecOP;
-    _userValue = _lowState-&gt;userValue;
+void State_FreeStand::run()
+{
+  Vec34 vecOP;
+  _userValue = _lowState-&gt;userValue;
@@ -44,5 +46,6 @@
-    vecOP = _calcOP( invNormalize(_userValue.lx, _rowMin, _rowMax),
-                     invNormalize(_userValue.ly, _pitchMin, _pitchMax),
-                    -invNormalize(_userValue.rx, _yawMin, _yawMax),
-                     invNormalize(_userValue.ry, _heightMin, _heightMax) );
-    _calcCmd(vecOP);
+  vecOP = _calcOP(
+    invNormalize(_userValue.lx, _rowMin, _rowMax),
+    invNormalize(_userValue.ly, _pitchMin, _pitchMax),
+    -invNormalize(_userValue.rx, _yawMin, _yawMax),
+    invNormalize(_userValue.ry, _heightMin, _heightMax) );
+  _calcCmd(vecOP);
@@ -51,2 +54,3 @@
-void State_FreeStand::exit(){
-    _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
+void State_FreeStand::exit()
+{
+  _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
@@ -55,13 +59,11 @@
-FSMStateName State_FreeStand::checkChange(){
-    if(_lowState-&gt;userCmd == UserCommand::L2_A){
-        return FSMStateName::FIXEDSTAND;
-    }
-    else if(_lowState-&gt;userCmd == UserCommand::L2_B){
-        return FSMStateName::PASSIVE;
-    }
-    else if(_lowState-&gt;userCmd == UserCommand::START){
-        return FSMStateName::TROTTING;
-    }
-    else{
-        return FSMStateName::FREESTAND;
-    }
+FSMStateName State_FreeStand::checkChange()
+{
+  if (_lowState-&gt;userCmd == UserCommand::L2_A) {
+    return FSMStateName::FIXEDSTAND;
+  } else if (_lowState-&gt;userCmd == UserCommand::L2_B) {
+    return FSMStateName::PASSIVE;
+  } else if (_lowState-&gt;userCmd == UserCommand::START) {
+    return FSMStateName::TROTTING;
+  } else {
+    return FSMStateName::FREESTAND;
+  }
@@ -70,3 +72,4 @@
-Vec34 State_FreeStand::_calcOP(float row, float pitch, float yaw, float height){
-    Vec3 vecXO = -_initVecOX;
-    vecXO(2) += height;
+Vec34 State_FreeStand::_calcOP(float row, float pitch, float yaw, float height)
+{
+  Vec3 vecXO = -_initVecOX;
+  vecXO(2) += height;
@@ -74 +77 @@
-    RotMat rotM = rpyToRotMat(row, pitch, yaw);
+  RotMat rotM = rpyToRotMat(row, pitch, yaw);
@@ -76,2 +79,2 @@
-    HomoMat Tsb = homoMatrix(vecXO, rotM);
-    HomoMat Tbs = homoMatrixInverse(Tsb);
+  HomoMat Tsb = homoMatrix(vecXO, rotM);
+  HomoMat Tbs = homoMatrixInverse(Tsb);
@@ -79,6 +82,6 @@
-    Vec4 tempVec4;
-    Vec34 vecOP;
-    for(int i(0); i&lt;4; ++i){
-        tempVec4 = Tbs * homoVec(_initVecXP.col(i));
-        vecOP.col(i) = noHomoVec(tempVec4);
-    }
+  Vec4 tempVec4;
+  Vec34 vecOP;
+  for (int i(0); i &lt; 4; ++i) {
+    tempVec4 = Tbs * homoVec(_initVecXP.col(i));
+    vecOP.col(i) = noHomoVec(tempVec4);
+  }
@@ -86 +89 @@
-    return vecOP;
+  return vecOP;
@@ -89,4 +92,5 @@
-void State_FreeStand::_calcCmd(Vec34 vecOP){
-    Vec12 q = _ctrlComp-&gt;robotModel-&gt;getQ(vecOP, FrameType::BODY);
-    _lowCmd-&gt;setQ(q);
-}
+void State_FreeStand::_calcCmd(Vec34 vecOP)
+{
+  Vec12 q = _ctrlComp-&gt;robotModel-&gt;getQ(vecOP, FrameType::BODY);
+  _lowCmd-&gt;setQ(q);
+}

Code style divergence in file 'src/FSM/State_Passive.cpp':

--- src/FSM/State_Passive.cpp
+++ src/FSM/State_Passive.cpp.uncrustify
@@ -6,2 +6,2 @@
-State_Passive::State_Passive(CtrlComponents *ctrlComp)
-             :FSMState(ctrlComp, FSMStateName::PASSIVE, "passive"){}
+State_Passive::State_Passive(CtrlComponents * ctrlComp)
+: FSMState(ctrlComp, FSMStateName::PASSIVE, "passive") {}
@@ -9,10 +9,10 @@
-void State_Passive::enter(){
-    if(_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::GAZEBO){
-        for(int i=0; i&lt;12; i++){
-            _lowCmd-&gt;motorCmd[i].mode = 10;
-            _lowCmd-&gt;motorCmd[i].q = 0;
-            _lowCmd-&gt;motorCmd[i].dq = 0;
-            _lowCmd-&gt;motorCmd[i].Kp = 0;
-            _lowCmd-&gt;motorCmd[i].Kd = 8;
-            _lowCmd-&gt;motorCmd[i].tau = 0;
-        }
+void State_Passive::enter()
+{
+  if (_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::GAZEBO) {
+    for (int i = 0; i &lt; 12; i++) {
+      _lowCmd-&gt;motorCmd[i].mode = 10;
+      _lowCmd-&gt;motorCmd[i].q = 0;
+      _lowCmd-&gt;motorCmd[i].dq = 0;
+      _lowCmd-&gt;motorCmd[i].Kp = 0;
+      _lowCmd-&gt;motorCmd[i].Kd = 8;
+      _lowCmd-&gt;motorCmd[i].tau = 0;
@@ -20,9 +20,8 @@
-    else if(_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::REALROBOT){
-        for(int i=0; i&lt;12; i++){
-            _lowCmd-&gt;motorCmd[i].mode = 10;
-            _lowCmd-&gt;motorCmd[i].q = 0;
-            _lowCmd-&gt;motorCmd[i].dq = 0;
-            _lowCmd-&gt;motorCmd[i].Kp = 0;
-            _lowCmd-&gt;motorCmd[i].Kd = 3;
-            _lowCmd-&gt;motorCmd[i].tau = 0;
-        }
+  } else if (_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::REALROBOT) {
+    for (int i = 0; i &lt; 12; i++) {
+      _lowCmd-&gt;motorCmd[i].mode = 10;
+      _lowCmd-&gt;motorCmd[i].q = 0;
+      _lowCmd-&gt;motorCmd[i].dq = 0;
+      _lowCmd-&gt;motorCmd[i].Kp = 0;
+      _lowCmd-&gt;motorCmd[i].Kd = 3;
+      _lowCmd-&gt;motorCmd[i].tau = 0;
@@ -29,0 +29 @@
+  }
@@ -31 +31 @@
-    _ctrlComp-&gt;setAllSwing();
+  _ctrlComp-&gt;setAllSwing();
@@ -34,5 +34,2 @@
-void State_Passive::run(){
-    
-}
-
-void State_Passive::exit(){
+void State_Passive::run()
+{
@@ -42,8 +39,13 @@
-FSMStateName State_Passive::checkChange(){
-    if(_lowState-&gt;userCmd == UserCommand::L2_A){
-        return FSMStateName::FIXEDSTAND;
-    }
-    else{
-        return FSMStateName::PASSIVE;
-    }
-}
+void State_Passive::exit()
+{
+
+}
+
+FSMStateName State_Passive::checkChange()
+{
+  if (_lowState-&gt;userCmd == UserCommand::L2_A) {
+    return FSMStateName::FIXEDSTAND;
+  } else {
+    return FSMStateName::PASSIVE;
+  }
+}

Code style divergence in file 'src/FSM/State_StepTest.cpp':

--- src/FSM/State_StepTest.cpp
+++ src/FSM/State_StepTest.cpp.uncrustify
@@ -6,5 +6,6 @@
-State_StepTest::State_StepTest(CtrlComponents *ctrlComp)
-                  :FSMState(ctrlComp, FSMStateName::STEPTEST, "stepTest"),
-                  _est(ctrlComp-&gt;estimator), _robModel(ctrlComp-&gt;robotModel), 
-                  _balCtrl(ctrlComp-&gt;balCtrl), _contact(ctrlComp-&gt;contact),
-                  _phase(ctrlComp-&gt;phase){
+State_StepTest::State_StepTest(CtrlComponents * ctrlComp)
+: FSMState(ctrlComp, FSMStateName::STEPTEST, "stepTest"),
+  _est(ctrlComp-&gt;estimator), _robModel(ctrlComp-&gt;robotModel),
+  _balCtrl(ctrlComp-&gt;balCtrl), _contact(ctrlComp-&gt;contact),
+  _phase(ctrlComp-&gt;phase)
+{
@@ -12 +13 @@
-    _gaitHeight = 0.05;
+  _gaitHeight = 0.05;
@@ -14,2 +15,2 @@
-    _KpSwing = Vec3(600, 600, 200).asDiagonal();
-    _KdSwing = Vec3(20, 20, 5).asDiagonal();
+  _KpSwing = Vec3(600, 600, 200).asDiagonal();
+  _KdSwing = Vec3(20, 20, 5).asDiagonal();
@@ -17,4 +18,4 @@
-    _Kpp = Vec3(50, 50, 300).asDiagonal();
-    _Kpw = Vec3(600, 600, 600).asDiagonal();
-    _Kdp = Vec3(5, 5, 20).asDiagonal();
-    _Kdw = Vec3(10, 10, 10).asDiagonal();
+  _Kpp = Vec3(50, 50, 300).asDiagonal();
+  _Kpw = Vec3(600, 600, 600).asDiagonal();
+  _Kdp = Vec3(5, 5, 20).asDiagonal();
+  _Kdw = Vec3(10, 10, 10).asDiagonal();
@@ -23,7 +24,8 @@
-void State_StepTest::enter(){
-    _pcd = _est-&gt;getPosition();
-    _Rd  = _lowState-&gt;getRotMat();
-    _posFeetGlobalInit = _est-&gt;getFeetPos();
-    _posFeetGlobalGoal = _posFeetGlobalInit;
-    _ctrlComp-&gt;setStartWave();
-    _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
+void State_StepTest::enter()
+{
+  _pcd = _est-&gt;getPosition();
+  _Rd = _lowState-&gt;getRotMat();
+  _posFeetGlobalInit = _est-&gt;getFeetPos();
+  _posFeetGlobalGoal = _posFeetGlobalInit;
+  _ctrlComp-&gt;setStartWave();
+  _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
@@ -32,3 +34,4 @@
-void State_StepTest::run(){
-    _posBody = _est-&gt;getPosition();
-    _velBody = _est-&gt;getVelocity();
+void State_StepTest::run()
+{
+  _posBody = _est-&gt;getPosition();
+  _velBody = _est-&gt;getVelocity();
@@ -36,2 +39,2 @@
-    _B2G_RotMat = _lowState-&gt;getRotMat();
-    _G2B_RotMat = _B2G_RotMat.transpose();
+  _B2G_RotMat = _lowState-&gt;getRotMat();
+  _G2B_RotMat = _B2G_RotMat.transpose();
@@ -40,5 +43,6 @@
-    for(int i(0); i&lt;4; ++i){
-        if((*_contact)(i) == 0){
-            _posFeetGlobalGoal(2, i) = _posFeetGlobalInit(2, i) + (1-cos((*_phase)(i)*2*M_PI))*_gaitHeight;
-            _velFeetGlobalGoal(2, i) = sin((*_phase)(i)*2*M_PI)*2*M_PI*_gaitHeight;
-        }
+  for (int i(0); i &lt; 4; ++i) {
+    if ((*_contact)(i) == 0) {
+      _posFeetGlobalGoal(
+        2,
+        i) = _posFeetGlobalInit(2, i) + (1 - cos((*_phase)(i) * 2 * M_PI)) * _gaitHeight;
+      _velFeetGlobalGoal(2, i) = sin((*_phase)(i) * 2 * M_PI) * 2 * M_PI * _gaitHeight;
@@ -45,0 +50 @@
+  }
@@ -47 +52 @@
-    calcTau();
+  calcTau();
@@ -49,2 +54,2 @@
-    _lowCmd-&gt;setZeroGain();
-    _lowCmd-&gt;setTau(_tau);
+  _lowCmd-&gt;setZeroGain();
+  _lowCmd-&gt;setTau(_tau);
@@ -53,3 +58,4 @@
-void State_StepTest::exit(){
-    _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
-    _ctrlComp-&gt;setAllSwing();
+void State_StepTest::exit()
+{
+  _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
+  _ctrlComp-&gt;setAllSwing();
@@ -58,10 +64,9 @@
-FSMStateName State_StepTest::checkChange(){
-    if(_lowState-&gt;userCmd == UserCommand::L2_B){
-        return FSMStateName::PASSIVE;
-    }
-    else if(_lowState-&gt;userCmd == UserCommand::L2_A){
-        return FSMStateName::FIXEDSTAND;
-    }
-    else{
-        return FSMStateName::STEPTEST;
-    }
+FSMStateName State_StepTest::checkChange()
+{
+  if (_lowState-&gt;userCmd == UserCommand::L2_B) {
+    return FSMStateName::PASSIVE;
+  } else if (_lowState-&gt;userCmd == UserCommand::L2_A) {
+    return FSMStateName::FIXEDSTAND;
+  } else {
+    return FSMStateName::STEPTEST;
+  }
@@ -70,3 +75,5 @@
-void State_StepTest::calcTau(){
-    _ddPcd = _Kpp*(_pcd - _posBody) + _Kdp * (Vec3(0, 0, 0) - _velBody);
-    _dWbd  = _Kpw*rotMatToExp(_Rd*_G2B_RotMat) + _Kdw * (Vec3(0, 0, 0) - _lowState-&gt;getGyroGlobal());
+void State_StepTest::calcTau()
+{
+  _ddPcd = _Kpp * (_pcd - _posBody) + _Kdp * (Vec3(0, 0, 0) - _velBody);
+  _dWbd = _Kpw * rotMatToExp(_Rd * _G2B_RotMat) + _Kdw *
+    (Vec3(0, 0, 0) - _lowState-&gt;getGyroGlobal());
@@ -74,9 +81,9 @@
-    _posFeet2BGlobal = _est-&gt;getPosFeet2BGlobal();
-    _forceFeetGlobal = - _balCtrl-&gt;calF(_ddPcd, _dWbd, _B2G_RotMat, _posFeet2BGlobal, *_contact);
-    
-    _posFeetGlobal = _est-&gt;getFeetPos();
-    _velFeetGlobal = _est-&gt;getFeetVel();
-    for(int i(0); i&lt;4; ++i){
-        if((*_contact)(i) == 0){
-            _forceFeetGlobal.col(i) = _KpSwing*(_posFeetGlobalGoal.col(i) - _posFeetGlobal.col(i)) + _KdSwing*(_velFeetGlobalGoal.col(i)-_velFeetGlobal.col(i));
-        }
+  _posFeet2BGlobal = _est-&gt;getPosFeet2BGlobal();
+  _forceFeetGlobal = -_balCtrl-&gt;calF(_ddPcd, _dWbd, _B2G_RotMat, _posFeet2BGlobal, *_contact);
+
+  _posFeetGlobal = _est-&gt;getFeetPos();
+  _velFeetGlobal = _est-&gt;getFeetVel();
+  for (int i(0); i &lt; 4; ++i) {
+    if ((*_contact)(i) == 0) {
+      _forceFeetGlobal.col(i) = _KpSwing * (_posFeetGlobalGoal.col(i) - _posFeetGlobal.col(i)) +
+        _KdSwing * (_velFeetGlobalGoal.col(i) - _velFeetGlobal.col(i));
@@ -84,2 +91 @@
-    
-    _forceFeetBody = _G2B_RotMat * _forceFeetGlobal;
+  }
@@ -87,3 +93,5 @@
-    _q = vec34ToVec12(_lowState-&gt;getQ());
-    _tau = _robModel-&gt;getTau(_q, _forceFeetBody);
-}
+  _forceFeetBody = _G2B_RotMat * _forceFeetGlobal;
+
+  _q = vec34ToVec12(_lowState-&gt;getQ());
+  _tau = _robModel-&gt;getTau(_q, _forceFeetBody);
+}

Code style divergence in file 'src/FSM/State_SwingTest.cpp':

--- src/FSM/State_SwingTest.cpp
+++ src/FSM/State_SwingTest.cpp.uncrustify
@@ -6,8 +6,9 @@
-State_SwingTest::State_SwingTest(CtrlComponents *ctrlComp)
-                :FSMState(ctrlComp, FSMStateName::SWINGTEST, "swingTest"){
-    _xMin = -0.15;
-    _xMax =  0.10;
-    _yMin = -0.15;
-    _yMax =  0.15;
-    _zMin = -0.05;
-    _zMax =  0.20;
+State_SwingTest::State_SwingTest(CtrlComponents * ctrlComp)
+: FSMState(ctrlComp, FSMStateName::SWINGTEST, "swingTest")
+{
+  _xMin = -0.15;
+  _xMax = 0.10;
+  _yMin = -0.15;
+  _yMax = 0.15;
+  _zMin = -0.05;
+  _zMax = 0.20;
@@ -16,10 +17,7 @@
-void State_SwingTest::enter(){
-    for(int i=0; i&lt;4; i++){
-        if(_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::GAZEBO){
-            _lowCmd-&gt;setSimStanceGain(i);
-        }
-        else if(_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::REALROBOT){
-            _lowCmd-&gt;setRealStanceGain(i);
-        }
-        _lowCmd-&gt;setZeroDq(i);
-        _lowCmd-&gt;setZeroTau(i);
+void State_SwingTest::enter()
+{
+  for (int i = 0; i &lt; 4; i++) {
+    if (_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::GAZEBO) {
+      _lowCmd-&gt;setSimStanceGain(i);
+    } else if (_ctrlComp-&gt;ctrlPlatform == CtrlPlatform::REALROBOT) {
+      _lowCmd-&gt;setRealStanceGain(i);
@@ -27 +25,4 @@
-    _lowCmd-&gt;setSwingGain(0);
+    _lowCmd-&gt;setZeroDq(i);
+    _lowCmd-&gt;setZeroTau(i);
+  }
+  _lowCmd-&gt;setSwingGain(0);
@@ -29,2 +30,2 @@
-    _Kp = Vec3(20, 20, 50).asDiagonal();
-    _Kd = Vec3( 5,  5, 20).asDiagonal();
+  _Kp = Vec3(20, 20, 50).asDiagonal();
+  _Kd = Vec3(5, 5, 20).asDiagonal();
@@ -32,3 +33,3 @@
-    for(int i=0; i&lt;12; i++){
-        _lowCmd-&gt;motorCmd[i].q = _lowState-&gt;motorState[i].q;
-    }
+  for (int i = 0; i &lt; 12; i++) {
+    _lowCmd-&gt;motorCmd[i].q = _lowState-&gt;motorState[i].q;
+  }
@@ -36,3 +37,3 @@
-    _initFeetPos = _ctrlComp-&gt;robotModel-&gt;getFeet2BPositions(*_lowState, FrameType::HIP);
-    _feetPos = _initFeetPos;
-    _initPos = _initFeetPos.col(0);
+  _initFeetPos = _ctrlComp-&gt;robotModel-&gt;getFeet2BPositions(*_lowState, FrameType::HIP);
+  _feetPos = _initFeetPos;
+  _initPos = _initFeetPos.col(0);
@@ -40 +41 @@
-    _ctrlComp-&gt;setAllSwing();
+  _ctrlComp-&gt;setAllSwing();
@@ -43,2 +44,3 @@
-void State_SwingTest::run(){
-    _userValue = _lowState-&gt;userValue;
+void State_SwingTest::run()
+{
+  _userValue = _lowState-&gt;userValue;
@@ -46,11 +48,5 @@
-    if(_userValue.ly &gt; 0){
-        _posGoal(0) = invNormalize(_userValue.ly, _initPos(0), _initPos(0)+_xMax, 0, 1);
-    }else{
-        _posGoal(0) = invNormalize(_userValue.ly, _initPos(0)+_xMin, _initPos(0), -1, 0);
-    }
-    
-    if(_userValue.lx &gt; 0){
-        _posGoal(1) = invNormalize(_userValue.lx, _initPos(1, 0), _initPos(1)+_yMax, 0, 1);
-    }else{
-        _posGoal(1) = invNormalize(_userValue.lx, _initPos(1)+_yMin, _initPos(1), -1, 0);
-    }
+  if (_userValue.ly &gt; 0) {
+    _posGoal(0) = invNormalize(_userValue.ly, _initPos(0), _initPos(0) + _xMax, 0, 1);
+  } else {
+    _posGoal(0) = invNormalize(_userValue.ly, _initPos(0) + _xMin, _initPos(0), -1, 0);
+  }
@@ -58,5 +54,5 @@
-    if(_userValue.ry &gt; 0){
-        _posGoal(2) = invNormalize(_userValue.ry, _initPos(2), _initPos(2)+_zMax, 0, 1);
-    }else{
-        _posGoal(2) = invNormalize(_userValue.ry, _initPos(2)+_zMin, _initPos(2), -1, 0);
-    }
+  if (_userValue.lx &gt; 0) {
+    _posGoal(1) = invNormalize(_userValue.lx, _initPos(1, 0), _initPos(1) + _yMax, 0, 1);
+  } else {
+    _posGoal(1) = invNormalize(_userValue.lx, _initPos(1) + _yMin, _initPos(1), -1, 0);
+  }
@@ -64,2 +60,8 @@
-    _positionCtrl();
-    _torqueCtrl();
+  if (_userValue.ry &gt; 0) {
+    _posGoal(2) = invNormalize(_userValue.ry, _initPos(2), _initPos(2) + _zMax, 0, 1);
+  } else {
+    _posGoal(2) = invNormalize(_userValue.ry, _initPos(2) + _zMin, _initPos(2), -1, 0);
+  }
+
+  _positionCtrl();
+  _torqueCtrl();
@@ -68,2 +70,3 @@
-void State_SwingTest::exit(){
-    _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
+void State_SwingTest::exit()
+{
+  _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
@@ -72,10 +75,9 @@
-FSMStateName State_SwingTest::checkChange(){
-    if(_lowState-&gt;userCmd == UserCommand::L2_B){
-        return FSMStateName::PASSIVE;
-    }
-    else if(_lowState-&gt;userCmd == UserCommand::L2_A){
-        return FSMStateName::FIXEDSTAND;
-    }
-    else{
-        return FSMStateName::SWINGTEST;
-    }
+FSMStateName State_SwingTest::checkChange()
+{
+  if (_lowState-&gt;userCmd == UserCommand::L2_B) {
+    return FSMStateName::PASSIVE;
+  } else if (_lowState-&gt;userCmd == UserCommand::L2_A) {
+    return FSMStateName::FIXEDSTAND;
+  } else {
+    return FSMStateName::SWINGTEST;
+  }
@@ -84,4 +86,5 @@
-void State_SwingTest::_positionCtrl(){
-    _feetPos.col(0) = _posGoal;
-    _targetPos = _ctrlComp-&gt;robotModel-&gt;getQ(_feetPos, FrameType::HIP);
-    _lowCmd-&gt;setQ(_targetPos);
+void State_SwingTest::_positionCtrl()
+{
+  _feetPos.col(0) = _posGoal;
+  _targetPos = _ctrlComp-&gt;robotModel-&gt;getQ(_feetPos, FrameType::HIP);
+  _lowCmd-&gt;setQ(_targetPos);
@@ -90,3 +93,4 @@
-void State_SwingTest::_torqueCtrl(){
-    Vec3 pos0 = _ctrlComp-&gt;robotModel-&gt;getFootPosition(*_lowState, 0, FrameType::HIP);
-    Vec3 vel0 = _ctrlComp-&gt;robotModel-&gt;getFootVelocity(*_lowState, 0);
+void State_SwingTest::_torqueCtrl()
+{
+  Vec3 pos0 = _ctrlComp-&gt;robotModel-&gt;getFootPosition(*_lowState, 0, FrameType::HIP);
+  Vec3 vel0 = _ctrlComp-&gt;robotModel-&gt;getFootVelocity(*_lowState, 0);
@@ -94 +98 @@
-    Vec3 force0 = _Kp*(_posGoal - pos0) + _Kd*(-vel0);
+  Vec3 force0 = _Kp * (_posGoal - pos0) + _Kd * (-vel0);
@@ -96,2 +100,2 @@
-    Vec12 torque;
-    Mat3 jaco0 = _ctrlComp-&gt;robotModel-&gt;getJaco(*_lowState, 0);
+  Vec12 torque;
+  Mat3 jaco0 = _ctrlComp-&gt;robotModel-&gt;getJaco(*_lowState, 0);
@@ -99 +103 @@
-    torque.segment(0, 3) = jaco0.transpose() * force0;
+  torque.segment(0, 3) = jaco0.transpose() * force0;
@@ -101,2 +105,2 @@
-    _lowCmd-&gt;setTau(torque);
-}
+  _lowCmd-&gt;setTau(torque);
+}

Code style divergence in file 'src/FSM/State_Trotting.cpp':

--- src/FSM/State_Trotting.cpp
+++ src/FSM/State_Trotting.cpp.uncrustify
@@ -7,8 +7,9 @@
-State_Trotting::State_Trotting(CtrlComponents *ctrlComp)
-             :FSMState(ctrlComp, FSMStateName::TROTTING, "trotting"), 
-              _est(ctrlComp-&gt;estimator), _phase(ctrlComp-&gt;phase), 
-              _contact(ctrlComp-&gt;contact), _robModel(ctrlComp-&gt;robotModel), 
-              _balCtrl(ctrlComp-&gt;balCtrl){
-    _gait = new GaitGenerator(ctrlComp);
-
-    _gaitHeight = 0.08;
+State_Trotting::State_Trotting(CtrlComponents * ctrlComp)
+: FSMState(ctrlComp, FSMStateName::TROTTING, "trotting"),
+  _est(ctrlComp-&gt;estimator), _phase(ctrlComp-&gt;phase),
+  _contact(ctrlComp-&gt;contact), _robModel(ctrlComp-&gt;robotModel),
+  _balCtrl(ctrlComp-&gt;balCtrl)
+{
+  _gait = new GaitGenerator(ctrlComp);
+
+  _gaitHeight = 0.08;
@@ -17,6 +18,6 @@
-    _Kpp = Vec3(70, 70, 70).asDiagonal();
-    _Kdp = Vec3(10, 10, 10).asDiagonal();
-    _kpw = 780; 
-    _Kdw = Vec3(70, 70, 70).asDiagonal();
-    _KpSwing = Vec3(400, 400, 400).asDiagonal();
-    _KdSwing = Vec3(10, 10, 10).asDiagonal();
+  _Kpp = Vec3(70, 70, 70).asDiagonal();
+  _Kdp = Vec3(10, 10, 10).asDiagonal();
+  _kpw = 780;
+  _Kdw = Vec3(70, 70, 70).asDiagonal();
+  _KpSwing = Vec3(400, 400, 400).asDiagonal();
+  _KdSwing = Vec3(10, 10, 10).asDiagonal();
@@ -26,6 +27,6 @@
-    _Kpp = Vec3(20, 20, 100).asDiagonal();
-    _Kdp = Vec3(20, 20, 20).asDiagonal();
-    _kpw = 400;
-    _Kdw = Vec3(50, 50, 50).asDiagonal();
-    _KpSwing = Vec3(400, 400, 400).asDiagonal();
-    _KdSwing = Vec3(10, 10, 10).asDiagonal();
+  _Kpp = Vec3(20, 20, 100).asDiagonal();
+  _Kdp = Vec3(20, 20, 20).asDiagonal();
+  _kpw = 400;
+  _Kdw = Vec3(50, 50, 50).asDiagonal();
+  _KpSwing = Vec3(400, 400, 400).asDiagonal();
+  _KdSwing = Vec3(10, 10, 10).asDiagonal();
@@ -34,30 +35,79 @@
-    _vxLim = _robModel-&gt;getRobVelLimitX();
-    _vyLim = _robModel-&gt;getRobVelLimitY();
-    _wyawLim = _robModel-&gt;getRobVelLimitYaw();
-
-}
-
-State_Trotting::~State_Trotting(){
-    delete _gait;
-}
-
-void State_Trotting::enter(){
-    _pcd = _est-&gt;getPosition();
-    _pcd(2) = -_robModel-&gt;getFeetPosIdeal()(2, 0);
-    _vCmdBody.setZero();
-    _yawCmd = _lowState-&gt;getYaw();
-    _Rd = rotz(_yawCmd);
-    _wCmdGlobal.setZero();
-
-    _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
-    _gait-&gt;restart();
-}
-
-void State_Trotting::exit(){
-    _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
-    _ctrlComp-&gt;setAllSwing();
-}
-
-FSMStateName State_Trotting::checkChange(){
-    if(_lowState-&gt;userCmd == UserCommand::L2_B){
-        return FSMStateName::PASSIVE;
+  _vxLim = _robModel-&gt;getRobVelLimitX();
+  _vyLim = _robModel-&gt;getRobVelLimitY();
+  _wyawLim = _robModel-&gt;getRobVelLimitYaw();
+
+}
+
+State_Trotting::~State_Trotting()
+{
+  delete _gait;
+}
+
+void State_Trotting::enter()
+{
+  _pcd = _est-&gt;getPosition();
+  _pcd(2) = -_robModel-&gt;getFeetPosIdeal()(2, 0);
+  _vCmdBody.setZero();
+  _yawCmd = _lowState-&gt;getYaw();
+  _Rd = rotz(_yawCmd);
+  _wCmdGlobal.setZero();
+
+  _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
+  _gait-&gt;restart();
+}
+
+void State_Trotting::exit()
+{
+  _ctrlComp-&gt;ioInter-&gt;zeroCmdPanel();
+  _ctrlComp-&gt;setAllSwing();
+}
+
+FSMStateName State_Trotting::checkChange()
+{
+  if (_lowState-&gt;userCmd == UserCommand::L2_B) {
+    return FSMStateName::PASSIVE;
+  } else if (_lowState-&gt;userCmd == UserCommand::L2_A) {
+    return FSMStateName::FIXEDSTAND;
+  } else {
+    return FSMStateName::TROTTING;
+  }
+}
+
+void State_Trotting::run()
+{
+  _posBody = _est-&gt;getPosition();
+  _velBody = _est-&gt;getVelocity();
+  _posFeet2BGlobal = _est-&gt;getPosFeet2BGlobal();
+  _posFeetGlobal = _est-&gt;getFeetPos();
+  _velFeetGlobal = _est-&gt;getFeetVel();
+  _B2G_RotMat = _lowState-&gt;getRotMat();
+  _G2B_RotMat = _B2G_RotMat.transpose();
+  _yaw = _lowState-&gt;getYaw();
+  _dYaw = _lowState-&gt;getDYaw();
+
+  _userValue = _lowState-&gt;userValue;
+
+  getUserCmd();
+  calcCmd();
+
+  _gait-&gt;setGait(_vCmdGlobal.segment(0, 2), _wCmdGlobal(2), _gaitHeight);
+  _gait-&gt;run(_posFeetGlobalGoal, _velFeetGlobalGoal);
+
+  calcTau();
+  calcQQd();
+
+  if (checkStepOrNot()) {
+    _ctrlComp-&gt;setStartWave();
+  } else {
+    _ctrlComp-&gt;setAllStance();
+  }
+
+  _lowCmd-&gt;setTau(_tau);
+  _lowCmd-&gt;setQ(vec34ToVec12(_qGoal));
+  _lowCmd-&gt;setQd(vec34ToVec12(_qdGoal));
+
+  for (int i(0); i &lt; 4; ++i) {
+    if ((*_contact)(i) == 0) {
+      _lowCmd-&gt;setSwingGain(i);
+    } else {
+      _lowCmd-&gt;setStableGain(i);
@@ -65,2 +115,91 @@
-    else if(_lowState-&gt;userCmd == UserCommand::L2_A){
-        return FSMStateName::FIXEDSTAND;
+  }
+
+}
+
+bool State_Trotting::checkStepOrNot()
+{
+  if ( (fabs(_vCmdBody(0)) &gt; 0.03) ||
+    (fabs(_vCmdBody(1)) &gt; 0.03) ||
+    (fabs(_posError(0)) &gt; 0.08) ||
+    (fabs(_posError(1)) &gt; 0.08) ||
+    (fabs(_velError(0)) &gt; 0.05) ||
+    (fabs(_velError(1)) &gt; 0.05) ||
+    (fabs(_dYawCmd) &gt; 0.20) )
+  {
+    return true;
+  } else {
+    return false;
+  }
+}
+
+void State_Trotting::setHighCmd(double vx, double vy, double wz)
+{
+  _vCmdBody(0) = vx;
+  _vCmdBody(1) = vy;
+  _vCmdBody(2) = 0;
+  _dYawCmd = wz;
+}
+
+void State_Trotting::getUserCmd()
+{
+  /* Movement */
+  _vCmdBody(0) = invNormalize(_userValue.ly, _vxLim(0), _vxLim(1));
+  _vCmdBody(1) = -invNormalize(_userValue.lx, _vyLim(0), _vyLim(1));
+  _vCmdBody(2) = 0;
+
+  /* Turning */
+  _dYawCmd = -invNormalize(_userValue.rx, _wyawLim(0), _wyawLim(1));
+  _dYawCmd = 0.9 * _dYawCmdPast + (1 - 0.9) * _dYawCmd;
+  _dYawCmdPast = _dYawCmd;
+}
+
+void State_Trotting::calcCmd()
+{
+  /* Movement */
+  _vCmdGlobal = _B2G_RotMat * _vCmdBody;
+
+  _vCmdGlobal(0) = saturation(_vCmdGlobal(0), Vec2(_velBody(0) - 0.2, _velBody(0) + 0.2));
+  _vCmdGlobal(1) = saturation(_vCmdGlobal(1), Vec2(_velBody(1) - 0.2, _velBody(1) + 0.2));
+
+  _pcd(0) =
+    saturation(
+    _pcd(0) + _vCmdGlobal(0) * _ctrlComp-&gt;dt, Vec2(
+      _posBody(0) - 0.05, _posBody(
+        0) + 0.05));
+  _pcd(1) =
+    saturation(
+    _pcd(1) + _vCmdGlobal(1) * _ctrlComp-&gt;dt, Vec2(
+      _posBody(1) - 0.05, _posBody(
+        1) + 0.05));
+
+  _vCmdGlobal(2) = 0;
+
+  /* Turning */
+  _yawCmd = _yawCmd + _dYawCmd * _ctrlComp-&gt;dt;
+
+  _Rd = rotz(_yawCmd);
+  _wCmdGlobal(2) = _dYawCmd;
+}
+
+void State_Trotting::calcTau()
+{
+  _posError = _pcd - _posBody;
+  _velError = _vCmdGlobal - _velBody;
+
+  _ddPcd = _Kpp * _posError + _Kdp * _velError;
+  _dWbd = _kpw * rotMatToExp(_Rd * _G2B_RotMat) + _Kdw * (_wCmdGlobal - _lowState-&gt;getGyroGlobal());
+
+  _ddPcd(0) = saturation(_ddPcd(0), Vec2(-3, 3));
+  _ddPcd(1) = saturation(_ddPcd(1), Vec2(-3, 3));
+  _ddPcd(2) = saturation(_ddPcd(2), Vec2(-5, 5));
+
+  _dWbd(0) = saturation(_dWbd(0), Vec2(-40, 40));
+  _dWbd(1) = saturation(_dWbd(1), Vec2(-40, 40));
+  _dWbd(2) = saturation(_dWbd(2), Vec2(-10, 10));
+
+  _forceFeetGlobal = -_balCtrl-&gt;calF(_ddPcd, _dWbd, _B2G_RotMat, _posFeet2BGlobal, *_contact);
+
+  for (int i(0); i &lt; 4; ++i) {
+    if ((*_contact)(i) == 0) {
+      _forceFeetGlobal.col(i) = _KpSwing * (_posFeetGlobalGoal.col(i) - _posFeetGlobal.col(i)) +
+        _KdSwing * (_velFeetGlobalGoal.col(i) - _velFeetGlobal.col(i));
@@ -68,142 +207,22 @@
-    else{
-        return FSMStateName::TROTTING;
-    }
-}
-
-void State_Trotting::run(){
-    _posBody = _est-&gt;getPosition();
-    _velBody = _est-&gt;getVelocity();
-    _posFeet2BGlobal = _est-&gt;getPosFeet2BGlobal();
-    _posFeetGlobal = _est-&gt;getFeetPos();
-    _velFeetGlobal = _est-&gt;getFeetVel();
-    _B2G_RotMat = _lowState-&gt;getRotMat();
-    _G2B_RotMat = _B2G_RotMat.transpose();
-    _yaw = _lowState-&gt;getYaw();
-    _dYaw = _lowState-&gt;getDYaw();
-
-    _userValue = _lowState-&gt;userValue;
-
-    getUserCmd();
-    calcCmd();
-
-    _gait-&gt;setGait(_vCmdGlobal.segment(0,2), _wCmdGlobal(2), _gaitHeight);
-    _gait-&gt;run(_posFeetGlobalGoal, _velFeetGlobalGoal);
-
-    calcTau();
-    calcQQd();
-
-    if(checkStepOrNot()){
-        _ctrlComp-&gt;setStartWave();
-    }else{
-        _ctrlComp-&gt;setAllStance();
-    }
-
-    _lowCmd-&gt;setTau(_tau);
-    _lowCmd-&gt;setQ(vec34ToVec12(_qGoal));
-    _lowCmd-&gt;setQd(vec34ToVec12(_qdGoal));
-
-    for(int i(0); i&lt;4; ++i){
-        if((*_contact)(i) == 0){
-            _lowCmd-&gt;setSwingGain(i);
-        }else{
-            _lowCmd-&gt;setStableGain(i);
-        }
-    }
-
-}
-
-bool State_Trotting::checkStepOrNot(){
-    if( (fabs(_vCmdBody(0)) &gt; 0.03) ||
-        (fabs(_vCmdBody(1)) &gt; 0.03) ||
-        (fabs(_posError(0)) &gt; 0.08) ||
-        (fabs(_posError(1)) &gt; 0.08) ||
-        (fabs(_velError(0)) &gt; 0.05) ||
-        (fabs(_velError(1)) &gt; 0.05) ||
-        (fabs(_dYawCmd) &gt; 0.20) ){
-        return true;
-    }else{
-        return false;
-    }
-}
-
-void State_Trotting::setHighCmd(double vx, double vy, double wz){
-    _vCmdBody(0) = vx;
-    _vCmdBody(1) = vy;
-    _vCmdBody(2) = 0; 
-    _dYawCmd = wz;
-}
-
-void State_Trotting::getUserCmd(){
-    /* Movement */
-    _vCmdBody(0) =  invNormalize(_userValue.ly, _vxLim(0), _vxLim(1));
-    _vCmdBody(1) = -invNormalize(_userValue.lx, _vyLim(0), _vyLim(1));
-    _vCmdBody(2) = 0;
-
-    /* Turning */
-    _dYawCmd = -invNormalize(_userValue.rx, _wyawLim(0), _wyawLim(1));
-    _dYawCmd = 0.9*_dYawCmdPast + (1-0.9) * _dYawCmd;
-    _dYawCmdPast = _dYawCmd;
-}
-
-void State_Trotting::calcCmd(){
-    /* Movement */
-    _vCmdGlobal = _B2G_RotMat * _vCmdBody;
-
-    _vCmdGlobal(0) = saturation(_vCmdGlobal(0), Vec2(_velBody(0)-0.2, _velBody(0)+0.2));
-    _vCmdGlobal(1) = saturation(_vCmdGlobal(1), Vec2(_velBody(1)-0.2, _velBody(1)+0.2));
-
-    _pcd(0) = saturation(_pcd(0) + _vCmdGlobal(0) * _ctrlComp-&gt;dt, Vec2(_posBody(0) - 0.05, _posBody(0) + 0.05));
-    _pcd(1) = saturation(_pcd(1) + _vCmdGlobal(1) * _ctrlComp-&gt;dt, Vec2(_posBody(1) - 0.05, _posBody(1) + 0.05));
-
-    _vCmdGlobal(2) = 0;
-
-    /* Turning */
-    _yawCmd = _yawCmd + _dYawCmd * _ctrlComp-&gt;dt;
-
-    _Rd = rotz(_yawCmd);
-    _wCmdGlobal(2) = _dYawCmd;
-}
-
-void State_Trotting::calcTau(){
-    _posError = _pcd - _posBody;
-    _velError = _vCmdGlobal - _velBody;
-
-    _ddPcd = _Kpp * _posError + _Kdp * _velError;
-    _dWbd  = _kpw*rotMatToExp(_Rd*_G2B_RotMat) + _Kdw * (_wCmdGlobal - _lowState-&gt;getGyroGlobal());
-
-    _ddPcd(0) = saturation(_ddPcd(0), Vec2(-3, 3));
-    _ddPcd(1) = saturation(_ddPcd(1), Vec2(-3, 3));
-    _ddPcd(2) = saturation(_ddPcd(2), Vec2(-5, 5));
-
-    _dWbd(0) = saturation(_dWbd(0), Vec2(-40, 40));
-    _dWbd(1) = saturation(_dWbd(1), Vec2(-40, 40));
-    _dWbd(2) = saturation(_dWbd(2), Vec2(-10, 10));
-
-    _forceFeetGlobal = - _balCtrl-&gt;calF(_ddPcd, _dWbd, _B2G_RotMat, _posFeet2BGlobal, *_contact);
-
-    for(int i(0); i&lt;4; ++i){
-        if((*_contact)(i) == 0){
-            _forceFeetGlobal.col(i) = _KpSwing*(_posFeetGlobalGoal.col(i) - _posFeetGlobal.col(i)) + _KdSwing*(_velFeetGlobalGoal.col(i)-_velFeetGlobal.col(i));
-        }
-    }
-
-    _forceFeetBody = _G2B_RotMat * _forceFeetGlobal;
-    _q = vec34ToVec12(_lowState-&gt;getQ());
-    _tau = _robModel-&gt;getTau(_q, _forceFeetBody);
-}
-
-void State_Trotting::calcQQd(){
-
-    Vec34 _posFeet2B;
-    _posFeet2B = _robModel-&gt;getFeet2BPositions(*_lowState,FrameType::BODY);
-    
-    for(int i(0); i&lt;4; ++i){
-        _posFeet2BGoal.col(i) = _G2B_RotMat * (_posFeetGlobalGoal.col(i) - _posBody);
-        _velFeet2BGoal.col(i) = _G2B_RotMat * (_velFeetGlobalGoal.col(i) - _velBody); 
-        // _velFeet2BGoal.col(i) = _G2B_RotMat * (_velFeetGlobalGoal.col(i) - _velBody - _B2G_RotMat * (skew(_lowState-&gt;getGyro()) * _posFeet2B.col(i)) );  //  c.f formula (6.12) 
-    }
-    
-    _qGoal = vec12ToVec34(_robModel-&gt;getQ(_posFeet2BGoal, FrameType::BODY));
-    _qdGoal = vec12ToVec34(_robModel-&gt;getQd(_posFeet2B, _velFeet2BGoal, FrameType::BODY));
-}
-
+  }
+
+  _forceFeetBody = _G2B_RotMat * _forceFeetGlobal;
+  _q = vec34ToVec12(_lowState-&gt;getQ());
+  _tau = _robModel-&gt;getTau(_q, _forceFeetBody);
+}
+
+void State_Trotting::calcQQd()
+{
+
+  Vec34 _posFeet2B;
+  _posFeet2B = _robModel-&gt;getFeet2BPositions(*_lowState, FrameType::BODY);
+
+  for (int i(0); i &lt; 4; ++i) {
+    _posFeet2BGoal.col(i) = _G2B_RotMat * (_posFeetGlobalGoal.col(i) - _posBody);
+    _velFeet2BGoal.col(i) = _G2B_RotMat * (_velFeetGlobalGoal.col(i) - _velBody);
+    // _velFeet2BGoal.col(i) = _G2B_RotMat * (_velFeetGlobalGoal.col(i) - _velBody - _B2G_RotMat * (skew(_lowState-&gt;getGyro()) * _posFeet2B.col(i)) );  //  c.f formula (6.12)
+  }
+
+  _qGoal = vec12ToVec34(_robModel-&gt;getQ(_posFeet2BGoal, FrameType::BODY));
+  _qdGoal = vec12ToVec34(_robModel-&gt;getQd(_posFeet2B, _velFeet2BGoal, FrameType::BODY));
+}

Code style divergence in file 'src/FSM/State_move_base.cpp':

--- src/FSM/State_move_base.cpp
+++ src/FSM/State_move_base.cpp.uncrustify
@@ -8,6 +8,7 @@
-State_move_base::State_move_base(CtrlComponents *ctrlComp)
-    :State_Trotting(ctrlComp){
-    _stateName = FSMStateName::MOVE_BASE;
-    _stateNameString = "move_base";
-    initRecv();
-    
+State_move_base::State_move_base(CtrlComponents * ctrlComp)
+: State_Trotting(ctrlComp)
+{
+  _stateName = FSMStateName::MOVE_BASE;
+  _stateNameString = "move_base";
+  initRecv();
+
@@ -16,10 +17,9 @@
-FSMStateName State_move_base::checkChange(){
-    if(_lowState-&gt;userCmd == UserCommand::L2_B){
-        return FSMStateName::PASSIVE;
-    }
-    else if(_lowState-&gt;userCmd == UserCommand::L2_A){
-        return FSMStateName::FIXEDSTAND;
-    }
-    else{
-        return FSMStateName::MOVE_BASE;
-    }
+FSMStateName State_move_base::checkChange()
+{
+  if (_lowState-&gt;userCmd == UserCommand::L2_B) {
+    return FSMStateName::PASSIVE;
+  } else if (_lowState-&gt;userCmd == UserCommand::L2_A) {
+    return FSMStateName::FIXEDSTAND;
+  } else {
+    return FSMStateName::MOVE_BASE;
+  }
@@ -28,3 +28,4 @@
-void State_move_base::getUserCmd(){
-    setHighCmd(_vx, _vy, _wz);
-    ros::spinOnce();
+void State_move_base::getUserCmd()
+{
+  setHighCmd(_vx, _vy, _wz);
+  ros::spinOnce();
@@ -33,4 +34,5 @@
-void State_move_base::twistCallback(const geometry_msgs::Twist&amp; msg){
-    _vx = msg.linear.x;
-    _vy = msg.linear.y;
-    _wz = msg.angular.z;
+void State_move_base::twistCallback(const geometry_msgs::Twist &amp; msg)
+{
+  _vx = msg.linear.x;
+  _vy = msg.linear.y;
+  _wz = msg.angular.z;
@@ -39,2 +41,3 @@
-void State_move_base::initRecv(){
-    _cmdSub = _nm.subscribe("/cmd_vel", 1, &amp;State_move_base::twistCallback, this);
+void State_move_base::initRecv()
+{
+  _cmdSub = _nm.subscribe("/cmd_vel", 1, &amp;State_move_base::twistCallback, this);
@@ -49,11 +52,13 @@
-State_move_base::State_move_base(CtrlComponents *ctrlComp)
-    :State_Trotting(ctrlComp){
-    _stateName = FSMStateName::MOVE_BASE;
-    _stateNameString = "move_base";
-    _nm = rclcpp::Node::make_shared("state_mb");
-    auto executor = std::make_shared&lt;rclcpp::executors::MultiThreadedExecutor&gt;(
-        rclcpp::ExecutorOptions(), 1
-    );
-    executor-&gt;add_node(_nm);
-    executor_thread = std::thread([executor] (){
-        executor-&gt;spin();
+State_move_base::State_move_base(CtrlComponents * ctrlComp)
+: State_Trotting(ctrlComp)
+{
+  _stateName = FSMStateName::MOVE_BASE;
+  _stateNameString = "move_base";
+  _nm = rclcpp::Node::make_shared("state_mb");
+  auto executor = std::make_shared&lt;rclcpp::executors::MultiThreadedExecutor&gt;(
+    rclcpp::ExecutorOptions(), 1
+  );
+  executor-&gt;add_node(_nm);
+  executor_thread = std::thread(
+    [executor]() {
+      executor-&gt;spin();
@@ -61,2 +66,2 @@
-    executor_thread.detach();
-    initRecv();
+  executor_thread.detach();
+  initRecv();
@@ -65,10 +70,9 @@
-FSMStateName State_move_base::checkChange(){
-    if(_lowState-&gt;userCmd == UserCommand::L2_B){
-        return FSMStateName::PASSIVE;
-    }
-    else if(_lowState-&gt;userCmd == UserCommand::L2_A){
-        return FSMStateName::FIXEDSTAND;
-    }
-    else{
-        return FSMStateName::MOVE_BASE;
-    }
+FSMStateName State_move_base::checkChange()
+{
+  if (_lowState-&gt;userCmd == UserCommand::L2_B) {
+    return FSMStateName::PASSIVE;
+  } else if (_lowState-&gt;userCmd == UserCommand::L2_A) {
+    return FSMStateName::FIXEDSTAND;
+  } else {
+    return FSMStateName::MOVE_BASE;
+  }
@@ -77,2 +81,3 @@
-void State_move_base::getUserCmd(){
-    setHighCmd(_vx, _vy, _wz);
+void State_move_base::getUserCmd()
+{
+  setHighCmd(_vx, _vy, _wz);
@@ -81,4 +86,5 @@
-void State_move_base::twistCallback(const geometry_msgs::msg::Twist::SharedPtr msg){
-    _vx = msg-&gt;linear.x;
-    _vy = msg-&gt;linear.y;
-    _wz = msg-&gt;angular.z;
+void State_move_base::twistCallback(const geometry_msgs::msg::Twist::SharedPtr msg)
+{
+  _vx = msg-&gt;linear.x;
+  _vy = msg-&gt;linear.y;
+  _wz = msg-&gt;angular.z;
@@ -87,3 +93,7 @@
-void State_move_base::initRecv(){
-    std::cout &lt;&lt; "Initialized cmd vel sub" &lt;&lt; std::endl;
-    _cmdSub = _nm-&gt;create_subscription&lt;geometry_msgs::msg::Twist&gt;("/cmd_vel", 1, std::bind(&amp;State_move_base::twistCallback, this, std::placeholders::_1));
+void State_move_base::initRecv()
+{
+  std::cout &lt;&lt; "Initialized cmd vel sub" &lt;&lt; std::endl;
+  _cmdSub =
+    _nm-&gt;create_subscription&lt;geometry_msgs::msg::Twist&gt;(
+    "/cmd_vel", 1,
+    std::bind(&amp;State_move_base::twistCallback, this, std::placeholders::_1));
@@ -92 +102 @@
-#endif  // COMPILE_WITH_ROS2_MB
+#endif  // COMPILE_WITH_ROS2_MB

Code style divergence in file 'src/Gait/FeetEndCal.cpp':

--- src/Gait/FeetEndCal.cpp
+++ src/Gait/FeetEndCal.cpp.uncrustify
@@ -6,5 +6,6 @@
-FeetEndCal::FeetEndCal(CtrlComponents *ctrlComp)
-           : _est(ctrlComp-&gt;estimator), _lowState(ctrlComp-&gt;lowState),
-             _robModel(ctrlComp-&gt;robotModel){
-    _Tstance  = ctrlComp-&gt;waveGen-&gt;getTstance();
-    _Tswing   = ctrlComp-&gt;waveGen-&gt;getTswing();
+FeetEndCal::FeetEndCal(CtrlComponents * ctrlComp)
+: _est(ctrlComp-&gt;estimator), _lowState(ctrlComp-&gt;lowState),
+  _robModel(ctrlComp-&gt;robotModel)
+{
+  _Tstance = ctrlComp-&gt;waveGen-&gt;getTstance();
+  _Tswing = ctrlComp-&gt;waveGen-&gt;getTswing();
@@ -12,3 +13,3 @@
-    _kx = 0.005;
-    _ky = 0.005;
-    _kyaw = 0.005;
+  _kx = 0.005;
+  _ky = 0.005;
+  _kyaw = 0.005;
@@ -16,5 +17,5 @@
-    Vec34 feetPosBody = _robModel-&gt;getFeetPosIdeal();
-    for(int i(0); i&lt;4; ++i){
-        _feetRadius(i)    = sqrt( pow(feetPosBody(0, i), 2) + pow(feetPosBody(1, i), 2) );
-        _feetInitAngle(i) = atan2(feetPosBody(1, i), feetPosBody(0, i));
-    }
+  Vec34 feetPosBody = _robModel-&gt;getFeetPosIdeal();
+  for (int i(0); i &lt; 4; ++i) {
+    _feetRadius(i) = sqrt(pow(feetPosBody(0, i), 2) + pow(feetPosBody(1, i), 2) );
+    _feetInitAngle(i) = atan2(feetPosBody(1, i), feetPosBody(0, i));
+  }
@@ -23 +24,2 @@
-FeetEndCal::~FeetEndCal(){
+FeetEndCal::~FeetEndCal()
+{
@@ -27,3 +29,4 @@
-Vec3 FeetEndCal::calFootPos(int legID, Vec2 vxyGoalGlobal, float dYawGoal, float phase){
-    _bodyVelGlobal = _est-&gt;getVelocity();
-    _bodyWGlobal = _lowState-&gt;getGyroGlobal();
+Vec3 FeetEndCal::calFootPos(int legID, Vec2 vxyGoalGlobal, float dYawGoal, float phase)
+{
+  _bodyVelGlobal = _est-&gt;getVelocity();
+  _bodyWGlobal = _lowState-&gt;getGyroGlobal();
@@ -31,3 +34,5 @@
-    _nextStep(0) = _bodyVelGlobal(0)*(1-phase)*_Tswing + _bodyVelGlobal(0)*_Tstance/2 + _kx*(_bodyVelGlobal(0) - vxyGoalGlobal(0));
-    _nextStep(1) = _bodyVelGlobal(1)*(1-phase)*_Tswing + _bodyVelGlobal(1)*_Tstance/2 + _ky*(_bodyVelGlobal(1) - vxyGoalGlobal(1));
-    _nextStep(2) = 0;
+  _nextStep(0) = _bodyVelGlobal(0) * (1 - phase) * _Tswing + _bodyVelGlobal(0) * _Tstance / 2 +
+    _kx * (_bodyVelGlobal(0) - vxyGoalGlobal(0));
+  _nextStep(1) = _bodyVelGlobal(1) * (1 - phase) * _Tswing + _bodyVelGlobal(1) * _Tstance / 2 +
+    _ky * (_bodyVelGlobal(1) - vxyGoalGlobal(1));
+  _nextStep(2) = 0;
@@ -35,3 +40,3 @@
-    _yaw = _lowState-&gt;getYaw();
-    _dYaw = _lowState-&gt;getDYaw();
-    _nextYaw = _dYaw*(1-phase)*_Tswing + _dYaw*_Tstance/2 + _kyaw*(dYawGoal - _dYaw);
+  _yaw = _lowState-&gt;getYaw();
+  _dYaw = _lowState-&gt;getDYaw();
+  _nextYaw = _dYaw * (1 - phase) * _Tswing + _dYaw * _Tstance / 2 + _kyaw * (dYawGoal - _dYaw);
@@ -39,2 +44,2 @@
-    _nextStep(0) += _feetRadius(legID) * cos(_yaw + _feetInitAngle(legID) + _nextYaw);
-    _nextStep(1) += _feetRadius(legID) * sin(_yaw + _feetInitAngle(legID) + _nextYaw);
+  _nextStep(0) += _feetRadius(legID) * cos(_yaw + _feetInitAngle(legID) + _nextYaw);
+  _nextStep(1) += _feetRadius(legID) * sin(_yaw + _feetInitAngle(legID) + _nextYaw);
@@ -42,2 +47,2 @@
-    _footPos = _est-&gt;getPosition() + _nextStep;
-    _footPos(2) = 0.0;
+  _footPos = _est-&gt;getPosition() + _nextStep;
+  _footPos(2) = 0.0;
@@ -45,2 +50,2 @@
-    return _footPos;
-}
+  return _footPos;
+}

Code style divergence in file 'src/Gait/GaitGenerator.cpp':

--- src/Gait/GaitGenerator.cpp
+++ src/Gait/GaitGenerator.cpp.uncrustify
@@ -6,6 +6,7 @@
-GaitGenerator::GaitGenerator(CtrlComponents *ctrlComp)
-              : _waveG(ctrlComp-&gt;waveGen), _est(ctrlComp-&gt;estimator), 
-                _phase(ctrlComp-&gt;phase), _contact(ctrlComp-&gt;contact), 
-                _robModel(ctrlComp-&gt;robotModel), _state(ctrlComp-&gt;lowState){
-    _feetCal = new FeetEndCal(ctrlComp);
-    _firstRun = true;
+GaitGenerator::GaitGenerator(CtrlComponents * ctrlComp)
+: _waveG(ctrlComp-&gt;waveGen), _est(ctrlComp-&gt;estimator),
+  _phase(ctrlComp-&gt;phase), _contact(ctrlComp-&gt;contact),
+  _robModel(ctrlComp-&gt;robotModel), _state(ctrlComp-&gt;lowState)
+{
+  _feetCal = new FeetEndCal(ctrlComp);
+  _firstRun = true;
@@ -14 +15,2 @@
-GaitGenerator::~GaitGenerator(){
+GaitGenerator::~GaitGenerator()
+{
@@ -17,4 +19,5 @@
-void GaitGenerator::setGait(Vec2 vxyGoalGlobal, float dYawGoal, float gaitHeight){
-    _vxyGoal = vxyGoalGlobal;
-    _dYawGoal = dYawGoal;
-    _gaitHeight = gaitHeight;
+void GaitGenerator::setGait(Vec2 vxyGoalGlobal, float dYawGoal, float gaitHeight)
+{
+  _vxyGoal = vxyGoalGlobal;
+  _dYawGoal = dYawGoal;
+  _gaitHeight = gaitHeight;
@@ -23,3 +26,4 @@
-void GaitGenerator::restart(){
-    _firstRun = true;
-    _vxyGoal.setZero();
+void GaitGenerator::restart()
+{
+  _firstRun = true;
+  _vxyGoal.setZero();
@@ -28,4 +32,19 @@
-void GaitGenerator::run(Vec34 &amp;feetPos, Vec34 &amp;feetVel){
-    if(_firstRun){
-        _startP = _est-&gt;getFeetPos();
-        _firstRun = false;
+void GaitGenerator::run(Vec34 &amp; feetPos, Vec34 &amp; feetVel)
+{
+  if (_firstRun) {
+    _startP = _est-&gt;getFeetPos();
+    _firstRun = false;
+  }
+
+  for (int i(0); i &lt; 4; ++i) {
+    if ((*_contact)(i) == 1) {
+      if ((*_phase)(i) &lt; 0.5) {
+        _startP.col(i) = _est-&gt;getFootPos(i);
+      }
+      feetPos.col(i) = _startP.col(i);
+      feetVel.col(i).setZero();
+    } else {
+      _endP.col(i) = _feetCal-&gt;calFootPos(i, _vxyGoal, _dYawGoal, (*_phase)(i));
+
+      feetPos.col(i) = getFootPos(i);
+      feetVel.col(i) = getFootVel(i);
@@ -33,18 +52,3 @@
-
-    for(int i(0); i&lt;4; ++i){
-        if((*_contact)(i) == 1){
-            if((*_phase)(i) &lt; 0.5){
-                _startP.col(i) = _est-&gt;getFootPos(i);
-            }
-            feetPos.col(i) = _startP.col(i);
-            feetVel.col(i).setZero();
-        }
-        else{
-            _endP.col(i) = _feetCal-&gt;calFootPos(i, _vxyGoal, _dYawGoal, (*_phase)(i));
-
-            feetPos.col(i) = getFootPos(i);
-            feetVel.col(i) = getFootVel(i);
-        }
-    }
-    _pastP = feetPos;
-    _phasePast = *_phase;
+  }
+  _pastP = feetPos;
+  _phasePast = *_phase;
@@ -53,2 +57,3 @@
-Vec3 GaitGenerator::getFootPos(int i){
-    Vec3 footPos;
+Vec3 GaitGenerator::getFootPos(int i)
+{
+  Vec3 footPos;
@@ -56,5 +61,5 @@
-    footPos(0) = cycloidXYPosition(_startP.col(i)(0), _endP.col(i)(0), (*_phase)(i));
-    footPos(1) = cycloidXYPosition(_startP.col(i)(1), _endP.col(i)(1), (*_phase)(i));
-    footPos(2) =  cycloidZPosition(_startP.col(i)(2), _gaitHeight, (*_phase)(i));
-    
-    return footPos;
+  footPos(0) = cycloidXYPosition(_startP.col(i)(0), _endP.col(i)(0), (*_phase)(i));
+  footPos(1) = cycloidXYPosition(_startP.col(i)(1), _endP.col(i)(1), (*_phase)(i));
+  footPos(2) = cycloidZPosition(_startP.col(i)(2), _gaitHeight, (*_phase)(i));
+
+  return footPos;
@@ -63,2 +68,3 @@
-Vec3 GaitGenerator::getFootVel(int i){
-    Vec3 footVel;
+Vec3 GaitGenerator::getFootVel(int i)
+{
+  Vec3 footVel;
@@ -66,3 +72,3 @@
-    footVel(0) = cycloidXYVelocity(_startP.col(i)(0), _endP.col(i)(0), (*_phase)(i));
-    footVel(1) = cycloidXYVelocity(_startP.col(i)(1), _endP.col(i)(1), (*_phase)(i));
-    footVel(2) =  cycloidZVelocity(_gaitHeight, (*_phase)(i));
+  footVel(0) = cycloidXYVelocity(_startP.col(i)(0), _endP.col(i)(0), (*_phase)(i));
+  footVel(1) = cycloidXYVelocity(_startP.col(i)(1), _endP.col(i)(1), (*_phase)(i));
+  footVel(2) = cycloidZVelocity(_gaitHeight, (*_phase)(i));
@@ -70 +76 @@
-    return footVel;
+  return footVel;
@@ -73,3 +79,4 @@
-float GaitGenerator::cycloidXYPosition(float start, float end, float phase){
-    float phasePI = 2 * M_PI * phase;
-    return (end - start)*(phasePI - sin(phasePI))/(2*M_PI) + start;
+float GaitGenerator::cycloidXYPosition(float start, float end, float phase)
+{
+  float phasePI = 2 * M_PI * phase;
+  return (end - start) * (phasePI - sin(phasePI)) / (2 * M_PI) + start;
@@ -78,3 +85,4 @@
-float GaitGenerator::cycloidXYVelocity(float start, float end, float phase){
-    float phasePI = 2 * M_PI * phase;
-    return (end - start)*(1 - cos(phasePI)) / _waveG-&gt;getTswing();
+float GaitGenerator::cycloidXYVelocity(float start, float end, float phase)
+{
+  float phasePI = 2 * M_PI * phase;
+  return (end - start) * (1 - cos(phasePI)) / _waveG-&gt;getTswing();
@@ -83,3 +91,4 @@
-float GaitGenerator::cycloidZPosition(float start, float h, float phase){
-    float phasePI = 2 * M_PI * phase;
-    return h*(1 - cos(phasePI))/2 + start;
+float GaitGenerator::cycloidZPosition(float start, float h, float phase)
+{
+  float phasePI = 2 * M_PI * phase;
+  return h * (1 - cos(phasePI)) / 2 + start;
@@ -88,4 +97,5 @@
-float GaitGenerator::cycloidZVelocity(float h, float phase){
-    float phasePI = 2 * M_PI * phase;
-    return h*M_PI * sin(phasePI) / _waveG-&gt;getTswing();
-}
+float GaitGenerator::cycloidZVelocity(float h, float phase)
+{
+  float phasePI = 2 * M_PI * phase;
+  return h * M_PI * sin(phasePI) / _waveG-&gt;getTswing();
+}

Code style divergence in file 'src/Gait/WaveGenerator.cpp':

--- src/Gait/WaveGenerator.cpp
+++ src/Gait/WaveGenerator.cpp.uncrustify
@@ -10 +10 @@
-    : _period(period), _stRatio(stancePhaseRatio), _bias(bias)
+: _period(period), _stRatio(stancePhaseRatio), _bias(bias)
@@ -13,4 +13,9 @@
-    if ((_stRatio &gt;= 1) || (_stRatio &lt;= 0))
-    {
-        std::cout &lt;&lt; "[ERROR] The stancePhaseRatio of WaveGenerator should between (0, 1)" &lt;&lt; std::endl;
-        exit(-1);
+  if ((_stRatio &gt;= 1) || (_stRatio &lt;= 0)) {
+    std::cout &lt;&lt; "[ERROR] The stancePhaseRatio of WaveGenerator should between (0, 1)" &lt;&lt; std::endl;
+    exit(-1);
+  }
+
+  for (int i(0); i &lt; bias.rows(); ++i) {
+    if ((bias(i) &gt; 1) || (bias(i) &lt; 0)) {
+      std::cout &lt;&lt; "[ERROR] The bias of WaveGenerator should between [0, 1]" &lt;&lt; std::endl;
+      exit(-1);
@@ -17,0 +23 @@
+  }
@@ -19,13 +25,4 @@
-    for (int i(0); i &lt; bias.rows(); ++i)
-    {
-        if ((bias(i) &gt; 1) || (bias(i) &lt; 0))
-        {
-            std::cout &lt;&lt; "[ERROR] The bias of WaveGenerator should between [0, 1]" &lt;&lt; std::endl;
-            exit(-1);
-        }
-    }
-
-    _startT = getSystemTime();
-    _contactPast.setZero();
-    _phasePast &lt;&lt; 0.5, 0.5, 0.5, 0.5;
-    _statusPast = WaveStatus::SWING_ALL;
+  _startT = getSystemTime();
+  _contactPast.setZero();
+  _phasePast &lt;&lt; 0.5, 0.5, 0.5, 0.5;
+  _statusPast = WaveStatus::SWING_ALL;
@@ -38 +35 @@
-void WaveGenerator::calcContactPhase(Vec4 &amp;phaseResult, VecInt4 &amp;contactResult, WaveStatus status)
+void WaveGenerator::calcContactPhase(Vec4 &amp; phaseResult, VecInt4 &amp; contactResult, WaveStatus status)
@@ -41 +38 @@
-    calcWave(_phase, _contact, status);
+  calcWave(_phase, _contact, status);
@@ -43,16 +40,3 @@
-    if (status != _statusPast)
-    {
-        if (_switchStatus.sum() == 0)
-        {
-            _switchStatus.setOnes();
-        }
-        calcWave(_phasePast, _contactPast, _statusPast);
-        // two special case
-        if ((status == WaveStatus::STANCE_ALL) &amp;&amp; (_statusPast == WaveStatus::SWING_ALL))
-        {
-            _contactPast.setOnes();
-        }
-        else if ((status == WaveStatus::SWING_ALL) &amp;&amp; (_statusPast == WaveStatus::STANCE_ALL))
-        {
-            _contactPast.setZero();
-        }
+  if (status != _statusPast) {
+    if (_switchStatus.sum() == 0) {
+      _switchStatus.setOnes();
@@ -59,0 +44,8 @@
+    calcWave(_phasePast, _contactPast, _statusPast);
+    // two special case
+    if ((status == WaveStatus::STANCE_ALL) &amp;&amp; (_statusPast == WaveStatus::SWING_ALL)) {
+      _contactPast.setOnes();
+    } else if ((status == WaveStatus::SWING_ALL) &amp;&amp; (_statusPast == WaveStatus::STANCE_ALL)) {
+      _contactPast.setZero();
+    }
+  }
@@ -61,18 +53,8 @@
-    if (_switchStatus.sum() != 0)
-    {
-        for (int i(0); i &lt; 4; ++i)
-        {
-            if (_contact(i) == _contactPast(i))
-            {
-                _switchStatus(i) = 0;
-            }
-            else
-            {
-                _contact(i) = _contactPast(i);
-                _phase(i) = _phasePast(i);
-            }
-        }
-        if (_switchStatus.sum() == 0)
-        {
-            _statusPast = status;
-        }
+  if (_switchStatus.sum() != 0) {
+    for (int i(0); i &lt; 4; ++i) {
+      if (_contact(i) == _contactPast(i)) {
+        _switchStatus(i) = 0;
+      } else {
+        _contact(i) = _contactPast(i);
+        _phase(i) = _phasePast(i);
+      }
@@ -79,0 +62,4 @@
+    if (_switchStatus.sum() == 0) {
+      _statusPast = status;
+    }
+  }
@@ -81,2 +67,2 @@
-    phaseResult = _phase;
-    contactResult = _contact;
+  phaseResult = _phase;
+  contactResult = _contact;
@@ -87 +73 @@
-    return _period * _stRatio;
+  return _period * _stRatio;
@@ -92 +78 @@
-    return _period * (1 - _stRatio);
+  return _period * (1 - _stRatio);
@@ -97 +83 @@
-    return _period;
+  return _period;
@@ -100 +86 @@
-void WaveGenerator::calcWave(Vec4 &amp;phase, VecInt4 &amp;contact, WaveStatus status)
+void WaveGenerator::calcWave(Vec4 &amp; phase, VecInt4 &amp; contact, WaveStatus status)
@@ -102,17 +88,11 @@
-    if (status == WaveStatus::WAVE_ALL)
-    {
-        _passT = (double)(getSystemTime() - _startT) * 1e-6;
-        for (int i(0); i &lt; 4; ++i)
-        {
-            _normalT(i) = fmod(_passT + _period - _period * _bias(i), _period) / _period;
-            if (_normalT(i) &lt; _stRatio)
-            {
-                contact(i) = 1;
-                phase(i) = _normalT(i) / _stRatio;
-            }
-            else
-            {
-                contact(i) = 0;
-                phase(i) = (_normalT(i) - _stRatio) / (1 - _stRatio);
-            }
-        }
+  if (status == WaveStatus::WAVE_ALL) {
+    _passT = (double)(getSystemTime() - _startT) * 1e-6;
+    for (int i(0); i &lt; 4; ++i) {
+      _normalT(i) = fmod(_passT + _period - _period * _bias(i), _period) / _period;
+      if (_normalT(i) &lt; _stRatio) {
+        contact(i) = 1;
+        phase(i) = _normalT(i) / _stRatio;
+      } else {
+        contact(i) = 0;
+        phase(i) = (_normalT(i) - _stRatio) / (1 - _stRatio);
+      }
@@ -120,11 +100,8 @@
-    else if (status == WaveStatus::SWING_ALL)
-    {
-        contact.setZero();
-        phase &lt;&lt; 0.5, 0.5, 0.5, 0.5;
-    }
-    else if (status == WaveStatus::STANCE_ALL)
-    {
-        contact.setOnes();
-        phase &lt;&lt; 0.5, 0.5, 0.5, 0.5;
-    }
-}
+  } else if (status == WaveStatus::SWING_ALL) {
+    contact.setZero();
+    phase &lt;&lt; 0.5, 0.5, 0.5, 0.5;
+  } else if (status == WaveStatus::STANCE_ALL) {
+    contact.setOnes();
+    phase &lt;&lt; 0.5, 0.5, 0.5, 0.5;
+  }
+}

Code style divergence in file 'src/common/LowPassFilter.cpp':

--- src/common/LowPassFilter.cpp
+++ src/common/LowPassFilter.cpp.uncrustify
@@ -7,3 +7,4 @@
-LPFilter::LPFilter(double samplePeriod, double cutFrequency){
-    _weight = 1.0 / ( 1.0 + 1.0/(2.0*M_PI * samplePeriod * cutFrequency) );
-    _start  = false;
+LPFilter::LPFilter(double samplePeriod, double cutFrequency)
+{
+  _weight = 1.0 / ( 1.0 + 1.0 / (2.0 * M_PI * samplePeriod * cutFrequency) );
+  _start = false;
@@ -12,6 +13,7 @@
-void LPFilter::addValue(double newValue){
-    if(!_start){
-        _start = true;
-        _pastValue = newValue;
-    }
-    _pastValue = _weight*newValue + (1-_weight)*_pastValue;
+void LPFilter::addValue(double newValue)
+{
+  if (!_start) {
+    _start = true;
+    _pastValue = newValue;
+  }
+  _pastValue = _weight * newValue + (1 - _weight) * _pastValue;
@@ -20,2 +22,3 @@
-double LPFilter::getValue(){
-    return _pastValue;
+double LPFilter::getValue()
+{
+  return _pastValue;
@@ -24,3 +27,4 @@
-void LPFilter::clear(){
-    _start = false;
-}
+void LPFilter::clear()
+{
+  _start = false;
+}

Code style divergence in file 'src/common/unitreeLeg.cpp':

--- src/common/unitreeLeg.cpp
+++ src/common/unitreeLeg.cpp.uncrustify
@@ -11,14 +11,16 @@
-QuadrupedLeg::QuadrupedLeg(int legID, float abadLinkLength, float hipLinkLength, 
-                           float kneeLinkLength, Vec3 pHip2B)
-            :_abadLinkLength(abadLinkLength), 
-             _hipLinkLength(hipLinkLength), 
-             _kneeLinkLength(kneeLinkLength), 
-             _pHip2B(pHip2B){
-    if (legID == 0 || legID == 2)
-        _sideSign = -1;
-    else if (legID == 1 || legID == 3)
-        _sideSign = 1;
-    else{
-        std::cout &lt;&lt; "Leg ID incorrect!" &lt;&lt; std::endl;
-        exit(-1);
-    }
+QuadrupedLeg::QuadrupedLeg(
+  int legID, float abadLinkLength, float hipLinkLength,
+  float kneeLinkLength, Vec3 pHip2B)
+: _abadLinkLength(abadLinkLength),
+  _hipLinkLength(hipLinkLength),
+  _kneeLinkLength(kneeLinkLength),
+  _pHip2B(pHip2B)
+{
+  if (legID == 0 || legID == 2) {
+    _sideSign = -1;
+  } else if (legID == 1 || legID == 3) {
+    _sideSign = 1;
+  } else {
+    std::cout &lt;&lt; "Leg ID incorrect!" &lt;&lt; std::endl;
+    exit(-1);
+  }
@@ -28,4 +30,5 @@
-Vec3 QuadrupedLeg::calcPEe2H(Vec3 q){
-    float l1 = _sideSign * _abadLinkLength;
-    float l2 = -_hipLinkLength;
-    float l3 = -_kneeLinkLength;
+Vec3 QuadrupedLeg::calcPEe2H(Vec3 q)
+{
+  float l1 = _sideSign * _abadLinkLength;
+  float l2 = -_hipLinkLength;
+  float l3 = -_kneeLinkLength;
@@ -33,3 +36,3 @@
-    float s1 = std::sin(q(0));
-    float s2 = std::sin(q(1));
-    float s3 = std::sin(q(2));
+  float s1 = std::sin(q(0));
+  float s2 = std::sin(q(1));
+  float s3 = std::sin(q(2));
@@ -37,3 +40,3 @@
-    float c1 = std::cos(q(0));
-    float c2 = std::cos(q(1));
-    float c3 = std::cos(q(2));
+  float c1 = std::cos(q(0));
+  float c2 = std::cos(q(1));
+  float c3 = std::cos(q(2));
@@ -41,2 +44,2 @@
-    float c23 = c2 * c3 - s2 * s3;
-    float s23 = s2 * c3 + c2 * s3;
+  float c23 = c2 * c3 - s2 * s3;
+  float s23 = s2 * c3 + c2 * s3;
@@ -44 +47 @@
-    Vec3 pEe2H;
+  Vec3 pEe2H;
@@ -46,3 +49,3 @@
-    pEe2H(0) = l3 * s23 + l2 * s2;
-    pEe2H(1) = -l3 * s1 * c23 + l1 * c1 - l2 * c2 * s1;
-    pEe2H(2) =  l3 * c1 * c23 + l1 * s1 + l2 * c1 * c2;
+  pEe2H(0) = l3 * s23 + l2 * s2;
+  pEe2H(1) = -l3 * s1 * c23 + l1 * c1 - l2 * c2 * s1;
+  pEe2H(2) = l3 * c1 * c23 + l1 * s1 + l2 * c1 * c2;
@@ -50 +53 @@
-    return pEe2H;
+  return pEe2H;
@@ -54,2 +57,3 @@
-Vec3 QuadrupedLeg::calcPEe2B(Vec3 q){
-    return _pHip2B + calcPEe2H(q);
+Vec3 QuadrupedLeg::calcPEe2B(Vec3 q)
+{
+  return _pHip2B + calcPEe2H(q);
@@ -59,2 +63,3 @@
-Vec3 QuadrupedLeg::calcVEe(Vec3 q, Vec3 qd){
-    return calcJaco(q) * qd;
+Vec3 QuadrupedLeg::calcVEe(Vec3 q, Vec3 qd)
+{
+  return calcJaco(q) * qd;
@@ -64,10 +69,11 @@
-Vec3 QuadrupedLeg::calcQ(Vec3 pEe, FrameType frame){
-    Vec3 pEe2H;
-    if(frame == FrameType::HIP)
-        pEe2H = pEe;
-    else if(frame == FrameType::BODY)
-        pEe2H = pEe - _pHip2B;
-    else{
-        std::cout &lt;&lt; "[ERROR] The frame of QuadrupedLeg::calcQ can only be HIP or BODY!" &lt;&lt; std::endl;
-        exit(-1);
-    }
+Vec3 QuadrupedLeg::calcQ(Vec3 pEe, FrameType frame)
+{
+  Vec3 pEe2H;
+  if (frame == FrameType::HIP) {
+    pEe2H = pEe;
+  } else if (frame == FrameType::BODY) {
+    pEe2H = pEe - _pHip2B;
+  } else {
+    std::cout &lt;&lt; "[ERROR] The frame of QuadrupedLeg::calcQ can only be HIP or BODY!" &lt;&lt; std::endl;
+    exit(-1);
+  }
@@ -75,4 +81,4 @@
-    float q1, q2, q3;
-    Vec3 qResult;
-    float px, py, pz;
-    float b2y, b3z, b4z, a, b, c;
+  float q1, q2, q3;
+  Vec3 qResult;
+  float px, py, pz;
+  float b2y, b3z, b4z, a, b, c;
@@ -80,3 +86,3 @@
-    px = pEe2H(0);
-    py = pEe2H(1);
-    pz = pEe2H(2);
+  px = pEe2H(0);
+  py = pEe2H(1);
+  pz = pEe2H(2);
@@ -84,6 +90,6 @@
-    b2y = _abadLinkLength * _sideSign;
-    b3z = -_hipLinkLength;
-    b4z = -_kneeLinkLength;
-    a = _abadLinkLength;
-    c = sqrt(pow(px, 2) + pow(py, 2) + pow(pz, 2)); // whole length
-    b = sqrt(pow(c, 2) - pow(a, 2)); // distance between shoulder and footpoint
+  b2y = _abadLinkLength * _sideSign;
+  b3z = -_hipLinkLength;
+  b4z = -_kneeLinkLength;
+  a = _abadLinkLength;
+  c = sqrt(pow(px, 2) + pow(py, 2) + pow(pz, 2));   // whole length
+  b = sqrt(pow(c, 2) - pow(a, 2));   // distance between shoulder and footpoint
@@ -91,3 +97,3 @@
-    q1 = q1_ik(py, pz, b2y);
-    q3 = q3_ik(b3z, b4z, b);
-    q2 = q2_ik(q1, q3, px, py, pz, b3z, b4z);
+  q1 = q1_ik(py, pz, b2y);
+  q3 = q3_ik(b3z, b4z, b);
+  q2 = q2_ik(q1, q3, px, py, pz, b3z, b4z);
@@ -95,3 +101,3 @@
-    qResult(0) = q1;
-    qResult(1) = q2;
-    qResult(2) = q3;
+  qResult(0) = q1;
+  qResult(1) = q2;
+  qResult(2) = q3;
@@ -99 +105 @@
-    return qResult;
+  return qResult;
@@ -103,2 +109,3 @@
-Vec3 QuadrupedLeg::calcQd(Vec3 q, Vec3 vEe){
-    return calcJaco(q).inverse() * vEe;
+Vec3 QuadrupedLeg::calcQd(Vec3 q, Vec3 vEe)
+{
+  return calcJaco(q).inverse() * vEe;
@@ -108,3 +115,4 @@
-Vec3 QuadrupedLeg::calcQd(Vec3 pEe, Vec3 vEe, FrameType frame){
-    Vec3 q = calcQ(pEe, frame);
-    return calcJaco(q).inverse() * vEe;
+Vec3 QuadrupedLeg::calcQd(Vec3 pEe, Vec3 vEe, FrameType frame)
+{
+  Vec3 q = calcQ(pEe, frame);
+  return calcJaco(q).inverse() * vEe;
@@ -114,2 +122,3 @@
-Vec3 QuadrupedLeg::calcTau(Vec3 q, Vec3 force){
-    return calcJaco(q).transpose() * force;
+Vec3 QuadrupedLeg::calcTau(Vec3 q, Vec3 force)
+{
+  return calcJaco(q).transpose() * force;
@@ -119,2 +128,3 @@
-Mat3 QuadrupedLeg::calcJaco(Vec3 q){
-    Mat3 jaco;
+Mat3 QuadrupedLeg::calcJaco(Vec3 q)
+{
+  Mat3 jaco;
@@ -122,3 +132,3 @@
-    float l1 = _abadLinkLength * _sideSign;
-    float l2 = -_hipLinkLength;
-    float l3 = -_kneeLinkLength;
+  float l1 = _abadLinkLength * _sideSign;
+  float l2 = -_hipLinkLength;
+  float l3 = -_kneeLinkLength;
@@ -126,3 +136,3 @@
-    float s1 = std::sin(q(0));
-    float s2 = std::sin(q(1));
-    float s3 = std::sin(q(2));
+  float s1 = std::sin(q(0));
+  float s2 = std::sin(q(1));
+  float s3 = std::sin(q(2));
@@ -130,3 +140,3 @@
-    float c1 = std::cos(q(0));
-    float c2 = std::cos(q(1));
-    float c3 = std::cos(q(2));
+  float c1 = std::cos(q(0));
+  float c2 = std::cos(q(1));
+  float c3 = std::cos(q(2));
@@ -134,11 +144,11 @@
-    float c23 = c2 * c3 - s2 * s3;
-    float s23 = s2 * c3 + c2 * s3;
-    jaco(0, 0) = 0;
-    jaco(1, 0) = -l3 * c1 * c23 - l2 * c1 * c2 - l1 * s1;
-    jaco(2, 0) = -l3 * s1 * c23 - l2 * c2 * s1 + l1 * c1;
-    jaco(0, 1) = l3 * c23 + l2 * c2;
-    jaco(1, 1) = l3 * s1 * s23 + l2 * s1 * s2;
-    jaco(2, 1) = -l3 * c1 * s23 - l2 * c1 * s2;
-    jaco(0, 2) = l3 * c23;
-    jaco(1, 2) = l3 * s1 * s23;
-    jaco(2, 2) = -l3 * c1 * s23;
+  float c23 = c2 * c3 - s2 * s3;
+  float s23 = s2 * c3 + c2 * s3;
+  jaco(0, 0) = 0;
+  jaco(1, 0) = -l3 * c1 * c23 - l2 * c1 * c2 - l1 * s1;
+  jaco(2, 0) = -l3 * s1 * c23 - l2 * c2 * s1 + l1 * c1;
+  jaco(0, 1) = l3 * c23 + l2 * c2;
+  jaco(1, 1) = l3 * s1 * s23 + l2 * s1 * s2;
+  jaco(2, 1) = -l3 * c1 * s23 - l2 * c1 * s2;
+  jaco(0, 2) = l3 * c23;
+  jaco(1, 2) = l3 * s1 * s23;
+  jaco(2, 2) = -l3 * c1 * s23;
@@ -146 +156 @@
-    return jaco;
+  return jaco;
@@ -149,5 +159,6 @@
-float QuadrupedLeg::q1_ik(float py, float pz, float l1){
-    float q1;
-    float L = sqrt(pow(py,2)+pow(pz,2)-pow(l1,2));
-    q1 = atan2(pz*l1+py*L, py*l1-pz*L);
-    return q1;
+float QuadrupedLeg::q1_ik(float py, float pz, float l1)
+{
+  float q1;
+  float L = sqrt(pow(py, 2) + pow(pz, 2) - pow(l1, 2));
+  q1 = atan2(pz * l1 + py * L, py * l1 - pz * L);
+  return q1;
@@ -156,8 +167,9 @@
-float QuadrupedLeg::q3_ik(float b3z, float b4z, float b){
-    float q3, temp;
-    temp = (pow(b3z, 2) + pow(b4z, 2) - pow(b, 2))/(2*fabs(b3z*b4z));
-    if(temp&gt;1) temp = 1;
-    if(temp&lt;-1) temp = -1;
-    q3 = acos(temp);
-    q3 = -(M_PI - q3); //0~180
-    return q3;
+float QuadrupedLeg::q3_ik(float b3z, float b4z, float b)
+{
+  float q3, temp;
+  temp = (pow(b3z, 2) + pow(b4z, 2) - pow(b, 2)) / (2 * fabs(b3z * b4z));
+  if (temp &gt; 1) {temp = 1;}
+  if (temp &lt; -1) {temp = -1;}
+  q3 = acos(temp);
+  q3 = -(M_PI - q3);   //0~180
+  return q3;
@@ -166,9 +178,10 @@
-float QuadrupedLeg::q2_ik(float q1, float q3, float px, float py, float pz, float b3z, float b4z){
-    float q2, a1, a2, m1, m2;
-    
-    a1 = py*sin(q1) - pz*cos(q1);
-    a2 = px;
-    m1 = b4z*sin(q3);
-    m2 = b3z + b4z*cos(q3);
-    q2 = atan2(m1*a1+m2*a2, m1*a2-m2*a1);
-    return q2;
+float QuadrupedLeg::q2_ik(float q1, float q3, float px, float py, float pz, float b3z, float b4z)
+{
+  float q2, a1, a2, m1, m2;
+
+  a1 = py * sin(q1) - pz * cos(q1);
+  a2 = px;
+  m1 = b4z * sin(q3);
+  m2 = b3z + b4z * cos(q3);
+  q2 = atan2(m1 * a1 + m2 * a2, m1 * a2 - m2 * a1);
+  return q2;

Code style divergence in file 'src/common/unitreeRobot.cpp':

--- src/common/unitreeRobot.cpp
+++ src/common/unitreeRobot.cpp.uncrustify
@@ -7,2 +7,3 @@
-Vec3 QuadrupedRobot::getX(LowlevelState &amp;state){
-    return getFootPosition(state, 0, FrameType::BODY);
+Vec3 QuadrupedRobot::getX(LowlevelState &amp; state)
+{
+  return getFootPosition(state, 0, FrameType::BODY);
@@ -11,4 +12,5 @@
-Vec34 QuadrupedRobot::getVecXP(LowlevelState &amp;state){
-    Vec3 x = getX(state);
-    Vec34 vecXP, qLegs;
-    qLegs = state.getQ();
+Vec34 QuadrupedRobot::getVecXP(LowlevelState &amp; state)
+{
+  Vec3 x = getX(state);
+  Vec34 vecXP, qLegs;
+  qLegs = state.getQ();
@@ -16,4 +18,4 @@
-    for(int i(0); i &lt; 4; ++i){
-        vecXP.col(i) = _Legs[i]-&gt;calcPEe2B(qLegs.col(i)) - x;
-    }
-    return vecXP;
+  for (int i(0); i &lt; 4; ++i) {
+    vecXP.col(i) = _Legs[i]-&gt;calcPEe2B(qLegs.col(i)) - x;
+  }
+  return vecXP;
@@ -22,6 +24,7 @@
-Vec12 QuadrupedRobot::getQ(const Vec34 &amp;vecP, FrameType frame){
-    Vec12 q;
-    for(int i(0); i &lt; 4; ++i){
-        q.segment(3*i, 3) = _Legs[i]-&gt;calcQ(vecP.col(i), frame);
-    }
-    return q;
+Vec12 QuadrupedRobot::getQ(const Vec34 &amp; vecP, FrameType frame)
+{
+  Vec12 q;
+  for (int i(0); i &lt; 4; ++i) {
+    q.segment(3 * i, 3) = _Legs[i]-&gt;calcQ(vecP.col(i), frame);
+  }
+  return q;
@@ -30,6 +33,7 @@
-Vec12 QuadrupedRobot::getQd(const Vec34 &amp;pos, const Vec34 &amp;vel, FrameType frame){
-    Vec12 qd;
-    for(int i(0); i &lt; 4; ++i){
-        qd.segment(3*i, 3) = _Legs[i]-&gt;calcQd(pos.col(i), vel.col(i), frame);
-    }
-    return qd;
+Vec12 QuadrupedRobot::getQd(const Vec34 &amp; pos, const Vec34 &amp; vel, FrameType frame)
+{
+  Vec12 qd;
+  for (int i(0); i &lt; 4; ++i) {
+    qd.segment(3 * i, 3) = _Legs[i]-&gt;calcQd(pos.col(i), vel.col(i), frame);
+  }
+  return qd;
@@ -38,6 +42,7 @@
-Vec12 QuadrupedRobot::getTau(const Vec12 &amp;q, const Vec34 feetForce){
-    Vec12 tau;
-    for(int i(0); i &lt; 4; ++i){
-        tau.segment(3*i, 3) = _Legs[i]-&gt;calcTau(q.segment(3*i, 3), feetForce.col(i));
-    }
-    return tau;
+Vec12 QuadrupedRobot::getTau(const Vec12 &amp; q, const Vec34 feetForce)
+{
+  Vec12 tau;
+  for (int i(0); i &lt; 4; ++i) {
+    tau.segment(3 * i, 3) = _Legs[i]-&gt;calcTau(q.segment(3 * i, 3), feetForce.col(i));
+  }
+  return tau;
@@ -47,2 +52,3 @@
-Vec3 QuadrupedRobot::getFootPosition(LowlevelState &amp;state, int id, FrameType frame){
-    Vec34 qLegs= state.getQ();
+Vec3 QuadrupedRobot::getFootPosition(LowlevelState &amp; state, int id, FrameType frame)
+{
+  Vec34 qLegs = state.getQ();
@@ -50,8 +56,9 @@
-    if(frame == FrameType::BODY){
-        return _Legs[id]-&gt;calcPEe2B(qLegs.col(id));
-    }else if(frame == FrameType::HIP){
-        return _Legs[id]-&gt;calcPEe2H(qLegs.col(id));
-    }else{
-        std::cout &lt;&lt; "[ERROR] The frame of function: getFootPosition can only be BODY or HIP." &lt;&lt; std::endl;
-        exit(-1);
-    }
+  if (frame == FrameType::BODY) {
+    return _Legs[id]-&gt;calcPEe2B(qLegs.col(id));
+  } else if (frame == FrameType::HIP) {
+    return _Legs[id]-&gt;calcPEe2H(qLegs.col(id));
+  } else {
+    std::cout &lt;&lt; "[ERROR] The frame of function: getFootPosition can only be BODY or HIP." &lt;&lt;
+      std::endl;
+    exit(-1);
+  }
@@ -61,4 +68,5 @@
-Vec3 QuadrupedRobot::getFootVelocity(LowlevelState &amp;state, int id){
-    Vec34 qLegs = state.getQ();
-    Vec34 qdLegs= state.getQd();
-    return _Legs[id]-&gt;calcVEe(qLegs.col(id), qdLegs.col(id));
+Vec3 QuadrupedRobot::getFootVelocity(LowlevelState &amp; state, int id)
+{
+  Vec34 qLegs = state.getQ();
+  Vec34 qdLegs = state.getQd();
+  return _Legs[id]-&gt;calcVEe(qLegs.col(id), qdLegs.col(id));
@@ -68,7 +76,6 @@
-Vec34 QuadrupedRobot::getFeet2BPositions(LowlevelState &amp;state, FrameType frame){
-    Vec34 feetPos;
-    if(frame == FrameType::GLOBAL){
-        for(int i(0); i&lt;4; ++i){
-            feetPos.col(i) = getFootPosition(state, i, FrameType::BODY);
-        }
-        feetPos = state.getRotMat() * feetPos;
+Vec34 QuadrupedRobot::getFeet2BPositions(LowlevelState &amp; state, FrameType frame)
+{
+  Vec34 feetPos;
+  if (frame == FrameType::GLOBAL) {
+    for (int i(0); i &lt; 4; ++i) {
+      feetPos.col(i) = getFootPosition(state, i, FrameType::BODY);
@@ -76,4 +83,4 @@
-    else if((frame == FrameType::BODY) || (frame == FrameType::HIP)){
-        for(int i(0); i&lt;4; ++i){
-            feetPos.col(i) = getFootPosition(state, i, frame);
-        }
+    feetPos = state.getRotMat() * feetPos;
+  } else if ((frame == FrameType::BODY) || (frame == FrameType::HIP)) {
+    for (int i(0); i &lt; 4; ++i) {
+      feetPos.col(i) = getFootPosition(state, i, frame);
@@ -81,5 +88,5 @@
-    else{
-        std::cout &lt;&lt; "[ERROR] Frame error of function getFeet2BPositions" &lt;&lt; std::endl;
-        exit(-1);
-    }
-    return feetPos;
+  } else {
+    std::cout &lt;&lt; "[ERROR] Frame error of function getFeet2BPositions" &lt;&lt; std::endl;
+    exit(-1);
+  }
+  return feetPos;
@@ -88,5 +95,6 @@
-Vec34 QuadrupedRobot::getFeet2BVelocities(LowlevelState &amp;state, FrameType frame){
-    Vec34 feetVel;
-    for(int i(0); i&lt;4; ++i){
-        feetVel.col(i) = getFootVelocity(state, i);
-    }
+Vec34 QuadrupedRobot::getFeet2BVelocities(LowlevelState &amp; state, FrameType frame)
+{
+  Vec34 feetVel;
+  for (int i(0); i &lt; 4; ++i) {
+    feetVel.col(i) = getFootVelocity(state, i);
+  }
@@ -94,12 +102,10 @@
-    if(frame == FrameType::GLOBAL){
-        Vec34 feetPos = getFeet2BPositions(state, FrameType::BODY);
-        feetVel += skew(state.getGyro()) * feetPos;
-        return state.getRotMat() * feetVel;
-    }
-    else if((frame == FrameType::BODY) || (frame == FrameType::HIP)){
-        return feetVel;
-    }
-    else{
-        std::cout &lt;&lt; "[ERROR] Frame error of function getFeet2BVelocities" &lt;&lt; std::endl;
-        exit(-1);
-    }   
+  if (frame == FrameType::GLOBAL) {
+    Vec34 feetPos = getFeet2BPositions(state, FrameType::BODY);
+    feetVel += skew(state.getGyro()) * feetPos;
+    return state.getRotMat() * feetVel;
+  } else if ((frame == FrameType::BODY) || (frame == FrameType::HIP)) {
+    return feetVel;
+  } else {
+    std::cout &lt;&lt; "[ERROR] Frame error of function getFeet2BVelocities" &lt;&lt; std::endl;
+    exit(-1);
+  }
@@ -108,2 +114,3 @@
-Mat3 QuadrupedRobot::getJaco(LowlevelState &amp;state, int legID){
-    return _Legs[legID]-&gt;calcJaco(state.getQ().col(legID));
+Mat3 QuadrupedRobot::getJaco(LowlevelState &amp; state, int legID)
+{
+  return _Legs[legID]-&gt;calcJaco(state.getQ().col(legID));
@@ -112,5 +119,6 @@
-A1Robot::A1Robot(){
-    _Legs[0] = new A1Leg(0, Vec3( 0.1805, -0.047, 0));
-    _Legs[1] = new A1Leg(1, Vec3( 0.1805,  0.047, 0));
-    _Legs[2] = new A1Leg(2, Vec3(-0.1805, -0.047, 0));
-    _Legs[3] = new A1Leg(3, Vec3(-0.1805,  0.047, 0));
+A1Robot::A1Robot()
+{
+  _Legs[0] = new A1Leg(0, Vec3(0.1805, -0.047, 0));
+  _Legs[1] = new A1Leg(1, Vec3(0.1805, 0.047, 0));
+  _Legs[2] = new A1Leg(2, Vec3(-0.1805, -0.047, 0));
+  _Legs[3] = new A1Leg(3, Vec3(-0.1805, 0.047, 0));
@@ -118,3 +126,3 @@
-    _feetPosNormalStand &lt;&lt;  0.1805,  0.1805, -0.1805, -0.1805, 
-                           -0.1308,  0.1308, -0.1308,  0.1308,
-                           -0.3180, -0.3180, -0.3180, -0.3180;
+  _feetPosNormalStand &lt;&lt; 0.1805, 0.1805, -0.1805, -0.1805,
+    -0.1308, 0.1308, -0.1308, 0.1308,
+    -0.3180, -0.3180, -0.3180, -0.3180;
@@ -122,3 +130,3 @@
-    _robVelLimitX &lt;&lt; -0.4, 0.4;
-    _robVelLimitY &lt;&lt; -0.3, 0.3;
-    _robVelLimitYaw &lt;&lt; -0.5, 0.5;
+  _robVelLimitX &lt;&lt; -0.4, 0.4;
+  _robVelLimitY &lt;&lt; -0.3, 0.3;
+  _robVelLimitYaw &lt;&lt; -0.5, 0.5;
@@ -127,3 +135,3 @@
-    _mass = 12.5;
-    _pcb &lt;&lt; 0.01, 0.0, 0.0;
-    _Ib = Vec3(0.132, 0.3475, 0.3775).asDiagonal();
+  _mass = 12.5;
+  _pcb &lt;&lt; 0.01, 0.0, 0.0;
+  _Ib = Vec3(0.132, 0.3475, 0.3775).asDiagonal();
@@ -133,3 +141,3 @@
-    _mass = 13.4;
-    _pcb &lt;&lt; 0.0, 0.0, 0.0;
-    _Ib = Vec3(0.132, 0.3475, 0.3775).asDiagonal();
+  _mass = 13.4;
+  _pcb &lt;&lt; 0.0, 0.0, 0.0;
+  _Ib = Vec3(0.132, 0.3475, 0.3775).asDiagonal();
@@ -139,5 +147,6 @@
-Go1Robot::Go1Robot(){
-    _Legs[0] = new Go1Leg(0, Vec3( 0.1881, -0.04675, 0));
-    _Legs[1] = new Go1Leg(1, Vec3( 0.1881,  0.04675, 0));
-    _Legs[2] = new Go1Leg(2, Vec3(-0.1881, -0.04675, 0));
-    _Legs[3] = new Go1Leg(3, Vec3(-0.1881,  0.04675, 0));
+Go1Robot::Go1Robot()
+{
+  _Legs[0] = new Go1Leg(0, Vec3(0.1881, -0.04675, 0));
+  _Legs[1] = new Go1Leg(1, Vec3(0.1881, 0.04675, 0));
+  _Legs[2] = new Go1Leg(2, Vec3(-0.1881, -0.04675, 0));
+  _Legs[3] = new Go1Leg(3, Vec3(-0.1881, 0.04675, 0));
@@ -145,3 +154,3 @@
-    _feetPosNormalStand &lt;&lt;  0.1881,  0.1881, -0.1881, -0.1881,
-                           -0.1300,  0.1300, -0.1300,  0.1300,
-                           -0.3200, -0.3200, -0.3200, -0.3200;
+  _feetPosNormalStand &lt;&lt; 0.1881, 0.1881, -0.1881, -0.1881,
+    -0.1300, 0.1300, -0.1300, 0.1300,
+    -0.3200, -0.3200, -0.3200, -0.3200;
@@ -149,3 +158,3 @@
-    _robVelLimitX &lt;&lt; -0.4, 0.4;
-    _robVelLimitY &lt;&lt; -0.3, 0.3;
-    _robVelLimitYaw &lt;&lt; -0.5, 0.5;
+  _robVelLimitX &lt;&lt; -0.4, 0.4;
+  _robVelLimitY &lt;&lt; -0.3, 0.3;
+  _robVelLimitYaw &lt;&lt; -0.5, 0.5;
@@ -155,3 +164,3 @@
-    _mass = 10.5;
-    _pcb &lt;&lt; 0.04, 0.0, 0.0;
-    _Ib = Vec3(0.0792, 0.2085, 0.2265).asDiagonal();
+  _mass = 10.5;
+  _pcb &lt;&lt; 0.04, 0.0, 0.0;
+  _Ib = Vec3(0.0792, 0.2085, 0.2265).asDiagonal();
@@ -161,3 +170,3 @@
-    _mass = 12.0;
-    _pcb &lt;&lt; 0.0, 0.0, 0.0;
-    _Ib = Vec3(0.0792, 0.2085, 0.2265).asDiagonal();
+  _mass = 12.0;
+  _pcb &lt;&lt; 0.0, 0.0, 0.0;
+  _Ib = Vec3(0.0792, 0.2085, 0.2265).asDiagonal();
@@ -165 +174 @@
-}
+}

Code style divergence in file 'src/control/BalanceCtrl.cpp':

--- src/control/BalanceCtrl.cpp
+++ src/control/BalanceCtrl.cpp.uncrustify
@@ -9,9 +9,10 @@
-            : _mass(mass), _Ib(Ib), _S(S), _alpha(alpha), _beta(beta){
-    _Fprev.setZero();
-    _g &lt;&lt; 0, 0, -9.81;
-    _fricRatio = 0.3;
-    _fricMat &lt;&lt;  1,  0, _fricRatio,
-                -1,  0, _fricRatio,
-                 0,  1, _fricRatio,
-                 0, -1, _fricRatio,
-                 0,  0, 1;
+: _mass(mass), _Ib(Ib), _S(S), _alpha(alpha), _beta(beta)
+{
+  _Fprev.setZero();
+  _g &lt;&lt; 0, 0, -9.81;
+  _fricRatio = 0.3;
+  _fricMat &lt;&lt; 1, 0, _fricRatio,
+    -1, 0, _fricRatio,
+    0, 1, _fricRatio,
+    0, -1, _fricRatio,
+    0, 0, 1;
@@ -20,3 +21,4 @@
-BalanceCtrl::BalanceCtrl(QuadrupedRobot *robModel){
-    Vec6 s;
-    Vec12 w, u;
+BalanceCtrl::BalanceCtrl(QuadrupedRobot * robModel)
+{
+  Vec6 s;
+  Vec12 w, u;
@@ -24,4 +26,4 @@
-    _mass = robModel-&gt;getRobMass();
-    _pcb = robModel-&gt;getPcb();
-    _Ib = robModel-&gt;getRobInertial();
-    _g &lt;&lt; 0, 0, -9.81;
+  _mass = robModel-&gt;getRobMass();
+  _pcb = robModel-&gt;getPcb();
+  _Ib = robModel-&gt;getRobInertial();
+  _g &lt;&lt; 0, 0, -9.81;
@@ -29,5 +31,5 @@
-    w &lt;&lt; 10, 10, 4, 10, 10, 4, 10, 10, 4, 10, 10, 4;
-    u &lt;&lt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3;
-    _alpha = 0.001;
-    _beta  = 0.1;
-    _fricRatio = 0.4;
+  w &lt;&lt; 10, 10, 4, 10, 10, 4, 10, 10, 4, 10, 10, 4;
+  u &lt;&lt; 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3;
+  _alpha = 0.001;
+  _beta = 0.1;
+  _fricRatio = 0.4;
@@ -35 +37 @@
-    s &lt;&lt; 20, 20, 50, 450, 450, 450; 
+  s &lt;&lt; 20, 20, 50, 450, 450, 450;
@@ -37,10 +39,10 @@
-    _S = s.asDiagonal();
-    _W = w.asDiagonal();
-    _U = u.asDiagonal();
-    
-    _Fprev.setZero();
-    _fricMat &lt;&lt;  1,  0, _fricRatio,
-                -1,  0, _fricRatio,
-                 0,  1, _fricRatio,
-                 0, -1, _fricRatio,
-                 0,  0, 1;
+  _S = s.asDiagonal();
+  _W = w.asDiagonal();
+  _U = u.asDiagonal();
+
+  _Fprev.setZero();
+  _fricMat &lt;&lt; 1, 0, _fricRatio,
+    -1, 0, _fricRatio,
+    0, 1, _fricRatio,
+    0, -1, _fricRatio,
+    0, 0, 1;
@@ -49,4 +51,5 @@
-Vec34 BalanceCtrl::calF(Vec3 ddPcd, Vec3 dWbd, RotMat rotM, Vec34 feetPos2B, VecInt4 contact){
-    calMatrixA(feetPos2B, rotM, contact);
-    calVectorBd(ddPcd, dWbd, rotM);
-    calConstraints(contact);
+Vec34 BalanceCtrl::calF(Vec3 ddPcd, Vec3 dWbd, RotMat rotM, Vec34 feetPos2B, VecInt4 contact)
+{
+  calMatrixA(feetPos2B, rotM, contact);
+  calVectorBd(ddPcd, dWbd, rotM);
+  calConstraints(contact);
@@ -54,2 +57,2 @@
-    _G = _A.transpose()*_S*_A + _alpha*_W + _beta*_U;
-    _g0T = -_bd.transpose()*_S*_A - _beta*_Fprev.transpose()*_U;
+  _G = _A.transpose() * _S * _A + _alpha * _W + _beta * _U;
+  _g0T = -_bd.transpose() * _S * _A - _beta * _Fprev.transpose() * _U;
@@ -57 +60 @@
-    solveQP();
+  solveQP();
@@ -59,2 +62,2 @@
-    _Fprev = _F;
-    return vec12ToVec34(_F);
+  _Fprev = _F;
+  return vec12ToVec34(_F);
@@ -63,5 +66,6 @@
-void BalanceCtrl::calMatrixA(Vec34 feetPos2B, RotMat rotM, VecInt4 contact){
-    for(int i(0); i &lt; 4; ++i){
-        _A.block(0, 3*i, 3, 3) = I3;
-        _A.block(3, 3*i, 3, 3) = skew(feetPos2B.col(i) - rotM*_pcb);
-    }
+void BalanceCtrl::calMatrixA(Vec34 feetPos2B, RotMat rotM, VecInt4 contact)
+{
+  for (int i(0); i &lt; 4; ++i) {
+    _A.block(0, 3 * i, 3, 3) = I3;
+    _A.block(3, 3 * i, 3, 3) = skew(feetPos2B.col(i) - rotM * _pcb);
+  }
@@ -70,3 +74,4 @@
-void BalanceCtrl::calVectorBd(Vec3 ddPcd, Vec3 dWbd, RotMat rotM){
-    _bd.head(3) = _mass * (ddPcd - _g);
-    _bd.tail(3) = (rotM * _Ib * rotM.transpose()) * dWbd;
+void BalanceCtrl::calVectorBd(Vec3 ddPcd, Vec3 dWbd, RotMat rotM)
+{
+  _bd.head(3) = _mass * (ddPcd - _g);
+  _bd.tail(3) = (rotM * _Ib * rotM.transpose()) * dWbd;
@@ -75,6 +80,6 @@
-void BalanceCtrl::calConstraints(VecInt4 contact){
-    int contactLegNum = 0;
-    for(int i(0); i&lt;4; ++i){
-        if(contact(i) == 1){
-            contactLegNum += 1;
-        }
+void BalanceCtrl::calConstraints(VecInt4 contact)
+{
+  int contactLegNum = 0;
+  for (int i(0); i &lt; 4; ++i) {
+    if (contact(i) == 1) {
+      contactLegNum += 1;
@@ -81,0 +87 @@
+  }
@@ -83,4 +89,4 @@
-    _CI.resize(5*contactLegNum, 12);
-    _ci0.resize(5*contactLegNum);
-    _CE.resize(3*(4 - contactLegNum), 12);
-    _ce0.resize(3*(4 - contactLegNum));
+  _CI.resize(5 * contactLegNum, 12);
+  _ci0.resize(5 * contactLegNum);
+  _CE.resize(3 * (4 - contactLegNum), 12);
+  _ce0.resize(3 * (4 - contactLegNum));
@@ -88,4 +94,4 @@
-    _CI.setZero();
-    _ci0.setZero();
-    _CE.setZero();
-    _ce0.setZero();
+  _CI.setZero();
+  _ci0.setZero();
+  _CE.setZero();
+  _ce0.setZero();
@@ -93,10 +99,9 @@
-    int ceID = 0;
-    int ciID = 0;
-    for(int i(0); i&lt;4; ++i){
-        if(contact(i) == 1){
-            _CI.block(5*ciID, 3*i, 5, 3) = _fricMat;
-            ++ciID;
-        }else{
-            _CE.block(3*ceID, 3*i, 3, 3) = I3;
-            ++ceID;
-        }
+  int ceID = 0;
+  int ciID = 0;
+  for (int i(0); i &lt; 4; ++i) {
+    if (contact(i) == 1) {
+      _CI.block(5 * ciID, 3 * i, 5, 3) = _fricMat;
+      ++ciID;
+    } else {
+      _CE.block(3 * ceID, 3 * i, 3, 3) = I3;
+      ++ceID;
@@ -103,0 +109 @@
+  }
@@ -106,4 +112,5 @@
-void BalanceCtrl::solveQP(){
-    int n = _F.size();
-    int m = _ce0.size();
-    int p = _ci0.size();
+void BalanceCtrl::solveQP()
+{
+  int n = _F.size();
+  int m = _ce0.size();
+  int p = _ci0.size();
@@ -111,7 +118,7 @@
-    G.resize(n, n);
-    CE.resize(n, m);
-    CI.resize(n, p);
-    g0.resize(n);
-    ce0.resize(m);
-    ci0.resize(p);
-    x.resize(n);
+  G.resize(n, n);
+  CE.resize(n, m);
+  CI.resize(n, p);
+  g0.resize(n);
+  ce0.resize(m);
+  ci0.resize(p);
+  x.resize(n);
@@ -119,4 +126,3 @@
-    for (int i = 0; i &lt; n; ++i) {
-        for (int j = 0; j &lt; n; ++j) {
-            G[i][j] = _G(i, j);
-        }
+  for (int i = 0; i &lt; n; ++i) {
+    for (int j = 0; j &lt; n; ++j) {
+      G[i][j] = _G(i, j);
@@ -123,0 +130 @@
+  }
@@ -125,4 +132,3 @@
-    for (int i = 0; i &lt; n; ++i) {
-        for (int j = 0; j &lt; m; ++j) {
-            CE[i][j] = (_CE.transpose())(i, j);
-        }
+  for (int i = 0; i &lt; n; ++i) {
+    for (int j = 0; j &lt; m; ++j) {
+      CE[i][j] = (_CE.transpose())(i, j);
@@ -129,0 +136 @@
+  }
@@ -131,4 +138,3 @@
-    for (int i = 0; i &lt; n; ++i) {
-        for (int j = 0; j &lt; p; ++j) {
-            CI[i][j] = (_CI.transpose())(i, j);
-        }
+  for (int i = 0; i &lt; n; ++i) {
+    for (int j = 0; j &lt; p; ++j) {
+      CI[i][j] = (_CI.transpose())(i, j);
@@ -135,0 +142 @@
+  }
@@ -137,3 +144,3 @@
-    for (int i = 0; i &lt; n; ++i) {
-        g0[i] = _g0T[i];
-    }
+  for (int i = 0; i &lt; n; ++i) {
+    g0[i] = _g0T[i];
+  }
@@ -141,3 +148,3 @@
-    for (int i = 0; i &lt; m; ++i) {
-        ce0[i] = _ce0[i];
-    }
+  for (int i = 0; i &lt; m; ++i) {
+    ce0[i] = _ce0[i];
+  }
@@ -145,3 +152,3 @@
-    for (int i = 0; i &lt; p; ++i) {
-        ci0[i] = _ci0[i];
-    }
+  for (int i = 0; i &lt; p; ++i) {
+    ci0[i] = _ci0[i];
+  }
@@ -149 +156 @@
-    double value = solve_quadprog(G, g0, CE, ce0, CI, ci0, x);
+  double value = solve_quadprog(G, g0, CE, ce0, CI, ci0, x);
@@ -151,4 +158,4 @@
-    for (int i = 0; i &lt; n; ++i) {
-        _F[i] = x[i];
-    }
-}
+  for (int i = 0; i &lt; n; ++i) {
+    _F[i] = x[i];
+  }
+}

Code style divergence in file 'src/control/ControlFrame.cpp':

--- src/control/ControlFrame.cpp
+++ src/control/ControlFrame.cpp.uncrustify
@@ -6,2 +6,4 @@
-ControlFrame::ControlFrame(CtrlComponents *ctrlComp):_ctrlComp(ctrlComp){
-    _FSMController = new FSM(_ctrlComp);
+ControlFrame::ControlFrame(CtrlComponents * ctrlComp)
+: _ctrlComp(ctrlComp)
+{
+  _FSMController = new FSM(_ctrlComp);
@@ -10,3 +12,4 @@
-void ControlFrame::run(){
-    _FSMController-&gt;run();
-}
+void ControlFrame::run()
+{
+  _FSMController-&gt;run();
+}

Code style divergence in file 'src/control/Estimator.cpp':

--- src/control/Estimator.cpp
+++ src/control/Estimator.cpp.uncrustify
@@ -8,24 +8,25 @@
-Estimator::Estimator(QuadrupedRobot *robotModel, LowlevelState* lowState, 
-                     VecInt4 *contact, Vec4 *phase, double dt, Vec18 Qdig,
-                     std::string testName)
-          :_robModel(robotModel), _lowState(lowState), _contact(contact),
-           _phase(phase), _dt(dt), _Qdig(Qdig), _estName(testName){
-
-    _initSystem();
-}
-
-Estimator::Estimator(QuadrupedRobot *robotModel, LowlevelState* lowState, 
-                     VecInt4 *contact, Vec4 *phase, double dt)
-          :_robModel(robotModel), _lowState(lowState), _contact(contact), 
-           _phase(phase), _dt(dt){
-
-    for(int i(0); i&lt;_Qdig.rows(); ++i){
-        if(i &lt; 3){
-            _Qdig(i) = 0.0003;
-        }
-        else if(i &lt; 6){
-            _Qdig(i) = 0.0003;
-        }
-        else{
-            _Qdig(i) = 0.01;
-        }
+Estimator::Estimator(
+  QuadrupedRobot * robotModel, LowlevelState * lowState,
+  VecInt4 * contact, Vec4 * phase, double dt, Vec18 Qdig,
+  std::string testName)
+: _robModel(robotModel), _lowState(lowState), _contact(contact),
+  _phase(phase), _dt(dt), _Qdig(Qdig), _estName(testName)
+{
+
+  _initSystem();
+}
+
+Estimator::Estimator(
+  QuadrupedRobot * robotModel, LowlevelState * lowState,
+  VecInt4 * contact, Vec4 * phase, double dt)
+: _robModel(robotModel), _lowState(lowState), _contact(contact),
+  _phase(phase), _dt(dt)
+{
+
+  for (int i(0); i &lt; _Qdig.rows(); ++i) {
+    if (i &lt; 3) {
+      _Qdig(i) = 0.0003;
+    } else if (i &lt; 6) {
+      _Qdig(i) = 0.0003;
+    } else {
+      _Qdig(i) = 0.01;
@@ -33,86 +34,145 @@
-
-    _estName = "current";
-
-    _initSystem();
-
-}
-
-Estimator::~Estimator(){
-}
-
-void Estimator::_initSystem(){
-    _g &lt;&lt; 0, 0, -9.81;
-    _largeVariance = 100;
-
-    _xhat.setZero();
-    _u.setZero();
-    _A.setZero();
-    _A.block(0, 0, 3, 3) = I3;
-    _A.block(0, 3, 3, 3) = I3 * _dt;
-    _A.block(3, 3, 3, 3) = I3;
-    _A.block(6, 6, 12, 12) = I12;
-    _B.setZero();
-    _B.block(3, 0, 3, 3) = I3 * _dt;
-    _C.setZero();
-    _C.block(0, 0, 3, 3) = -I3;
-    _C.block(3, 0, 3, 3) = -I3;
-    _C.block(6, 0, 3, 3) = -I3;
-    _C.block(9, 0, 3, 3) = -I3;
-    _C.block(12, 3, 3, 3) = -I3;
-    _C.block(15, 3, 3, 3) = -I3;
-    _C.block(18, 3, 3, 3) = -I3;
-    _C.block(21, 3, 3, 3) = -I3;
-    _C.block(0, 6, 12, 12) = I12;
-    _C(24, 8) = 1;
-    _C(25, 11) = 1;
-    _C(26, 14) = 1;
-    _C(27, 17) = 1;
-    _P.setIdentity();
-    _P = _largeVariance * _P;
-
-    _RInit &lt;&lt;  0.008 , 0.012 ,-0.000 ,-0.009 , 0.012 , 0.000 , 0.009 ,-0.009 ,-0.000 ,-0.009 ,-0.009 , 0.000 ,-0.000 , 0.000 ,-0.000 , 0.000 ,-0.000 ,-0.001 ,-0.002 , 0.000 ,-0.000 ,-0.003 ,-0.000 ,-0.001 , 0.000 , 0.000 , 0.000 , 0.000,
-               0.012 , 0.019 ,-0.001 ,-0.014 , 0.018 ,-0.000 , 0.014 ,-0.013 ,-0.000 ,-0.014 ,-0.014 , 0.001 ,-0.001 , 0.001 ,-0.001 , 0.000 , 0.000 ,-0.001 ,-0.003 , 0.000 ,-0.001 ,-0.004 ,-0.000 ,-0.001 , 0.000 , 0.000 , 0.000 , 0.000,
-               -0.000, -0.001,  0.001,  0.001, -0.001,  0.000, -0.000,  0.000, -0.000,  0.001,  0.000, -0.000,  0.000, -0.000,  0.000,  0.000, -0.000, -0.000,  0.000, -0.000, -0.000, -0.000,  0.000,  0.000,  0.000,  0.000,  0.000,  0.000,
-               -0.009, -0.014,  0.001,  0.010, -0.013,  0.000, -0.010,  0.010,  0.000,  0.010,  0.010, -0.000,  0.001,  0.000,  0.000,  0.001, -0.000,  0.001,  0.002, -0.000,  0.000,  0.003,  0.000,  0.001,  0.000,  0.000,  0.000,  0.000,
-               0.012 , 0.018 ,-0.001 ,-0.013 , 0.018 ,-0.000 , 0.013 ,-0.013 ,-0.000 ,-0.013 ,-0.013 , 0.001 ,-0.001 , 0.000 ,-0.001 , 0.000 , 0.001 ,-0.001 ,-0.003 , 0.000 ,-0.001 ,-0.004 ,-0.000 ,-0.001 , 0.000 , 0.000 , 0.000 , 0.000,
-               0.000 ,-0.000 , 0.000 , 0.000 ,-0.000 , 0.001 , 0.000 , 0.000 ,-0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 , 0.000 ,-0.000 , 0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 ,-0.000 ,-0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000,
-               0.009 , 0.014 ,-0.000 ,-0.010 , 0.013 , 0.000 , 0.010 ,-0.010 ,-0.000 ,-0.010 ,-0.010 , 0.000 ,-0.001 , 0.000 ,-0.001 , 0.000 ,-0.000 ,-0.001 ,-0.001 , 0.000 ,-0.000 ,-0.003 ,-0.000 ,-0.001 , 0.000 , 0.000 , 0.000 , 0.000,
-               -0.009, -0.013,  0.000,  0.010, -0.013,  0.000, -0.010,  0.009,  0.000,  0.010,  0.010, -0.000,  0.001, -0.000,  0.000, -0.000,  0.000,  0.001,  0.002,  0.000,  0.000,  0.003,  0.000,  0.001,  0.000,  0.000,  0.000,  0.000,
-               -0.000, -0.000, -0.000,  0.000, -0.000, -0.000, -0.000,  0.000,  0.001,  0.000,  0.000,  0.000,  0.000, -0.000,  0.000, -0.000,  0.000, -0.000,  0.000, -0.000,  0.000,  0.000, -0.000, -0.000,  0.000,  0.000,  0.000,  0.000,
-               -0.009, -0.014,  0.001,  0.010, -0.013,  0.000, -0.010,  0.010,  0.000,  0.010,  0.010, -0.000,  0.001,  0.000,  0.000, -0.000, -0.000,  0.001,  0.002, -0.000,  0.000,  0.003,  0.000,  0.001,  0.000,  0.000,  0.000,  0.000,
-               -0.009, -0.014,  0.000,  0.010, -0.013,  0.000, -0.010,  0.010,  0.000,  0.010,  0.010, -0.000,  0.001, -0.000,  0.000, -0.000,  0.000,  0.001,  0.002, -0.000,  0.000,  0.003,  0.001,  0.001,  0.000,  0.000,  0.000,  0.000,
-               0.000 , 0.001 ,-0.000 ,-0.000 , 0.001 ,-0.000 , 0.000 ,-0.000 , 0.000 ,-0.000 ,-0.000 , 0.001 , 0.000 ,-0.000 ,-0.000 ,-0.000 , 0.000 , 0.000 ,-0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000,
-               -0.000, -0.001,  0.000,  0.001, -0.001, -0.000, -0.001,  0.001,  0.000,  0.001,  0.001,  0.000,  1.708,  0.048,  0.784,  0.062,  0.042,  0.053,  0.077,  0.001, -0.061,  0.046, -0.019, -0.029,  0.000,  0.000,  0.000,  0.000,
-               0.000 , 0.001 ,-0.000 , 0.000 , 0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 , 0.000 ,-0.000 ,-0.000 , 0.048 , 5.001 ,-1.631 ,-0.036 , 0.144 , 0.040 , 0.036 , 0.016 ,-0.051 ,-0.067 ,-0.024 ,-0.005 , 0.000 , 0.000 , 0.000 , 0.000,
-               -0.000, -0.001,  0.000,  0.000, -0.001, -0.000, -0.001,  0.000,  0.000,  0.000,  0.000, -0.000,  0.784, -1.631,  1.242,  0.057, -0.037,  0.018,  0.034, -0.017, -0.015,  0.058, -0.021, -0.029,  0.000,  0.000,  0.000,  0.000,
-               0.000 , 0.000 , 0.000 , 0.001 , 0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 ,-0.000 ,-0.000 ,-0.000 , 0.062 ,-0.036 , 0.057 , 6.228 ,-0.014 , 0.932 , 0.059 , 0.053 ,-0.069 , 0.148 , 0.015 ,-0.031 , 0.000 , 0.000 , 0.000 , 0.000,
-               -0.000,  0.000, -0.000, -0.000,  0.001,  0.000, -0.000,  0.000,  0.000, -0.000,  0.000,  0.000,  0.042,  0.144, -0.037, -0.014,  3.011,  0.986,  0.076,  0.030, -0.052, -0.027,  0.057,  0.051,  0.000,  0.000,  0.000,  0.000,
-               -0.001, -0.001, -0.000,  0.001, -0.001,  0.000, -0.001,  0.001, -0.000,  0.001,  0.001,  0.000,  0.053,  0.040,  0.018,  0.932,  0.986,  0.885,  0.090,  0.044, -0.055,  0.057,  0.051, -0.003,  0.000,  0.000,  0.000,  0.000,
-               -0.002, -0.003,  0.000,  0.002, -0.003, -0.000, -0.001,  0.002,  0.000,  0.002,  0.002, -0.000,  0.077,  0.036,  0.034,  0.059,  0.076,  0.090,  6.230,  0.139,  0.763,  0.013, -0.019, -0.024,  0.000,  0.000,  0.000,  0.000,
-               0.000 , 0.000 ,-0.000 ,-0.000 , 0.000 ,-0.000 , 0.000 , 0.000 ,-0.000 ,-0.000 ,-0.000 , 0.000 , 0.001 , 0.016 ,-0.017 , 0.053 , 0.030 , 0.044 , 0.139 , 3.130 ,-1.128 ,-0.010 , 0.131 , 0.018 , 0.000 , 0.000 , 0.000 , 0.000,
-               -0.000, -0.001, -0.000,  0.000, -0.001, -0.000, -0.000,  0.000,  0.000,  0.000,  0.000,  0.000, -0.061, -0.051, -0.015, -0.069, -0.052, -0.055,  0.763, -1.128,  0.866, -0.022, -0.053,  0.007,  0.000,  0.000,  0.000,  0.000,
-               -0.003, -0.004, -0.000,  0.003, -0.004, -0.000, -0.003,  0.003,  0.000,  0.003,  0.003,  0.000,  0.046, -0.067,  0.058,  0.148, -0.027,  0.057,  0.013, -0.010, -0.022,  2.437, -0.102,  0.938,  0.000,  0.000,  0.000,  0.000,
-               -0.000, -0.000,  0.000,  0.000, -0.000,  0.000, -0.000,  0.000, -0.000,  0.000,  0.001,  0.000, -0.019, -0.024, -0.021,  0.015,  0.057,  0.051, -0.019,  0.131, -0.053, -0.102,  4.944,  1.724,  0.000,  0.000,  0.000,  0.000,
-               -0.001, -0.001,  0.000,  0.001, -0.001,  0.000, -0.001,  0.001, -0.000,  0.001,  0.001,  0.000, -0.029, -0.005, -0.029, -0.031,  0.051, -0.003, -0.024,  0.018,  0.007,  0.938,  1.724,  1.569,  0.000,  0.000,  0.000,  0.000,
-               0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 1.0 , 0.000 , 0.000 , 0.000,
-               0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 1.0 , 0.000 , 0.000,
-               0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 1.0 , 0.000,
-               0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 0.000 , 1.0;
-
-    /* A1 Worked */
-    _Cu &lt;&lt;   268.573,  -43.819, -147.211,
-            -43.819 ,  92.949 ,  58.082,
-            -147.211,   58.082,  302.120;
-
-    _QInit = _Qdig.asDiagonal();
-    _QInit +=  _B * _Cu * _B.transpose();
-
-    _RCheck  = new AvgCov(28, _estName + " R");
-    _uCheck  = new AvgCov(3,  _estName + " u");
-
-    _vxFilter = new LPFilter(_dt, 3.0);
-    _vyFilter = new LPFilter(_dt, 3.0);
-    _vzFilter = new LPFilter(_dt, 3.0);
-
-
-    /* ROS odometry publisher */
+  }
+
+  _estName = "current";
+
+  _initSystem();
+
+}
+
+Estimator::~Estimator()
+{
+}
+
+void Estimator::_initSystem()
+{
+  _g &lt;&lt; 0, 0, -9.81;
+  _largeVariance = 100;
+
+  _xhat.setZero();
+  _u.setZero();
+  _A.setZero();
+  _A.block(0, 0, 3, 3) = I3;
+  _A.block(0, 3, 3, 3) = I3 * _dt;
+  _A.block(3, 3, 3, 3) = I3;
+  _A.block(6, 6, 12, 12) = I12;
+  _B.setZero();
+  _B.block(3, 0, 3, 3) = I3 * _dt;
+  _C.setZero();
+  _C.block(0, 0, 3, 3) = -I3;
+  _C.block(3, 0, 3, 3) = -I3;
+  _C.block(6, 0, 3, 3) = -I3;
+  _C.block(9, 0, 3, 3) = -I3;
+  _C.block(12, 3, 3, 3) = -I3;
+  _C.block(15, 3, 3, 3) = -I3;
+  _C.block(18, 3, 3, 3) = -I3;
+  _C.block(21, 3, 3, 3) = -I3;
+  _C.block(0, 6, 12, 12) = I12;
+  _C(24, 8) = 1;
+  _C(25, 11) = 1;
+  _C(26, 14) = 1;
+  _C(27, 17) = 1;
+  _P.setIdentity();
+  _P = _largeVariance * _P;
+
+  _RInit &lt;&lt; 0.008, 0.012, -0.000, -0.009, 0.012, 0.000, 0.009, -0.009, -0.000, -0.009, -0.009,
+    0.000, -0.000, 0.000, -0.000, 0.000, -0.000, -0.001, -0.002, 0.000, -0.000, -0.003, -0.000,
+    -0.001, 0.000, 0.000, 0.000, 0.000,
+    0.012, 0.019, -0.001, -0.014, 0.018, -0.000, 0.014, -0.013, -0.000, -0.014, -0.014, 0.001,
+    -0.001, 0.001, -0.001, 0.000, 0.000, -0.001, -0.003, 0.000, -0.001, -0.004, -0.000, -0.001,
+    0.000, 0.000, 0.000, 0.000,
+    -0.000, -0.001, 0.001, 0.001, -0.001, 0.000, -0.000, 0.000, -0.000, 0.001, 0.000, -0.000, 0.000,
+    -0.000, 0.000, 0.000, -0.000, -0.000, 0.000, -0.000, -0.000, -0.000, 0.000, 0.000, 0.000, 0.000,
+    0.000, 0.000,
+    -0.009, -0.014, 0.001, 0.010, -0.013, 0.000, -0.010, 0.010, 0.000, 0.010, 0.010, -0.000, 0.001,
+    0.000, 0.000, 0.001, -0.000, 0.001, 0.002, -0.000, 0.000, 0.003, 0.000, 0.001, 0.000, 0.000,
+    0.000, 0.000,
+    0.012, 0.018, -0.001, -0.013, 0.018, -0.000, 0.013, -0.013, -0.000, -0.013, -0.013, 0.001,
+    -0.001, 0.000, -0.001, 0.000, 0.001, -0.001, -0.003, 0.000, -0.001, -0.004, -0.000, -0.001,
+    0.000, 0.000, 0.000, 0.000,
+    0.000, -0.000, 0.000, 0.000, -0.000, 0.001, 0.000, 0.000, -0.000, 0.000, 0.000, -0.000, -0.000,
+    0.000, -0.000, 0.000, 0.000, 0.000, -0.000, -0.000, -0.000, -0.000, 0.000, 0.000, 0.000, 0.000,
+    0.000, 0.000,
+    0.009, 0.014, -0.000, -0.010, 0.013, 0.000, 0.010, -0.010, -0.000, -0.010, -0.010, 0.000,
+    -0.001, 0.000, -0.001, 0.000, -0.000, -0.001, -0.001, 0.000, -0.000, -0.003, -0.000, -0.001,
+    0.000, 0.000, 0.000, 0.000,
+    -0.009, -0.013, 0.000, 0.010, -0.013, 0.000, -0.010, 0.009, 0.000, 0.010, 0.010, -0.000, 0.001,
+    -0.000, 0.000, -0.000, 0.000, 0.001, 0.002, 0.000, 0.000, 0.003, 0.000, 0.001, 0.000, 0.000,
+    0.000, 0.000,
+    -0.000, -0.000, -0.000, 0.000, -0.000, -0.000, -0.000, 0.000, 0.001, 0.000, 0.000, 0.000, 0.000,
+    -0.000, 0.000, -0.000, 0.000, -0.000, 0.000, -0.000, 0.000, 0.000, -0.000, -0.000, 0.000, 0.000,
+    0.000, 0.000,
+    -0.009, -0.014, 0.001, 0.010, -0.013, 0.000, -0.010, 0.010, 0.000, 0.010, 0.010, -0.000, 0.001,
+    0.000, 0.000, -0.000, -0.000, 0.001, 0.002, -0.000, 0.000, 0.003, 0.000, 0.001, 0.000, 0.000,
+    0.000, 0.000,
+    -0.009, -0.014, 0.000, 0.010, -0.013, 0.000, -0.010, 0.010, 0.000, 0.010, 0.010, -0.000, 0.001,
+    -0.000, 0.000, -0.000, 0.000, 0.001, 0.002, -0.000, 0.000, 0.003, 0.001, 0.001, 0.000, 0.000,
+    0.000, 0.000,
+    0.000, 0.001, -0.000, -0.000, 0.001, -0.000, 0.000, -0.000, 0.000, -0.000, -0.000, 0.001, 0.000,
+    -0.000, -0.000, -0.000, 0.000, 0.000, -0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
+    0.000, 0.000,
+    -0.000, -0.001, 0.000, 0.001, -0.001, -0.000, -0.001, 0.001, 0.000, 0.001, 0.001, 0.000, 1.708,
+    0.048, 0.784, 0.062, 0.042, 0.053, 0.077, 0.001, -0.061, 0.046, -0.019, -0.029, 0.000, 0.000,
+    0.000, 0.000,
+    0.000, 0.001, -0.000, 0.000, 0.000, 0.000, 0.000, -0.000, -0.000, 0.000, -0.000, -0.000, 0.048,
+    5.001, -1.631, -0.036, 0.144, 0.040, 0.036, 0.016, -0.051, -0.067, -0.024, -0.005, 0.000, 0.000,
+    0.000, 0.000,
+    -0.000, -0.001, 0.000, 0.000, -0.001, -0.000, -0.001, 0.000, 0.000, 0.000, 0.000, -0.000, 0.784,
+    -1.631, 1.242, 0.057, -0.037, 0.018, 0.034, -0.017, -0.015, 0.058, -0.021, -0.029, 0.000, 0.000,
+    0.000, 0.000,
+    0.000, 0.000, 0.000, 0.001, 0.000, 0.000, 0.000, -0.000, -0.000, -0.000, -0.000, -0.000, 0.062,
+    -0.036, 0.057, 6.228, -0.014, 0.932, 0.059, 0.053, -0.069, 0.148, 0.015, -0.031, 0.000, 0.000,
+    0.000, 0.000,
+    -0.000, 0.000, -0.000, -0.000, 0.001, 0.000, -0.000, 0.000, 0.000, -0.000, 0.000, 0.000, 0.042,
+    0.144, -0.037, -0.014, 3.011, 0.986, 0.076, 0.030, -0.052, -0.027, 0.057, 0.051, 0.000, 0.000,
+    0.000, 0.000,
+    -0.001, -0.001, -0.000, 0.001, -0.001, 0.000, -0.001, 0.001, -0.000, 0.001, 0.001, 0.000, 0.053,
+    0.040, 0.018, 0.932, 0.986, 0.885, 0.090, 0.044, -0.055, 0.057, 0.051, -0.003, 0.000, 0.000,
+    0.000, 0.000,
+    -0.002, -0.003, 0.000, 0.002, -0.003, -0.000, -0.001, 0.002, 0.000, 0.002, 0.002, -0.000, 0.077,
+    0.036, 0.034, 0.059, 0.076, 0.090, 6.230, 0.139, 0.763, 0.013, -0.019, -0.024, 0.000, 0.000,
+    0.000, 0.000,
+    0.000, 0.000, -0.000, -0.000, 0.000, -0.000, 0.000, 0.000, -0.000, -0.000, -0.000, 0.000, 0.001,
+    0.016, -0.017, 0.053, 0.030, 0.044, 0.139, 3.130, -1.128, -0.010, 0.131, 0.018, 0.000, 0.000,
+    0.000, 0.000,
+    -0.000, -0.001, -0.000, 0.000, -0.001, -0.000, -0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
+    -0.061, -0.051, -0.015, -0.069, -0.052, -0.055, 0.763, -1.128, 0.866, -0.022, -0.053, 0.007,
+    0.000, 0.000, 0.000, 0.000,
+    -0.003, -0.004, -0.000, 0.003, -0.004, -0.000, -0.003, 0.003, 0.000, 0.003, 0.003, 0.000, 0.046,
+    -0.067, 0.058, 0.148, -0.027, 0.057, 0.013, -0.010, -0.022, 2.437, -0.102, 0.938, 0.000, 0.000,
+    0.000, 0.000,
+    -0.000, -0.000, 0.000, 0.000, -0.000, 0.000, -0.000, 0.000, -0.000, 0.000, 0.001, 0.000, -0.019,
+    -0.024, -0.021, 0.015, 0.057, 0.051, -0.019, 0.131, -0.053, -0.102, 4.944, 1.724, 0.000, 0.000,
+    0.000, 0.000,
+    -0.001, -0.001, 0.000, 0.001, -0.001, 0.000, -0.001, 0.001, -0.000, 0.001, 0.001, 0.000, -0.029,
+    -0.005, -0.029, -0.031, 0.051, -0.003, -0.024, 0.018, 0.007, 0.938, 1.724, 1.569, 0.000, 0.000,
+    0.000, 0.000,
+    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
+    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 1.0, 0.000, 0.000,
+    0.000,
+    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
+    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 1.0, 0.000,
+    0.000,
+    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
+    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 1.0,
+    0.000,
+    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
+    0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000, 0.000,
+    0.000, 1.0;
+
+  /* A1 Worked */
+  _Cu &lt;&lt; 268.573, -43.819, -147.211,
+    -43.819, 92.949, 58.082,
+    -147.211, 58.082, 302.120;
+
+  _QInit = _Qdig.asDiagonal();
+  _QInit += _B * _Cu * _B.transpose();
+
+  _RCheck = new AvgCov(28, _estName + " R");
+  _uCheck = new AvgCov(3, _estName + " u");
+
+  _vxFilter = new LPFilter(_dt, 3.0);
+  _vyFilter = new LPFilter(_dt, 3.0);
+  _vzFilter = new LPFilter(_dt, 3.0);
+
+
+  /* ROS odometry publisher */
@@ -120 +180 @@
-        _pub = _nh.advertise&lt;nav_msgs::Odometry&gt;("odom", 1);
+  _pub = _nh.advertise&lt;nav_msgs::Odometry&gt;("odom", 1);
@@ -124,3 +184,3 @@
-        _nh = rclcpp::Node::make_shared("estimator");
-        _pub = _nh-&gt;create_publisher&lt;nav_msgs::msg::Odometry&gt;("odom", 1);
-        _odomBroadcaster = std::make_shared&lt;tf2_ros::TransformBroadcaster&gt;(_nh); 
+  _nh = rclcpp::Node::make_shared("estimator");
+  _pub = _nh-&gt;create_publisher&lt;nav_msgs::msg::Odometry&gt;("odom", 1);
+  _odomBroadcaster = std::make_shared&lt;tf2_ros::TransformBroadcaster&gt;(_nh);
@@ -130,22 +190,21 @@
-void Estimator::run(){
-    _feetH.setZero();
-    _feetPosGlobalKine = _robModel-&gt;getFeet2BPositions(*_lowState, FrameType::GLOBAL);
-    _feetVelGlobalKine = _robModel-&gt;getFeet2BVelocities(*_lowState, FrameType::GLOBAL);
-
-    _Q = _QInit;
-    _R = _RInit;
-
-    for(int i(0); i &lt; 4; ++i){
-        if((*_contact)(i) == 0){
-            _Q.block(6+3*i, 6+3*i, 3, 3) = _largeVariance * I3;
-            _R.block(12+3*i, 12+3*i, 3, 3) = _largeVariance * I3;
-            _R(24+i, 24+i) = _largeVariance;
-        }
-        else{
-            _trust = windowFunc((*_phase)(i), 0.2);
-            _Q.block(6+3*i, 6+3*i, 3, 3) = (1 + (1-_trust)*_largeVariance) * _QInit.block(6+3*i, 6+3*i, 3, 3);
-            _R.block(12+3*i, 12+3*i, 3, 3) = (1 + (1-_trust)*_largeVariance) * _RInit.block(12+3*i, 12+3*i, 3, 3);
-            _R(24+i, 24+i) = (1 + (1-_trust)*_largeVariance) * _RInit(24+i, 24+i);
-        }
-        _feetPos2Body.segment(3*i, 3) = _feetPosGlobalKine.col(i);
-        _feetVel2Body.segment(3*i, 3) = _feetVelGlobalKine.col(i);
+void Estimator::run()
+{
+  _feetH.setZero();
+  _feetPosGlobalKine = _robModel-&gt;getFeet2BPositions(*_lowState, FrameType::GLOBAL);
+  _feetVelGlobalKine = _robModel-&gt;getFeet2BVelocities(*_lowState, FrameType::GLOBAL);
+
+  _Q = _QInit;
+  _R = _RInit;
+
+  for (int i(0); i &lt; 4; ++i) {
+    if ((*_contact)(i) == 0) {
+      _Q.block(6 + 3 * i, 6 + 3 * i, 3, 3) = _largeVariance * I3;
+      _R.block(12 + 3 * i, 12 + 3 * i, 3, 3) = _largeVariance * I3;
+      _R(24 + i, 24 + i) = _largeVariance;
+    } else {
+      _trust = windowFunc((*_phase)(i), 0.2);
+      _Q.block(6 + 3 * i, 6 + 3 * i, 3, 3) = (1 + (1 - _trust) * _largeVariance) * _QInit.block(
+        6 + 3 * i, 6 + 3 * i, 3, 3);
+      _R.block(12 + 3 * i, 12 + 3 * i, 3, 3) = (1 + (1 - _trust) * _largeVariance) * _RInit.block(
+        12 + 3 * i, 12 + 3 * i, 3, 3);
+      _R(24 + i, 24 + i) = (1 + (1 - _trust) * _largeVariance) * _RInit(24 + i, 24 + i);
@@ -153,23 +212,26 @@
-
-    _rotMatB2G = _lowState-&gt;getRotMat();
-    _u = _rotMatB2G * _lowState-&gt;getAcc() + _g;
-    _xhat = _A * _xhat + _B * _u;
-    _yhat = _C * _xhat;
-    _y &lt;&lt; _feetPos2Body, _feetVel2Body, _feetH;
-
-    _Ppriori = _A * _P * _A.transpose() + _Q;
-    _S =  _R + _C * _Ppriori * _C.transpose();
-    _Slu = _S.lu();
-    _Sy = _Slu.solve(_y - _yhat);
-    _Sc = _Slu.solve(_C);
-    _SR = _Slu.solve(_R);
-    _STC = (_S.transpose()).lu().solve(_C);
-    _IKC = I18 - _Ppriori*_C.transpose()*_Sc;
-
-    _xhat += _Ppriori * _C.transpose() * _Sy;
-    _P =  _IKC * _Ppriori * _IKC.transpose()
-        + _Ppriori * _C.transpose() * _SR * _STC * _Ppriori.transpose();
-
-    _vxFilter-&gt;addValue(_xhat(3));
-    _vyFilter-&gt;addValue(_xhat(4));
-    _vzFilter-&gt;addValue(_xhat(5));
+    _feetPos2Body.segment(3 * i, 3) = _feetPosGlobalKine.col(i);
+    _feetVel2Body.segment(3 * i, 3) = _feetVelGlobalKine.col(i);
+  }
+
+  _rotMatB2G = _lowState-&gt;getRotMat();
+  _u = _rotMatB2G * _lowState-&gt;getAcc() + _g;
+  _xhat = _A * _xhat + _B * _u;
+  _yhat = _C * _xhat;
+  _y &lt;&lt; _feetPos2Body, _feetVel2Body, _feetH;
+
+  _Ppriori = _A * _P * _A.transpose() + _Q;
+  _S = _R + _C * _Ppriori * _C.transpose();
+  _Slu = _S.lu();
+  _Sy = _Slu.solve(_y - _yhat);
+  _Sc = _Slu.solve(_C);
+  _SR = _Slu.solve(_R);
+  _STC = (_S.transpose()).lu().solve(_C);
+  _IKC = I18 - _Ppriori * _C.transpose() * _Sc;
+
+  _xhat += _Ppriori * _C.transpose() * _Sy;
+  _P = _IKC * _Ppriori * _IKC.transpose() +
+    _Ppriori * _C.transpose() * _SR * _STC * _Ppriori.transpose();
+
+  _vxFilter-&gt;addValue(_xhat(3));
+  _vyFilter-&gt;addValue(_xhat(4));
+  _vzFilter-&gt;addValue(_xhat(5));
@@ -178,46 +240,46 @@
-        if(_count % ((int)( 1.0/(_dt*_pubFreq))) == 0){
-            _currentTime = ros::Time::now();
-            /* tf */
-            _odomTF.header.stamp = _currentTime;
-            _odomTF.header.frame_id = "odom";
-            _odomTF.child_frame_id  = "base_link";
-
-            _odomTF.transform.translation.x = _xhat(0);
-            _odomTF.transform.translation.y = _xhat(1);
-            _odomTF.transform.translation.z = _xhat(2);
-            _odomTF.transform.rotation.w = _lowState-&gt;imu.quaternion[0];
-            _odomTF.transform.rotation.x = _lowState-&gt;imu.quaternion[1];
-            _odomTF.transform.rotation.y = _lowState-&gt;imu.quaternion[2];
-            _odomTF.transform.rotation.z = _lowState-&gt;imu.quaternion[3];
-
-            _odomBroadcaster.sendTransform(_odomTF);
-
-            /* odometry */
-            _odomMsg.header.stamp = _currentTime;
-            _odomMsg.header.frame_id = "odom";
-
-            _odomMsg.pose.pose.position.x = _xhat(0);
-            _odomMsg.pose.pose.position.y = _xhat(1);
-            _odomMsg.pose.pose.position.z = _xhat(2);
-
-            _odomMsg.pose.pose.orientation.w = _lowState-&gt;imu.quaternion[0];
-            _odomMsg.pose.pose.orientation.x = _lowState-&gt;imu.quaternion[1];
-            _odomMsg.pose.pose.orientation.y = _lowState-&gt;imu.quaternion[2];
-            _odomMsg.pose.pose.orientation.z = _lowState-&gt;imu.quaternion[3];
-            _odomMsg.pose.covariance = _odom_pose_covariance;
-
-            _odomMsg.child_frame_id = "base_link";
-            _velBody = _rotMatB2G.transpose() * _xhat.segment(3, 3);
-            _wBody   = _lowState-&gt;imu.getGyro();
-            _odomMsg.twist.twist.linear.x = _velBody(0);
-            _odomMsg.twist.twist.linear.y = _velBody(1);
-            _odomMsg.twist.twist.linear.z = _velBody(2);
-            _odomMsg.twist.twist.angular.x = _wBody(0);
-            _odomMsg.twist.twist.angular.y = _wBody(1);
-            _odomMsg.twist.twist.angular.z = _wBody(2);
-            _odomMsg.twist.covariance = _odom_twist_covariance;
-
-            _pub.publish(_odomMsg);
-            _count = 1;
-        }
-        ++_count;
+  if (_count % ((int)( 1.0 / (_dt * _pubFreq))) == 0) {
+    _currentTime = ros::Time::now();
+    /* tf */
+    _odomTF.header.stamp = _currentTime;
+    _odomTF.header.frame_id = "odom";
+    _odomTF.child_frame_id = "base_link";
+
+    _odomTF.transform.translation.x = _xhat(0);
+    _odomTF.transform.translation.y = _xhat(1);
+    _odomTF.transform.translation.z = _xhat(2);
+    _odomTF.transform.rotation.w = _lowState-&gt;imu.quaternion[0];
+    _odomTF.transform.rotation.x = _lowState-&gt;imu.quaternion[1];
+    _odomTF.transform.rotation.y = _lowState-&gt;imu.quaternion[2];
+    _odomTF.transform.rotation.z = _lowState-&gt;imu.quaternion[3];
+
+    _odomBroadcaster.sendTransform(_odomTF);
+
+    /* odometry */
+    _odomMsg.header.stamp = _currentTime;
+    _odomMsg.header.frame_id = "odom";
+
+    _odomMsg.pose.pose.position.x = _xhat(0);
+    _odomMsg.pose.pose.position.y = _xhat(1);
+    _odomMsg.pose.pose.position.z = _xhat(2);
+
+    _odomMsg.pose.pose.orientation.w = _lowState-&gt;imu.quaternion[0];
+    _odomMsg.pose.pose.orientation.x = _lowState-&gt;imu.quaternion[1];
+    _odomMsg.pose.pose.orientation.y = _lowState-&gt;imu.quaternion[2];
+    _odomMsg.pose.pose.orientation.z = _lowState-&gt;imu.quaternion[3];
+    _odomMsg.pose.covariance = _odom_pose_covariance;
+
+    _odomMsg.child_frame_id = "base_link";
+    _velBody = _rotMatB2G.transpose() * _xhat.segment(3, 3);
+    _wBody = _lowState-&gt;imu.getGyro();
+    _odomMsg.twist.twist.linear.x = _velBody(0);
+    _odomMsg.twist.twist.linear.y = _velBody(1);
+    _odomMsg.twist.twist.linear.z = _velBody(2);
+    _odomMsg.twist.twist.angular.x = _wBody(0);
+    _odomMsg.twist.twist.angular.y = _wBody(1);
+    _odomMsg.twist.twist.angular.z = _wBody(2);
+    _odomMsg.twist.covariance = _odom_twist_covariance;
+
+    _pub.publish(_odomMsg);
+    _count = 1;
+  }
+  ++_count;
@@ -227,46 +289,46 @@
-        if(_count % ((int)( 1.0/(_dt*_pubFreq))) == 0){
-            _currentTime = _nh-&gt;get_clock()-&gt;now();
-            /* tf */
-            _odomTF.header.stamp = _currentTime;
-            _odomTF.header.frame_id = "odom";
-            _odomTF.child_frame_id  = "base";
-
-            _odomTF.transform.translation.x = _xhat(0);
-            _odomTF.transform.translation.y = _xhat(1);
-            _odomTF.transform.translation.z = _xhat(2);
-            _odomTF.transform.rotation.w = _lowState-&gt;imu.quaternion[0];
-            _odomTF.transform.rotation.x = _lowState-&gt;imu.quaternion[1];
-            _odomTF.transform.rotation.y = _lowState-&gt;imu.quaternion[2];
-            _odomTF.transform.rotation.z = _lowState-&gt;imu.quaternion[3];
-
-            // _odomBroadcaster-&gt;sendTransform(_odomTF);
-
-            /* odometry */
-            _odomMsg.header.stamp = _currentTime;
-            _odomMsg.header.frame_id = "odom";
-
-            _odomMsg.pose.pose.position.x = _xhat(0);
-            _odomMsg.pose.pose.position.y = _xhat(1);
-            _odomMsg.pose.pose.position.z = _xhat(2);
-
-            _odomMsg.pose.pose.orientation.w = _lowState-&gt;imu.quaternion[0];
-            _odomMsg.pose.pose.orientation.x = _lowState-&gt;imu.quaternion[1];
-            _odomMsg.pose.pose.orientation.y = _lowState-&gt;imu.quaternion[2];
-            _odomMsg.pose.pose.orientation.z = _lowState-&gt;imu.quaternion[3];
-            _odomMsg.pose.covariance = _odom_pose_covariance;
-
-            _odomMsg.child_frame_id = "base";
-            _velBody = _rotMatB2G.transpose() * _xhat.segment(3, 3);
-            _wBody   = _lowState-&gt;imu.getGyro();
-            _odomMsg.twist.twist.linear.x = _velBody(0);
-            _odomMsg.twist.twist.linear.y = _velBody(1);
-            _odomMsg.twist.twist.linear.z = _velBody(2);
-            _odomMsg.twist.twist.angular.x = _wBody(0);
-            _odomMsg.twist.twist.angular.y = _wBody(1);
-            _odomMsg.twist.twist.angular.z = _wBody(2);
-            _odomMsg.twist.covariance = _odom_twist_covariance;
-
-            // _pub-&gt;publish(_odomMsg);
-            _count = 1;
-        }
-        ++_count;
+  if (_count % ((int)( 1.0 / (_dt * _pubFreq))) == 0) {
+    _currentTime = _nh-&gt;get_clock()-&gt;now();
+    /* tf */
+    _odomTF.header.stamp = _currentTime;
+    _odomTF.header.frame_id = "odom";
+    _odomTF.child_frame_id = "base";
+
+    _odomTF.transform.translation.x = _xhat(0);
+    _odomTF.transform.translation.y = _xhat(1);
+    _odomTF.transform.translation.z = _xhat(2);
+    _odomTF.transform.rotation.w = _lowState-&gt;imu.quaternion[0];
+    _odomTF.transform.rotation.x = _lowState-&gt;imu.quaternion[1];
+    _odomTF.transform.rotation.y = _lowState-&gt;imu.quaternion[2];
+    _odomTF.transform.rotation.z = _lowState-&gt;imu.quaternion[3];
+
+    // _odomBroadcaster-&gt;sendTransform(_odomTF);
+
+    /* odometry */
+    _odomMsg.header.stamp = _currentTime;
+    _odomMsg.header.frame_id = "odom";
+
+    _odomMsg.pose.pose.position.x = _xhat(0);
+    _odomMsg.pose.pose.position.y = _xhat(1);
+    _odomMsg.pose.pose.position.z = _xhat(2);
+
+    _odomMsg.pose.pose.orientation.w = _lowState-&gt;imu.quaternion[0];
+    _odomMsg.pose.pose.orientation.x = _lowState-&gt;imu.quaternion[1];
+    _odomMsg.pose.pose.orientation.y = _lowState-&gt;imu.quaternion[2];
+    _odomMsg.pose.pose.orientation.z = _lowState-&gt;imu.quaternion[3];
+    _odomMsg.pose.covariance = _odom_pose_covariance;
+
+    _odomMsg.child_frame_id = "base";
+    _velBody = _rotMatB2G.transpose() * _xhat.segment(3, 3);
+    _wBody = _lowState-&gt;imu.getGyro();
+    _odomMsg.twist.twist.linear.x = _velBody(0);
+    _odomMsg.twist.twist.linear.y = _velBody(1);
+    _odomMsg.twist.twist.linear.z = _velBody(2);
+    _odomMsg.twist.twist.angular.x = _wBody(0);
+    _odomMsg.twist.twist.angular.y = _wBody(1);
+    _odomMsg.twist.twist.angular.z = _wBody(2);
+    _odomMsg.twist.covariance = _odom_twist_covariance;
+
+    // _pub-&gt;publish(_odomMsg);
+    _count = 1;
+  }
+  ++_count;
@@ -276,36 +338,43 @@
-Vec3 Estimator::getPosition(){
-    return _xhat.segment(0, 3);
-}
-
-Vec3 Estimator::getVelocity(){
-    return _xhat.segment(3, 3);
-}
-
-Vec3 Estimator::getFootPos(int i){
-    return getPosition() + _lowState-&gt;getRotMat() * _robModel-&gt;getFootPosition(*_lowState, i, FrameType::BODY);
-}
-
-Vec34 Estimator::getFeetPos(){
-    Vec34 feetPos;
-    for(int i(0); i &lt; 4; ++i){
-        feetPos.col(i) = getFootPos(i);
-    }
-    return feetPos;
-}
-
-Vec34 Estimator::getFeetVel(){
-    Vec34 feetVel = _robModel-&gt;getFeet2BVelocities(*_lowState, FrameType::GLOBAL);
-    for(int i(0); i &lt; 4; ++i){
-        feetVel.col(i) += getVelocity();
-    }
-    return feetVel;
-}
-
-Vec34 Estimator::getPosFeet2BGlobal(){
-    Vec34 feet2BPos;
-    for(int i(0); i &lt; 4; ++i){
-        feet2BPos.col(i) = getFootPos(i) - getPosition();
-    }
-    return feet2BPos;
-}
-
+Vec3 Estimator::getPosition()
+{
+  return _xhat.segment(0, 3);
+}
+
+Vec3 Estimator::getVelocity()
+{
+  return _xhat.segment(3, 3);
+}
+
+Vec3 Estimator::getFootPos(int i)
+{
+  return getPosition() + _lowState-&gt;getRotMat() * _robModel-&gt;getFootPosition(
+    *_lowState, i,
+    FrameType::BODY);
+}
+
+Vec34 Estimator::getFeetPos()
+{
+  Vec34 feetPos;
+  for (int i(0); i &lt; 4; ++i) {
+    feetPos.col(i) = getFootPos(i);
+  }
+  return feetPos;
+}
+
+Vec34 Estimator::getFeetVel()
+{
+  Vec34 feetVel = _robModel-&gt;getFeet2BVelocities(*_lowState, FrameType::GLOBAL);
+  for (int i(0); i &lt; 4; ++i) {
+    feetVel.col(i) += getVelocity();
+  }
+  return feetVel;
+}
+
+Vec34 Estimator::getPosFeet2BGlobal()
+{
+  Vec34 feet2BPos;
+  for (int i(0); i &lt; 4; ++i) {
+    feet2BPos.col(i) = getFootPos(i) - getPosition();
+  }
+  return feet2BPos;
+}

Code style divergence in file 'src/interface/IOROS.cpp':

--- src/interface/IOROS.cpp
+++ src/interface/IOROS.cpp.uncrustify
@@ -12,95 +12,140 @@
-void RosShutDown(int sig){
-	ROS_INFO("ROS interface shutting down!");
-	ros::shutdown();
-}
-
-IOROS::IOROS():IOInterface(){
-    std::cout &lt;&lt; "The control interface for ROS 2 Gazebo simulation" &lt;&lt; std::endl;
-    ros::param::get("/robot_name", _robot_name);
-    std::cout &lt;&lt; "robot_name: " &lt;&lt; _robot_name &lt;&lt; std::endl;
-
-    // start subscriber
-    initRecv();
-    ros::AsyncSpinner subSpinner(1); // one threads
-    subSpinner.start();
-    usleep(300000);     //wait for subscribers start
-    // initialize publisher
-    initSend();   
-
-    signal(SIGINT, RosShutDown);
-
-    cmdPanel = new KeyBoard();
-}
-
-IOROS::~IOROS(){
-    delete cmdPanel;
-    ros::shutdown();
-}
-
-void IOROS::sendRecv(const LowlevelCmd *cmd, LowlevelState *state){
-    sendCmd(cmd);
-    recvState(state);
-
-    state-&gt;userCmd = cmdPanel-&gt;getUserCmd();
-    state-&gt;userValue = cmdPanel-&gt;getUserValue();
-}
-
-void IOROS::sendCmd(const LowlevelCmd *lowCmd){
-    for(int i(0); i &lt; 12; ++i){
-        _lowCmd.motorCmd[i].mode = lowCmd-&gt;motorCmd[i].mode;
-        _lowCmd.motorCmd[i].q = lowCmd-&gt;motorCmd[i].q;
-        _lowCmd.motorCmd[i].dq = lowCmd-&gt;motorCmd[i].dq;
-        _lowCmd.motorCmd[i].tau = lowCmd-&gt;motorCmd[i].tau;
-        _lowCmd.motorCmd[i].Kd = lowCmd-&gt;motorCmd[i].Kd;
-        _lowCmd.motorCmd[i].Kp = lowCmd-&gt;motorCmd[i].Kp;
-    }
-    for(int m(0); m &lt; 12; ++m){
-        _servo_pub[m].publish(_lowCmd.motorCmd[m]);
-    }
-    ros::spinOnce();
-}
-
-void IOROS::recvState(LowlevelState *state){
-    for(int i(0); i &lt; 12; ++i){
-        state-&gt;motorState[i].q = _lowState.motorState[i].q;
-        state-&gt;motorState[i].dq = _lowState.motorState[i].dq;
-        state-&gt;motorState[i].ddq = _lowState.motorState[i].ddq;
-        state-&gt;motorState[i].tauEst = _lowState.motorState[i].tauEst;
-    }
-    for(int i(0); i &lt; 3; ++i){
-        state-&gt;imu.quaternion[i] = _lowState.imu.quaternion[i];
-        state-&gt;imu.accelerometer[i] = _lowState.imu.accelerometer[i];
-        state-&gt;imu.gyroscope[i] = _lowState.imu.gyroscope[i];
-    }
-    state-&gt;imu.quaternion[3] = _lowState.imu.quaternion[3];
-}
-
-void IOROS::initSend(){
-    _servo_pub[0] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;("/" + _robot_name + "_gazebo/FR_hip_controller/command", 1);
-    _servo_pub[1] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;("/" + _robot_name + "_gazebo/FR_thigh_controller/command", 1);
-    _servo_pub[2] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;("/" + _robot_name + "_gazebo/FR_calf_controller/command", 1);
-    _servo_pub[3] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;("/" + _robot_name + "_gazebo/FL_hip_controller/command", 1);
-    _servo_pub[4] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;("/" + _robot_name + "_gazebo/FL_thigh_controller/command", 1);
-    _servo_pub[5] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;("/" + _robot_name + "_gazebo/FL_calf_controller/command", 1);
-    _servo_pub[6] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;("/" + _robot_name + "_gazebo/RR_hip_controller/command", 1);
-    _servo_pub[7] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;("/" + _robot_name + "_gazebo/RR_thigh_controller/command", 1);
-    _servo_pub[8] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;("/" + _robot_name + "_gazebo/RR_calf_controller/command", 1);
-    _servo_pub[9] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;("/" + _robot_name + "_gazebo/RL_hip_controller/command", 1);
-    _servo_pub[10] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;("/" + _robot_name + "_gazebo/RL_thigh_controller/command", 1);
-    _servo_pub[11] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;("/" + _robot_name + "_gazebo/RL_calf_controller/command", 1);
-}
-
-void IOROS::initRecv(){
-    _imu_sub = _nm.subscribe("/trunk_imu", 1, &amp;IOROS::imuCallback, this);
-    _servo_sub[0] = _nm.subscribe("/" + _robot_name + "_gazebo/FR_hip_controller/state", 1, &amp;IOROS::FRhipCallback, this);
-    _servo_sub[1] = _nm.subscribe("/" + _robot_name + "_gazebo/FR_thigh_controller/state", 1, &amp;IOROS::FRthighCallback, this);
-    _servo_sub[2] = _nm.subscribe("/" + _robot_name + "_gazebo/FR_calf_controller/state", 1, &amp;IOROS::FRcalfCallback, this);
-    _servo_sub[3] = _nm.subscribe("/" + _robot_name + "_gazebo/FL_hip_controller/state", 1, &amp;IOROS::FLhipCallback, this);
-    _servo_sub[4] = _nm.subscribe("/" + _robot_name + "_gazebo/FL_thigh_controller/state", 1, &amp;IOROS::FLthighCallback, this);
-    _servo_sub[5] = _nm.subscribe("/" + _robot_name + "_gazebo/FL_calf_controller/state", 1, &amp;IOROS::FLcalfCallback, this);
-    _servo_sub[6] = _nm.subscribe("/" + _robot_name + "_gazebo/RR_hip_controller/state", 1, &amp;IOROS::RRhipCallback, this);
-    _servo_sub[7] = _nm.subscribe("/" + _robot_name + "_gazebo/RR_thigh_controller/state", 1, &amp;IOROS::RRthighCallback, this);
-    _servo_sub[8] = _nm.subscribe("/" + _robot_name + "_gazebo/RR_calf_controller/state", 1, &amp;IOROS::RRcalfCallback, this);
-    _servo_sub[9] = _nm.subscribe("/" + _robot_name + "_gazebo/RL_hip_controller/state", 1, &amp;IOROS::RLhipCallback, this);
-    _servo_sub[10] = _nm.subscribe("/" + _robot_name + "_gazebo/RL_thigh_controller/state", 1, &amp;IOROS::RLthighCallback, this);
-    _servo_sub[11] = _nm.subscribe("/" + _robot_name + "_gazebo/RL_calf_controller/state", 1, &amp;IOROS::RLcalfCallback, this);
+void RosShutDown(int sig)
+{
+  ROS_INFO("ROS interface shutting down!");
+  ros::shutdown();
+}
+
+IOROS::IOROS()
+: IOInterface()
+{
+  std::cout &lt;&lt; "The control interface for ROS 2 Gazebo simulation" &lt;&lt; std::endl;
+  ros::param::get("/robot_name", _robot_name);
+  std::cout &lt;&lt; "robot_name: " &lt;&lt; _robot_name &lt;&lt; std::endl;
+
+  // start subscriber
+  initRecv();
+  ros::AsyncSpinner subSpinner(1);   // one threads
+  subSpinner.start();
+  usleep(300000);       //wait for subscribers start
+  // initialize publisher
+  initSend();
+
+  signal(SIGINT, RosShutDown);
+
+  cmdPanel = new KeyBoard();
+}
+
+IOROS::~IOROS()
+{
+  delete cmdPanel;
+  ros::shutdown();
+}
+
+void IOROS::sendRecv(const LowlevelCmd * cmd, LowlevelState * state)
+{
+  sendCmd(cmd);
+  recvState(state);
+
+  state-&gt;userCmd = cmdPanel-&gt;getUserCmd();
+  state-&gt;userValue = cmdPanel-&gt;getUserValue();
+}
+
+void IOROS::sendCmd(const LowlevelCmd * lowCmd)
+{
+  for (int i(0); i &lt; 12; ++i) {
+    _lowCmd.motorCmd[i].mode = lowCmd-&gt;motorCmd[i].mode;
+    _lowCmd.motorCmd[i].q = lowCmd-&gt;motorCmd[i].q;
+    _lowCmd.motorCmd[i].dq = lowCmd-&gt;motorCmd[i].dq;
+    _lowCmd.motorCmd[i].tau = lowCmd-&gt;motorCmd[i].tau;
+    _lowCmd.motorCmd[i].Kd = lowCmd-&gt;motorCmd[i].Kd;
+    _lowCmd.motorCmd[i].Kp = lowCmd-&gt;motorCmd[i].Kp;
+  }
+  for (int m(0); m &lt; 12; ++m) {
+    _servo_pub[m].publish(_lowCmd.motorCmd[m]);
+  }
+  ros::spinOnce();
+}
+
+void IOROS::recvState(LowlevelState * state)
+{
+  for (int i(0); i &lt; 12; ++i) {
+    state-&gt;motorState[i].q = _lowState.motorState[i].q;
+    state-&gt;motorState[i].dq = _lowState.motorState[i].dq;
+    state-&gt;motorState[i].ddq = _lowState.motorState[i].ddq;
+    state-&gt;motorState[i].tauEst = _lowState.motorState[i].tauEst;
+  }
+  for (int i(0); i &lt; 3; ++i) {
+    state-&gt;imu.quaternion[i] = _lowState.imu.quaternion[i];
+    state-&gt;imu.accelerometer[i] = _lowState.imu.accelerometer[i];
+    state-&gt;imu.gyroscope[i] = _lowState.imu.gyroscope[i];
+  }
+  state-&gt;imu.quaternion[3] = _lowState.imu.quaternion[3];
+}
+
+void IOROS::initSend()
+{
+  _servo_pub[0] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;(
+    "/" + _robot_name + "_gazebo/FR_hip_controller/command", 1);
+  _servo_pub[1] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;(
+    "/" + _robot_name + "_gazebo/FR_thigh_controller/command", 1);
+  _servo_pub[2] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;(
+    "/" + _robot_name + "_gazebo/FR_calf_controller/command", 1);
+  _servo_pub[3] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;(
+    "/" + _robot_name + "_gazebo/FL_hip_controller/command", 1);
+  _servo_pub[4] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;(
+    "/" + _robot_name + "_gazebo/FL_thigh_controller/command", 1);
+  _servo_pub[5] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;(
+    "/" + _robot_name + "_gazebo/FL_calf_controller/command", 1);
+  _servo_pub[6] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;(
+    "/" + _robot_name + "_gazebo/RR_hip_controller/command", 1);
+  _servo_pub[7] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;(
+    "/" + _robot_name + "_gazebo/RR_thigh_controller/command", 1);
+  _servo_pub[8] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;(
+    "/" + _robot_name + "_gazebo/RR_calf_controller/command", 1);
+  _servo_pub[9] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;(
+    "/" + _robot_name + "_gazebo/RL_hip_controller/command", 1);
+  _servo_pub[10] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;(
+    "/" + _robot_name + "_gazebo/RL_thigh_controller/command", 1);
+  _servo_pub[11] = _nm.advertise&lt;unitree_legged_msgs::MotorCmd&gt;(
+    "/" + _robot_name + "_gazebo/RL_calf_controller/command", 1);
+}
+
+void IOROS::initRecv()
+{
+  _imu_sub = _nm.subscribe("/trunk_imu", 1, &amp;IOROS::imuCallback, this);
+  _servo_sub[0] = _nm.subscribe(
+    "/" + _robot_name + "_gazebo/FR_hip_controller/state", 1,
+    &amp;IOROS::FRhipCallback, this);
+  _servo_sub[1] = _nm.subscribe(
+    "/" + _robot_name + "_gazebo/FR_thigh_controller/state", 1,
+    &amp;IOROS::FRthighCallback, this);
+  _servo_sub[2] = _nm.subscribe(
+    "/" + _robot_name + "_gazebo/FR_calf_controller/state", 1,
+    &amp;IOROS::FRcalfCallback, this);
+  _servo_sub[3] = _nm.subscribe(
+    "/" + _robot_name + "_gazebo/FL_hip_controller/state", 1,
+    &amp;IOROS::FLhipCallback, this);
+  _servo_sub[4] = _nm.subscribe(
+    "/" + _robot_name + "_gazebo/FL_thigh_controller/state", 1,
+    &amp;IOROS::FLthighCallback, this);
+  _servo_sub[5] = _nm.subscribe(
+    "/" + _robot_name + "_gazebo/FL_calf_controller/state", 1,
+    &amp;IOROS::FLcalfCallback, this);
+  _servo_sub[6] = _nm.subscribe(
+    "/" + _robot_name + "_gazebo/RR_hip_controller/state", 1,
+    &amp;IOROS::RRhipCallback, this);
+  _servo_sub[7] = _nm.subscribe(
+    "/" + _robot_name + "_gazebo/RR_thigh_controller/state", 1,
+    &amp;IOROS::RRthighCallback, this);
+  _servo_sub[8] = _nm.subscribe(
+    "/" + _robot_name + "_gazebo/RR_calf_controller/state", 1,
+    &amp;IOROS::RRcalfCallback, this);
+  _servo_sub[9] = _nm.subscribe(
+    "/" + _robot_name + "_gazebo/RL_hip_controller/state", 1,
+    &amp;IOROS::RLhipCallback, this);
+  _servo_sub[10] = _nm.subscribe(
+    "/" + _robot_name + "_gazebo/RL_thigh_controller/state", 1,
+    &amp;IOROS::RLthighCallback, this);
+  _servo_sub[11] = _nm.subscribe(
+    "/" + _robot_name + "_gazebo/RL_calf_controller/state", 1,
+    &amp;IOROS::RLcalfCallback, this);
@@ -110,109 +155,109 @@
-{ 
-    _lowState.imu.quaternion[0] = msg.orientation.w;
-    _lowState.imu.quaternion[1] = msg.orientation.x;
-    _lowState.imu.quaternion[2] = msg.orientation.y;
-    _lowState.imu.quaternion[3] = msg.orientation.z;
-
-    _lowState.imu.gyroscope[0] = msg.angular_velocity.x;
-    _lowState.imu.gyroscope[1] = msg.angular_velocity.y;
-    _lowState.imu.gyroscope[2] = msg.angular_velocity.z;
-    
-    _lowState.imu.accelerometer[0] = msg.linear_acceleration.x;
-    _lowState.imu.accelerometer[1] = msg.linear_acceleration.y;
-    _lowState.imu.accelerometer[2] = msg.linear_acceleration.z;
-}
-
-void IOROS::FRhipCallback(const unitree_legged_msgs::MotorState&amp; msg)
-{
-    _lowState.motorState[0].mode = msg.mode;
-    _lowState.motorState[0].q = msg.q;
-    _lowState.motorState[0].dq = msg.dq;
-    _lowState.motorState[0].tauEst = msg.tauEst;
-}
-
-void IOROS::FRthighCallback(const unitree_legged_msgs::MotorState&amp; msg)
-{
-    _lowState.motorState[1].mode = msg.mode;
-    _lowState.motorState[1].q = msg.q;
-    _lowState.motorState[1].dq = msg.dq;
-    _lowState.motorState[1].tauEst = msg.tauEst;
-}
-
-void IOROS::FRcalfCallback(const unitree_legged_msgs::MotorState&amp; msg)
-{
-    _lowState.motorState[2].mode = msg.mode;
-    _lowState.motorState[2].q = msg.q;
-    _lowState.motorState[2].dq = msg.dq;
-    _lowState.motorState[2].tauEst = msg.tauEst;
-}
-
-void IOROS::FLhipCallback(const unitree_legged_msgs::MotorState&amp; msg)
-{
-    _lowState.motorState[3].mode = msg.mode;
-    _lowState.motorState[3].q = msg.q;
-    _lowState.motorState[3].dq = msg.dq;
-    _lowState.motorState[3].tauEst = msg.tauEst;
-}
-
-void IOROS::FLthighCallback(const unitree_legged_msgs::MotorState&amp; msg)
-{
-    _lowState.motorState[4].mode = msg.mode;
-    _lowState.motorState[4].q = msg.q;
-    _lowState.motorState[4].dq = msg.dq;
-    _lowState.motorState[4].tauEst = msg.tauEst;
-}
-
-void IOROS::FLcalfCallback(const unitree_legged_msgs::MotorState&amp; msg)
-{
-    _lowState.motorState[5].mode = msg.mode;
-    _lowState.motorState[5].q = msg.q;
-    _lowState.motorState[5].dq = msg.dq;
-    _lowState.motorState[5].tauEst = msg.tauEst;
-}
-
-void IOROS::RRhipCallback(const unitree_legged_msgs::MotorState&amp; msg)
-{
-    _lowState.motorState[6].mode = msg.mode;
-    _lowState.motorState[6].q = msg.q;
-    _lowState.motorState[6].dq = msg.dq;
-    _lowState.motorState[6].tauEst = msg.tauEst;
-}
-
-void IOROS::RRthighCallback(const unitree_legged_msgs::MotorState&amp; msg)
-{
-    _lowState.motorState[7].mode = msg.mode;
-    _lowState.motorState[7].q = msg.q;
-    _lowState.motorState[7].dq = msg.dq;
-    _lowState.motorState[7].tauEst = msg.tauEst;
-}
-
-void IOROS::RRcalfCallback(const unitree_legged_msgs::MotorState&amp; msg)
-{
-    _lowState.motorState[8].mode = msg.mode;
-    _lowState.motorState[8].q = msg.q;
-    _lowState.motorState[8].dq = msg.dq;
-    _lowState.motorState[8].tauEst = msg.tauEst;
-}
-
-void IOROS::RLhipCallback(const unitree_legged_msgs::MotorState&amp; msg)
-{
-    _lowState.motorState[9].mode = msg.mode;
-    _lowState.motorState[9].q = msg.q;
-    _lowState.motorState[9].dq = msg.dq;
-    _lowState.motorState[9].tauEst = msg.tauEst;
-}
-
-void IOROS::RLthighCallback(const unitree_legged_msgs::MotorState&amp; msg)
-{
-    _lowState.motorState[10].mode = msg.mode;
-    _lowState.motorState[10].q = msg.q;
-    _lowState.motorState[10].dq = msg.dq;
-    _lowState.motorState[10].tauEst = msg.tauEst;
-}
-
-void IOROS::RLcalfCallback(const unitree_legged_msgs::MotorState&amp; msg)
-{
-    _lowState.motorState[11].mode = msg.mode;
-    _lowState.motorState[11].q = msg.q;
-    _lowState.motorState[11].dq = msg.dq;
-    _lowState.motorState[11].tauEst = msg.tauEst;
+{
+  _lowState.imu.quaternion[0] = msg.orientation.w;
+  _lowState.imu.quaternion[1] = msg.orientation.x;
+  _lowState.imu.quaternion[2] = msg.orientation.y;
+  _lowState.imu.quaternion[3] = msg.orientation.z;
+
+  _lowState.imu.gyroscope[0] = msg.angular_velocity.x;
+  _lowState.imu.gyroscope[1] = msg.angular_velocity.y;
+  _lowState.imu.gyroscope[2] = msg.angular_velocity.z;
+
+  _lowState.imu.accelerometer[0] = msg.linear_acceleration.x;
+  _lowState.imu.accelerometer[1] = msg.linear_acceleration.y;
+  _lowState.imu.accelerometer[2] = msg.linear_acceleration.z;
+}
+
+void IOROS::FRhipCallback(const unitree_legged_msgs::MotorState &amp; msg)
+{
+  _lowState.motorState[0].mode = msg.mode;
+  _lowState.motorState[0].q = msg.q;
+  _lowState.motorState[0].dq = msg.dq;
+  _lowState.motorState[0].tauEst = msg.tauEst;
+}
+
+void IOROS::FRthighCallback(const unitree_legged_msgs::MotorState &amp; msg)
+{
+  _lowState.motorState[1].mode = msg.mode;
+  _lowState.motorState[1].q = msg.q;
+  _lowState.motorState[1].dq = msg.dq;
+  _lowState.motorState[1].tauEst = msg.tauEst;
+}
+
+void IOROS::FRcalfCallback(const unitree_legged_msgs::MotorState &amp; msg)
+{
+  _lowState.motorState[2].mode = msg.mode;
+  _lowState.motorState[2].q = msg.q;
+  _lowState.motorState[2].dq = msg.dq;
+  _lowState.motorState[2].tauEst = msg.tauEst;
+}
+
+void IOROS::FLhipCallback(const unitree_legged_msgs::MotorState &amp; msg)
+{
+  _lowState.motorState[3].mode = msg.mode;
+  _lowState.motorState[3].q = msg.q;
+  _lowState.motorState[3].dq = msg.dq;
+  _lowState.motorState[3].tauEst = msg.tauEst;
+}
+
+void IOROS::FLthighCallback(const unitree_legged_msgs::MotorState &amp; msg)
+{
+  _lowState.motorState[4].mode = msg.mode;
+  _lowState.motorState[4].q = msg.q;
+  _lowState.motorState[4].dq = msg.dq;
+  _lowState.motorState[4].tauEst = msg.tauEst;
+}
+
+void IOROS::FLcalfCallback(const unitree_legged_msgs::MotorState &amp; msg)
+{
+  _lowState.motorState[5].mode = msg.mode;
+  _lowState.motorState[5].q = msg.q;
+  _lowState.motorState[5].dq = msg.dq;
+  _lowState.motorState[5].tauEst = msg.tauEst;
+}
+
+void IOROS::RRhipCallback(const unitree_legged_msgs::MotorState &amp; msg)
+{
+  _lowState.motorState[6].mode = msg.mode;
+  _lowState.motorState[6].q = msg.q;
+  _lowState.motorState[6].dq = msg.dq;
+  _lowState.motorState[6].tauEst = msg.tauEst;
+}
+
+void IOROS::RRthighCallback(const unitree_legged_msgs::MotorState &amp; msg)
+{
+  _lowState.motorState[7].mode = msg.mode;
+  _lowState.motorState[7].q = msg.q;
+  _lowState.motorState[7].dq = msg.dq;
+  _lowState.motorState[7].tauEst = msg.tauEst;
+}
+
+void IOROS::RRcalfCallback(const unitree_legged_msgs::MotorState &amp; msg)
+{
+  _lowState.motorState[8].mode = msg.mode;
+  _lowState.motorState[8].q = msg.q;
+  _lowState.motorState[8].dq = msg.dq;
+  _lowState.motorState[8].tauEst = msg.tauEst;
+}
+
+void IOROS::RLhipCallback(const unitree_legged_msgs::MotorState &amp; msg)
+{
+  _lowState.motorState[9].mode = msg.mode;
+  _lowState.motorState[9].q = msg.q;
+  _lowState.motorState[9].dq = msg.dq;
+  _lowState.motorState[9].tauEst = msg.tauEst;
+}
+
+void IOROS::RLthighCallback(const unitree_legged_msgs::MotorState &amp; msg)
+{
+  _lowState.motorState[10].mode = msg.mode;
+  _lowState.motorState[10].q = msg.q;
+  _lowState.motorState[10].dq = msg.dq;
+  _lowState.motorState[10].tauEst = msg.tauEst;
+}
+
+void IOROS::RLcalfCallback(const unitree_legged_msgs::MotorState &amp; msg)
+{
+  _lowState.motorState[11].mode = msg.mode;
+  _lowState.motorState[11].q = msg.q;
+  _lowState.motorState[11].dq = msg.dq;
+  _lowState.motorState[11].tauEst = msg.tauEst;
@@ -236,6 +281,7 @@
-void IOROS::RosShutDown(int sig){
-
-	// RCLCPP_INFO_ONCE(_nm-&gt;get_logger(), "ROS 2 interface shutting down!");
-    std::cout &lt;&lt; "ROS 2 interface shutting down!" &lt;&lt; std::endl;
-    // executor_thread.join();
-	rclcpp::shutdown();
+void IOROS::RosShutDown(int sig)
+{
+
+  // RCLCPP_INFO_ONCE(_nm-&gt;get_logger(), "ROS 2 interface shutting down!");
+  std::cout &lt;&lt; "ROS 2 interface shutting down!" &lt;&lt; std::endl;
+  // executor_thread.join();
+  rclcpp::shutdown();
@@ -246 +292 @@
-//     joint_index_map["FL_thigh_joint"] = 1;         
+//     joint_index_map["FL_thigh_joint"] = 1;
@@ -250 +296 @@
-//     joint_index_map["FR_calf_joint"] = 5;         
+//     joint_index_map["FR_calf_joint"] = 5;
@@ -252 +298 @@
-//     joint_index_map["RL_thigh_joint"] = 7;         
+//     joint_index_map["RL_thigh_joint"] = 7;
@@ -254,2 +300,2 @@
-//     joint_index_map["RR_hip_joint"] = 9;          
-//     joint_index_map["RR_thigh_joint"] = 10;        
+//     joint_index_map["RR_hip_joint"] = 9;
+//     joint_index_map["RR_thigh_joint"] = 10;
@@ -259,31 +305,34 @@
-IOROS::IOROS(rclcpp::Node::SharedPtr node_ptr) : IOInterface(){
-    _nm = node_ptr;
-    
-    std::cout &lt;&lt; "The control interface for ROS 2 Gazebo simulation" &lt;&lt; std::endl;
-    _nm-&gt;declare_parameter("robot_name", "go2");
-    _nm-&gt;get_parameter("robot_name", _robot_name);
-    std::cout &lt;&lt; "robot_name: " &lt;&lt; _robot_name &lt;&lt; std::endl;
-
-    // initialize map
-    // initializeJointIndexMap();
-
-    // _joint_cmd = std_msgs::msg::Float64MultiArray();
-    // for(int i = 0; i &lt; 12; i++){
-    //     _joint_cmd.data.push_back(0.0);
-    // }
-    
-    // start subscriber
-    initRecv();
-    std::cout &lt;&lt; "init recv" &lt;&lt; std::endl;
-
-    // ros::AsyncSpinner subSpinner(1); // one threads
-    // subSpinner.start();
-
-    // ROS 2 equivalent
-    auto executor = std::make_shared&lt;rclcpp::executors::MultiThreadedExecutor&gt;(
-        rclcpp::ExecutorOptions(), 1
-    );
-    
-    executor-&gt;add_node(_nm);
-    executor_thread = std::thread([executor] (){
-        executor-&gt;spin();
+IOROS::IOROS(rclcpp::Node::SharedPtr node_ptr)
+: IOInterface()
+{
+  _nm = node_ptr;
+
+  std::cout &lt;&lt; "The control interface for ROS 2 Gazebo simulation" &lt;&lt; std::endl;
+  _nm-&gt;declare_parameter("robot_name", "go2");
+  _nm-&gt;get_parameter("robot_name", _robot_name);
+  std::cout &lt;&lt; "robot_name: " &lt;&lt; _robot_name &lt;&lt; std::endl;
+
+  // initialize map
+  // initializeJointIndexMap();
+
+  // _joint_cmd = std_msgs::msg::Float64MultiArray();
+  // for(int i = 0; i &lt; 12; i++){
+  //     _joint_cmd.data.push_back(0.0);
+  // }
+
+  // start subscriber
+  initRecv();
+  std::cout &lt;&lt; "init recv" &lt;&lt; std::endl;
+
+  // ros::AsyncSpinner subSpinner(1); // one threads
+  // subSpinner.start();
+
+  // ROS 2 equivalent
+  auto executor = std::make_shared&lt;rclcpp::executors::MultiThreadedExecutor&gt;(
+    rclcpp::ExecutorOptions(), 1
+  );
+
+  executor-&gt;add_node(_nm);
+  executor_thread = std::thread(
+    [executor]() {
+      executor-&gt;spin();
@@ -291,92 +340,165 @@
-    executor_thread.detach();
-    std::cout &lt;&lt; "executor thread detached and running" &lt;&lt; std::endl;
-
-    usleep(300000);     // wait for subscribers start
-
-    initSend();   
-
-    signal(SIGINT, IOROS::RosShutDown);
-
-    cmdPanel = new KeyBoard();
-    
-}
-
-IOROS::~IOROS(){
-    delete cmdPanel;
-    rclcpp::shutdown();
-}
-
-void IOROS::sendRecv(const LowlevelCmd *cmd, LowlevelState *state){
-    sendCmd(cmd);
-    recvState(state);
-
-    state-&gt;userCmd = cmdPanel-&gt;getUserCmd();
-    state-&gt;userValue = cmdPanel-&gt;getUserValue();
-}
-
-void IOROS::sendCmd(const LowlevelCmd *lowCmd){
-    
-    for(int i(0); i &lt; 12; ++i){
-        _lowCmd.motor_cmd[i].mode = lowCmd-&gt;motorCmd[i].mode;
-        _lowCmd.motor_cmd[i].q = lowCmd-&gt;motorCmd[i].q;
-        _lowCmd.motor_cmd[i].dq = lowCmd-&gt;motorCmd[i].dq;
-        _lowCmd.motor_cmd[i].tau = lowCmd-&gt;motorCmd[i].tau;
-        _lowCmd.motor_cmd[i].kd = lowCmd-&gt;motorCmd[i].Kd;
-        _lowCmd.motor_cmd[i].kp = lowCmd-&gt;motorCmd[i].Kp;
-
-    }
-    for(int m(0); m &lt; 12; ++m){
-        _servo_pub[m]-&gt;publish(_lowCmd.motor_cmd[m]);
-    }
-    // _joint_cmd_pub-&gt;publish(_joint_cmd);
-    // rclcpp::spin_once();
-
-
-}
-
-void IOROS::recvState(LowlevelState *state){
-    for(int i(0); i &lt; 12; ++i){
-        state-&gt;motorState[i].q = _lowState.motor_state[i].q;
-        state-&gt;motorState[i].dq = _lowState.motor_state[i].dq;
-        state-&gt;motorState[i].ddq = _lowState.motor_state[i].ddq;
-        state-&gt;motorState[i].tauEst = _lowState.motor_state[i].tau_est;
-    }
-    for(int i(0); i &lt; 3; ++i){
-        state-&gt;imu.quaternion[i] = _lowState.imu.quaternion[i];
-        state-&gt;imu.accelerometer[i] = _lowState.imu.accelerometer[i];
-        state-&gt;imu.gyroscope[i] = _lowState.imu.gyroscope[i];
-    }
-    state-&gt;imu.quaternion[3] = _lowState.imu.quaternion[3];
-}
-
-void IOROS::initSend(){
-    _servo_pub.push_back(_nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;("/FR_hip_controller/command", 1));
-    _servo_pub.push_back(_nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;("/FR_thigh_controller/command", 1));
-    _servo_pub.push_back(_nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;("/FR_calf_controller/command", 1));
-    _servo_pub.push_back(_nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;("/FL_hip_controller/command", 1));
-    _servo_pub.push_back(_nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;("/FL_thigh_controller/command", 1));
-    _servo_pub.push_back(_nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;("/FL_calf_controller/command", 1));
-    _servo_pub.push_back(_nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;("/RR_hip_controller/command", 1));
-    _servo_pub.push_back(_nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;("/RR_thigh_controller/command", 1));
-    _servo_pub.push_back(_nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;("/RR_calf_controller/command", 1));
-    _servo_pub.push_back(_nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;("/RL_hip_controller/command", 1));
-    _servo_pub.push_back(_nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;("/RL_thigh_controller/command", 1));
-    _servo_pub.push_back(_nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;("/RL_calf_controller/command", 1));
-    // _joint_cmd_pub = _nm-&gt;create_publisher&lt;std_msgs::msg::Float64MultiArray&gt;("/joint_group_position_controller/commands", 1);
-}
-
-void IOROS::initRecv(){
-    _imu_sub = _nm-&gt;create_subscription&lt;sensor_msgs::msg::Imu&gt;("/imu_plugin/out", 1, std::bind(&amp;IOROS::imuCallback, this, std::placeholders::_1));
-    _servo_sub.push_back(_nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;("/FR_hip_controller/state", 1, std::bind(&amp;IOROS::FRhipCallback, this, std::placeholders::_1)));
-    _servo_sub.push_back(_nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;("/FR_thigh_controller/state", 1, std::bind(&amp;IOROS::FRthighCallback, this, std::placeholders::_1)));
-    _servo_sub.push_back(_nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;("/FR_calf_controller/state", 1, std::bind(&amp;IOROS::FRcalfCallback, this, std::placeholders::_1)));
-    _servo_sub.push_back(_nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;("/FL_hip_controller/state", 1, std::bind(&amp;IOROS::FLhipCallback, this, std::placeholders::_1)));
-    _servo_sub.push_back(_nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;("/FL_thigh_controller/state", 1, std::bind(&amp;IOROS::FLthighCallback, this, std::placeholders::_1)));
-    _servo_sub.push_back(_nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;("/FL_calf_controller/state", 1, std::bind(&amp;IOROS::FLcalfCallback, this, std::placeholders::_1)));
-    _servo_sub.push_back(_nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;("/RR_hip_controller/state", 1, std::bind(&amp;IOROS::RRhipCallback, this, std::placeholders::_1)));
-    _servo_sub.push_back(_nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;("/RR_thigh_controller/state", 1, std::bind(&amp;IOROS::RRthighCallback, this, std::placeholders::_1)));
-    _servo_sub.push_back(_nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;("/RR_calf_controller/state", 1, std::bind(&amp;IOROS::RRcalfCallback, this, std::placeholders::_1)));
-    _servo_sub.push_back(_nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;("/RL_hip_controller/state", 1, std::bind(&amp;IOROS::RLhipCallback, this, std::placeholders::_1)));
-    _servo_sub.push_back(_nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;("/RL_thigh_controller/state", 1, std::bind(&amp;IOROS::RLthighCallback, this, std::placeholders::_1)));
-    _servo_sub.push_back(_nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;("/RL_calf_controller/state", 1, std::bind(&amp;IOROS::RLcalfCallback, this, std::placeholders::_1)));
-    // _joint_state_sub = _nm-&gt;create_subscription&lt;sensor_msgs::msg::JointState&gt;("/joint_states", 1, std::bind(&amp;IOROS::jointStateCallback, this, std::placeholders::_1));
+  executor_thread.detach();
+  std::cout &lt;&lt; "executor thread detached and running" &lt;&lt; std::endl;
+
+  usleep(300000);       // wait for subscribers start
+
+  initSend();
+
+  signal(SIGINT, IOROS::RosShutDown);
+
+  cmdPanel = new KeyBoard();
+
+}
+
+IOROS::~IOROS()
+{
+  delete cmdPanel;
+  rclcpp::shutdown();
+}
+
+void IOROS::sendRecv(const LowlevelCmd * cmd, LowlevelState * state)
+{
+  sendCmd(cmd);
+  recvState(state);
+
+  state-&gt;userCmd = cmdPanel-&gt;getUserCmd();
+  state-&gt;userValue = cmdPanel-&gt;getUserValue();
+}
+
+void IOROS::sendCmd(const LowlevelCmd * lowCmd)
+{
+
+  for (int i(0); i &lt; 12; ++i) {
+    _lowCmd.motor_cmd[i].mode = lowCmd-&gt;motorCmd[i].mode;
+    _lowCmd.motor_cmd[i].q = lowCmd-&gt;motorCmd[i].q;
+    _lowCmd.motor_cmd[i].dq = lowCmd-&gt;motorCmd[i].dq;
+    _lowCmd.motor_cmd[i].tau = lowCmd-&gt;motorCmd[i].tau;
+    _lowCmd.motor_cmd[i].kd = lowCmd-&gt;motorCmd[i].Kd;
+    _lowCmd.motor_cmd[i].kp = lowCmd-&gt;motorCmd[i].Kp;
+
+  }
+  for (int m(0); m &lt; 12; ++m) {
+    _servo_pub[m]-&gt;publish(_lowCmd.motor_cmd[m]);
+  }
+  // _joint_cmd_pub-&gt;publish(_joint_cmd);
+  // rclcpp::spin_once();
+
+
+}
+
+void IOROS::recvState(LowlevelState * state)
+{
+  for (int i(0); i &lt; 12; ++i) {
+    state-&gt;motorState[i].q = _lowState.motor_state[i].q;
+    state-&gt;motorState[i].dq = _lowState.motor_state[i].dq;
+    state-&gt;motorState[i].ddq = _lowState.motor_state[i].ddq;
+    state-&gt;motorState[i].tauEst = _lowState.motor_state[i].tau_est;
+  }
+  for (int i(0); i &lt; 3; ++i) {
+    state-&gt;imu.quaternion[i] = _lowState.imu.quaternion[i];
+    state-&gt;imu.accelerometer[i] = _lowState.imu.accelerometer[i];
+    state-&gt;imu.gyroscope[i] = _lowState.imu.gyroscope[i];
+  }
+  state-&gt;imu.quaternion[3] = _lowState.imu.quaternion[3];
+}
+
+void IOROS::initSend()
+{
+  _servo_pub.push_back(
+    _nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;(
+      "/FR_hip_controller/command", 1));
+  _servo_pub.push_back(
+    _nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;(
+      "/FR_thigh_controller/command", 1));
+  _servo_pub.push_back(
+    _nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;(
+      "/FR_calf_controller/command", 1));
+  _servo_pub.push_back(
+    _nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;(
+      "/FL_hip_controller/command", 1));
+  _servo_pub.push_back(
+    _nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;(
+      "/FL_thigh_controller/command", 1));
+  _servo_pub.push_back(
+    _nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;(
+      "/FL_calf_controller/command", 1));
+  _servo_pub.push_back(
+    _nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;(
+      "/RR_hip_controller/command", 1));
+  _servo_pub.push_back(
+    _nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;(
+      "/RR_thigh_controller/command", 1));
+  _servo_pub.push_back(
+    _nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;(
+      "/RR_calf_controller/command", 1));
+  _servo_pub.push_back(
+    _nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;(
+      "/RL_hip_controller/command", 1));
+  _servo_pub.push_back(
+    _nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;(
+      "/RL_thigh_controller/command", 1));
+  _servo_pub.push_back(
+    _nm-&gt;create_publisher&lt;ros2_unitree_legged_msgs::msg::MotorCmd&gt;(
+      "/RL_calf_controller/command", 1));
+  // _joint_cmd_pub = _nm-&gt;create_publisher&lt;std_msgs::msg::Float64MultiArray&gt;("/joint_group_position_controller/commands", 1);
+}
+
+void IOROS::initRecv()
+{
+  _imu_sub =
+    _nm-&gt;create_subscription&lt;sensor_msgs::msg::Imu&gt;(
+    "/imu_plugin/out", 1,
+    std::bind(&amp;IOROS::imuCallback, this, std::placeholders::_1));
+  _servo_sub.push_back(
+    _nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;(
+      "/FR_hip_controller/state", 1,
+      std::bind(&amp;IOROS::FRhipCallback, this, std::placeholders::_1)));
+  _servo_sub.push_back(
+    _nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;(
+      "/FR_thigh_controller/state", 1, std::bind(
+        &amp;IOROS::FRthighCallback, this,
+        std::placeholders::_1)));
+  _servo_sub.push_back(
+    _nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;(
+      "/FR_calf_controller/state", 1,
+      std::bind(&amp;IOROS::FRcalfCallback, this, std::placeholders::_1)));
+  _servo_sub.push_back(
+    _nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;(
+      "/FL_hip_controller/state", 1,
+      std::bind(&amp;IOROS::FLhipCallback, this, std::placeholders::_1)));
+  _servo_sub.push_back(
+    _nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;(
+      "/FL_thigh_controller/state", 1, std::bind(
+        &amp;IOROS::FLthighCallback, this,
+        std::placeholders::_1)));
+  _servo_sub.push_back(
+    _nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;(
+      "/FL_calf_controller/state", 1,
+      std::bind(&amp;IOROS::FLcalfCallback, this, std::placeholders::_1)));
+  _servo_sub.push_back(
+    _nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;(
+      "/RR_hip_controller/state", 1,
+      std::bind(&amp;IOROS::RRhipCallback, this, std::placeholders::_1)));
+  _servo_sub.push_back(
+    _nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;(
+      "/RR_thigh_controller/state", 1, std::bind(
+        &amp;IOROS::RRthighCallback, this,
+        std::placeholders::_1)));
+  _servo_sub.push_back(
+    _nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;(
+      "/RR_calf_controller/state", 1,
+      std::bind(&amp;IOROS::RRcalfCallback, this, std::placeholders::_1)));
+  _servo_sub.push_back(
+    _nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;(
+      "/RL_hip_controller/state", 1,
+      std::bind(&amp;IOROS::RLhipCallback, this, std::placeholders::_1)));
+  _servo_sub.push_back(
+    _nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;(
+      "/RL_thigh_controller/state", 1, std::bind(
+        &amp;IOROS::RLthighCallback, this,
+        std::placeholders::_1)));
+  _servo_sub.push_back(
+    _nm-&gt;create_subscription&lt;ros2_unitree_legged_msgs::msg::MotorState&gt;(
+      "/RL_calf_controller/state", 1,
+      std::bind(&amp;IOROS::RLcalfCallback, this, std::placeholders::_1)));
+  // _joint_state_sub = _nm-&gt;create_subscription&lt;sensor_msgs::msg::JointState&gt;("/joint_states", 1, std::bind(&amp;IOROS::jointStateCallback, this, std::placeholders::_1));
@@ -387,12 +509,12 @@
-    _lowState.imu.quaternion[0] = msg-&gt;orientation.w;
-    _lowState.imu.quaternion[1] = msg-&gt;orientation.x;
-    _lowState.imu.quaternion[2] = msg-&gt;orientation.y;
-    _lowState.imu.quaternion[3] = msg-&gt;orientation.z;
-
-    _lowState.imu.gyroscope[0] = msg-&gt;angular_velocity.x;
-    _lowState.imu.gyroscope[1] = msg-&gt;angular_velocity.y;
-    _lowState.imu.gyroscope[2] = msg-&gt;angular_velocity.z;
-    
-    _lowState.imu.accelerometer[0] = msg-&gt;linear_acceleration.x;
-    _lowState.imu.accelerometer[1] = msg-&gt;linear_acceleration.y;
-    _lowState.imu.accelerometer[2] = msg-&gt;linear_acceleration.z;
+  _lowState.imu.quaternion[0] = msg-&gt;orientation.w;
+  _lowState.imu.quaternion[1] = msg-&gt;orientation.x;
+  _lowState.imu.quaternion[2] = msg-&gt;orientation.y;
+  _lowState.imu.quaternion[3] = msg-&gt;orientation.z;
+
+  _lowState.imu.gyroscope[0] = msg-&gt;angular_velocity.x;
+  _lowState.imu.gyroscope[1] = msg-&gt;angular_velocity.y;
+  _lowState.imu.gyroscope[2] = msg-&gt;angular_velocity.z;
+
+  _lowState.imu.accelerometer[0] = msg-&gt;linear_acceleration.x;
+  _lowState.imu.accelerometer[1] = msg-&gt;linear_acceleration.y;
+  _lowState.imu.accelerometer[2] = msg-&gt;linear_acceleration.z;
@@ -404,4 +526,4 @@
-    _lowState.motor_state[0].mode = msg-&gt;mode;
-    _lowState.motor_state[0].q = msg-&gt;q;
-    _lowState.motor_state[0].dq = msg-&gt;dq;
-    _lowState.motor_state[0].tau_est = msg-&gt;tau_est;
+  _lowState.motor_state[0].mode = msg-&gt;mode;
+  _lowState.motor_state[0].q = msg-&gt;q;
+  _lowState.motor_state[0].dq = msg-&gt;dq;
+  _lowState.motor_state[0].tau_est = msg-&gt;tau_est;
@@ -412,4 +534,4 @@
-    _lowState.motor_state[1].mode = msg-&gt;mode;
-    _lowState.motor_state[1].q = msg-&gt;q;
-    _lowState.motor_state[1].dq = msg-&gt;dq;
-    _lowState.motor_state[1].tau_est = msg-&gt;tau_est;
+  _lowState.motor_state[1].mode = msg-&gt;mode;
+  _lowState.motor_state[1].q = msg-&gt;q;
+  _lowState.motor_state[1].dq = msg-&gt;dq;
+  _lowState.motor_state[1].tau_est = msg-&gt;tau_est;
@@ -420,4 +542,4 @@
-    _lowState.motor_state[2].mode = msg-&gt;mode;
-    _lowState.motor_state[2].q = msg-&gt;q;
-    _lowState.motor_state[2].dq = msg-&gt;dq;
-    _lowState.motor_state[2].tau_est = msg-&gt;tau_est;
+  _lowState.motor_state[2].mode = msg-&gt;mode;
+  _lowState.motor_state[2].q = msg-&gt;q;
+  _lowState.motor_state[2].dq = msg-&gt;dq;
+  _lowState.motor_state[2].tau_est = msg-&gt;tau_est;
@@ -428,4 +550,4 @@
-    _lowState.motor_state[3].mode = msg-&gt;mode;
-    _lowState.motor_state[3].q = msg-&gt;q;
-    _lowState.motor_state[3].dq = msg-&gt;dq;
-    _lowState.motor_state[3].tau_est = msg-&gt;tau_est;
+  _lowState.motor_state[3].mode = msg-&gt;mode;
+  _lowState.motor_state[3].q = msg-&gt;q;
+  _lowState.motor_state[3].dq = msg-&gt;dq;
+  _lowState.motor_state[3].tau_est = msg-&gt;tau_est;
@@ -436,4 +558,4 @@
-    _lowState.motor_state[4].mode = msg-&gt;mode;
-    _lowState.motor_state[4].q = msg-&gt;q;
-    _lowState.motor_state[4].dq = msg-&gt;dq;
-    _lowState.motor_state[4].tau_est = msg-&gt;tau_est;
+  _lowState.motor_state[4].mode = msg-&gt;mode;
+  _lowState.motor_state[4].q = msg-&gt;q;
+  _lowState.motor_state[4].dq = msg-&gt;dq;
+  _lowState.motor_state[4].tau_est = msg-&gt;tau_est;
@@ -444,4 +566,4 @@
-    _lowState.motor_state[5].mode = msg-&gt;mode;
-    _lowState.motor_state[5].q = msg-&gt;q;
-    _lowState.motor_state[5].dq = msg-&gt;dq;
-    _lowState.motor_state[5].tau_est = msg-&gt;tau_est;
+  _lowState.motor_state[5].mode = msg-&gt;mode;
+  _lowState.motor_state[5].q = msg-&gt;q;
+  _lowState.motor_state[5].dq = msg-&gt;dq;
+  _lowState.motor_state[5].tau_est = msg-&gt;tau_est;
@@ -452,4 +574,4 @@
-    _lowState.motor_state[6].mode = msg-&gt;mode;
-    _lowState.motor_state[6].q = msg-&gt;q;
-    _lowState.motor_state[6].dq = msg-&gt;dq;
-    _lowState.motor_state[6].tau_est = msg-&gt;tau_est;
+  _lowState.motor_state[6].mode = msg-&gt;mode;
+  _lowState.motor_state[6].q = msg-&gt;q;
+  _lowState.motor_state[6].dq = msg-&gt;dq;
+  _lowState.motor_state[6].tau_est = msg-&gt;tau_est;
@@ -460,4 +582,4 @@
-    _lowState.motor_state[7].mode = msg-&gt;mode;
-    _lowState.motor_state[7].q = msg-&gt;q;
-    _lowState.motor_state[7].dq = msg-&gt;dq;
-    _lowState.motor_state[7].tau_est = msg-&gt;tau_est;
+  _lowState.motor_state[7].mode = msg-&gt;mode;
+  _lowState.motor_state[7].q = msg-&gt;q;
+  _lowState.motor_state[7].dq = msg-&gt;dq;
+  _lowState.motor_state[7].tau_est = msg-&gt;tau_est;
@@ -468,4 +590,4 @@
-    _lowState.motor_state[8].mode = msg-&gt;mode;
-    _lowState.motor_state[8].q = msg-&gt;q;
-    _lowState.motor_state[8].dq = msg-&gt;dq;
-    _lowState.motor_state[8].tau_est = msg-&gt;tau_est;
+  _lowState.motor_state[8].mode = msg-&gt;mode;
+  _lowState.motor_state[8].q = msg-&gt;q;
+  _lowState.motor_state[8].dq = msg-&gt;dq;
+  _lowState.motor_state[8].tau_est = msg-&gt;tau_est;
@@ -476,4 +598,4 @@
-    _lowState.motor_state[9].mode = msg-&gt;mode;
-    _lowState.motor_state[9].q = msg-&gt;q;
-    _lowState.motor_state[9].dq = msg-&gt;dq;
-    _lowState.motor_state[9].tau_est = msg-&gt;tau_est;
+  _lowState.motor_state[9].mode = msg-&gt;mode;
+  _lowState.motor_state[9].q = msg-&gt;q;
+  _lowState.motor_state[9].dq = msg-&gt;dq;
+  _lowState.motor_state[9].tau_est = msg-&gt;tau_est;
@@ -484,4 +606,4 @@
-    _lowState.motor_state[10].mode = msg-&gt;mode;
-    _lowState.motor_state[10].q = msg-&gt;q;
-    _lowState.motor_state[10].dq = msg-&gt;dq;
-    _lowState.motor_state[10].tau_est = msg-&gt;tau_est;
+  _lowState.motor_state[10].mode = msg-&gt;mode;
+  _lowState.motor_state[10].q = msg-&gt;q;
+  _lowState.motor_state[10].dq = msg-&gt;dq;
+  _lowState.motor_state[10].tau_est = msg-&gt;tau_est;
@@ -492,8 +614,8 @@
-    _lowState.motor_state[11].mode = msg-&gt;mode;
-    _lowState.motor_state[11].q = msg-&gt;q;
-    _lowState.motor_state[11].dq = msg-&gt;dq;
-    _lowState.motor_state[11].tau_est = msg-&gt;tau_est;
-}
-
-
-#endif  // COMPILE_WITH_ROS2_MB
+  _lowState.motor_state[11].mode = msg-&gt;mode;
+  _lowState.motor_state[11].q = msg-&gt;q;
+  _lowState.motor_state[11].dq = msg-&gt;dq;
+  _lowState.motor_state[11].tau_est = msg-&gt;tau_est;
+}
+
+
+#endif  // COMPILE_WITH_ROS2_MB

Code style divergence in file 'src/interface/IOSDK.cpp':

--- src/interface/IOSDK.cpp
+++ src/interface/IOSDK.cpp.uncrustify
@@ -11,4 +11,7 @@
-IOSDK::IOSDK():_safe(UNITREE_LEGGED_SDK::LeggedType::Aliengo), _udp(UNITREE_LEGGED_SDK::LOWLEVEL, 8090, "192.168.123.10", 8007){
-    std::cout &lt;&lt; "The control interface for real robot" &lt;&lt; std::endl;
-    _udp.InitCmdData(_lowCmd);
-    cmdPanel = new WirelessHandle();
+IOSDK::IOSDK()
+: _safe(UNITREE_LEGGED_SDK::LeggedType::Aliengo), _udp(UNITREE_LEGGED_SDK::LOWLEVEL, 8090,
+    "192.168.123.10", 8007)
+{
+  std::cout &lt;&lt; "The control interface for real robot" &lt;&lt; std::endl;
+  _udp.InitCmdData(_lowCmd);
+  cmdPanel = new WirelessHandle();
@@ -17,5 +20,5 @@
-    _pub = _nh.advertise&lt;sensor_msgs::JointState&gt;("/realRobot/joint_states", 20);
-    _joint_state.name.resize(12);
-    _joint_state.position.resize(12);
-    _joint_state.velocity.resize(12);
-    _joint_state.effort.resize(12);
+  _pub = _nh.advertise&lt;sensor_msgs::JointState&gt;("/realRobot/joint_states", 20);
+  _joint_state.name.resize(12);
+  _joint_state.position.resize(12);
+  _joint_state.velocity.resize(12);
+  _joint_state.effort.resize(12);
@@ -27,4 +30,6 @@
-IOSDK::IOSDK():_safe(UNITREE_LEGGED_SDK::LeggedType::Aliengo), _udp(UNITREE_LEGGED_SDK::LOWLEVEL){
-    std::cout &lt;&lt; "The control interface for real robot" &lt;&lt; std::endl;
-    _udp.InitCmdData(_lowCmd);
-    cmdPanel = new WirelessHandle();
+IOSDK::IOSDK()
+: _safe(UNITREE_LEGGED_SDK::LeggedType::Aliengo), _udp(UNITREE_LEGGED_SDK::LOWLEVEL)
+{
+  std::cout &lt;&lt; "The control interface for real robot" &lt;&lt; std::endl;
+  _udp.InitCmdData(_lowCmd);
+  cmdPanel = new WirelessHandle();
@@ -33,5 +38,5 @@
-    _pub = _nh.advertise&lt;sensor_msgs::JointState&gt;("/realRobot/joint_states", 20);
-    _joint_state.name.resize(12);
-    _joint_state.position.resize(12);
-    _joint_state.velocity.resize(12);
-    _joint_state.effort.resize(12);
+  _pub = _nh.advertise&lt;sensor_msgs::JointState&gt;("/realRobot/joint_states", 20);
+  _joint_state.name.resize(12);
+  _joint_state.position.resize(12);
+  _joint_state.velocity.resize(12);
+  _joint_state.effort.resize(12);
@@ -43,12 +48,10 @@
-void IOSDK::sendRecv(const LowlevelCmd *cmd, LowlevelState *state){
-    for(int i(0); i &lt; 12; ++i){
-        _lowCmd.motorCmd[i].mode = cmd-&gt;motorCmd[i].mode;
-        _lowCmd.motorCmd[i].q    = cmd-&gt;motorCmd[i].q;
-        _lowCmd.motorCmd[i].dq   = cmd-&gt;motorCmd[i].dq;
-        _lowCmd.motorCmd[i].Kp   = cmd-&gt;motorCmd[i].Kp;
-        _lowCmd.motorCmd[i].Kd   = cmd-&gt;motorCmd[i].Kd;
-        _lowCmd.motorCmd[i].tau  = cmd-&gt;motorCmd[i].tau;
-    }
-    
-    _udp.SetSend(_lowCmd);
-    _udp.Send();
+void IOSDK::sendRecv(const LowlevelCmd * cmd, LowlevelState * state)
+{
+  for (int i(0); i &lt; 12; ++i) {
+    _lowCmd.motorCmd[i].mode = cmd-&gt;motorCmd[i].mode;
+    _lowCmd.motorCmd[i].q = cmd-&gt;motorCmd[i].q;
+    _lowCmd.motorCmd[i].dq = cmd-&gt;motorCmd[i].dq;
+    _lowCmd.motorCmd[i].Kp = cmd-&gt;motorCmd[i].Kp;
+    _lowCmd.motorCmd[i].Kd = cmd-&gt;motorCmd[i].Kd;
+    _lowCmd.motorCmd[i].tau = cmd-&gt;motorCmd[i].tau;
+  }
@@ -56,2 +59,2 @@
-    _udp.Recv();
-    _udp.GetRecv(_lowState);
+  _udp.SetSend(_lowCmd);
+  _udp.Send();
@@ -59,7 +62,2 @@
-    for(int i(0); i &lt; 12; ++i){
-        state-&gt;motorState[i].q = _lowState.motorState[i].q;
-        state-&gt;motorState[i].dq = _lowState.motorState[i].dq;
-        state-&gt;motorState[i].ddq = _lowState.motorState[i].ddq;
-        state-&gt;motorState[i].tauEst = _lowState.motorState[i].tauEst;
-        state-&gt;motorState[i].mode = _lowState.motorState[i].mode;
-    }
+  _udp.Recv();
+  _udp.GetRecv(_lowState);
@@ -67,6 +65,7 @@
-    for(int i(0); i &lt; 3; ++i){
-        state-&gt;imu.quaternion[i] = _lowState.imu.quaternion[i];
-        state-&gt;imu.gyroscope[i]  = _lowState.imu.gyroscope[i];
-        state-&gt;imu.accelerometer[i] = _lowState.imu.accelerometer[i];
-    }
-    state-&gt;imu.quaternion[3] = _lowState.imu.quaternion[3];
+  for (int i(0); i &lt; 12; ++i) {
+    state-&gt;motorState[i].q = _lowState.motorState[i].q;
+    state-&gt;motorState[i].dq = _lowState.motorState[i].dq;
+    state-&gt;motorState[i].ddq = _lowState.motorState[i].ddq;
+    state-&gt;motorState[i].tauEst = _lowState.motorState[i].tauEst;
+    state-&gt;motorState[i].mode = _lowState.motorState[i].mode;
+  }
@@ -74,3 +73,10 @@
-    cmdPanel-&gt;receiveHandle(&amp;_lowState);
-    state-&gt;userCmd = cmdPanel-&gt;getUserCmd();
-    state-&gt;userValue = cmdPanel-&gt;getUserValue();
+  for (int i(0); i &lt; 3; ++i) {
+    state-&gt;imu.quaternion[i] = _lowState.imu.quaternion[i];
+    state-&gt;imu.gyroscope[i] = _lowState.imu.gyroscope[i];
+    state-&gt;imu.accelerometer[i] = _lowState.imu.accelerometer[i];
+  }
+  state-&gt;imu.quaternion[3] = _lowState.imu.quaternion[3];
+
+  cmdPanel-&gt;receiveHandle(&amp;_lowState);
+  state-&gt;userCmd = cmdPanel-&gt;getUserCmd();
+  state-&gt;userValue = cmdPanel-&gt;getUserValue();
@@ -79,10 +85,10 @@
-    _joint_state.header.stamp = ros::Time::now();
-    _joint_state.name = {"FR_hip_joint", "FR_thigh_joint", "FR_calf_joint", 
-                         "FL_hip_joint", "FL_thigh_joint", "FL_calf_joint",  
-                         "RR_hip_joint", "RR_thigh_joint", "RR_calf_joint", 
-                         "RL_hip_joint", "RL_thigh_joint", "RL_calf_joint"};
-    for(int i(0); i&lt;12; ++i){
-        _joint_state.position[i] = state-&gt;motorState[i].q;
-        _joint_state.velocity[i] = state-&gt;motorState[i].dq;
-        _joint_state.effort[i]   = state-&gt;motorState[i].tauEst;
-    }
+  _joint_state.header.stamp = ros::Time::now();
+  _joint_state.name = {"FR_hip_joint", "FR_thigh_joint", "FR_calf_joint",
+    "FL_hip_joint", "FL_thigh_joint", "FL_calf_joint",
+    "RR_hip_joint", "RR_thigh_joint", "RR_calf_joint",
+    "RL_hip_joint", "RL_thigh_joint", "RL_calf_joint"};
+  for (int i(0); i &lt; 12; ++i) {
+    _joint_state.position[i] = state-&gt;motorState[i].q;
+    _joint_state.velocity[i] = state-&gt;motorState[i].dq;
+    _joint_state.effort[i] = state-&gt;motorState[i].tauEst;
+  }
@@ -90 +96 @@
-    _pub.publish(_joint_state);
+  _pub.publish(_joint_state);
@@ -94 +100 @@
-#endif  // COMPILE_WITH_REAL_ROBOT
+#endif  // COMPILE_WITH_REAL_ROBOT

Code style divergence in file 'src/interface/KeyBoard.cpp':

--- src/interface/KeyBoard.cpp
+++ src/interface/KeyBoard.cpp.uncrustify
@@ -7,3 +7,4 @@
-KeyBoard::KeyBoard(){
-    userCmd = UserCommand::NONE;
-    userValue.setZero();
+KeyBoard::KeyBoard()
+{
+  userCmd = UserCommand::NONE;
+  userValue.setZero();
@@ -11,4 +12,4 @@
-    tcgetattr( fileno( stdin ), &amp;_oldSettings );
-    _newSettings = _oldSettings;
-    _newSettings.c_lflag &amp;= (~ICANON &amp; ~ECHO);
-    tcsetattr( fileno( stdin ), TCSANOW, &amp;_newSettings );
+  tcgetattr(fileno(stdin), &amp;_oldSettings);
+  _newSettings = _oldSettings;
+  _newSettings.c_lflag &amp;= (~ICANON &amp; ~ECHO);
+  tcsetattr(fileno(stdin), TCSANOW, &amp;_newSettings);
@@ -16 +17 @@
-    pthread_create(&amp;_tid, NULL, runKeyBoard, (void*)this);
+  pthread_create(&amp;_tid, NULL, runKeyBoard, (void *)this);
@@ -19,4 +20,5 @@
-KeyBoard::~KeyBoard(){
-    pthread_cancel(_tid);
-    pthread_join(_tid, NULL);
-    tcsetattr( fileno( stdin ), TCSANOW, &amp;_oldSettings );
+KeyBoard::~KeyBoard()
+{
+  pthread_cancel(_tid);
+  pthread_join(_tid, NULL);
+  tcsetattr(fileno(stdin), TCSANOW, &amp;_oldSettings);
@@ -25,2 +27,3 @@
-UserCommand KeyBoard::checkCmd(){
-    switch (_c){
+UserCommand KeyBoard::checkCmd()
+{
+  switch (_c) {
@@ -28 +31 @@
-        return UserCommand::L2_B;
+      return UserCommand::L2_B;
@@ -30 +33 @@
-        return UserCommand::L2_A;
+      return UserCommand::L2_A;
@@ -32 +35 @@
-        return UserCommand::L2_X;
+      return UserCommand::L2_X;
@@ -34 +37 @@
-        return UserCommand::START;
+      return UserCommand::START;
@@ -37 +40 @@
-        return UserCommand::L2_Y;
+      return UserCommand::L2_Y;
@@ -41 +44 @@
-        return UserCommand::L2_Y;
+      return UserCommand::L2_Y;
@@ -44 +47 @@
-        return UserCommand::L1_X;
+      return UserCommand::L1_X;
@@ -46 +49 @@
-        return UserCommand::L1_A;
+      return UserCommand::L1_A;
@@ -48 +51 @@
-        return UserCommand::L1_Y;
+      return UserCommand::L1_Y;
@@ -50,2 +53,2 @@
-        userValue.setZero();
-        return UserCommand::NONE;
+      userValue.setZero();
+      return UserCommand::NONE;
@@ -53,2 +56,2 @@
-        return UserCommand::NONE;
-    }
+      return UserCommand::NONE;
+  }
@@ -57,14 +60,15 @@
-void KeyBoard::changeValue(){
-    switch (_c){
-    case 'w':case 'W':
-        userValue.ly = min&lt;float&gt;(userValue.ly+sensitivityLeft, 1.0);
-        break;
-    case 's':case 'S':
-        userValue.ly = max&lt;float&gt;(userValue.ly-sensitivityLeft, -1.0);
-        break;
-    case 'd':case 'D':
-        userValue.lx = min&lt;float&gt;(userValue.lx+sensitivityLeft, 1.0);
-        break;
-    case 'a':case 'A':
-        userValue.lx = max&lt;float&gt;(userValue.lx-sensitivityLeft, -1.0);
-        break;
+void KeyBoard::changeValue()
+{
+  switch (_c) {
+    case 'w': case 'W':
+      userValue.ly = min&lt;float&gt;(userValue.ly + sensitivityLeft, 1.0);
+      break;
+    case 's': case 'S':
+      userValue.ly = max&lt;float&gt;(userValue.ly - sensitivityLeft, -1.0);
+      break;
+    case 'd': case 'D':
+      userValue.lx = min&lt;float&gt;(userValue.lx + sensitivityLeft, 1.0);
+      break;
+    case 'a': case 'A':
+      userValue.lx = max&lt;float&gt;(userValue.lx - sensitivityLeft, -1.0);
+      break;
@@ -72,12 +76,12 @@
-    case 'i':case 'I':
-        userValue.ry = min&lt;float&gt;(userValue.ry+sensitivityRight, 1.0);
-        break;
-    case 'k':case 'K':
-        userValue.ry = max&lt;float&gt;(userValue.ry-sensitivityRight, -1.0);
-        break;
-    case 'l':case 'L':
-        userValue.rx = min&lt;float&gt;(userValue.rx+sensitivityRight, 1.0);
-        break;
-    case 'j':case 'J':
-        userValue.rx = max&lt;float&gt;(userValue.rx-sensitivityRight, -1.0);
-        break;
+    case 'i': case 'I':
+      userValue.ry = min&lt;float&gt;(userValue.ry + sensitivityRight, 1.0);
+      break;
+    case 'k': case 'K':
+      userValue.ry = max&lt;float&gt;(userValue.ry - sensitivityRight, -1.0);
+      break;
+    case 'l': case 'L':
+      userValue.rx = min&lt;float&gt;(userValue.rx + sensitivityRight, 1.0);
+      break;
+    case 'j': case 'J':
+      userValue.rx = max&lt;float&gt;(userValue.rx - sensitivityRight, -1.0);
+      break;
@@ -85,2 +89,2 @@
-        break;
-    }
+      break;
+  }
@@ -89,3 +93,4 @@
-void* KeyBoard::runKeyBoard(void *arg){
-    ((KeyBoard*)arg)-&gt;run(NULL);
-    return NULL;
+void * KeyBoard::runKeyBoard(void * arg)
+{
+  ((KeyBoard *)arg)-&gt;run(NULL);
+  return NULL;
@@ -94,4 +99,5 @@
-void* KeyBoard::run(void *arg){
-    while(1){
-        FD_ZERO(&amp;set);
-        FD_SET( fileno( stdin ), &amp;set );
+void * KeyBoard::run(void * arg)
+{
+  while (1) {
+    FD_ZERO(&amp;set);
+    FD_SET(fileno(stdin), &amp;set);
@@ -99 +105 @@
-        res = select( fileno( stdin )+1, &amp;set, NULL, NULL, NULL);
+    res = select(fileno(stdin) + 1, &amp;set, NULL, NULL, NULL);
@@ -101,8 +107,7 @@
-        if(res &gt; 0){
-            ret = read( fileno( stdin ), &amp;_c, 1 );
-            userCmd = checkCmd();
-            if(userCmd == UserCommand::NONE)
-                changeValue();
-            _c = '\0';
-        }
-        usleep(1000);
+    if (res &gt; 0) {
+      ret = read(fileno(stdin), &amp;_c, 1);
+      userCmd = checkCmd();
+      if (userCmd == UserCommand::NONE) {
+        changeValue();
+      }
+      _c = '\0';
@@ -110,2 +115,4 @@
-    return NULL;
-}
+    usleep(1000);
+  }
+  return NULL;
+}

Code style divergence in file 'src/interface/WirelessHandle.cpp':

--- src/interface/WirelessHandle.cpp
+++ src/interface/WirelessHandle.cpp.uncrustify
@@ -11 +11,2 @@
-WirelessHandle::WirelessHandle(){
+WirelessHandle::WirelessHandle()
+{
@@ -14 +15,2 @@
-void WirelessHandle::receiveHandle(UNITREE_LEGGED_SDK::LowState *lowState){
+void WirelessHandle::receiveHandle(UNITREE_LEGGED_SDK::LowState * lowState)
+{
@@ -16 +18 @@
-    memcpy(&amp;_keyData, lowState-&gt;wirelessRemote, 40);  // note: available in the unitree_legged_sdk_3.2
+  memcpy(&amp;_keyData, lowState-&gt;wirelessRemote, 40);    // note: available in the unitree_legged_sdk_3.2
@@ -19,14 +21,15 @@
-    memcpy(&amp;_keyData, &amp;lowState-&gt;wirelessRemote[0], 40);
-#endif  
-    if(((int)_keyData.btn.components.L2 == 1) &amp;&amp; 
-       ((int)_keyData.btn.components.B  == 1)){
-        userCmd = UserCommand::L2_B;
-    }
-    else if(((int)_keyData.btn.components.L2 == 1) &amp;&amp; 
-            ((int)_keyData.btn.components.A  == 1)){
-        userCmd = UserCommand::L2_A;
-    }
-    else if(((int)_keyData.btn.components.L2 == 1) &amp;&amp; 
-            ((int)_keyData.btn.components.X  == 1)){
-        userCmd = UserCommand::L2_X;
-    }
+  memcpy(&amp;_keyData, &amp;lowState-&gt;wirelessRemote[0], 40);
+#endif
+  if (((int)_keyData.btn.components.L2 == 1) &amp;&amp;
+    ((int)_keyData.btn.components.B == 1))
+  {
+    userCmd = UserCommand::L2_B;
+  } else if (((int)_keyData.btn.components.L2 == 1) &amp;&amp;
+    ((int)_keyData.btn.components.A == 1))
+  {
+    userCmd = UserCommand::L2_A;
+  } else if (((int)_keyData.btn.components.L2 == 1) &amp;&amp;
+    ((int)_keyData.btn.components.X == 1))
+  {
+    userCmd = UserCommand::L2_X;
+  }
@@ -35,4 +38,5 @@
-    else if(((int)_keyData.btn.components.L2 == 1) &amp;&amp; 
-            ((int)_keyData.btn.components.Y  == 1)){
-        userCmd = UserCommand::L2_Y;
-    }
+  else if (((int)_keyData.btn.components.L2 == 1) &amp;&amp;
+    ((int)_keyData.btn.components.Y == 1))
+  {
+    userCmd = UserCommand::L2_Y;
+  }
@@ -42,4 +46,5 @@
-    else if(((int)_keyData.btn.components.L2 == 1) &amp;&amp; 
-            ((int)_keyData.btn.components.Y  == 1)){
-        userCmd = UserCommand::L2_Y;
-    }
+  else if (((int)_keyData.btn.components.L2 == 1) &amp;&amp;
+    ((int)_keyData.btn.components.Y == 1))
+  {
+    userCmd = UserCommand::L2_Y;
+  }
@@ -48,15 +53,15 @@
-    else if(((int)_keyData.btn.components.L1 == 1) &amp;&amp; 
-            ((int)_keyData.btn.components.X  == 1)){
-        userCmd = UserCommand::L1_X;
-    }
-    else if(((int)_keyData.btn.components.L1 == 1) &amp;&amp; 
-            ((int)_keyData.btn.components.A  == 1)){
-        userCmd = UserCommand::L1_A;
-    }
-    else if(((int)_keyData.btn.components.L1 == 1) &amp;&amp; 
-            ((int)_keyData.btn.components.Y  == 1)){
-        userCmd = UserCommand::L1_Y;
-    }
-    else if((int)_keyData.btn.components.start == 1){
-        userCmd = UserCommand::START;
-    }
+  else if (((int)_keyData.btn.components.L1 == 1) &amp;&amp;
+    ((int)_keyData.btn.components.X == 1))
+  {
+    userCmd = UserCommand::L1_X;
+  } else if (((int)_keyData.btn.components.L1 == 1) &amp;&amp;
+    ((int)_keyData.btn.components.A == 1))
+  {
+    userCmd = UserCommand::L1_A;
+  } else if (((int)_keyData.btn.components.L1 == 1) &amp;&amp;
+    ((int)_keyData.btn.components.Y == 1))
+  {
+    userCmd = UserCommand::L1_Y;
+  } else if ((int)_keyData.btn.components.start == 1) {
+    userCmd = UserCommand::START;
+  }
@@ -64,5 +69,5 @@
-    userValue.L2 = killZeroOffset(_keyData.L2, 0.08);
-    userValue.lx = killZeroOffset(_keyData.lx, 0.08);
-    userValue.ly = killZeroOffset(_keyData.ly, 0.08);
-    userValue.rx = killZeroOffset(_keyData.rx, 0.08);
-    userValue.ry = killZeroOffset(_keyData.ry, 0.08);
+  userValue.L2 = killZeroOffset(_keyData.L2, 0.08);
+  userValue.lx = killZeroOffset(_keyData.lx, 0.08);
+  userValue.ly = killZeroOffset(_keyData.ly, 0.08);
+  userValue.rx = killZeroOffset(_keyData.rx, 0.08);
+  userValue.ry = killZeroOffset(_keyData.ry, 0.08);

Code style divergence in file 'src/main.cpp':

--- src/main.cpp
+++ src/main.cpp.uncrustify
@@ -33,2 +33,2 @@
-    std::cout &lt;&lt; "stop the controller" &lt;&lt; std::endl;
-    running = false;
+  std::cout &lt;&lt; "stop the controller" &lt;&lt; std::endl;
+  running = false;
@@ -39,7 +39,6 @@
-    pid_t pid = getpid();
-    sched_param param;
-    param.sched_priority = sched_get_priority_max(SCHED_FIFO);
-    if (sched_setscheduler(pid, SCHED_FIFO, &amp;param) == -1)
-    {
-        std::cout &lt;&lt; "[ERROR] Function setProcessScheduler failed." &lt;&lt; std::endl;
-    }
+  pid_t pid = getpid();
+  sched_param param;
+  param.sched_priority = sched_get_priority_max(SCHED_FIFO);
+  if (sched_setscheduler(pid, SCHED_FIFO, &amp;param) == -1) {
+    std::cout &lt;&lt; "[ERROR] Function setProcessScheduler failed." &lt;&lt; std::endl;
+  }
@@ -48 +47 @@
-int main(int argc, char **argv)
+int main(int argc, char ** argv)
@@ -50,4 +49,4 @@
-    /* set real-time process */
-    setProcessScheduler();
-    /* set the print format */
-    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3);
+  /* set real-time process */
+  setProcessScheduler();
+  /* set the print format */
+  std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3);
@@ -56 +55 @@
-    // ros::init(argc, argv, "unitree_gazebo_servo");
+  // ros::init(argc, argv, "unitree_gazebo_servo");
@@ -58,4 +57,4 @@
-    // ROS 2
-    rclcpp::init(argc, argv);
-    auto node = std::make_shared&lt;rclcpp::Node&gt;("unitree_gazebo_server");
-    std::cout &lt;&lt; "initialized node" &lt;&lt; std::endl;
+  // ROS 2
+  rclcpp::init(argc, argv);
+  auto node = std::make_shared&lt;rclcpp::Node&gt;("unitree_gazebo_server");
+  std::cout &lt;&lt; "initialized node" &lt;&lt; std::endl;
@@ -65,2 +64,2 @@
-    IOInterface *ioInter;
-    CtrlPlatform ctrlPlat;
+  IOInterface * ioInter;
+  CtrlPlatform ctrlPlat;
@@ -69,2 +68,2 @@
-    ioInter = new IOROS(node);
-    ctrlPlat = CtrlPlatform::GAZEBO;
+  ioInter = new IOROS(node);
+  ctrlPlat = CtrlPlatform::GAZEBO;
@@ -74,2 +73,2 @@
-    ioInter = new IOSDK();
-    ctrlPlat = CtrlPlatform::REALROBOT;
+  ioInter = new IOSDK();
+  ctrlPlat = CtrlPlatform::REALROBOT;
@@ -78,5 +77,5 @@
-    CtrlComponents *ctrlComp = new CtrlComponents(ioInter);
-    ctrlComp-&gt;ctrlPlatform = ctrlPlat;
-    ctrlComp-&gt;dt = 0.002; // run at 500hz
-    ctrlComp-&gt;running = &amp;running;
-    std::cout &lt;&lt; "initialized ctrl components" &lt;&lt; std::endl;
+  CtrlComponents * ctrlComp = new CtrlComponents(ioInter);
+  ctrlComp-&gt;ctrlPlatform = ctrlPlat;
+  ctrlComp-&gt;dt = 0.002;   // run at 500hz
+  ctrlComp-&gt;running = &amp;running;
+  std::cout &lt;&lt; "initialized ctrl components" &lt;&lt; std::endl;
@@ -85 +84 @@
-    ctrlComp-&gt;robotModel = new A1Robot();
+  ctrlComp-&gt;robotModel = new A1Robot();
@@ -88 +87 @@
-    ctrlComp-&gt;robotModel = new Go1Robot();
+  ctrlComp-&gt;robotModel = new Go1Robot();
@@ -91,6 +90,6 @@
-    ctrlComp-&gt;waveGen = new WaveGenerator(0.45, 0.5, Vec4(0, 0.5, 0.5, 0)); // Trot
-    std::cout &lt;&lt; "initialized wave generator" &lt;&lt; std::endl;
-    // ctrlComp-&gt;waveGen = new WaveGenerator(1.1, 0.75, Vec4(0, 0.25, 0.5, 0.75));  //Crawl, only for sim
-    // ctrlComp-&gt;waveGen = new WaveGenerator(0.4, 0.6, Vec4(0, 0.5, 0.5, 0));  //Walking Trot, only for sim
-    // ctrlComp-&gt;waveGen = new WaveGenerator(0.4, 0.35, Vec4(0, 0.5, 0.5, 0));  //Running Trot, only for sim
-    // ctrlComp-&gt;waveGen = new WaveGenerator(0.4, 0.7, Vec4(0, 0, 0, 0));  //Pronk, only for sim
+  ctrlComp-&gt;waveGen = new WaveGenerator(0.45, 0.5, Vec4(0, 0.5, 0.5, 0));   // Trot
+  std::cout &lt;&lt; "initialized wave generator" &lt;&lt; std::endl;
+  // ctrlComp-&gt;waveGen = new WaveGenerator(1.1, 0.75, Vec4(0, 0.25, 0.5, 0.75));  //Crawl, only for sim
+  // ctrlComp-&gt;waveGen = new WaveGenerator(0.4, 0.6, Vec4(0, 0.5, 0.5, 0));  //Walking Trot, only for sim
+  // ctrlComp-&gt;waveGen = new WaveGenerator(0.4, 0.35, Vec4(0, 0.5, 0.5, 0));  //Running Trot, only for sim
+  // ctrlComp-&gt;waveGen = new WaveGenerator(0.4, 0.7, Vec4(0, 0, 0, 0));  //Pronk, only for sim
@@ -98 +97 @@
-    ctrlComp-&gt;geneObj();
+  ctrlComp-&gt;geneObj();
@@ -100,2 +99,2 @@
-    ControlFrame ctrlFrame(ctrlComp);
-    std::cout &lt;&lt; "initialized ctrl frame" &lt;&lt; std::endl;
+  ControlFrame ctrlFrame(ctrlComp);
+  std::cout &lt;&lt; "initialized ctrl frame" &lt;&lt; std::endl;
@@ -103,2 +102,2 @@
-    signal(SIGINT, ShutDown);
-    // std::cout &lt;&lt; "initialized main sig shutdown" &lt;&lt; std::endl;
+  signal(SIGINT, ShutDown);
+  // std::cout &lt;&lt; "initialized main sig shutdown" &lt;&lt; std::endl;
@@ -106,5 +105,4 @@
-    while (running)
-    {   
-        // std::cout &lt;&lt; "running main loop" &lt;&lt; std::endl;
-        ctrlFrame.run();
-    }
+  while (running) {
+    // std::cout &lt;&lt; "running main loop" &lt;&lt; std::endl;
+    ctrlFrame.run();
+  }
@@ -112,2 +110,2 @@
-    delete ctrlComp;
-    return 0;
+  delete ctrlComp;
+  return 0;

Code style divergence in file 'src/quadProgpp/Array.cc':

--- src/quadProgpp/Array.cc
+++ src/quadProgpp/Array.cc.uncrustify
@@ -2,2 +2,2 @@
-// This file is part of QuadProg++:  
-// Copyright (C) 2006--2009 Luca Di Gaspero. 
+// This file is part of QuadProg++:
+// Copyright (C) 2006--2009 Luca Di Gaspero.
@@ -16,8 +16,6 @@
-std::set&lt;unsigned int&gt; seq(unsigned int s, unsigned int e)
-{
-	std::set&lt;unsigned int&gt; tmp;
-	for (unsigned int i = s; i &lt;= e; i++)
-		tmp.insert(i);
-	
-	return tmp;
-}
+  std::set &lt; unsigned int &gt; seq(unsigned int s, unsigned int e)
+  {
+    std::set &lt; unsigned int &gt; tmp;
+    for (unsigned int i = s; i &lt;= e; i++) {
+      tmp.insert(i);
+    }
@@ -25,7 +23,10 @@
-std::set&lt;unsigned int&gt; singleton(unsigned int i)
-{
-	std::set&lt;unsigned int&gt; tmp;
-	tmp.insert(i);
-	
-	return tmp;
-}
+    return tmp;
+  }
+
+  std::set &lt; unsigned int &gt; singleton(unsigned int i)
+  {
+    std::set &lt; unsigned int &gt; tmp;
+    tmp.insert(i);
+
+    return tmp;
+  }

Code style divergence in file 'src/quadProgpp/QuadProg++.cc':

--- src/quadProgpp/QuadProg++.cc
+++ src/quadProgpp/QuadProg++.cc.uncrustify
@@ -1 +1 @@
-/* 
+/*
@@ -3 +3 @@
- 
+
@@ -8 +8 @@
- 
+
@@ -11 +11 @@
- 
+
@@ -25,6 +25,14 @@
-// Utility functions for updating some data needed by the solution method 
-void compute_d(Vector&lt;double&gt;&amp; d, const Matrix&lt;double&gt;&amp; J, const Vector&lt;double&gt;&amp; np);
-void update_z(Vector&lt;double&gt;&amp; z, const Matrix&lt;double&gt;&amp; J, const Vector&lt;double&gt;&amp; d, int iq);
-void update_r(const Matrix&lt;double&gt;&amp; R, Vector&lt;double&gt;&amp; r, const Vector&lt;double&gt;&amp; d, int iq);
-bool add_constraint(Matrix&lt;double&gt;&amp; R, Matrix&lt;double&gt;&amp; J, Vector&lt;double&gt;&amp; d, unsigned int&amp; iq, double&amp; rnorm);
-void delete_constraint(Matrix&lt;double&gt;&amp; R, Matrix&lt;double&gt;&amp; J, Vector&lt;int&gt;&amp; A, Vector&lt;double&gt;&amp; u, unsigned int n, int p, unsigned int&amp; iq, int l);
+// Utility functions for updating some data needed by the solution method
+  void compute_d(Vector &lt; double &gt; &amp; d, const Matrix &lt; double &gt; &amp; J, const Vector &lt; double &gt; &amp; np);
+  void update_z(
+    Vector &lt; double &gt; &amp; z, const Matrix &lt; double &gt; &amp; J, const Vector &lt; double &gt; &amp; d,
+    int iq);
+  void update_r(
+    const Matrix &lt; double &gt; &amp; R, Vector &lt; double &gt; &amp; r, const Vector &lt; double &gt; &amp; d,
+    int iq);
+  bool add_constraint(
+    Matrix &lt; double &gt; &amp; R, Matrix &lt; double &gt; &amp; J, Vector &lt; double &gt; &amp; d,
+    unsigned int &amp; iq, double &amp; rnorm);
+  void delete_constraint(
+    Matrix &lt; double &gt; &amp; R, Matrix &lt; double &gt; &amp; J, Vector &lt; int &gt; &amp; A,
+    Vector &lt; double &gt; &amp; u, unsigned int n, int p, unsigned int &amp; iq, int l);
@@ -34,6 +42,12 @@
-void cholesky_decomposition(Matrix&lt;double&gt;&amp; A);
-void cholesky_solve(const Matrix&lt;double&gt;&amp; L, Vector&lt;double&gt;&amp; x, const Vector&lt;double&gt;&amp; b);
-void forward_elimination(const Matrix&lt;double&gt;&amp; L, Vector&lt;double&gt;&amp; y, const Vector&lt;double&gt;&amp; b);
-void backward_elimination(const Matrix&lt;double&gt;&amp; U, Vector&lt;double&gt;&amp; x, const Vector&lt;double&gt;&amp; y);
-
-// Utility functions for computing the scalar product and the euclidean 
+  void cholesky_decomposition(Matrix &lt; double &gt; &amp; A);
+  void cholesky_solve(
+    const Matrix &lt; double &gt; &amp; L, Vector &lt; double &gt; &amp; x,
+    const Vector &lt; double &gt; &amp; b);
+  void forward_elimination(
+    const Matrix &lt; double &gt; &amp; L, Vector &lt; double &gt; &amp; y,
+    const Vector &lt; double &gt; &amp; b);
+  void backward_elimination(
+    const Matrix &lt; double &gt; &amp; U, Vector &lt; double &gt; &amp; x,
+    const Vector &lt; double &gt; &amp; y);
+
+// Utility functions for computing the scalar product and the euclidean
@@ -41,2 +55,2 @@
-double scalar_product(const Vector&lt;double&gt;&amp; x, const Vector&lt;double&gt;&amp; y);
-double distance(double a, double b);
+  double scalar_product(const Vector &lt; double &gt; &amp; x, const Vector &lt; double &gt; &amp; y);
+  double distance(double a, double b);
@@ -45,4 +59,4 @@
-void print_matrix(const char* name, const Matrix&lt;double&gt;&amp; A, int n = -1, int m = -1);
-
-template&lt;typename T&gt;
-void print_vector(const char* name, const Vector&lt;T&gt;&amp; v, int n = -1);
+  void print_matrix(const char * name, const Matrix &lt; double &gt; &amp; A, int n = -1, int m = -1);
+
+  template &lt; typename T &gt;
+  void print_vector(const char * name, const Vector &lt; T &gt; &amp; v, int n = -1);
@@ -51,44 +65,45 @@
-double solve_quadprog(Matrix&lt;double&gt;&amp; G, Vector&lt;double&gt;&amp; g0, 
-                      const Matrix&lt;double&gt;&amp; CE, const Vector&lt;double&gt;&amp; ce0,  
-                      const Matrix&lt;double&gt;&amp; CI, const Vector&lt;double&gt;&amp; ci0, 
-                      Vector&lt;double&gt;&amp; x)
-{
-  std::ostringstream msg;
-  unsigned int n = G.ncols(), p = CE.ncols(), m = CI.ncols();
-  if (G.nrows() != n)
-  {
-    msg &lt;&lt; "The matrix G is not a squared matrix (" &lt;&lt; G.nrows() &lt;&lt; " x " &lt;&lt; G.ncols() &lt;&lt; ")";
-    throw std::logic_error(msg.str());
-  }
-  if (CE.nrows() != n)
-  {
-    msg &lt;&lt; "The matrix CE is incompatible (incorrect number of rows " &lt;&lt; CE.nrows() &lt;&lt; " , expecting " &lt;&lt; n &lt;&lt; ")";
-    throw std::logic_error(msg.str());
-  }
-  if (ce0.size() != p)
-  {
-    msg &lt;&lt; "The vector ce0 is incompatible (incorrect dimension " &lt;&lt; ce0.size() &lt;&lt; ", expecting " &lt;&lt; p &lt;&lt; ")";
-    throw std::logic_error(msg.str());
-  }
-  if (CI.nrows() != n)
-  {
-    msg &lt;&lt; "The matrix CI is incompatible (incorrect number of rows " &lt;&lt; CI.nrows() &lt;&lt; " , expecting " &lt;&lt; n &lt;&lt; ")";
-    throw std::logic_error(msg.str());
-  }
-  if (ci0.size() != m)
-  {
-    msg &lt;&lt; "The vector ci0 is incompatible (incorrect dimension " &lt;&lt; ci0.size() &lt;&lt; ", expecting " &lt;&lt; m &lt;&lt; ")";
-    throw std::logic_error(msg.str());
-  }
-  x.resize(n);
-  register unsigned int i, j, k, l; /* indices */
-  int ip; // this is the index of the constraint to be added to the active set
-  Matrix&lt;double&gt; R(n, n), J(n, n);
-  Vector&lt;double&gt; s(m + p), z(n), r(m + p), d(n), np(n), u(m + p), x_old(n), u_old(m + p);
-  double f_value, psi, c1, c2, sum, ss, R_norm;
-  double inf;
-  if (std::numeric_limits&lt;double&gt;::has_infinity)
-    inf = std::numeric_limits&lt;double&gt;::infinity();
-  else
-    inf = 1.0E300;
-  double t, t1, t2; /* t is the step lenght, which is the minimum of the partial step length t1 
+  double solve_quadprog(
+    Matrix &lt; double &gt; &amp; G, Vector &lt; double &gt; &amp; g0,
+    const Matrix &lt; double &gt; &amp; CE, const Vector &lt; double &gt; &amp; ce0,
+    const Matrix &lt; double &gt; &amp; CI, const Vector &lt; double &gt; &amp; ci0,
+    Vector &lt; double &gt; &amp; x)
+  {
+    std::ostringstream msg;
+    unsigned int n = G.ncols(), p = CE.ncols(), m = CI.ncols();
+    if (G.nrows() != n) {
+      msg &lt;&lt; "The matrix G is not a squared matrix (" &lt;&lt; G.nrows() &lt;&lt; " x " &lt;&lt; G.ncols() &lt;&lt; ")";
+      throw std::logic_error(msg.str());
+    }
+    if (CE.nrows() != n) {
+      msg &lt;&lt; "The matrix CE is incompatible (incorrect number of rows " &lt;&lt; CE.nrows() &lt;&lt;
+        " , expecting " &lt;&lt; n &lt;&lt; ")";
+      throw std::logic_error(msg.str());
+    }
+    if (ce0.size() != p) {
+      msg &lt;&lt; "The vector ce0 is incompatible (incorrect dimension " &lt;&lt; ce0.size() &lt;&lt;
+        ", expecting " &lt;&lt; p &lt;&lt; ")";
+      throw std::logic_error(msg.str());
+    }
+    if (CI.nrows() != n) {
+      msg &lt;&lt; "The matrix CI is incompatible (incorrect number of rows " &lt;&lt; CI.nrows() &lt;&lt;
+        " , expecting " &lt;&lt; n &lt;&lt; ")";
+      throw std::logic_error(msg.str());
+    }
+    if (ci0.size() != m) {
+      msg &lt;&lt; "The vector ci0 is incompatible (incorrect dimension " &lt;&lt; ci0.size() &lt;&lt;
+        ", expecting " &lt;&lt; m &lt;&lt; ")";
+      throw std::logic_error(msg.str());
+    }
+    x.resize(n);
+    register unsigned int i, j, k, l; /* indices */
+    int ip; // this is the index of the constraint to be added to the active set
+    Matrix &lt; double &gt; R(n, n), J(n, n);
+    Vector &lt; double &gt; s(m + p), z(n), r(m + p), d(n), np(n), u(m + p), x_old(n), u_old(m + p);
+    double f_value, psi, c1, c2, sum, ss, R_norm;
+    double inf;
+    if (std::numeric_limits &lt; double &gt; ::has_infinity) {
+      inf = std::numeric_limits &lt; double &gt; ::infinity();
+    } else {
+      inf = 1.0E300;
+    }
+    double t, t1, t2; /* t is the step lenght, which is the minimum of the partial step length t1
@@ -96,111 +111,153 @@
-  Vector&lt;int&gt; A(m + p), A_old(m + p), iai(m + p);
-  unsigned int iq, iter = 0;
-  Vector&lt;bool&gt; iaexcl(m + p);
-	
-  /* p is the number of equality constraints */
-  /* m is the number of inequality constraints */
-#ifdef TRACE_SOLVER
-  std::cout &lt;&lt; std::endl &lt;&lt; "Starting solve_quadprog" &lt;&lt; std::endl;
-  print_matrix("G", G);
-  print_vector("g0", g0);
-  print_matrix("CE", CE);
-  print_vector("ce0", ce0);
-  print_matrix("CI", CI);
-  print_vector("ci0", ci0);
-#endif  
-  
-  /*
-   * Preprocessing phase
-   */
-	
-  /* compute the trace of the original matrix G */
-  c1 = 0.0;
-  for (i = 0; i &lt; n; i++)
-  {
-    c1 += G[i][i];
-  }
-  /* decompose the matrix G in the form L^T L */
-  cholesky_decomposition(G);
-#ifdef TRACE_SOLVER
-  print_matrix("G", G);
-#endif
-  /* initialize the matrix R */
-  for (i = 0; i &lt; n; i++)
-  {
-    d[i] = 0.0;
-    for (j = 0; j &lt; n; j++)
-      R[i][j] = 0.0;
-  }
-  R_norm = 1.0; /* this variable will hold the norm of the matrix R */
-  
-  /* compute the inverse of the factorized matrix G^-1, this is the initial value for H */
-  c2 = 0.0;
-  for (i = 0; i &lt; n; i++) 
-  {
-    d[i] = 1.0;
-    forward_elimination(G, z, d);
-    for (j = 0; j &lt; n; j++)
-      J[i][j] = z[j];
-    c2 += z[i];
-    d[i] = 0.0;
-  }
-#ifdef TRACE_SOLVER
-  print_matrix("J", J);
-#endif
-  
-  /* c1 * c2 is an estimate for cond(G) */
-  
-  /* 
-    * Find the unconstrained minimizer of the quadratic form 0.5 * x G x + g0 x 
-   * this is a feasible point in the dual space
-   * x = G^-1 * g0
-   */
-  cholesky_solve(G, x, g0);
-  for (i = 0; i &lt; n; i++)
-    x[i] = -x[i];
-  /* and compute the current solution value */ 
-  f_value = 0.5 * scalar_product(g0, x);
-#ifdef TRACE_SOLVER
-  std::cout &lt;&lt; "Unconstrained solution: " &lt;&lt; f_value &lt;&lt; std::endl;
-  print_vector("x", x);
-#endif
-  
-  /* Add equality constraints to the working set A */
-  iq = 0;
-  for (i = 0; i &lt; p; i++)
-  {
-    for (j = 0; j &lt; n; j++)
-      np[j] = CE[j][i];
-    compute_d(d, J, np);
-    update_z(z, J, d, iq);
-    update_r(R, r, d, iq);
-#ifdef TRACE_SOLVER
-    print_matrix("R", R, n, iq);
-    print_vector("z", z);
-    print_vector("r", r, iq);
-    print_vector("d", d);
-#endif
-    
-    /* compute full step length t2: i.e., the minimum step in primal space s.t. the contraint 
-      becomes feasible */
-    t2 = 0.0;
-    if (fabs(scalar_product(z, z)) &gt; std::numeric_limits&lt;double&gt;::epsilon()) // i.e. z != 0
-      t2 = (-scalar_product(np, x) - ce0[i]) / scalar_product(z, np);
-    
-    /* set x = x + t2 * z */
-    for (k = 0; k &lt; n; k++)
-      x[k] += t2 * z[k];
-    
-    /* set u = u+ */
-    u[iq] = t2;
-    for (k = 0; k &lt; iq; k++)
-      u[k] -= t2 * r[k];
-    
-    /* compute the new solution value */
-    f_value += 0.5 * (t2 * t2) * scalar_product(z, np);
-    A[i] = -i - 1;
-    
-    if (!add_constraint(R, J, d, iq, R_norm))
-    {	  
-      // Equality constraints are linearly dependent
-      throw std::runtime_error("Constraints are linearly dependent");
+    Vector &lt; int &gt; A(m + p), A_old(m + p), iai(m + p);
+    unsigned int iq, iter = 0;
+    Vector &lt; bool &gt; iaexcl(m + p);
+
+    /* p is the number of equality constraints */
+    /* m is the number of inequality constraints */
+#ifdef TRACE_SOLVER
+    std::cout &lt;&lt; std::endl &lt;&lt; "Starting solve_quadprog" &lt;&lt; std::endl;
+    print_matrix("G", G);
+    print_vector("g0", g0);
+    print_matrix("CE", CE);
+    print_vector("ce0", ce0);
+    print_matrix("CI", CI);
+    print_vector("ci0", ci0);
+#endif
+
+    /*
+     * Preprocessing phase
+     */
+
+    /* compute the trace of the original matrix G */
+    c1 = 0.0;
+    for (i = 0; i &lt; n; i++) {
+      c1 += G[i][i];
+    }
+    /* decompose the matrix G in the form L^T L */
+    cholesky_decomposition(G);
+#ifdef TRACE_SOLVER
+    print_matrix("G", G);
+#endif
+    /* initialize the matrix R */
+    for (i = 0; i &lt; n; i++) {
+      d[i] = 0.0;
+      for (j = 0; j &lt; n; j++) {
+        R[i][j] = 0.0;
+      }
+    }
+    R_norm = 1.0; /* this variable will hold the norm of the matrix R */
+
+    /* compute the inverse of the factorized matrix G^-1, this is the initial value for H */
+    c2 = 0.0;
+    for (i = 0; i &lt; n; i++) {
+      d[i] = 1.0;
+      forward_elimination(G, z, d);
+      for (j = 0; j &lt; n; j++) {
+        J[i][j] = z[j];
+      }
+      c2 += z[i];
+      d[i] = 0.0;
+    }
+#ifdef TRACE_SOLVER
+    print_matrix("J", J);
+#endif
+
+    /* c1 * c2 is an estimate for cond(G) */
+
+    /*
+      * Find the unconstrained minimizer of the quadratic form 0.5 * x G x + g0 x
+     * this is a feasible point in the dual space
+     * x = G^-1 * g0
+     */
+    cholesky_solve(G, x, g0);
+    for (i = 0; i &lt; n; i++) {
+      x[i] = -x[i];
+    }
+    /* and compute the current solution value */
+    f_value = 0.5 * scalar_product(g0, x);
+#ifdef TRACE_SOLVER
+    std::cout &lt;&lt; "Unconstrained solution: " &lt;&lt; f_value &lt;&lt; std::endl;
+    print_vector("x", x);
+#endif
+
+    /* Add equality constraints to the working set A */
+    iq = 0;
+    for (i = 0; i &lt; p; i++) {
+      for (j = 0; j &lt; n; j++) {
+        np[j] = CE[j][i];
+      }
+      compute_d(d, J, np);
+      update_z(z, J, d, iq);
+      update_r(R, r, d, iq);
+#ifdef TRACE_SOLVER
+      print_matrix("R", R, n, iq);
+      print_vector("z", z);
+      print_vector("r", r, iq);
+      print_vector("d", d);
+#endif
+
+      /* compute full step length t2: i.e., the minimum step in primal space s.t. the contraint
+        becomes feasible */
+      t2 = 0.0;
+      if (fabs(scalar_product(z, z)) &gt; std::numeric_limits &lt; double &gt; ::epsilon()) { // i.e. z != 0
+        t2 = (-scalar_product(np, x) - ce0[i]) / scalar_product(z, np);
+      }
+
+      /* set x = x + t2 * z */
+      for (k = 0; k &lt; n; k++) {
+        x[k] += t2 * z[k];
+      }
+
+      /* set u = u+ */
+      u[iq] = t2;
+      for (k = 0; k &lt; iq; k++) {
+        u[k] -= t2 * r[k];
+      }
+
+      /* compute the new solution value */
+      f_value += 0.5 * (t2 * t2) * scalar_product(z, np);
+      A[i] = -i - 1;
+
+      if (!add_constraint(R, J, d, iq, R_norm)) {
+        // Equality constraints are linearly dependent
+        throw std::runtime_error("Constraints are linearly dependent");
+        return f_value;
+      }
+    }
+
+    /* set iai = K \ A */
+    for (i = 0; i &lt; m; i++) {
+      iai[i] = i;
+    }
+
+l1: iter++;
+#ifdef TRACE_SOLVER
+    print_vector("x", x);
+#endif
+    /* step 1: choose a violated constraint */
+    for (i = p; i &lt; iq; i++) {
+      ip = A[i];
+      iai[ip] = -1;
+    }
+
+    /* compute s[x] = ci^T * x + ci0 for all elements of K \ A */
+    ss = 0.0;
+    psi = 0.0; /* this value will contain the sum of all infeasibilities */
+    ip = 0; /* ip will be the index of the chosen violated constraint */
+    for (i = 0; i &lt; m; i++) {
+      iaexcl[i] = true;
+      sum = 0.0;
+      for (j = 0; j &lt; n; j++) {
+        sum += CI[j][i] * x[j];
+      }
+      sum += ci0[i];
+      s[i] = sum;
+      psi += std::min(0.0, sum);
+    }
+#ifdef TRACE_SOLVER
+    print_vector("s", s, m);
+#endif
+
+
+    if (fabs(psi) &lt;= m * std::numeric_limits &lt; double &gt; ::epsilon() * c1 * c2 * 100.0) {
+      /* numerically there are not infeasibilities anymore */
@@ -209,52 +266,11 @@
-  }
-  
-  /* set iai = K \ A */
-  for (i = 0; i &lt; m; i++)
-    iai[i] = i;
-  
-l1:	iter++;
-#ifdef TRACE_SOLVER
-  print_vector("x", x);
-#endif
-  /* step 1: choose a violated constraint */
-  for (i = p; i &lt; iq; i++)
-  {
-    ip = A[i];
-    iai[ip] = -1;
-  }
-	
-  /* compute s[x] = ci^T * x + ci0 for all elements of K \ A */
-  ss = 0.0;
-  psi = 0.0; /* this value will contain the sum of all infeasibilities */
-  ip = 0; /* ip will be the index of the chosen violated constraint */
-  for (i = 0; i &lt; m; i++)
-  {
-    iaexcl[i] = true;
-    sum = 0.0;
-    for (j = 0; j &lt; n; j++)
-      sum += CI[j][i] * x[j];
-    sum += ci0[i];
-    s[i] = sum;
-    psi += std::min(0.0, sum);
-  }
-#ifdef TRACE_SOLVER
-  print_vector("s", s, m);
-#endif
-  
-  
-  if (fabs(psi) &lt;= m * std::numeric_limits&lt;double&gt;::epsilon() * c1 * c2* 100.0)
-  {
-    /* numerically there are not infeasibilities anymore */
-    return f_value;
-  }
-  
-  /* save old values for u and A */
-  for (i = 0; i &lt; iq; i++)
-  {
-    u_old[i] = u[i];
-    A_old[i] = A[i];
-  }
-  /* and for x */
-  for (i = 0; i &lt; n; i++)
-    x_old[i] = x[i];
-  
+
+    /* save old values for u and A */
+    for (i = 0; i &lt; iq; i++) {
+      u_old[i] = u[i];
+      A_old[i] = A[i];
+    }
+    /* and for x */
+    for (i = 0; i &lt; n; i++) {
+      x_old[i] = x[i];
+    }
+
@@ -262,4 +278,2 @@
-    for (i = 0; i &lt; m; i++)
-    {
-      if (s[i] &lt; ss &amp;&amp; iai[i] != -1 &amp;&amp; iaexcl[i])
-      {
+    for (i = 0; i &lt; m; i++) {
+      if (s[i] &lt; ss &amp;&amp; iai[i] != -1 &amp;&amp; iaexcl[i]) {
@@ -270,18 +284,18 @@
-  if (ss &gt;= 0.0)
-  {
-    return f_value;
-  }
-  
-  /* set np = n[ip] */
-  for (i = 0; i &lt; n; i++)
-    np[i] = CI[i][ip];
-  /* set u = [u 0]^T */
-  u[iq] = 0.0;
-  /* add ip to the active set A */
-  A[iq] = ip;
-  
-#ifdef TRACE_SOLVER
-  std::cout &lt;&lt; "Trying with constraint " &lt;&lt; ip &lt;&lt; std::endl;
-  print_vector("np", np);
-#endif
-  
+    if (ss &gt;= 0.0) {
+      return f_value;
+    }
+
+    /* set np = n[ip] */
+    for (i = 0; i &lt; n; i++) {
+      np[i] = CI[i][ip];
+    }
+    /* set u = [u 0]^T */
+    u[iq] = 0.0;
+    /* add ip to the active set A */
+    A[iq] = ip;
+
+#ifdef TRACE_SOLVER
+    std::cout &lt;&lt; "Trying with constraint " &lt;&lt; ip &lt;&lt; std::endl;
+    print_vector("np", np);
+#endif
+
@@ -291,58 +305,78 @@
-  update_z(z, J, d, iq);
-  /* compute N* np (if q &gt; 0): the negative of the step direction in the dual space */
-  update_r(R, r, d, iq);
-#ifdef TRACE_SOLVER
-  std::cout &lt;&lt; "Step direction z" &lt;&lt; std::endl;
-  print_vector("z", z);
-  print_vector("r", r, iq + 1);
-  print_vector("u", u, iq + 1);
-  print_vector("d", d);
-  print_vector("A", A, iq + 1);
-#endif
-  
-  /* Step 2b: compute step length */
-  l = 0;
-  /* Compute t1: partial step length (maximum step in dual space without violating dual feasibility */
-  t1 = inf; /* +inf */
-  /* find the index l s.t. it reaches the minimum of u+[x] / r */
-  for (k = p; k &lt; iq; k++)
-  {
-    if (r[k] &gt; 0.0)
-    {
-      if (u[k] / r[k] &lt; t1)
-	    {
-	      t1 = u[k] / r[k];
-	      l = A[k];
-	    }
-    }
-  }
-  /* Compute t2: full step length (minimum step in primal space such that the constraint ip becomes feasible */
-  if (fabs(scalar_product(z, z))  &gt; std::numeric_limits&lt;double&gt;::epsilon()) // i.e. z != 0
-  {
-    t2 = -s[ip] / scalar_product(z, np);
-    if (t2 &lt; 0) // patch suggested by Takano Akio for handling numerical inconsistencies
-      t2 = inf;
-  }
-  else
-    t2 = inf; /* +inf */
-  
-  /* the step is chosen as the minimum of t1 and t2 */
-  t = std::min(t1, t2);
-#ifdef TRACE_SOLVER
-  std::cout &lt;&lt; "Step sizes: " &lt;&lt; t &lt;&lt; " (t1 = " &lt;&lt; t1 &lt;&lt; ", t2 = " &lt;&lt; t2 &lt;&lt; ") ";
-#endif
-  
-  /* Step 2c: determine new S-pair and take step: */
-  
-  /* case (i): no step in primal or dual space */
-  if (t &gt;= inf)
-  {
-    /* QPP is infeasible */
-    // FIXME: unbounded to raise
-    return inf;
-  }
-  /* case (ii): step in dual space */
-  if (t2 &gt;= inf)
-  {
-    /* set u = u +  t * [-r 1] and drop constraint l from the active set A */
-    for (k = 0; k &lt; iq; k++)
+    update_z(z, J, d, iq);
+    /* compute N* np (if q &gt; 0): the negative of the step direction in the dual space */
+    update_r(R, r, d, iq);
+#ifdef TRACE_SOLVER
+    std::cout &lt;&lt; "Step direction z" &lt;&lt; std::endl;
+    print_vector("z", z);
+    print_vector("r", r, iq + 1);
+    print_vector("u", u, iq + 1);
+    print_vector("d", d);
+    print_vector("A", A, iq + 1);
+#endif
+
+    /* Step 2b: compute step length */
+    l = 0;
+    /* Compute t1: partial step length (maximum step in dual space without violating dual feasibility */
+    t1 = inf; /* +inf */
+    /* find the index l s.t. it reaches the minimum of u+[x] / r */
+    for (k = p; k &lt; iq; k++) {
+      if (r[k] &gt; 0.0) {
+        if (u[k] / r[k] &lt; t1) {
+          t1 = u[k] / r[k];
+          l = A[k];
+        }
+      }
+    }
+    /* Compute t2: full step length (minimum step in primal space such that the constraint ip becomes feasible */
+    if (fabs(scalar_product(z, z)) &gt; std::numeric_limits &lt; double &gt; ::epsilon()) { // i.e. z != 0
+      t2 = -s[ip] / scalar_product(z, np);
+      if (t2 &lt; 0) { // patch suggested by Takano Akio for handling numerical inconsistencies
+        t2 = inf;
+      }
+    } else {
+      t2 = inf; /* +inf */
+
+    }
+    /* the step is chosen as the minimum of t1 and t2 */
+    t = std::min(t1, t2);
+#ifdef TRACE_SOLVER
+    std::cout &lt;&lt; "Step sizes: " &lt;&lt; t &lt;&lt; " (t1 = " &lt;&lt; t1 &lt;&lt; ", t2 = " &lt;&lt; t2 &lt;&lt; ") ";
+#endif
+
+    /* Step 2c: determine new S-pair and take step: */
+
+    /* case (i): no step in primal or dual space */
+    if (t &gt;= inf) {
+      /* QPP is infeasible */
+      // FIXME: unbounded to raise
+      return inf;
+    }
+    /* case (ii): step in dual space */
+    if (t2 &gt;= inf) {
+      /* set u = u +  t * [-r 1] and drop constraint l from the active set A */
+      for (k = 0; k &lt; iq; k++) {
+        u[k] -= t * r[k];
+      }
+      u[iq] += t;
+      iai[l] = l;
+      delete_constraint(R, J, A, u, n, p, iq, l);
+#ifdef TRACE_SOLVER
+      std::cout &lt;&lt; " in dual space: "
+                &lt;&lt; f_value &lt;&lt; std::endl;
+      print_vector("x", x);
+      print_vector("z", z);
+      print_vector("A", A, iq + 1);
+#endif
+      goto l2a;
+    }
+
+    /* case (iii): step in primal and dual space */
+
+    /* set x = x + t * z */
+    for (k = 0; k &lt; n; k++) {
+      x[k] += t * z[k];
+    }
+    /* update the solution value */
+    f_value += t * scalar_product(z, np) * (0.5 * t + u[iq]);
+    /* u = u + t * [-r 1] */
+    for (k = 0; k &lt; iq; k++) {
@@ -349,0 +384 @@
+    }
@@ -350,0 +386,53 @@
+#ifdef TRACE_SOLVER
+    std::cout &lt;&lt; " in both spaces: "
+              &lt;&lt; f_value &lt;&lt; std::endl;
+    print_vector("x", x);
+    print_vector("u", u, iq + 1);
+    print_vector("r", r, iq + 1);
+    print_vector("A", A, iq + 1);
+#endif
+
+    if (fabs(t - t2) &lt; std::numeric_limits &lt; double &gt; ::epsilon()) {
+#ifdef TRACE_SOLVER
+      std::cout &lt;&lt; "Full step has taken " &lt;&lt; t &lt;&lt; std::endl;
+      print_vector("x", x);
+#endif
+      /* full step has taken */
+      /* add constraint ip to the active set*/
+      if (!add_constraint(R, J, d, iq, R_norm)) {
+        iaexcl[ip] = false;
+        delete_constraint(R, J, A, u, n, p, iq, ip);
+#ifdef TRACE_SOLVER
+        print_matrix("R", R);
+        print_vector("A", A, iq);
+        print_vector("iai", iai);
+#endif
+        for (i = 0; i &lt; m; i++) {
+          iai[i] = i;
+        }
+        for (i = p; i &lt; iq; i++) {
+          A[i] = A_old[i];
+          u[i] = u_old[i];
+          iai[A[i]] = -1;
+        }
+        for (i = 0; i &lt; n; i++) {
+          x[i] = x_old[i];
+        }
+        goto l2; /* go to step 2 */
+      } else {
+        iai[ip] = -1;
+      }
+#ifdef TRACE_SOLVER
+      print_matrix("R", R);
+      print_vector("A", A, iq);
+      print_vector("iai", iai);
+#endif
+      goto l1;
+    }
+
+    /* a patial step has taken */
+#ifdef TRACE_SOLVER
+    std::cout &lt;&lt; "Partial step has taken " &lt;&lt; t &lt;&lt; std::endl;
+    print_vector("x", x);
+#endif
+    /* drop constraint l */
@@ -354,61 +441,0 @@
-    std::cout &lt;&lt; " in dual space: " 
-      &lt;&lt; f_value &lt;&lt; std::endl;
-    print_vector("x", x);
-    print_vector("z", z);
-    print_vector("A", A, iq + 1);
-#endif
-    goto l2a;
-  }
-  
-  /* case (iii): step in primal and dual space */
-  
-  /* set x = x + t * z */
-  for (k = 0; k &lt; n; k++)
-    x[k] += t * z[k];
-  /* update the solution value */
-  f_value += t * scalar_product(z, np) * (0.5 * t + u[iq]);
-  /* u = u + t * [-r 1] */
-  for (k = 0; k &lt; iq; k++)
-    u[k] -= t * r[k];
-  u[iq] += t;
-#ifdef TRACE_SOLVER
-  std::cout &lt;&lt; " in both spaces: " 
-    &lt;&lt; f_value &lt;&lt; std::endl;
-  print_vector("x", x);
-  print_vector("u", u, iq + 1);
-  print_vector("r", r, iq + 1);
-  print_vector("A", A, iq + 1);
-#endif
-  
-  if (fabs(t - t2) &lt; std::numeric_limits&lt;double&gt;::epsilon())
-  {
-#ifdef TRACE_SOLVER
-    std::cout &lt;&lt; "Full step has taken " &lt;&lt; t &lt;&lt; std::endl;
-    print_vector("x", x);
-#endif
-    /* full step has taken */
-    /* add constraint ip to the active set*/
-    if (!add_constraint(R, J, d, iq, R_norm))
-    {
-      iaexcl[ip] = false;
-      delete_constraint(R, J, A, u, n, p, iq, ip);
-#ifdef TRACE_SOLVER
-      print_matrix("R", R);
-      print_vector("A", A, iq);
-			print_vector("iai", iai);
-#endif
-      for (i = 0; i &lt; m; i++)
-        iai[i] = i;
-      for (i = p; i &lt; iq; i++)
-	    {
-	      A[i] = A_old[i];
-	      u[i] = u_old[i];
-				iai[A[i]] = -1;
-	    }
-      for (i = 0; i &lt; n; i++)
-        x[i] = x_old[i];
-      goto l2; /* go to step 2 */
-    }    
-    else
-      iai[ip] = -1;
-#ifdef TRACE_SOLVER
@@ -417,38 +444,3 @@
-		print_vector("iai", iai);
-#endif
-    goto l1;
-  }
-  
-  /* a patial step has taken */
-#ifdef TRACE_SOLVER
-  std::cout &lt;&lt; "Partial step has taken " &lt;&lt; t &lt;&lt; std::endl;
-  print_vector("x", x);
-#endif
-  /* drop constraint l */
-  iai[l] = l;
-  delete_constraint(R, J, A, u, n, p, iq, l);
-#ifdef TRACE_SOLVER
-  print_matrix("R", R);
-  print_vector("A", A, iq);
-#endif
-  
-  /* update s[ip] = CI * x + ci0 */
-  sum = 0.0;
-  for (k = 0; k &lt; n; k++)
-    sum += CI[k][ip] * x[k];
-  s[ip] = sum + ci0[ip];
-  
-#ifdef TRACE_SOLVER
-  print_vector("s", s, m);
-#endif
-  goto l2a;
-}
-
-inline void compute_d(Vector&lt;double&gt;&amp; d, const Matrix&lt;double&gt;&amp; J, const Vector&lt;double&gt;&amp; np)
-{
-  register int i, j, n = d.size();
-  register double sum;
-  
-  /* compute d = H^T * np */
-  for (i = 0; i &lt; n; i++)
-  {
+#endif
+
+    /* update s[ip] = CI * x + ci0 */
@@ -456,132 +448,158 @@
-    for (j = 0; j &lt; n; j++)
-      sum += J[j][i] * np[j];
-    d[i] = sum;
-  }
-}
-
-inline void update_z(Vector&lt;double&gt;&amp; z, const Matrix&lt;double&gt;&amp; J, const Vector&lt;double&gt;&amp; d, int iq)
-{
-  register int i, j, n = z.size();
-	
-  /* setting of z = H * d */
-  for (i = 0; i &lt; n; i++)
-  {
-    z[i] = 0.0;
-    for (j = iq; j &lt; n; j++)
-      z[i] += J[i][j] * d[j];
-  }
-}
-
-inline void update_r(const Matrix&lt;double&gt;&amp; R, Vector&lt;double&gt;&amp; r, const Vector&lt;double&gt;&amp; d, int iq)
-{
-  register int i, j;
-  register double sum;
-  
-  /* setting of r = R^-1 d */
-  for (i = iq - 1; i &gt;= 0; i--)
-  {
-    sum = 0.0;
-    for (j = i + 1; j &lt; iq; j++)
-      sum += R[i][j] * r[j];
-    r[i] = (d[i] - sum) / R[i][i];
-  }
-}
-
-bool add_constraint(Matrix&lt;double&gt;&amp; R, Matrix&lt;double&gt;&amp; J, Vector&lt;double&gt;&amp; d, unsigned int&amp; iq, double&amp; R_norm)
-{
-  unsigned int n = d.size();
-#ifdef TRACE_SOLVER
-  std::cout &lt;&lt; "Add constraint " &lt;&lt; iq &lt;&lt; '/';
-#endif
-  register unsigned int i, j, k;
-  double cc, ss, h, t1, t2, xny;
-	
-  /* we have to find the Givens rotation which will reduce the element
-    d[j] to zero.
-    if it is already zero we don't have to do anything, except of
-    decreasing j */  
-  for (j = n - 1; j &gt;= iq + 1; j--)
-  {
-    /* The Givens rotation is done with the matrix (cc cs, cs -cc).
-    If cc is one, then element (j) of d is zero compared with element
-    (j - 1). Hence we don't have to do anything. 
-    If cc is zero, then we just have to switch column (j) and column (j - 1) 
-    of J. Since we only switch columns in J, we have to be careful how we
-    update d depending on the sign of gs.
-    Otherwise we have to apply the Givens rotation to these columns.
-    The i - 1 element of d has to be updated to h. */
-    cc = d[j - 1];
-    ss = d[j];
-    h = distance(cc, ss);
-    if (fabs(h) &lt; std::numeric_limits&lt;double&gt;::epsilon()) // h == 0
-      continue;
-    d[j] = 0.0;
-    ss = ss / h;
-    cc = cc / h;
-    if (cc &lt; 0.0)
-    {
-      cc = -cc;
-      ss = -ss;
-      d[j - 1] = -h;
-    }
-    else
-      d[j - 1] = h;
-    xny = ss / (1.0 + cc);
-    for (k = 0; k &lt; n; k++)
-    {
-      t1 = J[k][j - 1];
-      t2 = J[k][j];
-      J[k][j - 1] = t1 * cc + t2 * ss;
-      J[k][j] = xny * (t1 + J[k][j - 1]) - t2;
-    }
-  }
-  /* update the number of constraints added*/
-  iq++;
-  /* To update R we have to put the iq components of the d vector
-    into column iq - 1 of R
-    */
-  for (i = 0; i &lt; iq; i++)
-    R[i][iq - 1] = d[i];
-#ifdef TRACE_SOLVER
-  std::cout &lt;&lt; iq &lt;&lt; std::endl;
-  print_matrix("R", R, iq, iq);
-  print_matrix("J", J);
-  print_vector("d", d, iq);
-#endif
-  
-  if (fabs(d[iq - 1]) &lt;= std::numeric_limits&lt;double&gt;::epsilon() * R_norm) 
-  {
-    // problem degenerate
-    return false;
-  }
-  R_norm = std::max&lt;double&gt;(R_norm, fabs(d[iq - 1]));
-  return true;
-}
-
-void delete_constraint(Matrix&lt;double&gt;&amp; R, Matrix&lt;double&gt;&amp; J, Vector&lt;int&gt;&amp; A, Vector&lt;double&gt;&amp; u, unsigned int n, int p, unsigned int&amp; iq, int l)
-{
-#ifdef TRACE_SOLVER
-  std::cout &lt;&lt; "Delete constraint " &lt;&lt; l &lt;&lt; ' ' &lt;&lt; iq;
-#endif
-  register unsigned int i, j, k, qq = 0; // just to prevent warnings from smart compilers
-  double cc, ss, h, xny, t1, t2;
-
-  bool found = false;
-  /* Find the index qq for active constraint l to be removed */
-  for (i = p; i &lt; iq; i++)
-    if (A[i] == l)
-    {
-      qq = i;
-      found = true;
-      break;
-    }
-
-  if(!found)
-  {
-    std::ostringstream os;
-    os &lt;&lt; "Attempt to delete non existing constraint, constraint: " &lt;&lt; l;
-    throw std::invalid_argument(os.str());
-  }
-  /* remove the constraint from the active set and the duals */
-  for (i = qq; i &lt; iq - 1; i++)
-    {
+    for (k = 0; k &lt; n; k++) {
+      sum += CI[k][ip] * x[k];
+    }
+    s[ip] = sum + ci0[ip];
+
+#ifdef TRACE_SOLVER
+    print_vector("s", s, m);
+#endif
+    goto l2a;
+  }
+
+  inline void compute_d(
+    Vector &lt; double &gt; &amp; d, const Matrix &lt; double &gt; &amp; J,
+    const Vector &lt; double &gt; &amp; np)
+  {
+    register int i, j, n = d.size();
+    register double sum;
+
+    /* compute d = H^T * np */
+    for (i = 0; i &lt; n; i++) {
+      sum = 0.0;
+      for (j = 0; j &lt; n; j++) {
+        sum += J[j][i] * np[j];
+      }
+      d[i] = sum;
+    }
+  }
+
+  inline void update_z(
+    Vector &lt; double &gt; &amp; z, const Matrix &lt; double &gt; &amp; J,
+    const Vector &lt; double &gt; &amp; d, int iq)
+  {
+    register int i, j, n = z.size();
+
+    /* setting of z = H * d */
+    for (i = 0; i &lt; n; i++) {
+      z[i] = 0.0;
+      for (j = iq; j &lt; n; j++) {
+        z[i] += J[i][j] * d[j];
+      }
+    }
+  }
+
+  inline void update_r(
+    const Matrix &lt; double &gt; &amp; R, Vector &lt; double &gt; &amp; r,
+    const Vector &lt; double &gt; &amp; d, int iq)
+  {
+    register int i, j;
+    register double sum;
+
+    /* setting of r = R^-1 d */
+    for (i = iq - 1; i &gt;= 0; i--) {
+      sum = 0.0;
+      for (j = i + 1; j &lt; iq; j++) {
+        sum += R[i][j] * r[j];
+      }
+      r[i] = (d[i] - sum) / R[i][i];
+    }
+  }
+
+  bool add_constraint(
+    Matrix &lt; double &gt; &amp; R, Matrix &lt; double &gt; &amp; J, Vector &lt; double &gt; &amp; d,
+    unsigned int &amp; iq, double &amp; R_norm)
+  {
+    unsigned int n = d.size();
+#ifdef TRACE_SOLVER
+    std::cout &lt;&lt; "Add constraint " &lt;&lt; iq &lt;&lt; '/';
+#endif
+    register unsigned int i, j, k;
+    double cc, ss, h, t1, t2, xny;
+
+    /* we have to find the Givens rotation which will reduce the element
+      d[j] to zero.
+      if it is already zero we don't have to do anything, except of
+      decreasing j */
+    for (j = n - 1; j &gt;= iq + 1; j--) {
+      /* The Givens rotation is done with the matrix (cc cs, cs -cc).
+      If cc is one, then element (j) of d is zero compared with element
+      (j - 1). Hence we don't have to do anything.
+      If cc is zero, then we just have to switch column (j) and column (j - 1)
+      of J. Since we only switch columns in J, we have to be careful how we
+      update d depending on the sign of gs.
+      Otherwise we have to apply the Givens rotation to these columns.
+      The i - 1 element of d has to be updated to h. */
+      cc = d[j - 1];
+      ss = d[j];
+      h = distance(cc, ss);
+      if (fabs(h) &lt; std::numeric_limits &lt; double &gt; ::epsilon()) { // h == 0
+        continue;
+      }
+      d[j] = 0.0;
+      ss = ss / h;
+      cc = cc / h;
+      if (cc &lt; 0.0) {
+        cc = -cc;
+        ss = -ss;
+        d[j - 1] = -h;
+      } else {
+        d[j - 1] = h;
+      }
+      xny = ss / (1.0 + cc);
+      for (k = 0; k &lt; n; k++) {
+        t1 = J[k][j - 1];
+        t2 = J[k][j];
+        J[k][j - 1] = t1 * cc + t2 * ss;
+        J[k][j] = xny * (t1 + J[k][j - 1]) - t2;
+      }
+    }
+    /* update the number of constraints added*/
+    iq++;
+    /* To update R we have to put the iq components of the d vector
+      into column iq - 1 of R
+      */
+    for (i = 0; i &lt; iq; i++) {
+      R[i][iq - 1] = d[i];
+    }
+#ifdef TRACE_SOLVER
+    std::cout &lt;&lt; iq &lt;&lt; std::endl;
+    print_matrix("R", R, iq, iq);
+    print_matrix("J", J);
+    print_vector("d", d, iq);
+#endif
+
+    if (fabs(d[iq - 1]) &lt;= std::numeric_limits &lt; double &gt; ::epsilon() * R_norm) {
+      // problem degenerate
+      return false;
+    }
+    R_norm = std::max &lt; double &gt; (R_norm, fabs(d[iq - 1]));
+    return true;
+  }
+
+  void delete_constraint(
+    Matrix &lt; double &gt; &amp; R, Matrix &lt; double &gt; &amp; J, Vector &lt; int &gt; &amp; A,
+    Vector &lt; double &gt; &amp; u, unsigned int n, int p, unsigned int &amp; iq, int l)
+  {
+#ifdef TRACE_SOLVER
+    std::cout &lt;&lt; "Delete constraint " &lt;&lt; l &lt;&lt; ' ' &lt;&lt; iq;
+#endif
+    register unsigned int i, j, k, qq = 0; // just to prevent warnings from smart compilers
+    double cc, ss, h, xny, t1, t2;
+
+    bool found = false;
+    /* Find the index qq for active constraint l to be removed */
+    for (i = p; i &lt; iq; i++) {
+      if (A[i] == l) {
+        qq = i;
+        found = true;
+        break;
+      }
+    }
+
+    if (!found) {
+      std::ostringstream os;
+      os &lt;&lt; "Attempt to delete non existing constraint, constraint: " &lt;&lt; l;
+      throw std::invalid_argument(os.str());
+    }
+    /* remove the constraint from the active set and the duals */
+    for (i = qq; i &lt; iq - 1; i++) {
@@ -590 +608 @@
-      for (j = 0; j &lt; n; j++)
+      for (j = 0; j &lt; n; j++) {
@@ -592,67 +610,63 @@
-    }
-      
-  A[iq - 1] = A[iq];
-  u[iq - 1] = u[iq];
-  A[iq] = 0; 
-  u[iq] = 0.0;
-  for (j = 0; j &lt; iq; j++)
-    R[j][iq - 1] = 0.0;
-  /* constraint has been fully removed */
-  iq--;
-#ifdef TRACE_SOLVER
-  std::cout &lt;&lt; '/' &lt;&lt; iq &lt;&lt; std::endl;
-#endif 
-  
-  if (iq == 0)
-    return;
-  
-  for (j = qq; j &lt; iq; j++)
-  {
-    cc = R[j][j];
-    ss = R[j + 1][j];
-    h = distance(cc, ss);
-    if (fabs(h) &lt; std::numeric_limits&lt;double&gt;::epsilon()) // h == 0
-      continue;
-    cc = cc / h;
-    ss = ss / h;
-    R[j + 1][j] = 0.0;
-    if (cc &lt; 0.0)
-    {
-      R[j][j] = -h;
-      cc = -cc;
-      ss = -ss;
-    }
-    else
-      R[j][j] = h;
-    
-    xny = ss / (1.0 + cc);
-    for (k = j + 1; k &lt; iq; k++)
-    {
-      t1 = R[j][k];
-      t2 = R[j + 1][k];
-      R[j][k] = t1 * cc + t2 * ss;
-      R[j + 1][k] = xny * (t1 + R[j][k]) - t2;
-    }
-    for (k = 0; k &lt; n; k++)
-    {
-      t1 = J[k][j];
-      t2 = J[k][j + 1];
-      J[k][j] = t1 * cc + t2 * ss;
-      J[k][j + 1] = xny * (J[k][j] + t1) - t2;
-    }
-  }
-}
-
-inline double distance(double a, double b)
-{
-  register double a1, b1, t;
-  a1 = fabs(a);
-  b1 = fabs(b);
-  if (a1 &gt; b1) 
-  {
-    t = (b1 / a1);
-    return a1 * sqrt(1.0 + t * t);
-  }
-  else
-    if (b1 &gt; a1)
-    {
+      }
+    }
+
+    A[iq - 1] = A[iq];
+    u[iq - 1] = u[iq];
+    A[iq] = 0;
+    u[iq] = 0.0;
+    for (j = 0; j &lt; iq; j++) {
+      R[j][iq - 1] = 0.0;
+    }
+    /* constraint has been fully removed */
+    iq--;
+#ifdef TRACE_SOLVER
+    std::cout &lt;&lt; '/' &lt;&lt; iq &lt;&lt; std::endl;
+#endif
+
+    if (iq == 0) {
+      return;
+    }
+
+    for (j = qq; j &lt; iq; j++) {
+      cc = R[j][j];
+      ss = R[j + 1][j];
+      h = distance(cc, ss);
+      if (fabs(h) &lt; std::numeric_limits &lt; double &gt; ::epsilon()) { // h == 0
+        continue;
+      }
+      cc = cc / h;
+      ss = ss / h;
+      R[j + 1][j] = 0.0;
+      if (cc &lt; 0.0) {
+        R[j][j] = -h;
+        cc = -cc;
+        ss = -ss;
+      } else {
+        R[j][j] = h;
+      }
+
+      xny = ss / (1.0 + cc);
+      for (k = j + 1; k &lt; iq; k++) {
+        t1 = R[j][k];
+        t2 = R[j + 1][k];
+        R[j][k] = t1 * cc + t2 * ss;
+        R[j + 1][k] = xny * (t1 + R[j][k]) - t2;
+      }
+      for (k = 0; k &lt; n; k++) {
+        t1 = J[k][j];
+        t2 = J[k][j + 1];
+        J[k][j] = t1 * cc + t2 * ss;
+        J[k][j + 1] = xny * (J[k][j] + t1) - t2;
+      }
+    }
+  }
+
+  inline double distance(double a, double b)
+  {
+    register double a1, b1, t;
+    a1 = fabs(a);
+    b1 = fabs(b);
+    if (a1 &gt; b1) {
+      t = (b1 / a1);
+      return a1 * sqrt(1.0 + t * t);
+    } else if (b1 &gt; a1) {
@@ -662,37 +676,26 @@
-  return a1 * sqrt(2.0);
-}
-
-
-inline double scalar_product(const Vector&lt;double&gt;&amp; x, const Vector&lt;double&gt;&amp; y)
-{
-  register int i, n = x.size();
-  register double sum;
-	
-  sum = 0.0;
-  for (i = 0; i &lt; n; i++)
-    sum += x[i] * y[i];
-  return sum;			
-}
-
-void cholesky_decomposition(Matrix&lt;double&gt;&amp; A) 
-{
-  register int i, j, k, n = A.nrows();
-  register double sum;
-	
-  for (i = 0; i &lt; n; i++)
-  {
-    for (j = i; j &lt; n; j++)
-    {
-      sum = A[i][j];
-      for (k = i - 1; k &gt;= 0; k--)
-        sum -= A[i][k]*A[j][k];
-      if (i == j) 
-	    {
-	      if (sum &lt;= 0.0)
-        {
-          std::ostringstream os;
-          // raise error
-          print_matrix("A", A);
-          os &lt;&lt; "Error in cholesky decomposition, sum: " &lt;&lt; sum;
-          throw std::logic_error(os.str());
-          exit(-1);
+    return a1 * sqrt(2.0);
+  }
+
+
+  inline double scalar_product(const Vector &lt; double &gt; &amp; x, const Vector &lt; double &gt; &amp; y)
+  {
+    register int i, n = x.size();
+    register double sum;
+
+    sum = 0.0;
+    for (i = 0; i &lt; n; i++) {
+      sum += x[i] * y[i];
+    }
+    return sum;
+  }
+
+  void cholesky_decomposition(Matrix &lt; double &gt; &amp; A)
+  {
+    register int i, j, k, n = A.nrows();
+    register double sum;
+
+    for (i = 0; i &lt; n; i++) {
+      for (j = i; j &lt; n; j++) {
+        sum = A[i][j];
+        for (k = i - 1; k &gt;= 0; k--) {
+          sum -= A[i][k] * A[j][k];
@@ -700,90 +703,108 @@
-	      A[i][i] = sqrt(sum);
-	    }
-      else
-        A[j][i] = sum / A[i][i];
-    }
-    for (k = i + 1; k &lt; n; k++)
-      A[i][k] = A[k][i];
-  } 
-}
-
-void cholesky_solve(const Matrix&lt;double&gt;&amp; L, Vector&lt;double&gt;&amp; x, const Vector&lt;double&gt;&amp; b)
-{
-  int n = L.nrows();
-  Vector&lt;double&gt; y(n);
-	
-  /* Solve L * y = b */
-  forward_elimination(L, y, b);
-  /* Solve L^T * x = y */
-  backward_elimination(L, x, y);
-}
-
-inline void forward_elimination(const Matrix&lt;double&gt;&amp; L, Vector&lt;double&gt;&amp; y, const Vector&lt;double&gt;&amp; b)
-{
-  register int i, j, n = L.nrows();
-	
-  y[0] = b[0] / L[0][0];
-  for (i = 1; i &lt; n; i++)
-  {
-    y[i] = b[i];
-    for (j = 0; j &lt; i; j++)
-      y[i] -= L[i][j] * y[j];
-    y[i] = y[i] / L[i][i];
-  }
-}
-
-inline void backward_elimination(const Matrix&lt;double&gt;&amp; U, Vector&lt;double&gt;&amp; x, const Vector&lt;double&gt;&amp; y)
-{
-  register int i, j, n = U.nrows();
-	
-  x[n - 1] = y[n - 1] / U[n - 1][n - 1];
-  for (i = n - 2; i &gt;= 0; i--)
-  {
-    x[i] = y[i];
-    for (j = i + 1; j &lt; n; j++)
-      x[i] -= U[i][j] * x[j];
-    x[i] = x[i] / U[i][i];
-  }
-}
-
-void print_matrix(const char* name, const Matrix&lt;double&gt;&amp; A, int n, int m)
-{
-  std::ostringstream s;
-  std::string t;
-  if (n == -1)
-    n = A.nrows();
-  if (m == -1)
-    m = A.ncols();
-	
-  s &lt;&lt; name &lt;&lt; ": " &lt;&lt; std::endl;
-  for (int i = 0; i &lt; n; i++)
-  {
-    s &lt;&lt; " ";
-    for (int j = 0; j &lt; m; j++)
-      s &lt;&lt; A[i][j] &lt;&lt; ", ";
-    s &lt;&lt; std::endl;
-  }
-  t = s.str();
-  t = t.substr(0, t.size() - 3); // To remove the trailing space, comma and newline
-	
-  std::cout &lt;&lt; t &lt;&lt; std::endl;
-}
-
-template&lt;typename T&gt;
-void print_vector(const char* name, const Vector&lt;T&gt;&amp; v, int n)
-{
-  std::ostringstream s;
-  std::string t;
-  if (n == -1)
-    n = v.size();
-	
-  s &lt;&lt; name &lt;&lt; ": " &lt;&lt; std::endl &lt;&lt; " ";
-  for (int i = 0; i &lt; n; i++)
-  {
-    s &lt;&lt; v[i] &lt;&lt; ", ";
-  }
-  t = s.str();
-  t = t.substr(0, t.size() - 2); // To remove the trailing space and comma
-	
-  std::cout &lt;&lt; t &lt;&lt; std::endl;
-}
+        if (i == j) {
+          if (sum &lt;= 0.0) {
+            std::ostringstream os;
+            // raise error
+            print_matrix("A", A);
+            os &lt;&lt; "Error in cholesky decomposition, sum: " &lt;&lt; sum;
+            throw std::logic_error(os.str());
+            exit(-1);
+          }
+          A[i][i] = sqrt(sum);
+        } else {
+          A[j][i] = sum / A[i][i];
+        }
+      }
+      for (k = i + 1; k &lt; n; k++) {
+        A[i][k] = A[k][i];
+      }
+    }
+  }
+
+  void cholesky_solve(
+    const Matrix &lt; double &gt; &amp; L, Vector &lt; double &gt; &amp; x,
+    const Vector &lt; double &gt; &amp; b)
+  {
+    int n = L.nrows();
+    Vector &lt; double &gt; y(n);
+
+    /* Solve L * y = b */
+    forward_elimination(L, y, b);
+    /* Solve L^T * x = y */
+    backward_elimination(L, x, y);
+  }
+
+  inline void forward_elimination(
+    const Matrix &lt; double &gt; &amp; L, Vector &lt; double &gt; &amp; y,
+    const Vector &lt; double &gt; &amp; b)
+  {
+    register int i, j, n = L.nrows();
+
+    y[0] = b[0] / L[0][0];
+    for (i = 1; i &lt; n; i++) {
+      y[i] = b[i];
+      for (j = 0; j &lt; i; j++) {
+        y[i] -= L[i][j] * y[j];
+      }
+      y[i] = y[i] / L[i][i];
+    }
+  }
+
+  inline void backward_elimination(
+    const Matrix &lt; double &gt; &amp; U, Vector &lt; double &gt; &amp; x,
+    const Vector &lt; double &gt; &amp; y)
+  {
+    register int i, j, n = U.nrows();
+
+    x[n - 1] = y[n - 1] / U[n - 1][n - 1];
+    for (i = n - 2; i &gt;= 0; i--) {
+      x[i] = y[i];
+      for (j = i + 1; j &lt; n; j++) {
+        x[i] -= U[i][j] * x[j];
+      }
+      x[i] = x[i] / U[i][i];
+    }
+  }
+
+  void print_matrix(const char * name, const Matrix &lt; double &gt; &amp; A, int n, int m)
+  {
+    std::ostringstream s;
+    std::string t;
+    if (n == -1) {
+      n = A.nrows();
+    }
+    if (m == -1) {
+      m = A.ncols();
+    }
+
+    s &lt;&lt; name &lt;&lt; ": " &lt;&lt; std::endl;
+    for (int i = 0; i &lt; n; i++) {
+      s &lt;&lt; " ";
+      for (int j = 0; j &lt; m; j++) {
+        s &lt;&lt; A[i][j] &lt;&lt; ", ";
+      }
+      s &lt;&lt; std::endl;
+    }
+    t = s.str();
+    t = t.substr(0, t.size() - 3); // To remove the trailing space, comma and newline
+
+    std::cout &lt;&lt; t &lt;&lt; std::endl;
+  }
+
+  template &lt; typename T &gt;
+  void print_vector(const char * name, const Vector &lt; T &gt; &amp; v, int n)
+  {
+    std::ostringstream s;
+    std::string t;
+    if (n == -1) {
+      n = v.size();
+    }
+
+    s &lt;&lt; name &lt;&lt; ": " &lt;&lt; std::endl &lt;&lt; " ";
+    for (int i = 0; i &lt; n; i++) {
+      s &lt;&lt; v[i] &lt;&lt; ", ";
+    }
+    t = s.str();
+    t = t.substr(0, t.size() - 2); // To remove the trailing space and comma
+
+    std::cout &lt;&lt; t &lt;&lt; std::endl;
+  }

63 files with code style divergence
-- run_test.py: return code 1
-- run_test.py: verify result file '/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/uncrustify.xunit.xml'
</Value>
				</Measurement>
			</Results>
			<Labels>
				<Label>linter</Label>
				<Label>uncrustify</Label>
			</Labels>
		</Test>
		<Test Status="passed">
			<Name>xmllint</Name>
			<Path>.</Path>
			<FullName>./xmllint</FullName>
			<FullCommandLine>/usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/xmllint.xunit.xml" "--package-name" "unitree_guide2" "--output-file" "/home/yk/rosros/build/unitree_guide2/ament_xmllint/xmllint.txt" "--command" "/opt/ros/humble/bin/ament_xmllint" "--xunit-file" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/xmllint.xunit.xml"</FullCommandLine>
			<Results>
				<NamedMeasurement type="numeric/double" name="Execution Time">
					<Value>2.45439</Value>
				</NamedMeasurement>
				<NamedMeasurement type="numeric/double" name="Processors">
					<Value>1</Value>
				</NamedMeasurement>
				<NamedMeasurement type="text/string" name="Completion Status">
					<Value>Completed</Value>
				</NamedMeasurement>
				<NamedMeasurement type="text/string" name="Command Line">
					<Value>/usr/bin/python3 "-u" "/opt/ros/humble/share/ament_cmake_test/cmake/run_test.py" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/xmllint.xunit.xml" "--package-name" "unitree_guide2" "--output-file" "/home/yk/rosros/build/unitree_guide2/ament_xmllint/xmllint.txt" "--command" "/opt/ros/humble/bin/ament_xmllint" "--xunit-file" "/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/xmllint.xunit.xml"</Value>
				</NamedMeasurement>
				<NamedMeasurement type="text/string" name="Environment">
					<Value>#CTEST_RESOURCE_GROUP_COUNT=</Value>
				</NamedMeasurement>
				<Measurement>
					<Value>-- run_test.py: invoking following command in '/home/yk/rosros/src/unitree_ros2_sim/unitree_guide2':
 - /opt/ros/humble/bin/ament_xmllint --xunit-file /home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/xmllint.xunit.xml
File 'package.xml' is valid

File 'config/plotjuggler_layout.xml' is valid

No problems found
-- run_test.py: return code 0
-- run_test.py: verify result file '/home/yk/rosros/build/unitree_guide2/test_results/unitree_guide2/xmllint.xunit.xml'
</Value>
				</Measurement>
			</Results>
			<Labels>
				<Label>linter</Label>
				<Label>xmllint</Label>
			</Labels>
		</Test>
		<EndDateTime>Nov 08 20:41 KST</EndDateTime>
		<EndTestTime>1731066094</EndTestTime>
		<ElapsedMinutes>0</ElapsedMinutes>
	</Testing>
</Site>
